[2025-09-16T03:36:05] OpenAI Codex v0.20.0 (research preview)
--------
workdir: /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
model: gpt-5
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: medium
reasoning summaries: auto
--------
[2025-09-16T03:36:05] User instructions:
Please ensure your implementation Always Works™ for:

## Task: Introduce Missing Theorems in FloatSpec/src/Core/${file}

## Scope

Introduce missing theorems in the file. You can find the record of missing theorems in file /Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Core_Theorems_Comparison.md, which is generated by comparing the Coq and Lean versions of the file. For all the missing theorems in the file, find their corresponding Coq implementation in /Users/louhantao/Desktop/code/semester_6.5/flocq/src/Core and implement them in Lean, using the same name and similar syntax with existing theorems. Leave the proofs empty for now.

### Prerequisites

1. **Read documentation first:**
    - FloatSpec/PIPELINE.md - understand the overall pipeline
    - ./CLAUDE.md - focus on proof writing instructions and mvcgen info

### Core Requirements

### Theorem Importing Process

1. **Follow the Zfast_div_eucl_spec example** in Zaux.lean and other theorems in current file as your template
2. **ONE-BY-ONE approach is mandatory:**
    - Write ONE theorem
    - Use the hoare triple syntax (introduced in FloatSpec/PIPELINE.md and CLAUDE.md) to write the theorem
    - Check immediately with mcp tool or `lake build`
    - Fix any errors before proceeding to next theorem
    - Never batch multiple theorems without checking
3. After writing each theorem, check whether they are aligned with the Coq implementation. If so, mark them as complete in the record file.

### Before Writing Each Theorem

1. **Verify function implementation** - ensure the function body is correct
2. **Preserve syntax** - do NOT change hoare triple syntax unless absolutely necessary
    - Think multiple times before modifying specs or code body
    - If changes are needed, decompose complex specs rather than rewriting

### Compilation Verification

- **After EVERY theorem:** Run `mcp` (preferred) or `lake build xxx`
- **Definition of complete:** NO errors or 'pure true' statements
- **Never mark as complete if:**
    - Any errors or 'pure true' statements remain
    - Compilation returns errors
    - Sorry is allowed, but only as a placeholder for the proof


### Important Notes

- Use MCP tool instead of bash command to get diagnostic messages!
- Skip already-imported theorems!! There might be warnings be just leave them there!
- You can use exisiting (and proved) theorem to assist your spec writing. If a theorem is necessary but not introduced, you can turn to work on that first. The useful theorems might not be in the same file, but in the import list
- When you are trying to use a certain lemma, check through mcp tools (or https://github.com/leanprover-community/mathlib4) to make sure the lemma exists. Else, write your own implementation of the lemma.

### Success Criteria

✅ All error and 'pure true' statements eliminated
✅ Clean compilation for entire file
✅ Each theorem verified individually before moving on

[2025-09-16T03:36:15] ERROR: MCP client for `leanexploreLocal` failed to start: request timed out
[2025-09-16T03:36:15] ERROR: MCP client for `leanexploreRemote` failed to start: request timed out
[2025-09-16T03:36:15] ERROR: MCP client for `LeanTool` failed to start: No such file or directory (os error 2)
[2025-09-16T03:36:19] thinking

**Exploring records for missing theorems**

I need to edit files using apply_patch and follow the developer's instructions closely. My first step is to explore the record file and see which theorems are missing. So, I’ll go ahead and open that markdown file to check what’s needed. I want to make sure I'm thorough in finding the relevant information before proceeding with any edits!
[2025-09-16T03:36:21] codex

I’ll open the comparison record to see which theorems are missing and identify the target file.
[2025-09-16T03:36:21] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Core_Theorems_Comparison.md","annotate_lines":true})
[2025-09-16T03:36:21] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Core_Theorems_Comparison.md","annotate_lines":true}) success in 5ms:
{
  "content": [
    {
      "text": "1   : # Core Theorems Comparison: Coq vs Lean (FloatSpec)\n2   : \n3   : This document lists all theorem-like declarations in flocq/src/Core (*.v) and FloatSpec/src/Core (*.lean), grouped by file, and indicates for each Coq declaration whether a corresponding Lean theorem/lemma exists. Matching is based on exact/normalized/substr name matches and, when available, explicit Coq references in Lean comments.\n4   : \n5   : ## File: Core.v\n6   : - Coq file: Core.v\n7   : - Lean file(s): (none)\n8   : \n9   : ### Coq Declarations\n10  : \n11  : ### Lean Declarations\n12  : \n13  : ### Mapping (Coq → Lean)\n14  : \n15  : ## File: Defs.v\n16  : - Coq file: Defs.v\n17  : - Lean file(s): Defs.lean\n18  : \n19  : ### Coq Declarations\n20  : \n21  : ### Lean Declarations\n22  : - theorem: `F2R_spec`\n23  : - theorem: `Fnum_extract_spec`\n24  : - theorem: `Fexp_extract_spec`\n25  : - theorem: `make_float_spec`\n26  : - theorem: `FlocqFloat_eq_spec`\n27  : - theorem: `F2R_zero_spec`\n28  : - theorem: `F2R_add_same_exp_spec`\n29  : \n30  : ### Mapping (Coq → Lean)\n31  : \n32  : ## File: Digits.v\n33  : - Coq file: Digits.v\n34  : - Lean file(s): Digits.lean\n35  : \n36  : ### Coq Declarations\n37  : - Theorem: `digits2_Pnat_correct`\n38  : - Theorem: `Zdigit_lt`\n39  : - Theorem: `Zdigit_0`\n40  : - Theorem: `Zdigit_opp`\n41  : - Theorem: `Zdigit_ge_Zpower_pos`\n42  : - Theorem: `Zdigit_ge_Zpower`\n43  : - Theorem: `Zdigit_not_0_pos`\n44  : - Theorem: `Zdigit_not_0`\n45  : - Theorem: `Zdigit_mul_pow`\n46  : - Theorem: `Zdigit_div_pow`\n47  : - Theorem: `Zdigit_mod_pow`\n48  : - Theorem: `Zdigit_mod_pow_out`\n49  : - Theorem: `Zsum_digit_digit`\n50  : - Theorem: `Zdigit_ext`\n51  : - Theorem: `ZOmod_plus_pow_digit`\n52  : - Theorem: `ZOdiv_plus_pow_digit`\n53  : - Theorem: `Zdigit_plus`\n54  : - Theorem: `Zdigit_scale`\n55  : - Theorem: `Zscale_0`\n56  : - Theorem: `Zsame_sign_scale`\n57  : - Theorem: `Zscale_mul_pow`\n58  : - Theorem: `Zscale_scale`\n59  : - Theorem: `Zdigit_slice`\n60  : - Theorem: `Zdigit_slice_out`\n61  : - Theorem: `Zslice_0`\n62  : - Theorem: `Zsame_sign_slice`\n63  : - Theorem: `Zslice_slice`\n64  : - Theorem: `Zslice_mul_pow`\n65  : - Theorem: `Zslice_div_pow`\n66  : - Theorem: `Zslice_scale`\n67  : - Theorem: `Zslice_div_pow_scale`\n68  : - Theorem: `Zplus_slice`\n69  : - Theorem: `Zdigits_correct`\n70  : - Theorem: `Zdigits_unique`\n71  : - Theorem: `Zdigits_abs`\n72  : - Theorem: `Zdigits_opp`\n73  : - Theorem: `Zdigits_cond_Zopp`\n74  : - Theorem: `Zdigits_gt_0`\n75  : - Theorem: `Zdigits_ge_0`\n76  : - Theorem: `Zdigit_out`\n77  : - Theorem: `Zdigit_digits`\n78  : - Theorem: `Zdigits_slice`\n79  : - Theorem: `Zdigits_mult_Zpower`\n80  : - Theorem: `Zdigits_Zpower`\n81  : - Theorem: `Zdigits_le`\n82  : - Theorem: `lt_Zdigits`\n83  : - Theorem: `Zpower_le_Zdigits`\n84  : - Theorem: `Zdigits_le_Zpower`\n85  : - Theorem: `Zpower_gt_Zdigits`\n86  : - Theorem: `Zdigits_gt_Zpower`\n87  : - Theorem: `Zdigits_mult_strong`\n88  : - Theorem: `Zdigits_mult`\n89  : - Theorem: `Zdigits_mult_ge`\n90  : - Theorem: `Zdigits_div_Zpower`\n91  : - Theorem: `Zdigits_succ_le`\n92  : - Theorem: `Z_of_nat_S_digits2_Pnat`\n93  : - Theorem: `Zpos_digits2_pos`\n94  : - Lemma: `Zdigits2_Zdigits`\n95  : \n96  : ### Lean Declarations\n97  : - lemma: `bits_pos`\n98  : - lemma: `split2`\n99  : - lemma: `bits_succ`\n100 : - lemma: `digits2_eq_bits`\n101 : - lemma: `bits_bounds`\n102 : - theorem: `digits2_Pnat_correct`\n103 : - theorem: `Zdigit_lt`\n104 : - theorem: `Zdigit_0`\n105 : - theorem: `Zdigit_opp`\n106 : - theorem: `Zdigit_ge_Zpower_pos`\n107 : - theorem: `Zdigit_ge_Zpower`\n108 : - theorem: `Zdigit_not_0_pos`\n109 : - theorem: `Zdigit_not_0`\n110 : - theorem: `Zdigit_mul_pow`\n111 : - theorem: `Zdigit_div_pow`\n112 : - theorem: `Zdigit_mod_pow`\n113 : - theorem: `Zdigit_mod_pow_out`\n114 : - theorem: `Zsum_digit_digit`\n115 : - theorem: `ZOmod_plus_pow_digit`\n116 : - theorem: `Zdigit_ext_nonneg`\n117 : - theorem: `ZOdiv_plus_pow_digit`\n118 : - theorem: `Zdigit_plus_nonneg`\n119 : - theorem: `Zdigit_scale_point`\n120 : - theorem: `Zscale_0`\n121 : - theorem: `Zsame_sign_scale`\n122 : - theorem: `Zscale_mul_pow`\n123 : - theorem: `Zscale_scale`\n124 : - theorem: `Zdigit_slice`\n125 : - theorem: `Zdigit_slice_out`\n126 : - theorem: `Zslice_0`\n127 : - theorem: `Zsame_sign_slice`\n128 : - theorem: `Zslice_slice`\n129 : - theorem: `Zslice_mul_pow`\n130 : - theorem: `Zslice_div_pow`\n131 : - theorem: `Zslice_scale`\n132 : - theorem: `Zslice_div_pow_scale_nonnegKp`\n133 : - theorem: `Zplus_slice`\n134 : - theorem: `Zdigits_correct`\n135 : - theorem: `Zdigits_unique`\n136 : - theorem: `Zdigits_abs`\n137 : - theorem: `Zdigits_opp`\n138 : - theorem: `Zdigits_cond_Zopp`\n139 : - theorem: `Zdigits_ge_0`\n140 : - theorem: `Zdigits_gt_0`\n141 : - theorem: `Zdigit_out`\n142 : - theorem: `Zdigit_digits`\n143 : - theorem: `lt_Zdigits`\n144 : - theorem: `Zdigits_le_Zpower`\n145 : - theorem: `Zdigits_slice`\n146 : - theorem: `Zdigits_mult_Zpower`\n147 : - theorem: `Zdigits_Zpower`\n148 : - theorem: `Zdigits_le`\n149 : - theorem: `Zpower_le_Zdigits`\n150 : - theorem: `Zdigits_le_Zdigits`\n151 : - theorem: `Zpower_gt_Zdigits`\n152 : - theorem: `Zdigits_gt_Zpower`\n153 : - theorem: `Zdigits_mult_strong`\n154 : - theorem: `Zdigits_mult`\n155 : - theorem: `Zdigits_mult_ge`\n156 : - theorem: `Zdigits_div_Zpower`\n157 : - theorem: `Zdigits_succ_le`\n158 : - theorem: `Z_of_nat_S_digits2_Pnat`\n159 : - theorem: `Zpos_digits2_pos`\n160 : - theorem: `Zdigits2_Zdigits`\n161 : - lemma: `beta_pos`\n162 : - lemma: `pow_pos_int`\n163 : - lemma: `Zdigit_at_zero`\n164 : - lemma: `Zdigit_eval_nonneg`\n165 : - lemma: `tdiv_zero_iff_lt_of_nonneg_pos`\n166 : - lemma: `tdiv_pow_succ_assoc`\n167 : - lemma: `exists_nonzero_digit`\n168 : - lemma: `tdiv_mod_pow_eq`\n169 : - lemma: `pow_mono_int`\n170 : - lemma: `pow_strict_mono_int`\n171 : - lemma: `wp_mono_pure`\n172 : - lemma: `zscale_div_exact`\n173 : - lemma: `div_mul_pow_eq_div_sub`\n174 : - lemma: `pow_base_mono`\n175 : - lemma: `abs_lt_beta_pow_succ_natAbs`\n176 : - theorem: `Zdigits_aux_bounds`\n177 : - lemma: `natAbs_sub_one_gt_of_nonpos`\n178 : - lemma: `pow_succ_ge`\n179 : - lemma: `pow_le_pow_exponent`\n180 : - lemma: `natAbs_sub_one_eq_add_one_of_nonpos`\n181 : - lemma: `Zdigits_aux_abs_eq`\n182 : - lemma: `Zdigits_pos_aux`\n183 : - lemma: `tdiv_lower_bound`\n184 : - lemma: `tdiv_upper_bound`\n185 : - lemma: `digit_nonzero_at_boundary`\n186 : - lemma: `Zdigits_implies_nonzero_digit`\n187 : - lemma: `digit_sum_bound`\n188 : - lemma: `highest_nonzero_digit_bound`\n189 : - lemma: `Zdigits_nonneg`\n190 : - lemma: `product_upper_bound`\n191 : - lemma: `pow_add_split`\n192 : - lemma: `Zdigits_run_eq`\n193 : - lemma: `Zdigits_sum_product_bound`\n194 : \n195 : ### Mapping (Coq → Lean)\n196 : - `digits2_Pnat_correct` → `digits2_Pnat_correct` (exact-name)\n197 : - `Zdigit_lt` → `Zdigit_lt` (exact-name)\n198 : - `Zdigit_0` → `Zdigit_0` (exact-name)\n199 : - `Zdigit_opp` → `Zdigit_opp` (exact-name)\n200 : - `Zdigit_ge_Zpower_pos` → `Zdigit_ge_Zpower_pos` (exact-name)\n201 : - `Zdigit_ge_Zpower` → `Zdigit_ge_Zpower` (exact-name)\n202 : - `Zdigit_not_0_pos` → `Zdigit_not_0_pos` (exact-name)\n203 : - `Zdigit_not_0` → `Zdigit_not_0` (exact-name)\n204 : - `Zdigit_mul_pow` → `Zdigit_mul_pow` (exact-name)\n205 : - `Zdigit_div_pow` → `Zdigit_div_pow` (exact-name)\n206 : - `Zdigit_mod_pow` → `Zdigit_mod_pow` (exact-name)\n207 : - `Zdigit_mod_pow_out` → `Zdigit_mod_pow_out` (exact-name)\n208 : - `Zsum_digit_digit` → `Zsum_digit_digit` (exact-name)\n209 : - `Zdigit_ext` → `Zdigit_ext_nonneg` (substring-name)\n210 : - `ZOmod_plus_pow_digit` → `ZOmod_plus_pow_digit` (exact-name)\n211 : - `ZOdiv_plus_pow_digit` → `ZOdiv_plus_pow_digit` (exact-name)\n212 : - `Zdigit_plus` → `Zdigit_plus_nonneg` (substring-name)\n213 : - `Zdigit_scale` → `Zdigit_scale_point` (substring-name)\n214 : - `Zscale_0` → `Zscale_0` (exact-name)\n215 : - `Zsame_sign_scale` → `Zsame_sign_scale` (exact-name)\n216 : - `Zscale_mul_pow` → `Zscale_mul_pow` (exact-name)\n217 : - `Zscale_scale` → `Zscale_scale` (exact-name)\n218 : - `Zdigit_slice` → `Zdigit_slice` (exact-name)\n219 : - `Zdigit_slice_out` → `Zdigit_slice_out` (exact-name)\n220 : - `Zslice_0` → `Zslice_0` (exact-name)\n221 : - `Zsame_sign_slice` → `Zsame_sign_slice` (exact-name)\n222 : - `Zslice_slice` → `Zslice_slice` (exact-name)\n223 : - `Zslice_mul_pow` → `Zslice_mul_pow` (exact-name)\n224 : - `Zslice_div_pow` → `Zslice_div_pow` (exact-name)\n225 : - `Zslice_scale` → `Zslice_scale` (exact-name)\n226 : - `Zslice_div_pow_scale` → `Zslice_div_pow` (substring-name)\n227 : - `Zplus_slice` → `Zplus_slice` (exact-name)\n228 : - `Zdigits_correct` → `Zdigits_correct` (exact-name)\n229 : - `Zdigits_unique` → `Zdigits_unique` (exact-name)\n230 : - `Zdigits_abs` → `Zdigits_abs` (exact-name)\n231 : - `Zdigits_opp` → `Zdigits_opp` (exact-name)\n232 : - `Zdigits_cond_Zopp` → `Zdigits_cond_Zopp` (exact-name)\n233 : - `Zdigits_gt_0` → `Zdigits_gt_0` (exact-name)\n234 : - `Zdigits_ge_0` → `Zdigits_ge_0` (exact-name)\n235 : - `Zdigit_out` → `Zdigit_out` (exact-name)\n236 : - `Zdigit_digits` → `Zdigit_digits` (exact-name)\n237 : - `Zdigits_slice` → `Zdigits_slice` (exact-name)\n238 : - `Zdigits_mult_Zpower` → `Zdigits_mult_Zpower` (exact-name)\n239 : - `Zdigits_Zpower` → `Zdigits_Zpower` (exact-name)\n240 : - `Zdigits_le` → `Zdigits_le` (exact-name)\n241 : - `lt_Zdigits` → `lt_Zdigits` (exact-name)\n242 : - `Zpower_le_Zdigits` → `Zpower_le_Zdigits` (exact-name)\n243 : - `Zdigits_le_Zpower` → `Zdigits_le_Zpower` (exact-name)\n244 : - `Zpower_gt_Zdigits` → `Zpower_gt_Zdigits` (exact-name)\n245 : - `Zdigits_gt_Zpower` → `Zdigits_gt_Zpower` (exact-name)\n246 : - `Zdigits_mult_strong` → `Zdigits_mult_strong` (exact-name)\n247 : - `Zdigits_mult` → `Zdigits_mult` (exact-name)\n248 : - `Zdigits_mult_ge` → `Zdigits_mult_ge` (exact-name)\n249 : - `Zdigits_div_Zpower` → `Zdigits_div_Zpower` (exact-name)\n250 : - `Zdigits_succ_le` → `Zdigits_succ_le` (exact-name)\n251 : - `Z_of_nat_S_digits2_Pnat` → `Z_of_nat_S_digits2_Pnat` (exact-name)\n252 : - `Zpos_digits2_pos` → `Zpos_digits2_pos` (exact-name)\n253 : - `Zdigits2_Zdigits` → `Zdigits2_Zdigits` (exact-name)\n254 : \n255 : ## File: FIX.v\n256 : - Coq file: FIX.v\n257 : - Lean file(s): FIX.lean\n258 : \n259 : ### Coq Declarations\n260 : - Theorem: `generic_format_FIX`\n261 : - Theorem: `FIX_format_generic`\n262 : - Theorem: `FIX_format_satisfies_any`\n263 : - Theorem: `ulp_FIX`\n264 : - Theorem: `round_FIX_IZR`\n265 : \n266 : ### Lean Declarations\n267 : - theorem: `FIX_exp_spec`\n268 : - theorem: `FIX_format_spec`\n269 : - theorem: `FIX_exp_correct_spec`\n270 : - theorem: `FIX_format_0_spec`\n271 : - theorem: `FIX_format_opp_spec`\n272 : \n273 : ### Mapping (Coq → Lean)\n274 : - `generic_format_FIX` → (no match)\n275 : - `FIX_format_generic` → (no match)\n276 : - `FIX_format_satisfies_any` → (no match)\n277 : - `ulp_FIX` → (no match)\n278 : - `ulp_FIX` → `ulp_FIX` (exact-name)\n279 : - `round_FIX_IZR` → (no match)\n280 :  - `round_FIX_IZR` → `round_FIX_IZR` (exact-name)\n281 : \n282 : ## File: FLT.v\n283 : - Coq file: FLT.v\n284 : - Lean file(s): FLT.lean\n285 : \n286 : ### Coq Declarations\n287 : - Theorem: `generic_format_FLT`\n288 : - Theorem: `FLT_format_generic`\n289 : - Theorem: `generic_format_FLT_bpow`\n290 : - Theorem: `FLT_format_bpow`\n291 : - Theorem: `FLT_format_satisfies_any`\n292 : - Theorem: `cexp_FLT_FLX`\n293 : - Theorem: `generic_format_FLT_FLX`\n294 : - Theorem: `generic_format_FLX_FLT`\n295 : - Theorem: `round_FLT_FLX`\n296 : - Theorem: `cexp_FLT_FIX`\n297 : - Theorem: `generic_format_FIX_FLT`\n298 : - Theorem: `generic_format_FLT_FIX`\n299 : - Lemma: `negligible_exp_FLT`\n300 : - Theorem: `generic_format_FLT_1`\n301 : - Theorem: `ulp_FLT_0`\n302 : - Theorem: `ulp_FLT_small`\n303 : - Theorem: `ulp_FLT_le`\n304 : - Theorem: `ulp_FLT_gt`\n305 : - Lemma: `ulp_FLT_exact_shift`\n306 : - Lemma: `succ_FLT_exact_shift_pos`\n307 : - Lemma: `succ_FLT_exact_shift`\n308 : - Lemma: `pred_FLT_exact_shift`\n309 : - Theorem: `ulp_FLT_pred_pos`\n310 : \n311 : ### Lean Declarations\n312 : - theorem: `FLT_exp_spec`\n313 : - theorem: `FLT_format_spec`\n314 : - theorem: `FLT_exp_correct_spec`\n315 : - theorem: `FLT_format_0_spec`\n316 : - theorem: `FLT_format_opp_spec`\n317 : - theorem: `FLT_format_abs_spec`\n318 : - theorem: `FLT_exp_FLX_spec`\n319 : \n320 : ### Mapping (Coq → Lean)\n321 :  - `generic_format_FLT` → `generic_format_FLT` (exact-name)\n322 :  - `FLT_format_generic` → `FLT_format_generic` (exact-name)\n323 : - `generic_format_FLT_bpow` → (no match)\n324 : - `FLT_format_bpow` → (no match)\n325 :  - `FLT_format_satisfies_any` → `FLT_format_satisfies_any` (exact-name)\n326 : - `cexp_FLT_FLX` → (no match)\n327 :  - `cexp_FLT_FLX` → `cexp_FLT_FLX` (exact-name)\n328 : - `generic_format_FLT_FLX` → (no match)\n329 : - `generic_format_FLX_FLT` → `generic_format_FLX_FLT` (exact-name)\n330 : - `round_FLT_FLX` → `round_FLT_FLX` (exact-name)\n331 :  - `cexp_FLT_FIX` → `cexp_FLT_FIX` (exact-name)\n332 : - `generic_format_FIX_FLT` → (no match)\n333 : - `generic_format_FLT_FIX` → (no match)\n334 : - `negligible_exp_FLT` → (no match)\n335 : - `generic_format_FLT_1` → `generic_format_FLT_1` (exact-name)\n336 :  - `ulp_FLT_0` → `ulp_FLT_0` (exact-name)\n337 :  - `ulp_FLT_small` → `ulp_FLT_small` (exact-name)\n338 : - `ulp_FLT_le` → (no match)\n339 : - `ulp_FLT_gt` → (no match)\n340 : - `ulp_FLT_exact_shift` → (no match)\n341 : - `succ_FLT_exact_shift_pos` → (no match)\n342 : - `succ_FLT_exact_shift` → (no match)\n343 : - `pred_FLT_exact_shift` → (no match)\n344 : - `ulp_FLT_pred_pos` → (no match)\n345 : \n346 : ## File: FLX.v\n347 : - Coq file: FLX.v\n348 : - Lean file(s): FLX.lean\n349 : \n350 : ### Coq Declarations\n351 : - Theorem: `FIX_format_FLX`\n352 : - Theorem: `FLX_format_generic`\n353 : - Theorem: `generic_format_FLX`\n354 : - Theorem: `FLX_format_satisfies_any`\n355 : - Theorem: `FLX_format_FIX`\n356 : - Theorem: `generic_format_FLXN`\n357 : - Theorem: `FLXN_format_generic`\n358 : - Theorem: `FLXN_format_satisfies_any`\n359 : - Lemma: `negligible_exp_FLX`\n360 : - Theorem: `generic_format_FLX_1`\n361 : - Theorem: `ulp_FLX_0`\n362 : - Lemma: `ulp_FLX_1`\n363 : - Lemma: `succ_FLX_1`\n364 : - Theorem: `eq_0_round_0_FLX`\n365 : - Theorem: `gt_0_round_gt_0_FLX`\n366 : - Theorem: `ulp_FLX_le`\n367 : - Theorem: `ulp_FLX_ge`\n368 : - Lemma: `ulp_FLX_exact_shift`\n369 : - Lemma: `succ_FLX_exact_shift`\n370 : - Lemma: `pred_FLX_exact_shift`\n371 : \n372 : ### Lean Declarations\n373 : - theorem: `FLX_exp_spec`\n374 : - theorem: `FLX_format_spec`\n375 : - theorem: `FLX_exp_correct_spec`\n376 : - theorem: `FLX_format_0_spec`\n377 : - theorem: `FLX_format_opp_spec`\n378 : - theorem: `FLX_format_abs_spec`\n379 : - theorem: `ulp_FLX_1`\n380 : \n381 : ### Mapping (Coq → Lean)\n382 : - `FIX_format_FLX` → (no match)\n383 :  - `FLX_format_generic` → `FLX_format_generic` (exact-name)\n384 : - `generic_format_FLX` → (no match)\n385 : - `FLX_format_satisfies_any` → `FLX_format_satisfies_any` (exact-name)\n386 : - `FLX_format_FIX` → (no match)\n387 : - `generic_format_FLXN` → (no match)\n388 : - `FLXN_format_generic` → (no match)\n389 : - `FLXN_format_satisfies_any` → (no match)\n390 : - `negligible_exp_FLX` → (no match)\n391 : - `generic_format_FLX_1` → `generic_format_FLX_1` (exact-name)\n392 : - `ulp_FLX_0` → `ulp_FLX_0` (exact-name)\n393 : - `ulp_FLX_1` → `ulp_FLX_1` (exact-name)\n394 : - `succ_FLX_1` → (no match)\n395 : - `eq_0_round_0_FLX` → (no match)\n396 : - `gt_0_round_gt_0_FLX` → (no match)\n397 : - `ulp_FLX_le` → `ulp_FLX_le` (exact-name)\n398 : - `ulp_FLX_ge` → (no match)\n399 :  - `ulp_FLX_ge` → `ulp_FLX_ge` (exact-name)\n400 : - `ulp_FLX_exact_shift` → (no match)\n401 :  - `ulp_FLX_exact_shift` → `ulp_FLX_exact_shift` (exact-name)\n402 : - `succ_FLX_exact_shift` → (no match)\n403 : - `pred_FLX_exact_shift` → (no match)\n404 : \n405 : ## File: FTZ.v\n406 : - Coq file: FTZ.v\n407 : - Lean file(s): FTZ.lean\n408 : \n409 : ### Coq Declarations\n410 : - Theorem: `FLXN_format_FTZ`\n411 : - Theorem: `generic_format_FTZ`\n412 : - Theorem: `FTZ_format_generic`\n413 : - Theorem: `FTZ_format_satisfies_any`\n414 : - Theorem: `FTZ_format_FLXN`\n415 : - Theorem: `ulp_FTZ_0`\n416 : - Theorem: `round_FTZ_FLX`\n417 : - Theorem: `round_FTZ_small`\n418 : \n419 : ### Lean Declarations\n420 : - theorem: `FTZ_exp_spec`\n421 : - theorem: `FTZ_format_spec`\n422 : - theorem: `FTZ_exp_correct_spec`\n423 : - theorem: `FTZ_format_0_spec`\n424 : - theorem: `FTZ_format_opp_spec`\n425 : - theorem: `FTZ_format_abs_spec`\n426 : \n427 : ### Mapping (Coq → Lean)\n428 : - `FLXN_format_FTZ` → `FLXN_format_FTZ` (exact-name)\n429 : - `generic_format_FTZ` → `generic_format_FTZ` (exact-name)\n430 : - `FTZ_format_generic` → `FTZ_format_generic` (exact-name)\n431 : - `FTZ_format_satisfies_any` → `FTZ_format_satisfies_any` (exact-name)\n432 : - `FTZ_format_FLXN` → `FTZ_format_FLXN` (exact-name)\n433 : - `ulp_FTZ_0` → `ulp_FTZ_0` (exact-name)\n434 : - `round_FTZ_FLX` → `round_FTZ_FLX` (exact-name)\n435 : - `round_FTZ_small` → `round_FTZ_small` (exact-name)\n436 : \n437 : ## File: Float_prop.v\n438 : - Coq file: Float_prop.v\n439 : - Lean file(s): Float_prop.lean\n440 : \n441 : ### Coq Declarations\n442 : - Theorem: `Rcompare_F2R`\n443 : - Theorem: `le_F2R`\n444 : - Theorem: `F2R_le`\n445 : - Theorem: `lt_F2R`\n446 : - Theorem: `F2R_lt`\n447 : - Theorem: `F2R_eq`\n448 : - Theorem: `eq_F2R`\n449 : - Theorem: `F2R_Zabs`\n450 : - Theorem: `F2R_Zopp`\n451 : - Theorem: `F2R_cond_Zopp`\n452 : - Theorem: `F2R_0`\n453 : - Theorem: `eq_0_F2R`\n454 : - Theorem: `ge_0_F2R`\n455 : - Theorem: `le_0_F2R`\n456 : - Theorem: `gt_0_F2R`\n457 : - Theorem: `lt_0_F2R`\n458 : - Theorem: `F2R_ge_0`\n459 : - Theorem: `F2R_le_0`\n460 : - Theorem: `F2R_gt_0`\n461 : - Theorem: `F2R_lt_0`\n462 : - Theorem: `F2R_neq_0`\n463 : - Lemma: `Fnum_ge_0`\n464 : - Lemma: `Fnum_le_0`\n465 : - Theorem: `F2R_bpow`\n466 : - Theorem: `bpow_le_F2R`\n467 : - Theorem: `F2R_p1_le_bpow`\n468 : - Theorem: `bpow_le_F2R_m1`\n469 : - Theorem: `F2R_lt_bpow`\n470 : - Theorem: `F2R_change_exp`\n471 : - Theorem: `F2R_prec_normalize`\n472 : - Theorem: `mag_F2R_bounds`\n473 : - Theorem: `mag_F2R`\n474 : - Theorem: `Zdigits_mag`\n475 : - Theorem: `mag_F2R_Zdigits`\n476 : - Theorem: `mag_F2R_bounds_Zdigits`\n477 : - Theorem: `float_distribution_pos`\n478 : \n479 : ### Lean Declarations\n480 : - theorem: `Rcompare_F2R`\n481 : - theorem: `le_F2R`\n482 : - theorem: `F2R_le`\n483 : - theorem: `lt_F2R`\n484 : - theorem: `F2R_lt`\n485 : - theorem: `F2R_eq`\n486 : - theorem: `eq_F2R`\n487 : - theorem: `F2R_Zabs`\n488 : - theorem: `F2R_Zopp`\n489 : - theorem: `F2R_cond_Zopp`\n490 : - theorem: `F2R_0`\n491 : - theorem: `eq_0_F2R`\n492 : - theorem: `ge_0_F2R`\n493 : - theorem: `le_0_F2R`\n494 : - theorem: `gt_0_F2R`\n495 : - theorem: `lt_0_F2R`\n496 : - theorem: `F2R_ge_0`\n497 : - theorem: `F2R_le_0`\n498 : - theorem: `F2R_gt_0`\n499 : - theorem: `F2R_lt_0`\n500 : - theorem: `F2R_neq_0`\n501 : - theorem: `F2R_bpow`\n502 : - theorem: `bpow_le_F2R`\n503 : - theorem: `F2R_p1_le_bpow`\n504 : - theorem: `bpow_le_F2R_m1`\n505 : - theorem: `F2R_lt_bpow`\n506 : - theorem: `F2R_change_exp`\n507 : - theorem: `F2R_prec_normalize`\n508 : - theorem: `mag_F2R_bounds`\n509 : - theorem: `mag_F2R`\n510 : - theorem: `Zdigits_mag`\n511 : - theorem: `mag_F2R_Zdigits`\n512 : - theorem: `mag_F2R_bounds_Zdigits`\n513 : - theorem: `float_distribution_pos`\n514 : \n515 : ### Mapping (Coq → Lean)\n516 : - `Rcompare_F2R` → `Rcompare_F2R` (exact-name)\n517 : - `le_F2R` → `le_F2R` (exact-name)\n518 : - `F2R_le` → `F2R_le` (exact-name)\n519 : - `lt_F2R` → `lt_F2R` (exact-name)\n520 : - `F2R_lt` → `F2R_lt` (exact-name)\n521 : - `F2R_eq` → `F2R_eq` (exact-name)\n522 : - `eq_F2R` → `eq_F2R` (exact-name)\n523 : - `F2R_Zabs` → `F2R_Zabs` (exact-name)\n524 : - `F2R_Zopp` → `F2R_Zopp` (exact-name)\n525 : - `F2R_cond_Zopp` → `F2R_cond_Zopp` (exact-name)\n526 : - `F2R_0` → `F2R_0` (exact-name)\n527 : - `eq_0_F2R` → `eq_0_F2R` (exact-name)\n528 : - `ge_0_F2R` → `ge_0_F2R` (exact-name)\n529 : - `le_0_F2R` → `le_0_F2R` (exact-name)\n530 : - `gt_0_F2R` → `gt_0_F2R` (exact-name)\n531 : - `lt_0_F2R` → `lt_0_F2R` (exact-name)\n532 : - `F2R_ge_0` → `F2R_ge_0` (exact-name)\n533 : - `F2R_le_0` → `F2R_le_0` (exact-name)\n534 : - `F2R_gt_0` → `F2R_gt_0` (exact-name)\n535 : - `F2R_lt_0` → `F2R_lt_0` (exact-name)\n536 : - `F2R_neq_0` → `F2R_neq_0` (exact-name)\n537 : - `Fnum_ge_0` → `Fnum_ge_0` (exact-name)\n538 : - `Fnum_le_0` → `Fnum_le_0` (exact-name)\n539 : - `F2R_bpow` → `F2R_bpow` (exact-name)\n540 : - `bpow_le_F2R` → `bpow_le_F2R` (exact-name)\n541 : - `F2R_p1_le_bpow` → `F2R_p1_le_bpow` (exact-name)\n542 : - `bpow_le_F2R_m1` → `bpow_le_F2R_m1` (exact-name)\n543 : - `F2R_lt_bpow` → `F2R_lt_bpow` (exact-name)\n544 : - `F2R_change_exp` → `F2R_change_exp` (exact-name)\n545 : - `F2R_prec_normalize` → `F2R_prec_normalize` (exact-name)\n546 : - `mag_F2R_bounds` → `mag_F2R_bounds` (exact-name)\n547 : - `mag_F2R` → `mag_F2R` (exact-name)\n548 : - `Zdigits_mag` → `Zdigits_mag` (exact-name)\n549 : - `mag_F2R_Zdigits` → `mag_F2R_Zdigits` (exact-name)\n550 : - `mag_F2R_bounds_Zdigits` → `mag_F2R_bounds_Zdigits` (exact-name)\n551 : - `float_distribution_pos` → `float_distribution_pos` (exact-name)\n552 : \n553 : ## File: Generic_fmt.v\n554 : - Coq file: Generic_fmt.v\n555 : - Lean file(s): Generic_fmt.lean, Round_generic.lean\n556 : \n557 : ### Coq Declarations\n558 : - Theorem: `valid_exp_large`\n559 : - Theorem: `valid_exp_large'`\n560 : - Theorem: `generic_format_0`\n561 : - Theorem: `cexp_opp`\n562 : - Theorem: `cexp_abs`\n563 : - Theorem: `canonical_generic_format`\n564 : - Theorem: `generic_format_bpow`\n565 : - Theorem: `generic_format_bpow'`\n566 : - Theorem: `generic_format_F2R`\n567 : - Lemma: `generic_format_F2R'`\n568 : - Theorem: `canonical_opp`\n569 : - Theorem: `canonical_abs`\n570 : - Theorem: `canonical_0`\n571 : - Theorem: `canonical_unique`\n572 : - Theorem: `scaled_mantissa_generic`\n573 : - Theorem: `scaled_mantissa_mult_bpow`\n574 : - Theorem: `scaled_mantissa_0`\n575 : - Theorem: `scaled_mantissa_opp`\n576 : - Theorem: `scaled_mantissa_abs`\n577 : - Theorem: `generic_format_opp`\n578 : - Theorem: `generic_format_abs`\n579 : - Theorem: `generic_format_abs_inv`\n580 : - Theorem: `cexp_fexp`\n581 : - Theorem: `cexp_fexp_pos`\n582 : - Theorem: `mantissa_small_pos`\n583 : - Theorem: `scaled_mantissa_lt_1`\n584 : - Theorem: `scaled_mantissa_lt_bpow`\n585 : - Theorem: `mag_generic_gt`\n586 : - Lemma: `mantissa_DN_small_pos`\n587 : - Lemma: `mantissa_UP_small_pos`\n588 : - Theorem: `generic_format_discrete`\n589 : - Theorem: `generic_format_canonical`\n590 : - Theorem: `generic_format_ge_bpow`\n591 : - Theorem: `abs_lt_bpow_prec`\n592 : - Theorem: `generic_format_bpow_inv'`\n593 : - Theorem: `generic_format_bpow_inv`\n594 : - Theorem: `Zrnd_DN_or_UP`\n595 : - Theorem: `Zrnd_ZR_or_AW`\n596 : - Theorem: `round_bounded_large_pos`\n597 : - Theorem: `round_bounded_small_pos`\n598 : - Lemma: `round_le_pos`\n599 : - Theorem: `round_generic`\n600 : - Theorem: `round_0`\n601 : - Theorem: `exp_small_round_0_pos`\n602 : - Lemma: `generic_format_round_pos`\n603 : - Theorem: `round_ext`\n604 : - Theorem: `round_opp`\n605 : - Theorem: `round_DN_or_UP`\n606 : - Theorem: `round_ZR_or_AW`\n607 : - Theorem: `round_le`\n608 : - Theorem: `round_ge_generic`\n609 : - Theorem: `round_le_generic`\n610 : - Theorem: `round_abs_abs`\n611 : - Theorem: `round_bounded_large`\n612 : - Theorem: `exp_small_round_0`\n613 : - Theorem: `abs_round_ge_generic`\n614 : - Theorem: `abs_round_le_generic`\n615 : - Theorem: `round_DN_opp`\n616 : - Theorem: `round_UP_opp`\n617 : - Theorem: `round_ZR_opp`\n618 : - Theorem: `round_ZR_abs`\n619 : - Theorem: `round_AW_opp`\n620 : - Theorem: `round_AW_abs`\n621 : - Theorem: `round_ZR_DN`\n622 : - Theorem: `round_ZR_UP`\n623 : - Theorem: `round_AW_UP`\n624 : - Theorem: `round_AW_DN`\n625 : - Theorem: `generic_format_round`\n626 : - Theorem: `round_DN_pt`\n627 : - Theorem: `generic_format_satisfies_any`\n628 : - Theorem: `round_UP_pt`\n629 : - Theorem: `round_ZR_pt`\n630 : - Lemma: `round_DN_small_pos`\n631 : - Theorem: `round_DN_UP_lt`\n632 : - Lemma: `round_UP_small_pos`\n633 : - Theorem: `generic_format_EM`\n634 : - Lemma: `round_large_pos_ge_bpow`\n635 : - Theorem: `mag_round_ZR`\n636 : - Theorem: `mag_round`\n637 : - Theorem: `mag_DN`\n638 : - Theorem: `cexp_DN`\n639 : - Theorem: `scaled_mantissa_DN`\n640 : - Theorem: `generic_N_pt_DN_or_UP`\n641 : - Theorem: `subnormal_exponent`\n642 : - Lemma: `cexp_le_bpow`\n643 : - Lemma: `cexp_ge_bpow`\n644 : - Lemma: `lt_cexp_pos`\n645 : - Theorem: `lt_cexp`\n646 : - Theorem: `mag_round_ge`\n647 : - Theorem: `cexp_round_ge`\n648 : - Theorem: `Znearest_DN_or_UP`\n649 : - Theorem: `Znearest_ge_floor`\n650 : - Theorem: `Znearest_le_ceil`\n651 : - Theorem: `Znearest_N_strict`\n652 : - Theorem: `Znearest_half`\n653 : - Theorem: `Znearest_imp`\n654 : - Theorem: `round_N_pt`\n655 : - Theorem: `round_N_middle`\n656 : - Lemma: `round_N_small_pos`\n657 : - Theorem: `round_NA_pt`\n658 : - Theorem: `round_N0_pt`\n659 : - Theorem: `Znearest_opp`\n660 : - Theorem: `round_N_opp`\n661 : - Lemma: `round_N0_opp`\n662 : - Lemma: `round_N_small`\n663 : - Theorem: `generic_inclusion_mag`\n664 : - Theorem: `generic_inclusion_lt_ge`\n665 : - Theorem: `generic_inclusion`\n666 : - Theorem: `generic_inclusion_le_ge`\n667 : - Theorem: `generic_inclusion_le`\n668 : - Theorem: `generic_inclusion_ge`\n669 : - Theorem: `generic_round_generic`\n670 : - Lemma: `round_NA_opp`\n671 : \n672 : ### Lean Declarations\n673 : - lemma: `Ztrunc_int`\n674 : - lemma: `zpow_ne_zero_of_pos`\n675 : - theorem: `valid_exp_large`\n676 : - theorem: `cexp_spec`\n677 : - theorem: `scaled_mantissa_spec`\n678 : - theorem: `generic_format_spec`\n679 : - theorem: `Ztrunc_neg`\n680 : - theorem: `Ztrunc_intCast`\n681 : - theorem: `zpow_mul_sub`\n682 : - theorem: `zpow_sub_add`\n683 : - theorem: `zpow_nonneg_toNat`\n684 : - theorem: `generic_format_0`\n685 : - theorem: `cexp_opp`\n686 : - theorem: `cexp_abs`\n687 : - theorem: `canonical_generic_format`\n688 : - theorem: `scaled_mantissa_mult_bpow`\n689 : - lemma: `Ztrunc_zero`\n690 : - theorem: `generic_format_F2R`\n691 : - theorem: `canonical_opp`\n692 : - theorem: `canonical_abs`\n693 : - theorem: `canonical_0`\n694 : - theorem: `canonical_unique`\n695 : - theorem: `scaled_mantissa_0`\n696 : - theorem: `scaled_mantissa_opp`\n697 : - theorem: `scaled_mantissa_abs`\n698 : - theorem: `generic_format_opp`\n699 : - theorem: `generic_format_abs`\n700 : - theorem: `generic_format_abs_inv`\n701 : - theorem: `generic_format_satisfies_any`\n702 : - theorem: `round_UP_exists`\n703 : - theorem: `generic_format_bpow`\n704 : - theorem: `scaled_mantissa_generic`\n705 : - theorem: `cexp_fexp`\n706 : - theorem: `cexp_fexp_pos`\n707 : - theorem: `mantissa_small_pos`\n708 : - theorem: `scaled_mantissa_lt_1`\n709 : - theorem: `scaled_mantissa_lt_bpow`\n710 : - theorem: `generic_format_round_DN`\n711 : - theorem: `generic_format_round_UP`\n712 : - theorem: `generic_format_precision_bound`\n713 : - theorem: `fexp_monotone`\n714 : - theorem: `generic_format_equiv`\n715 : - theorem: `round_to_generic_spec`\n716 : - theorem: `generic_format_inter_valid`\n717 : - theorem: `mag_generic_format`\n718 : - theorem: `precision_generic_format`\n719 : - theorem: `generic_format_error_bound`\n720 : - theorem: `generic_format_relative_error`\n721 : - theorem: `round_to_format_properties`\n722 : - theorem: `generic_format_neg_closed`\n723 : - theorem: `Rnd_UP_to_DN_via_neg`\n724 : \n725 : ### Mapping (Coq → Lean)\n726 : - `valid_exp_large` → `valid_exp_large` (exact-name)\n727 : - `valid_exp_large'` → `valid_exp_large` (normalized-name)\n728 : - `generic_format_0` → `generic_format_0` (exact-name)\n729 : - `cexp_opp` → `cexp_opp` (exact-name)\n730 : - `cexp_abs` → `cexp_abs` (exact-name)\n731 : - `canonical_generic_format` → `canonical_generic_format` (exact-name)\n732 : - `generic_format_bpow` → `generic_format_bpow` (exact-name)\n733 : - `generic_format_bpow'` → `generic_format_bpow` (normalized-name)\n734 : - `generic_format_F2R` → `generic_format_F2R` (exact-name)\n735 : - `generic_format_F2R'` → `generic_format_F2R` (normalized-name)\n736 : - `canonical_opp` → `canonical_opp` (exact-name)\n737 : - `canonical_abs` → `canonical_abs` (exact-name)\n738 : - `canonical_0` → `canonical_0` (exact-name)\n739 : - `canonical_unique` → `canonical_unique` (exact-name)\n740 : - `scaled_mantissa_generic` → `scaled_mantissa_generic` (exact-name)\n741 : - `scaled_mantissa_mult_bpow` → `scaled_mantissa_mult_bpow` (exact-name)\n742 : - `scaled_mantissa_0` → `scaled_mantissa_0` (exact-name)\n743 : - `scaled_mantissa_opp` → `scaled_mantissa_opp` (exact-name)\n744 : - `scaled_mantissa_abs` → `scaled_mantissa_abs` (exact-name)\n745 : - `generic_format_opp` → `generic_format_opp` (exact-name)\n746 : - `generic_format_abs` → `generic_format_abs` (exact-name)\n747 : - `generic_format_abs_inv` → `generic_format_abs_inv` (exact-name)\n748 : - `cexp_fexp` → `cexp_fexp` (exact-name)\n749 : - `cexp_fexp_pos` → `cexp_fexp_pos` (exact-name)\n750 : - `mantissa_small_pos` → `mantissa_small_pos` (exact-name)\n751 : - `scaled_mantissa_lt_1` → `scaled_mantissa_lt_1` (exact-name)\n752 : - `mag_generic_gt` → `mag_generic_gt` (exact-name)\n753 : - `mantissa_DN_small_pos` → (no match)\n754 : - `mantissa_UP_small_pos` → (no match)\n755 : - `generic_format_discrete` → (no match)\n756 : - `generic_format_canonical` → (no match)\n757 : - `generic_format_ge_bpow` → (no match)\n758 : - `abs_lt_bpow_prec` → (no match)\n759 : - `generic_format_bpow_inv'` → `generic_format_bpow` (substring-name)\n760 : - `generic_format_bpow_inv` → `generic_format_bpow` (substring-name)\n761 : - `Zrnd_DN_or_UP` → (no match)\n762 : - `Zrnd_ZR_or_AW` → (no match)\n763 : - `round_bounded_large_pos` → (no match)\n764 : - `round_bounded_small_pos` → (no match)\n765 : - `round_le_pos` → (no match)\n766 : - `round_generic` → (no match)\n767 : - `round_0` → `round_0` (exact-name)\n768 : - `exp_small_round_0_pos` → (no match)\n769 : - `generic_format_round_pos` → (no match)\n770 : - `round_ext` → (no match)\n771 : - `round_opp` → (no match)\n772 : - `round_DN_or_UP` → (no match)\n773 : - `round_ZR_or_AW` → (no match)\n774 : - `round_le` → (no match)\n775 : - `round_ge_generic` → (no match)\n776 : - `round_le_generic` → (no match)\n777 : - `round_abs_abs` → (no match)\n778 : - `round_bounded_large` → (no match)\n779 : - `exp_small_round_0` → (no match)\n780 : - `abs_round_ge_generic` → (no match)\n781 : - `abs_round_le_generic` → (no match)\n782 : - `round_DN_opp` → (no match)\n783 : - `round_UP_opp` → (no match)\n784 : - `round_ZR_opp` → (no match)\n785 : - `round_ZR_abs` → (no match)\n786 : - `round_AW_opp` → (no match)\n787 : - `round_AW_abs` → (no match)\n788 : - `round_ZR_DN` → (no match)\n789 : - `round_ZR_UP` → (no match)\n790 : - `round_AW_UP` → (no match)\n791 : - `round_AW_DN` → (no match)\n792 : - `generic_format_round` → `generic_format_round_DN` (substring-name)\n793 : - `round_DN_pt` → (no match)\n794 : - `generic_format_satisfies_any` → `generic_format_satisfies_any` (exact-name)\n795 : - `round_UP_pt` → (no match)\n796 : - `round_ZR_pt` → (no match)\n797 : - `round_DN_small_pos` → (no match)\n798 : - `round_DN_UP_lt` → (no match)\n799 : - `round_UP_small_pos` → (no match)\n800 : - `generic_format_EM` → (no match)\n801 : - `round_large_pos_ge_bpow` → (no match)\n802 : - `mag_round_ZR` → (no match)\n803 : - `mag_round` → (no match)\n804 : - `mag_DN` → (no match)\n805 : - `cexp_DN` → (no match)\n806 : - `scaled_mantissa_DN` → (no match)\n807 : - `generic_N_pt_DN_or_UP` → (no match)\n808 : - `subnormal_exponent` → (no match)\n809 : - `cexp_le_bpow` → (no match)\n810 : - `cexp_ge_bpow` → (no match)\n811 : - `lt_cexp_pos` → (no match)\n812 : - `lt_cexp` → (no match)\n813 : - `mag_round_ge` → (no match)\n814 : - `cexp_round_ge` → (no match)\n815 : - `Znearest_DN_or_UP` → (no match)\n816 : - `Znearest_ge_floor` → (no match)\n817 : - `Znearest_le_ceil` → (no match)\n818 : - `Znearest_N_strict` → (no match)\n819 : - `Znearest_half` → (no match)\n820 : - `Znearest_imp` → (no match)\n821 : - `round_N_pt` → (no match)\n822 : - `round_N_middle` → (no match)\n823 : - `round_N_small_pos` → (no match)\n824 : - `round_NA_pt` → (no match)\n825 : - `round_N0_pt` → (no match)\n826 : - `Znearest_opp` → (no match)\n827 : - `round_N_opp` → (no match)\n828 : - `round_N0_opp` → (no match)\n829 : - `round_N_small` → (no match)\n830 : - `generic_inclusion_mag` → (no match)\n831 : - `generic_inclusion_lt_ge` → (no match)\n832 : - `generic_inclusion` → (no match)\n833 : - `generic_inclusion_le_ge` → (no match)\n834 : - `generic_inclusion_le` → (no match)\n835 : - `generic_inclusion_ge` → (no match)\n836 : - `generic_round_generic` → (no match)\n837 : - `round_NA_opp` → (no match)\n838 : \n839 : ## File: Raux.v\n840 : - Coq file: Raux.v\n841 : - Lean file(s): Raux.lean\n842 : \n843 : ### Coq Declarations\n844 : - Theorem: `Rle_0_minus`\n845 : - Theorem: `Rabs_eq_Rabs`\n846 : - Theorem: `Rabs_minus_le`\n847 : - Theorem: `Rabs_eq_R0`\n848 : - Theorem: `Rmult_lt_compat`\n849 : - Lemma: `Rmult_neq_reg_r`\n850 : - Lemma: `Rmult_neq_compat_r`\n851 : - Theorem: `Rmult_min_distr_r`\n852 : - Theorem: `Rmult_min_distr_l`\n853 : - Lemma: `Rmin_opp`\n854 : - Lemma: `Rmax_opp`\n855 : - Theorem: `exp_le`\n856 : - Theorem: `Rinv_lt`\n857 : - Theorem: `Rinv_le`\n858 : - Theorem: `sqrt_ge_0`\n859 : - Lemma: `sqrt_neg`\n860 : - Lemma: `Rsqr_le_abs_0_alt`\n861 : - Theorem: `Rabs_le_inv`\n862 : - Theorem: `Rabs_ge`\n863 : - Theorem: `Rabs_ge_inv`\n864 : - Theorem: `Rabs_lt`\n865 : - Theorem: `Rabs_lt_inv`\n866 : - Theorem: `Rabs_gt`\n867 : - Theorem: `Rabs_gt_inv`\n868 : - Theorem: `IZR_le_lt`\n869 : - Theorem: `le_lt_IZR`\n870 : - Theorem: `neq_IZR`\n871 : - Theorem: `Rcompare_spec`\n872 : - Theorem: `Rcompare_Lt`\n873 : - Theorem: `Rcompare_Lt_inv`\n874 : - Theorem: `Rcompare_not_Lt`\n875 : - Theorem: `Rcompare_not_Lt_inv`\n876 : - Theorem: `Rcompare_Eq`\n877 : - Theorem: `Rcompare_Eq_inv`\n878 : - Theorem: `Rcompare_Gt`\n879 : - Theorem: `Rcompare_Gt_inv`\n880 : - Theorem: `Rcompare_not_Gt`\n881 : - Theorem: `Rcompare_not_Gt_inv`\n882 : - Theorem: `Rcompare_IZR`\n883 : - Theorem: `Rcompare_sym`\n884 : - Lemma: `Rcompare_opp`\n885 : - Theorem: `Rcompare_plus_r`\n886 : - Theorem: `Rcompare_plus_l`\n887 : - Theorem: `Rcompare_mult_r`\n888 : - Theorem: `Rcompare_mult_l`\n889 : - Theorem: `Rcompare_middle`\n890 : - Theorem: `Rcompare_half_l`\n891 : - Theorem: `Rcompare_half_r`\n892 : - Theorem: `Rcompare_sqr`\n893 : - Theorem: `Rmin_compare`\n894 : - Theorem: `Rle_bool_spec`\n895 : - Theorem: `Rle_bool_true`\n896 : - Theorem: `Rle_bool_false`\n897 : - Theorem: `Rlt_bool_spec`\n898 : - Theorem: `negb_Rlt_bool`\n899 : - Theorem: `negb_Rle_bool`\n900 : - Theorem: `Rlt_bool_true`\n901 : - Theorem: `Rlt_bool_false`\n902 : - Lemma: `Rlt_bool_opp`\n903 : - Theorem: `Req_bool_spec`\n904 : - Theorem: `Req_bool_true`\n905 : - Theorem: `Req_bool_false`\n906 : - Theorem: `Zfloor_lb`\n907 : - Theorem: `Zfloor_ub`\n908 : - Theorem: `Zfloor_lub`\n909 : - Theorem: `Zfloor_imp`\n910 : - Theorem: `Zfloor_IZR`\n911 : - Theorem: `Zfloor_le`\n912 : - Theorem: `Zceil_ub`\n913 : - Theorem: `Zceil_lb`\n914 : - Theorem: `Zceil_glb`\n915 : - Theorem: `Zceil_imp`\n916 : - Theorem: `Zceil_IZR`\n917 : - Theorem: `Zceil_le`\n918 : - Theorem: `Zceil_floor_neq`\n919 : - Theorem: `Ztrunc_IZR`\n920 : - Theorem: `Ztrunc_floor`\n921 : - Theorem: `Ztrunc_ceil`\n922 : - Theorem: `Ztrunc_le`\n923 : - Theorem: `Ztrunc_opp`\n924 : - Theorem: `Ztrunc_abs`\n925 : - Theorem: `Ztrunc_lub`\n926 : - Theorem: `Zaway_IZR`\n927 : - Theorem: `Zaway_ceil`\n928 : - Theorem: `Zaway_floor`\n929 : - Theorem: `Zaway_le`\n930 : - Theorem: `Zaway_opp`\n931 : - Theorem: `Zaway_abs`\n932 : - Theorem: `Rcompare_floor_ceil_middle`\n933 : - Theorem: `Rcompare_ceil_floor_middle`\n934 : - Theorem: `Zfloor_div`\n935 : - Theorem: `Ztrunc_div`\n936 : - Theorem: `radix_pos`\n937 : - Theorem: `IZR_Zpower_pos`\n938 : - Theorem: `bpow_powerRZ`\n939 : - Theorem: `bpow_ge_0`\n940 : - Theorem: `bpow_gt_0`\n941 : - Theorem: `bpow_plus`\n942 : - Theorem: `bpow_1`\n943 : - Theorem: `bpow_plus_1`\n944 : - Theorem: `bpow_opp`\n945 : - Theorem: `IZR_Zpower_nat`\n946 : - Theorem: `IZR_Zpower`\n947 : - Theorem: `bpow_lt`\n948 : - Theorem: `lt_bpow`\n949 : - Theorem: `bpow_le`\n950 : - Theorem: `le_bpow`\n951 : - Theorem: `bpow_inj`\n952 : - Theorem: `bpow_exp`\n953 : - Lemma: `sqrt_bpow`\n954 : - Lemma: `sqrt_bpow_ge`\n955 : - Theorem: `bpow_lt_bpow`\n956 : - Theorem: `bpow_unique`\n957 : - Theorem: `mag_unique`\n958 : - Theorem: `mag_opp`\n959 : - Theorem: `mag_abs`\n960 : - Theorem: `mag_unique_pos`\n961 : - Theorem: `mag_le_abs`\n962 : - Theorem: `mag_le`\n963 : - Lemma: `lt_mag`\n964 : - Theorem: `mag_bpow`\n965 : - Theorem: `mag_mult_bpow`\n966 : - Theorem: `mag_le_bpow`\n967 : - Theorem: `mag_gt_bpow`\n968 : - Theorem: `mag_ge_bpow`\n969 : - Theorem: `bpow_mag_gt`\n970 : - Theorem: `bpow_mag_le`\n971 : - Theorem: `mag_le_Zpower`\n972 : - Theorem: `mag_gt_Zpower`\n973 : - Lemma: `mag_mult`\n974 : - Lemma: `mag_plus`\n975 : - Lemma: `mag_minus`\n976 : - Lemma: `mag_minus_lb`\n977 : - Theorem: `mag_plus_ge`\n978 : - Lemma: `mag_div`\n979 : - Lemma: `mag_sqrt`\n980 : - Lemma: `mag_1`\n981 : - Theorem: `eqb_sym`\n982 : - Theorem: `eqb_false`\n983 : - Theorem: `eqb_true`\n984 : - Theorem: `IZR_cond_Zopp`\n985 : - Theorem: `abs_cond_Ropp`\n986 : - Theorem: `cond_Ropp_Rlt_bool`\n987 : - Theorem: `Rlt_bool_cond_Ropp`\n988 : - Theorem: `cond_Ropp_involutive`\n989 : - Theorem: `cond_Ropp_inj`\n990 : - Theorem: `cond_Ropp_mult_l`\n991 : - Theorem: `cond_Ropp_mult_r`\n992 : - Theorem: `cond_Ropp_plus`\n993 : - Theorem: `LPO_min`\n994 : - Theorem: `LPO`\n995 : - Lemma: `LPO_Z`\n996 : \n997 : ### Lean Declarations\n998 : - theorem: `Rle_0_minus_spec`\n999 : - theorem: `Rmult_lt_compat_spec`\n1000: - theorem: `Rmult_neq_reg_r_spec`\n1001: - theorem: `Rmult_neq_compat_r_spec`\n1002: - theorem: `Rmult_min_distr_r_spec`\n1003: - theorem: `Rmult_min_distr_l_spec`\n1004: - theorem: `Rmin_opp_spec`\n1005: - theorem: `Rmax_opp_spec`\n1006: - theorem: `Rabs_eq_Rabs_spec`\n1007: - theorem: `Rabs_minus_le_spec`\n1008:  - theorem: `Rabs_ge_spec`\n1009:  - theorem: `Rabs_ge_inv_spec`\n1010: - theorem: `Rcompare_spec`\n1011: - theorem: `Rcompare_sym_spec`\n1012: - theorem: `Rcompare_opp_spec`\n1013: - theorem: `Rcompare_plus_r_spec`\n1014: - theorem: `Rcompare_plus_l_spec`\n1015: - theorem: `Rcompare_mult_r_spec`\n1016: - theorem: `Rcompare_mult_l_spec`\n1017: - theorem: `Rle_bool_spec`\n1018: - theorem: `Rle_bool_true`\n1019: - theorem: `Rle_bool_false`\n1020: - theorem: `Rlt_bool_spec`\n1021: - theorem: `negb_Rlt_bool_spec`\n1022: - theorem: `negb_Rle_bool_spec`\n1023: - theorem: `Req_bool_spec`\n1024: - theorem: `eqb_sym_spec`\n1025: - theorem: `cond_Ropp_spec`\n1026: - theorem: `cond_Ropp_involutive_spec`\n1027: - theorem: `cond_Ropp_inj_spec`\n1028: \n1029: ### Mapping (Coq → Lean)\n1030: - `Rle_0_minus` → `Rle_0_minus_spec` (substring-name)\n1031: - `Rabs_eq_Rabs` → (no match)\n1032: - `Rabs_eq_Rabs` → `Rabs_eq_Rabs_spec` (substring-name)\n1033: - `Rabs_minus_le` → `Rabs_minus_le_spec` (substring-name)\n1034: - `Rabs_eq_R0` → `Rabs_eq_R0_spec` (substring-name)\n1035: - `Rmult_lt_compat` → `Rmult_lt_compat_spec` (substring-name)\n1036: - `Rmult_neq_reg_r` → `Rmult_neq_reg_r_spec` (substring-name)\n1037: - `Rmult_neq_compat_r` → `Rmult_neq_compat_r_spec` (substring-name)\n1038: - `Rmult_min_distr_r` → `Rmult_min_distr_r_spec` (substring-name)\n1039: - `Rmult_min_distr_l` → `Rmult_min_distr_l_spec` (substring-name)\n1040: - `Rmin_opp` → `Rmin_opp_spec` (substring-name)\n1041: - `Rmax_opp` → `Rmax_opp_spec` (substring-name)\n1042: - `exp_le` → `exp_le_spec` (substring-name)\n1043: - `Rinv_lt` → `Rinv_lt_spec` (substring-name)\n1044: - `Rinv_le` → `Rinv_le_spec` (substring-name)\n1045: - `sqrt_ge_0` → `sqrt_ge_0_spec` (substring-name)\n1046: - `sqrt_neg` → (no match)\n1047: - `Rsqr_le_abs_0_alt` → (no match)\n1048: - `Rabs_le_inv` → (no match)\n1049: - `Rabs_ge` → `Rabs_ge_spec` (substring-name)\n1050: - `Rabs_ge_inv` → `Rabs_ge_inv_spec` (substring-name)\n1051: - `Rabs_lt` → `Rabs_lt_spec` (substring-name)\n1052: - `Rabs_lt_inv` → (no match)\n1053: - `Rabs_gt` → `Rabs_gt_spec` (substring-name)\n1054: - `Rabs_gt_inv` → (no match)\n1055: - `IZR_le_lt` → (no match)\n1056: - `le_lt_IZR` → (no match)\n1057: - `neq_IZR` → (no match)\n1058: - `Rcompare_spec` → `Rcompare_spec` (exact-name)\n1059: - `Rcompare_Lt` → (no match)\n1060: - `Rcompare_Lt_inv` → (no match)\n1061: - `Rcompare_not_Lt` → (no match)\n1062: - `Rcompare_not_Lt_inv` → (no match)\n1063: - `Rcompare_Eq` → (no match)\n1064: - `Rcompare_Eq_inv` → (no match)\n1065: - `Rcompare_Gt` → (no match)\n1066: - `Rcompare_Gt_inv` → (no match)\n1067: - `Rcompare_not_Gt` → (no match)\n1068: - `Rcompare_not_Gt_inv` → (no match)\n1069: - `Rcompare_IZR` → (no match)\n1070: - `Rcompare_sym` → `Rcompare_sym_spec` (substring-name)\n1071: - `Rcompare_opp` → `Rcompare_opp_spec` (substring-name)\n1072: - `Rcompare_plus_r` → `Rcompare_plus_r_spec` (substring-name)\n1073: - `Rcompare_plus_l` → `Rcompare_plus_l_spec` (substring-name)\n1074: - `Rcompare_mult_r` → `Rcompare_mult_r_spec` (substring-name)\n1075: - `Rcompare_mult_l` → `Rcompare_mult_l_spec` (substring-name)\n1076: - `Rcompare_middle` → (no match)\n1077: - `Rcompare_half_l` → (no match)\n1078: - `Rcompare_half_r` → (no match)\n1079: - `Rcompare_sqr` → (no match)\n1080: - `Rmin_compare` → (no match)\n1081: - `Rle_bool_spec` → `Rle_bool_spec` (exact-name)\n1082: - `Rle_bool_true` → `Rle_bool_true` (exact-name)\n1083: - `Rle_bool_false` → `Rle_bool_false` (exact-name)\n1084: - `Rlt_bool_spec` → `Rlt_bool_spec` (exact-name)\n1085: - `negb_Rlt_bool` → `negb_Rlt_bool_spec` (substring-name)\n1086: - `negb_Rle_bool` → `negb_Rle_bool_spec` (substring-name)\n1087: - `Rlt_bool_true` → (no match)\n1088: - `Rlt_bool_false` → (no match)\n1089: - `Rlt_bool_opp` → (no match)\n1090: - `Req_bool_spec` → `Req_bool_spec` (exact-name)\n1091: - `Req_bool_true` → (no match)\n1092: - `Req_bool_false` → (no match)\n1093: - `Zfloor_lb` → (no match)\n1094: - `Zfloor_ub` → (no match)\n1095: - `Zfloor_lub` → (no match)\n1096: - `Zfloor_imp` → (no match)\n1097: - `Zfloor_IZR` → (no match)\n1098: - `Zfloor_le` → (no match)\n1099: - `Zceil_ub` → (no match)\n1100: - `Zceil_lb` → (no match)\n1101: - `Zceil_glb` → (no match)\n1102: - `Zceil_imp` → (no match)\n1103: - `Zceil_IZR` → (no match)\n1104: - `Zceil_le` → (no match)\n1105: - `Zceil_floor_neq` → (no match)\n1106: - `Ztrunc_IZR` → (no match)\n1107: - `Ztrunc_floor` → (no match)\n1108: - `Ztrunc_ceil` → (no match)\n1109: - `Ztrunc_le` → (no match)\n1110: - `Ztrunc_opp` → (no match)\n1111: - `Ztrunc_abs` → (no match)\n1112: - `Ztrunc_lub` → (no match)\n1113: - `Zaway_IZR` → (no match)\n1114: - `Zaway_ceil` → (no match)\n1115: - `Zaway_floor` → (no match)\n1116: - `Zaway_le` → (no match)\n1117: - `Zaway_opp` → (no match)\n1118: - `Zaway_abs` → (no match)\n1119: - `Rcompare_floor_ceil_middle` → (no match)\n1120: - `Rcompare_ceil_floor_middle` → (no match)\n1121: - `Zfloor_div` → (no match)\n1122: - `Ztrunc_div` → (no match)\n1123: - `radix_pos` → (no match)\n1124: - `IZR_Zpower_pos` → (no match)\n1125: - `bpow_powerRZ` → (no match)\n1126: - `bpow_ge_0` → (no match)\n1127: - `bpow_gt_0` → (no match)\n1128: - `bpow_plus` → (no match)\n1129: - `bpow_1` → (no match)\n1130: - `bpow_plus_1` → (no match)\n1131: - `bpow_opp` → (no match)\n1132: - `IZR_Zpower_nat` → (no match)\n1133: - `IZR_Zpower` → (no match)\n1134: - `bpow_lt` → (no match)\n1135: - `lt_bpow` → (no match)\n1136: - `bpow_le` → (no match)\n1137: - `le_bpow` → (no match)\n1138: - `bpow_inj` → (no match)\n1139: - `bpow_exp` → (no match)\n1140: - `sqrt_bpow` → (no match)\n1141: - `sqrt_bpow_ge` → (no match)\n1142: - `bpow_lt_bpow` → (no match)\n1143: - `bpow_unique` → (no match)\n1144: - `mag_unique` → (no match)\n1145: - `mag_opp` → (no match)\n1146: - `mag_abs` → (no match)\n1147: - `mag_unique_pos` → (no match)\n1148: - `mag_le_abs` → (no match)\n1149: - `mag_le` → (no match)\n1150: - `lt_mag` → (no match)\n1151: - `mag_bpow` → (no match)\n1152: - `mag_mult_bpow` → (no match)\n1153: - `mag_le_bpow` → (no match)\n1154: - `mag_gt_bpow` → (no match)\n1155: - `mag_ge_bpow` → (no match)\n1156: - `bpow_mag_gt` → (no match)\n1157: - `bpow_mag_le` → (no match)\n1158: - `mag_le_Zpower` → (no match)\n1159: - `mag_gt_Zpower` → (no match)\n1160: - `mag_mult` → (no match)\n1161: - `mag_plus` → (no match)\n1162: - `mag_minus` → (no match)\n1163: - `mag_minus_lb` → (no match)\n1164: - `mag_plus_ge` → (no match)\n1165: - `mag_div` → (no match)\n1166: - `mag_sqrt` → (no match)\n1167: - `mag_1` → (no match)\n1168: - `eqb_sym` → `eqb_sym_spec` (substring-name)\n1169: - `eqb_false` → (no match)\n1170: - `eqb_true` → (no match)\n1171: - `IZR_cond_Zopp` → (no match)\n1172: - `abs_cond_Ropp` → (no match)\n1173: - `cond_Ropp_Rlt_bool` → (no match)\n1174: - `Rlt_bool_cond_Ropp` → (no match)\n1175: - `cond_Ropp_involutive` → `cond_Ropp_involutive_spec` (substring-name)\n1176: - `cond_Ropp_inj` → `cond_Ropp_inj_spec` (substring-name)\n1177: - `cond_Ropp_mult_l` → (no match)\n1178: - `cond_Ropp_mult_r` → (no match)\n1179: - `cond_Ropp_plus` → (no match)\n1180: - `LPO_min` → (no match)\n1181: - `LPO` → (no match)\n1182: - `LPO_Z` → (no match)\n1183: \n1184: ## File: Round_NE.v\n1185: - Coq file: Round_NE.v\n1186: - Lean file(s): Round_NE.lean\n1187: \n1188: ### Coq Declarations\n1189: - Lemma: `DN_UP_parity_aux`\n1190: - Theorem: `DN_UP_parity_generic_pos`\n1191: - Theorem: `DN_UP_parity_generic`\n1192: - Theorem: `Rnd_NE_pt_total`\n1193: - Theorem: `Rnd_NE_pt_monotone`\n1194: - Theorem: `Rnd_NE_pt_round`\n1195: - Lemma: `round_NE_pt_pos`\n1196: - Theorem: `round_NE_opp`\n1197: - Lemma: `round_NE_abs`\n1198: - Theorem: `round_NE_pt`\n1199: \n1200: ### Lean Declarations\n1201: - theorem: `DN_UP_parity_aux`\n1202: - theorem: `DN_UP_parity_generic_pos`\n1203: - theorem: `DN_UP_parity_generic`\n1204: - theorem: `Rnd_NE_pt_unique_prop`\n1205: - theorem: `Rnd_NE_pt_unique`\n1206: - theorem: `Rnd_NE_pt_monotone`\n1207: - theorem: `Rnd_NE_pt_total`\n1208: - theorem: `Rnd_NE_pt_round`\n1209: - theorem: `satisfies_any_imp_NE`\n1210: - theorem: `Rnd_NE_pt_refl`\n1211: - theorem: `Rnd_NE_pt_idempotent`\n1212: - theorem: `DN_UP_parity_pos_holds`\n1213: - theorem: `Rnd_NE_pt_sign`\n1214: - theorem: `Rnd_NE_pt_abs`\n1215: - theorem: `round_NE_pt_pos`\n1216: - theorem: `round_NE_opp`\n1217: - theorem: `round_NE_abs`\n1218: - theorem: `round_NE_pt`\n1219: - theorem: `Rnd_NE_pt_error_bound`\n1220: - theorem: `Rnd_NE_pt_minimal_error`\n1221: \n1222: ### Mapping (Coq → Lean)\n1223: - `DN_UP_parity_aux` → `DN_UP_parity_aux` (exact-name)\n1224: - `DN_UP_parity_generic_pos` → `DN_UP_parity_generic_pos` (exact-name)\n1225: - `DN_UP_parity_generic` → `DN_UP_parity_generic` (exact-name)\n1226: - `Rnd_NE_pt_total` → `Rnd_NE_pt_total` (exact-name)\n1227: - `Rnd_NE_pt_monotone` → `Rnd_NE_pt_monotone` (exact-name)\n1228: - `Rnd_NE_pt_round` → `Rnd_NE_pt_round` (exact-name)\n1229: - `round_NE_pt_pos` → `round_NE_pt_pos` (exact-name)\n1230: - `round_NE_opp` → `round_NE_opp` (exact-name)\n1231: - `round_NE_abs` → `round_NE_abs` (exact-name)\n1232: - `round_NE_pt` → `round_NE_pt` (exact-name)\n1233: \n1234: ## File: Round_pred.v\n1235: - Coq file: Round_pred.v\n1236: - Lean file(s): Round_pred.lean\n1237: \n1238: ### Coq Declarations\n1239: - Theorem: `round_val_of_pred`\n1240: - Theorem: `round_fun_of_pred`\n1241: - Theorem: `round_unique`\n1242: - Theorem: `Rnd_DN_pt_monotone`\n1243: - Theorem: `Rnd_DN_pt_unique`\n1244: - Theorem: `Rnd_DN_unique`\n1245: - Theorem: `Rnd_UP_pt_monotone`\n1246: - Theorem: `Rnd_UP_pt_unique`\n1247: - Theorem: `Rnd_UP_unique`\n1248: - Theorem: `Rnd_UP_pt_opp`\n1249: - Theorem: `Rnd_DN_pt_opp`\n1250: - Theorem: `Rnd_DN_opp`\n1251: - Theorem: `Rnd_DN_UP_pt_split`\n1252: - Theorem: `Rnd_DN_pt_refl`\n1253: - Theorem: `Rnd_DN_pt_idempotent`\n1254: - Theorem: `Rnd_UP_pt_refl`\n1255: - Theorem: `Rnd_UP_pt_idempotent`\n1256: - Theorem: `Only_DN_or_UP`\n1257: - Theorem: `Rnd_ZR_abs`\n1258: - Theorem: `Rnd_ZR_pt_monotone`\n1259: - Theorem: `Rnd_N_pt_DN_or_UP`\n1260: - Theorem: `Rnd_N_pt_DN_or_UP_eq`\n1261: - Theorem: `Rnd_N_pt_opp_inv`\n1262: - Theorem: `Rnd_N_pt_monotone`\n1263: - Theorem: `Rnd_N_pt_unique`\n1264: - Theorem: `Rnd_N_pt_refl`\n1265: - Theorem: `Rnd_N_pt_idempotent`\n1266: - Theorem: `Rnd_N_pt_0`\n1267: - Theorem: `Rnd_N_pt_ge_0`\n1268: - Theorem: `Rnd_N_pt_le_0`\n1269: - Theorem: `Rnd_N_pt_abs`\n1270: - Theorem: `Rnd_N_pt_DN_UP`\n1271: - Theorem: `Rnd_N_pt_DN`\n1272: - Theorem: `Rnd_N_pt_UP`\n1273: - Theorem: `Rnd_NG_pt_unique`\n1274: - Theorem: `Rnd_NG_pt_monotone`\n1275: - Theorem: `Rnd_NG_pt_refl`\n1276: - Theorem: `Rnd_NG_pt_opp_inv`\n1277: - Theorem: `Rnd_NG_unique`\n1278: - Theorem: `Rnd_NA_NG_pt`\n1279: - Lemma: `Rnd_NA_pt_unique_prop`\n1280: - Theorem: `Rnd_NA_pt_unique`\n1281: - Theorem: `Rnd_NA_pt_N`\n1282: - Theorem: `Rnd_NA_unique`\n1283: - Theorem: `Rnd_NA_pt_monotone`\n1284: - Theorem: `Rnd_NA_pt_refl`\n1285: - Theorem: `Rnd_NA_pt_idempotent`\n1286: - Theorem: `Rnd_N0_NG_pt`\n1287: - Lemma: `Rnd_N0_pt_unique_prop`\n1288: - Theorem: `Rnd_N0_pt_unique`\n1289: - Theorem: `Rnd_N0_pt_N`\n1290: - Theorem: `Rnd_N0_unique`\n1291: - Theorem: `Rnd_N0_pt_monotone`\n1292: - Theorem: `Rnd_N0_pt_refl`\n1293: - Theorem: `Rnd_N0_pt_idempotent`\n1294: - Theorem: `round_pred_ge_0`\n1295: - Theorem: `round_pred_gt_0`\n1296: - Theorem: `round_pred_le_0`\n1297: - Theorem: `round_pred_lt_0`\n1298: - Theorem: `Rnd_DN_pt_equiv_format`\n1299: - Theorem: `Rnd_UP_pt_equiv_format`\n1300: - Theorem: `satisfies_any_eq`\n1301: - Theorem: `satisfies_any_imp_DN`\n1302: - Theorem: `satisfies_any_imp_UP`\n1303: - Theorem: `satisfies_any_imp_ZR`\n1304: - Theorem: `satisfies_any_imp_NG`\n1305: - Theorem: `satisfies_any_imp_NA`\n1306: - Theorem: `satisfies_any_imp_N0`\n1307: \n1308: ### Lean Declarations\n1309: - theorem: `Rnd_DN_spec`\n1310: - theorem: `Rnd_UP_spec`\n1311: - theorem: `Rnd_ZR_spec`\n1312: - theorem: `Rnd_N_spec`\n1313: - theorem: `Rnd_NG_spec`\n1314: - theorem: `Rnd_NA_spec`\n1315: - theorem: `Rnd_N0_spec`\n1316: - theorem: `round_val_of_pred_spec`\n1317: - theorem: `round_fun_of_pred_spec`\n1318: - theorem: `round_unique_spec`\n1319: - theorem: `Rnd_DN_pt_monotone_spec`\n1320: - theorem: `Rnd_DN_pt_unique_spec`\n1321: - theorem: `Rnd_DN_unique_spec`\n1322: - theorem: `Rnd_UP_pt_monotone_spec`\n1323: - theorem: `Rnd_UP_pt_unique_spec`\n1324: - theorem: `Rnd_UP_unique_spec`\n1325: - theorem: `Rnd_UP_pt_opp_spec`\n1326: - theorem: `Rnd_DN_pt_opp_spec`\n1327: - theorem: `Rnd_DN_pt_refl_spec`\n1328: - theorem: `Rnd_DN_pt_idempotent_spec`\n1329: - theorem: `Rnd_UP_pt_refl_spec`\n1330: - theorem: `Rnd_UP_pt_idempotent_spec`\n1331: - theorem: `Rnd_ZR_abs_spec`\n1332: \n1333: ### Mapping (Coq → Lean)\n1334: - `round_val_of_pred` → `round_val_of_pred_spec` (substring-name)\n1335: - `round_fun_of_pred` → `round_fun_of_pred_spec` (substring-name)\n1336: - `round_unique` → `round_unique_spec` (substring-name)\n1337: - `Rnd_DN_pt_monotone` → `Rnd_DN_pt_monotone_spec` (substring-name)\n1338: - `Rnd_DN_pt_unique` → `Rnd_DN_pt_unique_spec` (substring-name)\n1339: - `Rnd_DN_unique` → `Rnd_DN_unique_spec` (substring-name)\n1340: - `Rnd_UP_pt_monotone` → `Rnd_UP_pt_monotone_spec` (substring-name)\n1341: - `Rnd_UP_pt_unique` → `Rnd_UP_pt_unique_spec` (substring-name)\n1342: - `Rnd_UP_unique` → `Rnd_UP_unique_spec` (substring-name)\n1343: - `Rnd_UP_pt_opp` → `Rnd_UP_pt_opp_spec` (substring-name)\n1344: - `Rnd_DN_pt_opp` → `Rnd_DN_pt_opp_spec` (substring-name)\n1345: - `Rnd_DN_opp` → (no match)\n1346: - `Rnd_DN_UP_pt_split` → (no match)\n1347: - `Rnd_DN_pt_refl` → `Rnd_DN_pt_refl_spec` (substring-name)\n1348: - `Rnd_DN_pt_idempotent` → `Rnd_DN_pt_idempotent_spec` (substring-name)\n1349: - `Rnd_UP_pt_refl` → `Rnd_UP_pt_refl_spec` (substring-name)\n1350: - `Rnd_UP_pt_idempotent` → `Rnd_UP_pt_idempotent_spec` (substring-name)\n1351: - `Only_DN_or_UP` → (no match)\n1352: - `Rnd_ZR_abs` → `Rnd_ZR_abs_spec` (substring-name)\n1353: - `Rnd_ZR_pt_monotone` → (no match)\n1354: - `Rnd_N_pt_DN_or_UP` → (no match)\n1355: - `Rnd_N_pt_DN_or_UP_eq` → (no match)\n1356: - `Rnd_N_pt_opp_inv` → (no match)\n1357: - `Rnd_N_pt_monotone` → (no match)\n1358: - `Rnd_N_pt_unique` → (no match)\n1359: - `Rnd_N_pt_refl` → (no match)\n1360: - `Rnd_N_pt_idempotent` → (no match)\n1361: - `Rnd_N_pt_0` → (no match)\n1362: - `Rnd_N_pt_ge_0` → (no match)\n1363: - `Rnd_N_pt_le_0` → (no match)\n1364: - `Rnd_N_pt_abs` → (no match)\n1365: - `Rnd_N_pt_DN_UP` → (no match)\n1366: - `Rnd_N_pt_DN` → (no match)\n1367: - `Rnd_N_pt_UP` → (no match)\n1368: - `Rnd_NG_pt_unique` → (no match)\n1369: - `Rnd_NG_pt_monotone` → (no match)\n1370: - `Rnd_NG_pt_refl` → (no match)\n1371: - `Rnd_NG_pt_opp_inv` → (no match)\n1372: - `Rnd_NG_unique` → (no match)\n1373: - `Rnd_NA_NG_pt` → (no match)\n1374: - `Rnd_NA_pt_unique_prop` → (no match)\n1375: - `Rnd_NA_pt_unique` → (no match)\n1376: - `Rnd_NA_pt_N` → (no match)\n1377: - `Rnd_NA_unique` → (no match)\n1378: - `Rnd_NA_pt_monotone` → (no match)\n1379: - `Rnd_NA_pt_refl` → (no match)\n1380: - `Rnd_NA_pt_idempotent` → (no match)\n1381: - `Rnd_N0_NG_pt` → (no match)\n1382: - `Rnd_N0_pt_unique_prop` → (no match)\n1383: - `Rnd_N0_pt_unique` → (no match)\n1384: - `Rnd_N0_pt_N` → (no match)\n1385: - `Rnd_N0_unique` → (no match)\n1386: - `Rnd_N0_pt_monotone` → (no match)\n1387: - `Rnd_N0_pt_refl` → (no match)\n1388: - `Rnd_N0_pt_idempotent` → (no match)\n1389: - `round_pred_ge_0` → (no match)\n1390: - `round_pred_gt_0` → (no match)\n1391: - `round_pred_le_0` → (no match)\n1392: - `round_pred_lt_0` → (no match)\n1393: - `Rnd_DN_pt_equiv_format` → (no match)\n1394: - `Rnd_UP_pt_equiv_format` → (no match)\n1395: - `satisfies_any_eq` → (no match)\n1396: - `satisfies_any_imp_DN` → (no match)\n1397: - `satisfies_any_imp_UP` → (no match)\n1398: - `satisfies_any_imp_ZR` → (no match)\n1399: - `satisfies_any_imp_NG` → (no match)\n1400: - `satisfies_any_imp_NA` → (no match)\n1401: - `satisfies_any_imp_N0` → (no match)\n1402: \n1403: ## File: Ulp.v\n1404: - Coq file: Ulp.v\n1405: - Lean file(s): Ulp.lean\n1406: \n1407: ### Coq Declarations\n1408: - Lemma: `Z_le_dec_aux`\n1409: - Lemma: `negligible_exp_spec`\n1410: - Lemma: `negligible_exp_spec'`\n1411: - Lemma: `fexp_negligible_exp_eq`\n1412: - Lemma: `ulp_neq_0`\n1413: - Theorem: `ulp_opp`\n1414: - Theorem: `ulp_abs`\n1415: - Theorem: `ulp_ge_0`\n1416: - Theorem: `ulp_le_id`\n1417: - Theorem: `ulp_le_abs`\n1418: - Theorem: `round_UP_DN_ulp`\n1419: - Theorem: `ulp_canonical`\n1420: - Theorem: `ulp_bpow`\n1421: - Lemma: `generic_format_ulp_0`\n1422: - Lemma: `generic_format_bpow_ge_ulp_0`\n1423: - Lemma: `generic_format_ulp`\n1424: - Lemma: `not_FTZ_generic_format_ulp`\n1425: - Lemma: `ulp_ge_ulp_0`\n1426: - Lemma: `not_FTZ_ulp_ge_ulp_0`\n1427: - Lemma: `ulp_le_pos`\n1428: - Theorem: `ulp_le`\n1429: - Theorem: `eq_0_round_0_negligible_exp`\n1430: - Theorem: `pred_eq_pos`\n1431: - Theorem: `succ_eq_pos`\n1432: - Theorem: `succ_opp`\n1433: - Theorem: `pred_opp`\n1434: - Theorem: `pred_bpow`\n1435: - Theorem: `id_m_ulp_ge_bpow`\n1436: - Theorem: `id_p_ulp_le_bpow`\n1437: - Lemma: `generic_format_pred_aux1`\n1438: - Lemma: `generic_format_pred_aux2`\n1439: - Lemma: `generic_format_succ_aux1`\n1440: - Lemma: `generic_format_pred_pos`\n1441: - Theorem: `generic_format_succ`\n1442: - Theorem: `generic_format_pred`\n1443: - Lemma: `pred_pos_lt_id`\n1444: - Theorem: `succ_gt_id`\n1445: - Theorem: `pred_lt_id`\n1446: - Theorem: `succ_ge_id`\n1447: - Theorem: `pred_le_id`\n1448: - Lemma: `pred_pos_ge_0`\n1449: - Theorem: `pred_ge_0`\n1450: - Lemma: `pred_pos_plus_ulp_aux1`\n1451: - Lemma: `pred_pos_plus_ulp_aux2`\n1452: - Lemma: `pred_pos_plus_ulp_aux3`\n1453: - Lemma: `pred_pos_plus_ulp`\n1454: - Theorem: `pred_plus_ulp`\n1455: - Theorem: `mag_plus_eps`\n1456: - Theorem: `round_DN_plus_eps_pos`\n1457: - Theorem: `round_UP_plus_eps_pos`\n1458: - Theorem: `round_UP_pred_plus_eps_pos`\n1459: - Theorem: `round_DN_minus_eps_pos`\n1460: - Theorem: `round_DN_plus_eps`\n1461: - Theorem: `round_UP_plus_eps`\n1462: - Lemma: `le_pred_pos_lt`\n1463: - Lemma: `succ_le_lt_aux`\n1464: - Theorem: `succ_le_lt`\n1465: - Theorem: `pred_ge_gt`\n1466: - Theorem: `succ_gt_ge`\n1467: - Theorem: `pred_lt_le`\n1468: - Lemma: `succ_pred_pos`\n1469: - Theorem: `pred_ulp_0`\n1470: - Theorem: `succ_0`\n1471: - Theorem: `pred_0`\n1472: - Lemma: `pred_succ_pos`\n1473: - Theorem: `succ_pred`\n1474: - Theorem: `pred_succ`\n1475: - Theorem: `round_UP_pred_plus_eps`\n1476: - Theorem: `round_DN_minus_eps`\n1477: - Theorem: `error_lt_ulp`\n1478: - Theorem: `error_le_ulp`\n1479: - Theorem: `error_le_half_ulp`\n1480: - Theorem: `ulp_DN`\n1481: - Theorem: `round_neq_0_negligible_exp`\n1482: - Theorem: `error_lt_ulp_round`\n1483: - Lemma: `error_le_ulp_round`\n1484: - Theorem: `error_le_half_ulp_round`\n1485: - Theorem: `pred_le`\n1486: - Theorem: `succ_le`\n1487: - Theorem: `pred_le_inv`\n1488: - Theorem: `succ_le_inv`\n1489: - Theorem: `pred_lt`\n1490: - Theorem: `succ_lt`\n1491: - Lemma: `succ_le_plus_ulp`\n1492: - Lemma: `generic_format_plus_ulp`\n1493: - Theorem: `round_DN_ge_UP_gt`\n1494: - Theorem: `round_UP_le_DN_lt`\n1495: - Theorem: `pred_UP_le_DN`\n1496: - Theorem: `UP_le_succ_DN`\n1497: - Theorem: `pred_UP_eq_DN`\n1498: - Theorem: `succ_DN_eq_UP`\n1499: - Theorem: `round_DN_eq`\n1500: - Theorem: `round_UP_eq`\n1501: - Lemma: `ulp_ulp_0`\n1502: - Lemma: `ulp_succ_pos`\n1503: - Theorem: `ulp_pred_pos`\n1504: - Lemma: `ulp_round_pos`\n1505: - Theorem: `ulp_round`\n1506: - Lemma: `succ_round_ge_id`\n1507: - Lemma: `pred_round_le_id`\n1508: - Theorem: `round_N_le_midp`\n1509: - Theorem: `round_N_ge_midp`\n1510: - Lemma: `round_N_ge_ge_midp`\n1511: - Lemma: `round_N_le_le_midp`\n1512: - Lemma: `round_N_eq_DN`\n1513: - Lemma: `round_N_eq_DN_pt`\n1514: - Lemma: `round_N_eq_UP`\n1515: - Lemma: `round_N_eq_UP_pt`\n1516: - Lemma: `round_N_plus_ulp_ge`\n1517: - Lemma: `round_N_eq_ties`\n1518: \n1519: ### Lean Declarations\n1520: - theorem: `ulp_neq_0`\n1521: - theorem: `ulp_opp`\n1522: - theorem: `ulp_abs`\n1523: - theorem: `ulp_ge_0`\n1524: - theorem: `ulp_le_id`\n1525: - theorem: `ulp_le_abs`\n1526: - theorem: `ulp_bpow`\n1527: - theorem: `generic_format_ulp_0`\n1528: - theorem: `generic_format_bpow_ge_ulp_0`\n1529: \n1530: ### Mapping (Coq → Lean)\n1531: - `Z_le_dec_aux` → (no match)\n1532: - `negligible_exp_spec` → (no match)\n1533: - `negligible_exp_spec'` → (no match)\n1534: - `fexp_negligible_exp_eq` → (no match)\n1535: - `ulp_neq_0` → `ulp_neq_0` (exact-name)\n1536: - `ulp_opp` → `ulp_opp` (exact-name)\n1537: - `ulp_abs` → `ulp_abs` (exact-name)\n1538: - `ulp_ge_0` → `ulp_ge_0` (exact-name)\n1539: - `ulp_le_id` → `ulp_le_id` (exact-name)\n1540: - `ulp_le_abs` → `ulp_le_abs` (exact-name)\n1541: - `round_UP_DN_ulp` → (no match)\n1542: - `ulp_canonical` → (no match)\n1543: - `ulp_bpow` → `ulp_bpow` (exact-name)\n1544: - `generic_format_ulp_0` → `generic_format_ulp_0` (exact-name)\n1545: - `generic_format_bpow_ge_ulp_0` → `generic_format_bpow_ge_ulp_0` (exact-name)\n1546: - `generic_format_ulp` → `generic_format_ulp_0` (substring-name)\n1547: - `not_FTZ_generic_format_ulp` → (no match)\n1548: - `ulp_ge_ulp_0` → (no match)\n1549: - `not_FTZ_ulp_ge_ulp_0` → (no match)\n1550: - `ulp_le_pos` → (no match)\n1551: - `ulp_le` → `ulp_le_id` (substring-name)\n1552: - `eq_0_round_0_negligible_exp` → (no match)\n1553: - `pred_eq_pos` → (no match)\n1554: - `succ_eq_pos` → (no match)\n1555: - `succ_opp` → (no match)\n1556: - `pred_opp` → (no match)\n1557: - `pred_bpow` → (no match)\n1558: - `id_m_ulp_ge_bpow` → (no match)\n1559: - `id_p_ulp_le_bpow` → (no match)\n1560: - `generic_format_pred_aux1` → (no match)\n1561: - `generic_format_pred_aux2` → (no match)\n1562: - `generic_format_succ_aux1` → (no match)\n1563: - `generic_format_pred_pos` → (no match)\n1564: - `generic_format_succ` → (no match)\n1565: - `generic_format_pred` → (no match)\n1566: - `pred_pos_lt_id` → (no match)\n1567: - `succ_gt_id` → (no match)\n1568: - `pred_lt_id` → (no match)\n1569: - `succ_ge_id` → (no match)\n1570: - `pred_le_id` → (no match)\n1571: - `pred_pos_ge_0` → (no match)\n1572: - `pred_ge_0` → (no match)\n1573: - `pred_pos_plus_ulp_aux1` → (no match)\n1574: - `pred_pos_plus_ulp_aux2` → (no match)\n1575: - `pred_pos_plus_ulp_aux3` → (no match)\n1576: - `pred_pos_plus_ulp` → (no match)\n1577: - `pred_plus_ulp` → (no match)\n1578: - `mag_plus_eps` → (no match)\n1579: - `round_DN_plus_eps_pos` → (no match)\n1580: - `round_UP_plus_eps_pos` → (no match)\n1581: - `round_UP_pred_plus_eps_pos` → (no match)\n1582: - `round_DN_minus_eps_pos` → (no match)\n1583: - `round_DN_plus_eps` → (no match)\n1584: - `round_UP_plus_eps` → (no match)\n1585: - `le_pred_pos_lt` → (no match)\n1586: - `succ_le_lt_aux` → (no match)\n1587: - `succ_le_lt` → (no match)\n1588: - `pred_ge_gt` → (no match)\n1589: - `succ_gt_ge` → (no match)\n1590: - `pred_lt_le` → (no match)\n1591: - `succ_pred_pos` → (no match)\n1592: - `pred_ulp_0` → (no match)\n1593: - `succ_0` → (no match)\n1594: - `pred_0` → (no match)\n1595: - `pred_succ_pos` → (no match)\n1596: - `succ_pred` → (no match)\n1597: - `pred_succ` → (no match)\n1598: - `round_UP_pred_plus_eps` → (no match)\n1599: - `round_DN_minus_eps` → (no match)\n1600: - `error_lt_ulp` → (no match)\n1601: - `error_le_ulp` → (no match)\n1602: - `error_le_half_ulp` → (no match)\n1603: - `ulp_DN` → (no match)\n1604: - `round_neq_0_negligible_exp` → (no match)\n1605: - `error_lt_ulp_round` → (no match)\n1606: - `error_le_ulp_round` → (no match)\n1607: - `error_le_half_ulp_round` → (no match)\n1608: - `pred_le` → (no match)\n1609: - `succ_le` → (no match)\n1610: - `pred_le_inv` → (no match)\n1611: - `succ_le_inv` → (no match)\n1612: - `pred_lt` → (no match)\n1613: - `succ_lt` → (no match)\n1614: - `succ_le_plus_ulp` → (no match)\n1615: - `generic_format_plus_ulp` → (no match)\n1616: - `round_DN_ge_UP_gt` → (no match)\n1617: - `round_UP_le_DN_lt` → (no match)\n1618: - `pred_UP_le_DN` → (no match)\n1619: - `UP_le_succ_DN` → (no match)\n1620: - `pred_UP_eq_DN` → (no match)\n1621: - `succ_DN_eq_UP` → (no match)\n1622: - `round_DN_eq` → (no match)\n1623: - `round_UP_eq` → (no match)\n1624: - `ulp_ulp_0` → (no match)\n1625: - `ulp_succ_pos` → (no match)\n1626: - `ulp_pred_pos` → (no match)\n1627: - `ulp_round_pos` → (no match)\n1628: - `ulp_round` → (no match)\n1629: - `succ_round_ge_id` → (no match)\n1630: - `pred_round_le_id` → (no match)\n1631: - `round_N_le_midp` → (no match)\n1632: - `round_N_ge_midp` → (no match)\n1633: - `round_N_ge_ge_midp` → (no match)\n1634: - `round_N_le_le_midp` → (no match)\n1635: - `round_N_eq_DN` → (no match)\n1636: - `round_N_eq_DN_pt` → (no match)\n1637: - `round_N_eq_UP` → (no match)\n1638: - `round_N_eq_UP_pt` → (no match)\n1639: - `round_N_plus_ulp_ge` → (no match)\n1640: - `round_N_eq_ties` → (no match)\n1641: \n1642: ## File: Zaux.v\n1643: - Coq file: Zaux.v\n1644: - Lean file(s): Zaux.lean\n1645: \n1646: ### Coq Declarations\n1647: - Theorem: `Zopp_le_cancel`\n1648: - Theorem: `Zgt_not_eq`\n1649: - Lemma: `eqbool_irrelevance`\n1650: - Theorem: `Zeven_ex`\n1651: - Theorem: `Zpower_plus`\n1652: - Theorem: `Zpower_Zpower_nat`\n1653: - Theorem: `Zpower_nat_S`\n1654: - Theorem: `Zpower_pos_gt_0`\n1655: - Theorem: `Zeven_Zpower_odd`\n1656: - Theorem: `radix_val_inj`\n1657: - Theorem: `radix_gt_0`\n1658: - Theorem: `radix_gt_1`\n1659: - Theorem: `Zpower_gt_1`\n1660: - Theorem: `Zpower_gt_0`\n1661: - Theorem: `Zpower_ge_0`\n1662: - Theorem: `Zpower_le`\n1663: - Theorem: `Zpower_lt`\n1664: - Theorem: `Zpower_lt_Zpower`\n1665: - Theorem: `Zpower_gt_id`\n1666: - Theorem: `Zmod_mod_mult`\n1667: - Theorem: `ZOmod_eq`\n1668: - Theorem: `ZOmod_mod_mult`\n1669: - Theorem: `Zdiv_mod_mult`\n1670: - Theorem: `ZOdiv_mod_mult`\n1671: - Theorem: `ZOdiv_small_abs`\n1672: - Theorem: `ZOmod_small_abs`\n1673: - Theorem: `ZOdiv_plus`\n1674: - Theorem: `Zsame_sign_trans`\n1675: - Theorem: `Zsame_sign_trans_weak`\n1676: - Theorem: `Zsame_sign_imp`\n1677: - Theorem: `Zsame_sign_odiv`\n1678: - Theorem: `Zeq_bool_spec`\n1679: - Theorem: `Zeq_bool_true`\n1680: - Theorem: `Zeq_bool_false`\n1681: - Theorem: `Zeq_bool_diag`\n1682: - Theorem: `Zeq_bool_opp`\n1683: - Theorem: `Zeq_bool_opp'`\n1684: - Theorem: `Zle_bool_spec`\n1685: - Theorem: `Zle_bool_true`\n1686: - Theorem: `Zle_bool_false`\n1687: - Theorem: `Zle_bool_opp_l`\n1688: - Theorem: `Zle_bool_opp`\n1689: - Theorem: `Zle_bool_opp_r`\n1690: - Theorem: `Zlt_bool_spec`\n1691: - Theorem: `Zlt_bool_true`\n1692: - Theorem: `Zlt_bool_false`\n1693: - Theorem: `negb_Zle_bool`\n1694: - Theorem: `negb_Zlt_bool`\n1695: - Theorem: `Zlt_bool_opp_l`\n1696: - Theorem: `Zlt_bool_opp_r`\n1697: - Theorem: `Zlt_bool_opp`\n1698: - Theorem: `Zcompare_spec`\n1699: - Theorem: `Zcompare_Lt`\n1700: - Theorem: `Zcompare_Eq`\n1701: - Theorem: `Zcompare_Gt`\n1702: - Theorem: `cond_Zopp_0`\n1703: - Theorem: `cond_Zopp_negb`\n1704: - Theorem: `abs_cond_Zopp`\n1705: - Theorem: `cond_Zopp_Zlt_bool`\n1706: - Theorem: `Zeq_bool_cond_Zopp`\n1707: - Theorem: `Zfast_pow_pos_correct`\n1708: - Lemma: `Zdiv_eucl_unique`\n1709: - Lemma: `Zpos_div_eucl_aux1_correct`\n1710: - Lemma: `Zpos_div_eucl_aux_correct`\n1711: - Theorem: `Zfast_div_eucl_correct`\n1712: - Lemma: `iter_nat_plus`\n1713: - Lemma: `iter_nat_S`\n1714: - Lemma: `iter_pos_nat`\n1715: \n1716: ### Lean Declarations\n1717: - theorem: `Zopp_le_cancel_spec`\n1718: - theorem: `Zgt_not_eq_spec`\n1719: - theorem: `eqbool_irrelevance_spec`\n1720: - theorem: `Zeven_ex_spec`\n1721: - theorem: `Zpower_plus_spec`\n1722: - theorem: `Zpower_Zpower_nat_spec`\n1723: - theorem: `Zpower_nat_S_spec`\n1724: - theorem: `Zmod_mod_mult_spec`\n1725: - theorem: `ZOmod_eq_spec`\n1726: - theorem: `Zdiv_mod_mult_spec`\n1727: - theorem: `ZOmod_mod_mult_spec`\n1728: - theorem: `ZOdiv_plus_spec`\n1729: - theorem: `Zeq_bool_spec`\n1730: - theorem: `Zle_bool_spec`\n1731: - theorem: `Zlt_bool_spec`\n1732: - theorem: `Zeq_bool_true_spec`\n1733: - theorem: `Zeq_bool_false_spec`\n1734: - theorem: `Zeq_bool_diag_spec`\n1735: - theorem: `Zeq_bool_opp_spec`\n1736: - theorem: `Zeq_bool_opp`\n1737: - theorem: `Zle_bool_true_spec`\n1738: - theorem: `Zle_bool_false_spec`\n1739: - theorem: `Zle_bool_opp_l_spec`\n1740: - theorem: `Zle_bool_opp_spec`\n1741: - theorem: `Zle_bool_opp_r_spec`\n1742: - theorem: `negb_Zle_bool_spec`\n1743: - theorem: `negb_Zlt_bool_spec`\n1744: - theorem: `Zlt_bool_true_spec`\n1745: - theorem: `Zlt_bool_false_spec`\n1746: - theorem: `Zlt_bool_opp_l_spec`\n1747: - theorem: `Zlt_bool_opp_r_spec`\n1748: - theorem: `Zlt_bool_opp_spec`\n1749: - theorem: `Zcompare_spec`\n1750: - theorem: `Zcompare_Lt_spec`\n1751: - theorem: `Zcompare_Eq_spec`\n1752: - theorem: `Zcompare_Gt_spec`\n1753: - theorem: `cond_Zopp_spec`\n1754: - theorem: `cond_Zopp_0_spec`\n1755: - theorem: `cond_Zopp_negb_spec`\n1756: - theorem: `abs_cond_Zopp_spec`\n1757: - theorem: `cond_Zopp_Zlt_bool_spec`\n1758: - theorem: `Zeq_bool_cond_Zopp_spec`\n1759: - theorem: `Zfast_pow_pos_spec`\n1760: - theorem: `Zfast_div_eucl_spec`\n1761: - theorem: `iter_nat_spec`\n1762: - theorem: `iter_nat_S_spec`\n1763: - theorem: `iter_nat_plus_spec`\n1764: - theorem: `iter_pos_nat_spec`\n1765: \n1766: ### Mapping (Coq → Lean)\n1767: - `Zopp_le_cancel` → `Zopp_le_cancel_spec` (substring-name)\n1768: - `Zgt_not_eq` → `Zgt_not_eq_spec` (substring-name)\n1769: - `eqbool_irrelevance` → `eqbool_irrelevance_spec` (substring-name)\n1770: - `Zeven_ex` → `Zeven_ex_spec` (substring-name)\n1771: - `Zpower_plus` → `Zpower_plus_spec` (substring-name)\n1772: - `Zpower_Zpower_nat` → `Zpower_Zpower_nat_spec` (substring-name)\n1773: - `Zpower_nat_S` → `Zpower_Zpower_nat_spec` (substring-name)\n1774: - `Zpower_pos_gt_0` → (no match)\n1775: - `Zeven_Zpower_odd` → (no match)\n1776: - `radix_val_inj` → (no match)\n1777: - `radix_gt_0` → (no match)\n1778: - `radix_gt_1` → (no match)\n1779: - `Zpower_gt_1` → (no match)\n1780: - `Zpower_gt_0` → (no match)\n1781: - `Zpower_ge_0` → (no match)\n1782: - `Zpower_le` → (no match)\n1783: - `Zpower_lt` → (no match)\n1784: - `Zpower_lt_Zpower` → (no match)\n1785: - `Zpower_gt_id` → (no match)\n1786: - `Zmod_mod_mult` → `Zmod_mod_mult_spec` (substring-name)\n1787: - `ZOmod_eq` → `ZOmod_eq_spec` (substring-name)\n1788: - `ZOmod_mod_mult` → `ZOmod_mod_mult_spec` (substring-name)\n1789: - `Zdiv_mod_mult` → `Zdiv_mod_mult_spec` (substring-name)\n1790: - `ZOdiv_mod_mult` → (no match)\n1791: - `ZOdiv_small_abs` → (no match)\n1792: - `ZOmod_small_abs` → (no match)\n1793: - `ZOdiv_plus` → `ZOdiv_plus_spec` (substring-name)\n1794: - `Zsame_sign_trans` → (no match)\n1795: - `Zsame_sign_trans_weak` → (no match)\n1796: - `Zsame_sign_imp` → (no match)\n1797: - `Zsame_sign_odiv` → (no match)\n1798: - `Zeq_bool_spec` → `Zeq_bool_spec` (exact-name)\n1799: - `Zeq_bool_true` → `Zeq_bool_true_spec` (substring-name)\n1800: - `Zeq_bool_false` → `Zeq_bool_false_spec` (substring-name)\n1801: - `Zeq_bool_diag` → `Zeq_bool_diag_spec` (substring-name)\n1802: - `Zeq_bool_opp` → `Zeq_bool_opp` (exact-name)\n1803: - `Zeq_bool_opp'` → `Zeq_bool_opp` (normalized-name)\n1804: - `Zle_bool_spec` → `Zle_bool_spec` (exact-name)\n1805: - `Zle_bool_true` → `Zle_bool_true_spec` (substring-name)\n1806: - `Zle_bool_false` → `Zle_bool_false_spec` (substring-name)\n1807: - `Zle_bool_opp_l` → `Zle_bool_opp_l_spec` (substring-name)\n1808: - `Zle_bool_opp` → `Zle_bool_opp_l_spec` (substring-name)\n1809: - `Zle_bool_opp_r` → `Zle_bool_opp_r_spec` (substring-name)\n1810: - `Zlt_bool_spec` → `Zlt_bool_spec` (exact-name)\n1811: - `Zlt_bool_true` → `Zlt_bool_true_spec` (substring-name)\n1812: - `Zlt_bool_false` → `Zlt_bool_false_spec` (substring-name)\n1813: - `negb_Zle_bool` → `negb_Zle_bool_spec` (substring-name)\n1814: - `negb_Zlt_bool` → `negb_Zlt_bool_spec` (substring-name)\n1815: - `Zlt_bool_opp_l` → `Zlt_bool_opp_l_spec` (substring-name)\n1816: - `Zlt_bool_opp_r` → `Zlt_bool_opp_r_spec` (substring-name)\n1817: - `Zlt_bool_opp` → `Zlt_bool_opp_l_spec` (substring-name)\n1818: - `Zcompare_spec` → `Zcompare_spec` (exact-name)\n1819: - `Zcompare_Lt` → `Zcompare_Lt_spec` (substring-name)\n1820: - `Zcompare_Eq` → `Zcompare_Eq_spec` (substring-name)\n1821: - `Zcompare_Gt` → `Zcompare_Gt_spec` (substring-name)\n1822: - `cond_Zopp_0` → `cond_Zopp_0_spec` (substring-name)\n1823: - `cond_Zopp_negb` → `cond_Zopp_negb_spec` (substring-name)\n1824: - `abs_cond_Zopp` → `abs_cond_Zopp_spec` (substring-name)\n1825: - `cond_Zopp_Zlt_bool` → `cond_Zopp_Zlt_bool_spec` (substring-name)\n1826: - `Zeq_bool_cond_Zopp` → `Zeq_bool_cond_Zopp_spec` (substring-name)\n1827: - `Zfast_pow_pos_correct` → (no match)\n1828: - `Zdiv_eucl_unique` → (no match)\n1829: - `Zpos_div_eucl_aux1_correct` → (no match)\n1830: - `Zpos_div_eucl_aux_correct` → (no match)\n1831: - `Zfast_div_eucl_correct` → (no match)\n1832: - `iter_nat_plus` → `iter_nat_plus_spec` (substring-name)\n1833: - `iter_nat_S` → `iter_nat_spec` (substring-name)\n1834: - `iter_pos_nat` → `iter_pos_nat_spec` (substring-name)\n1835: \n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "1   : # Core Theorems Comparison: Coq vs Lean (FloatSpec)\n2   : \n3   : This document lists all theorem-like declarations in flocq/src/Core (*.v) and FloatSpec/src/Core (*.lean), grouped by file, and indicates for each Coq declaration whether a corresponding Lean theorem/lemma exists. Matching is based on exact/normalized/substr name matches and, when available, explicit Coq references in Lean comments.\n4   : \n5   : ## File: Core.v\n6   : - Coq file: Core.v\n7   : - Lean file(s): (none)\n8   : \n9   : ### Coq Declarations\n10  : \n11  : ### Lean Declarations\n12  : \n13  : ### Mapping (Coq → Lean)\n14  : \n15  : ## File: Defs.v\n16  : - Coq file: Defs.v\n17  : - Lean file(s): Defs.lean\n18  : \n19  : ### Coq Declarations\n20  : \n21  : ### Lean Declarations\n22  : - theorem: `F2R_spec`\n23  : - theorem: `Fnum_extract_spec`\n24  : - theorem: `Fexp_extract_spec`\n25  : - theorem: `make_float_spec`\n26  : - theorem: `FlocqFloat_eq_spec`\n27  : - theorem: `F2R_zero_spec`\n28  : - theorem: `F2R_add_same_exp_spec`\n29  : \n30  : ### Mapping (Coq → Lean)\n31  : \n32  : ## File: Digits.v\n33  : - Coq file: Digits.v\n34  : - Lean file(s): Digits.lean\n35  : \n36  : ### Coq Declarations\n37  : - Theorem: `digits2_Pnat_correct`\n38  : - Theorem: `Zdigit_lt`\n39  : - Theorem: `Zdigit_0`\n40  : - Theorem: `Zdigit_opp`\n41  : - Theorem: `Zdigit_ge_Zpower_pos`\n42  : - Theorem: `Zdigit_ge_Zpower`\n43  : - Theorem: `Zdigit_not_0_pos`\n44  : - Theorem: `Zdigit_not_0`\n45  : - Theorem: `Zdigit_mul_pow`\n46  : - Theorem: `Zdigit_div_pow`\n47  : - Theorem: `Zdigit_mod_pow`\n48  : - Theorem: `Zdigit_mod_pow_out`\n49  : - Theorem: `Zsum_digit_digit`\n50  : - Theorem: `Zdigit_ext`\n51  : - Theorem: `ZOmod_plus_pow_digit`\n52  : - Theorem: `ZOdiv_plus_pow_digit`\n53  : - Theorem: `Zdigit_plus`\n54  : - Theorem: `Zdigit_scale`\n55  : - Theorem: `Zscale_0`\n56  : - Theorem: `Zsame_sign_scale`\n57  : - Theorem: `Zscale_mul_pow`\n58  : - Theorem: `Zscale_scale`\n59  : - Theorem: `Zdigit_slice`\n60  : - Theorem: `Zdigit_slice_out`\n61  : - Theorem: `Zslice_0`\n62  : - Theorem: `Zsame_sign_slice`\n63  : - Theorem: `Zslice_slice`\n64  : - Theorem: `Zslice_mul_pow`\n65  : - Theorem: `Zslice_div_pow`\n66  : - Theorem: `Zslice_scale`\n67  : - Theorem: `Zslice_div_pow_scale`\n68  : - Theorem: `Zplus_slice`\n69  : - Theorem: `Zdigits_correct`\n70  : - Theorem: `Zdigits_unique`\n71  : - Theorem: `Zdigits_abs`\n72  : - Theorem: `Zdigits_opp`\n73  : - Theorem: `Zdigits_cond_Zopp`\n74  : - Theorem: `Zdigits_gt_0`\n75  : - Theorem: `Zdigits_ge_0`\n76  : - Theorem: `Zdigit_out`\n77  : - Theorem: `Zdigit_digits`\n78  : - Theorem: `Zdigits_slice`\n79  : - Theorem: `Zdigits_mult_Zpower`\n80  : - Theorem: `Zdigits_Zpower`\n81  : - Theorem: `Zdigits_le`\n82  : - Theorem: `lt_Zdigits`\n83  : - Theorem: `Zpower_le_Zdigits`\n84  : - Theorem: `Zdigits_le_Zpower`\n85  : - Theorem: `Zpower_gt_Zdigits`\n86  : - Theorem: `Zdigits_gt_Zpower`\n87  : - Theorem: `Zdigits_mult_strong`\n88  : - Theorem: `Zdigits_mult`\n89  : - Theorem: `Zdigits_mult_ge`\n90  : - Theorem: `Zdigits_div_Zpower`\n91  : - Theorem: `Zdigits_succ_le`\n92  : - Theorem: `Z_of_nat_S_digits2_Pnat`\n93  : - Theorem: `Zpos_digits2_pos`\n94  : - Lemma: `Zdigits2_Zdigits`\n95  : \n96  : ### Lean Declarations\n97  : - lemma: `bits_pos`\n98  : - lemma: `split2`\n99  : - lemma: `bits_succ`\n100 : - lemma: `digits2_eq_bits`\n101 : - lemma: `bits_bounds`\n102 : - theorem: `digits2_Pnat_correct`\n103 : - theorem: `Zdigit_lt`\n104 : - theorem: `Zdigit_0`\n105 : - theorem: `Zdigit_opp`\n106 : - theorem: `Zdigit_ge_Zpower_pos`\n107 : - theorem: `Zdigit_ge_Zpower`\n108 : - theorem: `Zdigit_not_0_pos`\n109 : - theorem: `Zdigit_not_0`\n110 : - theorem: `Zdigit_mul_pow`\n111 : - theorem: `Zdigit_div_pow`\n112 : - theorem: `Zdigit_mod_pow`\n113 : - theorem: `Zdigit_mod_pow_out`\n114 : - theorem: `Zsum_digit_digit`\n115 : - theorem: `ZOmod_plus_pow_digit`\n116 : - theorem: `Zdigit_ext_nonneg`\n117 : - theorem: `ZOdiv_plus_pow_digit`\n118 : - theorem: `Zdigit_plus_nonneg`\n119 : - theorem: `Zdigit_scale_point`\n120 : - theorem: `Zscale_0`\n121 : - theorem: `Zsame_sign_scale`\n122 : - theorem: `Zscale_mul_pow`\n123 : - theorem: `Zscale_scale`\n124 : - theorem: `Zdigit_slice`\n125 : - theorem: `Zdigit_slice_out`\n126 : - theorem: `Zslice_0`\n127 : - theorem: `Zsame_sign_slice`\n128 : - theorem: `Zslice_slice`\n129 : - theorem: `Zslice_mul_pow`\n130 : - theorem: `Zslice_div_pow`\n131 : - theorem: `Zslice_scale`\n132 : - theorem: `Zslice_div_pow_scale_nonnegKp`\n133 : - theorem: `Zplus_slice`\n134 : - theorem: `Zdigits_correct`\n135 : - theorem: `Zdigits_unique`\n136 : - theorem: `Zdigits_abs`\n137 : - theorem: `Zdigits_opp`\n138 : - theorem: `Zdigits_cond_Zopp`\n139 : - theorem: `Zdigits_ge_0`\n140 : - theorem: `Zdigits_gt_0`\n141 : - theorem: `Zdigit_out`\n142 : - theorem: `Zdigit_digits`\n143 : - theorem: `lt_Zdigits`\n144 : - theorem: `Zdigits_le_Zpower`\n145 : - theorem: `Zdigits_slice`\n146 : - theorem: `Zdigits_mult_Zpower`\n147 : - theorem: `Zdigits_Zpower`\n148 : - theorem: `Zdigits_le`\n149 : - theorem: `Zpower_le_Zdigits`\n150 : - theorem: `Zdigits_le_Zdigits`\n151 : - theorem: `Zpower_gt_Zdigits`\n152 : - theorem: `Zdigits_gt_Zpower`\n153 : - theorem: `Zdigits_mult_strong`\n154 : - theorem: `Zdigits_mult`\n155 : - theorem: `Zdigits_mult_ge`\n156 : - theorem: `Zdigits_div_Zpower`\n157 : - theorem: `Zdigits_succ_le`\n158 : - theorem: `Z_of_nat_S_digits2_Pnat`\n159 : - theorem: `Zpos_digits2_pos`\n160 : - theorem: `Zdigits2_Zdigits`\n161 : - lemma: `beta_pos`\n162 : - lemma: `pow_pos_int`\n163 : - lemma: `Zdigit_at_zero`\n164 : - lemma: `Zdigit_eval_nonneg`\n165 : - lemma: `tdiv_zero_iff_lt_of_nonneg_pos`\n166 : - lemma: `tdiv_pow_succ_assoc`\n167 : - lemma: `exists_nonzero_digit`\n168 : - lemma: `tdiv_mod_pow_eq`\n169 : - lemma: `pow_mono_int`\n170 : - lemma: `pow_strict_mono_int`\n171 : - lemma: `wp_mono_pure`\n172 : - lemma: `zscale_div_exact`\n173 : - lemma: `div_mul_pow_eq_div_sub`\n174 : - lemma: `pow_base_mono`\n175 : - lemma: `abs_lt_beta_pow_succ_natAbs`\n176 : - theorem: `Zdigits_aux_bounds`\n177 : - lemma: `natAbs_sub_one_gt_of_nonpos`\n178 : - lemma: `pow_succ_ge`\n179 : - lemma: `pow_le_pow_exponent`\n180 : - lemma: `natAbs_sub_one_eq_add_one_of_nonpos`\n181 : - lemma: `Zdigits_aux_abs_eq`\n182 : - lemma: `Zdigits_pos_aux`\n183 : - lemma: `tdiv_lower_bound`\n184 : - lemma: `tdiv_upper_bound`\n185 : - lemma: `digit_nonzero_at_boundary`\n186 : - lemma: `Zdigits_implies_nonzero_digit`\n187 : - lemma: `digit_sum_bound`\n188 : - lemma: `highest_nonzero_digit_bound`\n189 : - lemma: `Zdigits_nonneg`\n190 : - lemma: `product_upper_bound`\n191 : - lemma: `pow_add_split`\n192 : - lemma: `Zdigits_run_eq`\n193 : - lemma: `Zdigits_sum_product_bound`\n194 : \n195 : ### Mapping (Coq → Lean)\n196 : - `digits2_Pnat_correct` → `digits2_Pnat_correct` (exact-name)\n197 : - `Zdigit_lt` → `Zdigit_lt` (exact-name)\n198 : - `Zdigit_0` → `Zdigit_0` (exact-name)\n199 : - `Zdigit_opp` → `Zdigit_opp` (exact-name)\n200 : - `Zdigit_ge_Zpower_pos` → `Zdigit_ge_Zpower_pos` (exact-name)\n201 : - `Zdigit_ge_Zpower` → `Zdigit_ge_Zpower` (exact-name)\n202 : - `Zdigit_not_0_pos` → `Zdigit_not_0_pos` (exact-name)\n203 : - `Zdigit_not_0` → `Zdigit_not_0` (exact-name)\n204 : - `Zdigit_mul_pow` → `Zdigit_mul_pow` (exact-name)\n205 : - `Zdigit_div_pow` → `Zdigit_div_pow` (exact-name)\n206 : - `Zdigit_mod_pow` → `Zdigit_mod_pow` (exact-name)\n207 : - `Zdigit_mod_pow_out` → `Zdigit_mod_pow_out` (exact-name)\n208 : - `Zsum_digit_digit` → `Zsum_digit_digit` (exact-name)\n209 : - `Zdigit_ext` → `Zdigit_ext_nonneg` (substring-name)\n210 : - `ZOmod_plus_pow_digit` → `ZOmod_plus_pow_digit` (exact-name)\n211 : - `ZOdiv_plus_pow_digit` → `ZOdiv_plus_pow_digit` (exact-name)\n212 : - `Zdigit_plus` → `Zdigit_plus_nonneg` (substring-name)\n213 : - `Zdigit_scale` → `Zdigit_scale_point` (substring-name)\n214 : - `Zscale_0` → `Zscale_0` (exact-name)\n215 : - `Zsame_sign_scale` → `Zsame_sign_scale` (exact-name)\n216 : - `Zscale_mul_pow` → `Zscale_mul_pow` (exact-name)\n217 : - `Zscale_scale` → `Zscale_scale` (exact-name)\n218 : - `Zdigit_slice` → `Zdigit_slice` (exact-name)\n219 : - `Zdigit_slice_out` → `Zdigit_slice_out` (exact-name)\n220 : - `Zslice_0` → `Zslice_0` (exact-name)\n221 : - `Zsame_sign_slice` → `Zsame_sign_slice` (exact-name)\n222 : - `Zslice_slice` → `Zslice_slice` (exact-name)\n223 : - `Zslice_mul_pow` → `Zslice_mul_pow` (exact-name)\n224 : - `Zslice_div_pow` → `Zslice_div_pow` (exact-name)\n225 : - `Zslice_scale` → `Zslice_scale` (exact-name)\n226 : - `Zslice_div_pow_scale` → `Zslice_div_pow` (substring-name)\n227 : - `Zplus_slice` → `Zplus_slice` (exact-name)\n228 : - `Zdigits_correct` → `Zdigits_correct` (exact-name)\n229 : - `Zdigits_unique` → `Zdigits_unique` (exact-name)\n230 : - `Zdigits_abs` → `Zdigits_abs` (exact-name)\n231 : - `Zdigits_opp` → `Zdigits_opp` (exact-name)\n232 : - `Zdigits_cond_Zopp` → `Zdigits_cond_Zopp` (exact-name)\n233 : - `Zdigits_gt_0` → `Zdigits_gt_0` (exact-name)\n234 : - `Zdigits_ge_0` → `Zdigits_ge_0` (exact-name)\n235 : - `Zdigit_out` → `Zdigit_out` (exact-name)\n236 : - `Zdigit_digits` → `Zdigit_digits` (exact-name)\n237 : - `Zdigits_slice` → `Zdigits_slice` (exact-name)\n238 : - `Zdigits_mult_Zpower` → `Zdigits_mult_Zpower` (exact-name)\n239 : - `Zdigits_Zpower` → `Zdigits_Zpower` (exact-name)\n240 : - `Zdigits_le` → `Zdigits_le` (exact-name)\n241 : - `lt_Zdigits` → `lt_Zdigits` (exact-name)\n242 : - `Zpower_le_Zdigits` → `Zpower_le_Zdigits` (exact-name)\n243 : - `Zdigits_le_Zpower` → `Zdigits_le_Zpower` (exact-name)\n244 : - `Zpower_gt_Zdigits` → `Zpower_gt_Zdigits` (exact-name)\n245 : - `Zdigits_gt_Zpower` → `Zdigits_gt_Zpower` (exact-name)\n246 : - `Zdigits_mult_strong` → `Zdigits_mult_strong` (exact-name)\n247 : - `Zdigits_mult` → `Zdigits_mult` (exact-name)\n248 : - `Zdigits_mult_ge` → `Zdigits_mult_ge` (exact-name)\n249 : - `Zdigits_div_Zpower` → `Zdigits_div_Zpower` (exact-name)\n250 : - `Zdigits_succ_le` → `Zdigits_succ_le` (exact-name)\n251 : - `Z_of_nat_S_digits2_Pnat` → `Z_of_nat_S_digits2_Pnat` (exact-name)\n252 : - `Zpos_digits2_pos` → `Zpos_digits2_pos` (exact-name)\n253 : - `Zdigits2_Zdigits` → `Zdigits2_Zdigits` (exact-name)\n254 : \n255 : ## File: FIX.v\n256 : - Coq file: FIX.v\n257 : - Lean file(s): FIX.lean\n258 : \n259 : ### Coq Declarations\n260 : - Theorem: `generic_format_FIX`\n261 : - Theorem: `FIX_format_generic`\n262 : - Theorem: `FIX_format_satisfies_any`\n263 : - Theorem: `ulp_FIX`\n264 : - Theorem: `round_FIX_IZR`\n265 : \n266 : ### Lean Declarations\n267 : - theorem: `FIX_exp_spec`\n268 : - theorem: `FIX_format_spec`\n269 : - theorem: `FIX_exp_correct_spec`\n270 : - theorem: `FIX_format_0_spec`\n271 : - theorem: `FIX_format_opp_spec`\n272 : \n273 : ### Mapping (Coq → Lean)\n274 : - `generic_format_FIX` → (no match)\n275 : - `FIX_format_generic` → (no match)\n276 : - `FIX_format_satisfies_any` → (no match)\n277 : - `ulp_FIX` → (no match)\n278 : - `ulp_FIX` → `ulp_FIX` (exact-name)\n279 : - `round_FIX_IZR` → (no match)\n280 :  - `round_FIX_IZR` → `round_FIX_IZR` (exact-name)\n281 : \n282 : ## File: FLT.v\n283 : - Coq file: FLT.v\n284 : - Lean file(s): FLT.lean\n285 : \n286 : ### Coq Declarations\n287 : - Theorem: `generic_format_FLT`\n288 : - Theorem: `FLT_format_generic`\n289 : - Theorem: `generic_format_FLT_bpow`\n290 : - Theorem: `FLT_format_bpow`\n291 : - Theorem: `FLT_format_satisfies_any`\n292 : - Theorem: `cexp_FLT_FLX`\n293 : - Theorem: `generic_format_FLT_FLX`\n294 : - Theorem: `generic_format_FLX_FLT`\n295 : - Theorem: `round_FLT_FLX`\n296 : - Theorem: `cexp_FLT_FIX`\n297 : - Theorem: `generic_format_FIX_FLT`\n298 : - Theorem: `generic_format_FLT_FIX`\n299 : - Lemma: `negligible_exp_FLT`\n300 : - Theorem: `generic_format_FLT_1`\n301 : - Theorem: `ulp_FLT_0`\n302 : - Theorem: `ulp_FLT_small`\n303 : - Theorem: `ulp_FLT_le`\n304 : - Theorem: `ulp_FLT_gt`\n305 : - Lemma: `ulp_FLT_exact_shift`\n306 : - Lemma: `succ_FLT_exact_shift_pos`\n307 : - Lemma: `succ_FLT_exact_shift`\n308 : - Lemma: `pred_FLT_exact_shift`\n309 : - Theorem: `ulp_FLT_pred_pos`\n310 : \n311 : ### Lean Declarations\n312 : - theorem: `FLT_exp_spec`\n313 : - theorem: `FLT_format_spec`\n314 : - theorem: `FLT_exp_correct_spec`\n315 : - theorem: `FLT_format_0_spec`\n316 : - theorem: `FLT_format_opp_spec`\n317 : - theorem: `FLT_format_abs_spec`\n318 : - theorem: `FLT_exp_FLX_spec`\n319 : \n320 : ### Mapping (Coq → Lean)\n321 :  - `generic_format_FLT` → `generic_format_FLT` (exact-name)\n322 :  - `FLT_format_generic` → `FLT_format_generic` (exact-name)\n323 : - `generic_format_FLT_bpow` → (no match)\n324 : - `FLT_format_bpow` → (no match)\n325 :  - `FLT_format_satisfies_any` → `FLT_format_satisfies_any` (exact-name)\n326 : - `cexp_FLT_FLX` → (no match)\n327 :  - `cexp_FLT_FLX` → `cexp_FLT_FLX` (exact-name)\n328 : - `generic_format_FLT_FLX` → (no match)\n329 : - `generic_format_FLX_FLT` → `generic_format_FLX_FLT` (exact-name)\n330 : - `round_FLT_FLX` → `round_FLT_FLX` (exact-name)\n331 :  - `cexp_FLT_FIX` → `cexp_FLT_FIX` (exact-name)\n332 : - `generic_format_FIX_FLT` → (no match)\n333 : - `generic_format_FLT_FIX` → (no match)\n334 : - `negligible_exp_FLT` → (no match)\n335 : - `generic_format_FLT_1` → `generic_format_FLT_1` (exact-name)\n336 :  - `ulp_FLT_0` → `ulp_FLT_0` (exact-name)\n337 :  - `ulp_FLT_small` → `ulp_FLT_small` (exact-name)\n338 : - `ulp_FLT_le` → (no match)\n339 : - `ulp_FLT_gt` → (no match)\n340 : - `ulp_FLT_exact_shift` → (no match)\n341 : - `succ_FLT_exact_shift_pos` → (no match)\n342 : - `succ_FLT_exact_shift` → (no match)\n343 : - `pred_FLT_exact_shift` → (no match)\n344 : - `ulp_FLT_pred_pos` → (no match)\n345 : \n346 : ## File: FLX.v\n347 : - Coq file: FLX.v\n348 : - Lean file(s): FLX.lean\n349 : \n350 : ### Coq Declarations\n351 : - Theorem: `FIX_format_FLX`\n352 : - Theorem: `FLX_format_generic`\n353 : - Theorem: `generic_format_FLX`\n354 : - Theorem: `FLX_format_satisfies_any`\n355 : - Theorem: `FLX_format_FIX`\n356 : - Theorem: `generic_format_FLXN`\n357 : - Theorem: `FLXN_format_generic`\n358 : - Theorem: `FLXN_format_satisfies_any`\n359 : - Lemma: `negligible_exp_FLX`\n360 : - Theorem: `generic_format_FLX_1`\n361 : - Theorem: `ulp_FLX_0`\n362 : - Lemma: `ulp_FLX_1`\n363 : - Lemma: `succ_FLX_1`\n364 : - Theorem: `eq_0_round_0_FLX`\n365 : - Theorem: `gt_0_round_gt_0_FLX`\n366 : - Theorem: `ulp_FLX_le`\n367 : - Theorem: `ulp_FLX_ge`\n368 : - Lemma: `ulp_FLX_exact_shift`\n369 : - Lemma: `succ_FLX_exact_shift`\n370 : - Lemma: `pred_FLX_exact_shift`\n371 : \n372 : ### Lean Declarations\n373 : - theorem: `FLX_exp_spec`\n374 : - theorem: `FLX_format_spec`\n375 : - theorem: `FLX_exp_correct_spec`\n376 : - theorem: `FLX_format_0_spec`\n377 : - theorem: `FLX_format_opp_spec`\n378 : - theorem: `FLX_format_abs_spec`\n379 : - theorem: `ulp_FLX_1`\n380 : \n381 : ### Mapping (Coq → Lean)\n382 : - `FIX_format_FLX` → (no match)\n383 :  - `FLX_format_generic` → `FLX_format_generic` (exact-name)\n384 : - `generic_format_FLX` → (no match)\n385 : - `FLX_format_satisfies_any` → `FLX_format_satisfies_any` (exact-name)\n386 : - `FLX_format_FIX` → (no match)\n387 : - `generic_format_FLXN` → (no match)\n388 : - `FLXN_format_generic` → (no match)\n389 : - `FLXN_format_satisfies_any` → (no match)\n390 : - `negligible_exp_FLX` → (no match)\n391 : - `generic_format_FLX_1` → `generic_format_FLX_1` (exact-name)\n392 : - `ulp_FLX_0` → `ulp_FLX_0` (exact-name)\n393 : - `ulp_FLX_1` → `ulp_FLX_1` (exact-name)\n394 : - `succ_FLX_1` → (no match)\n395 : - `eq_0_round_0_FLX` → (no match)\n396 : - `gt_0_round_gt_0_FLX` → (no match)\n397 : - `ulp_FLX_le` → `ulp_FLX_le` (exact-name)\n398 : - `ulp_FLX_ge` → (no match)\n399 :  - `ulp_FLX_ge` → `ulp_FLX_ge` (exact-name)\n400 : - `ulp_FLX_exact_shift` → (no match)\n401 :  - `ulp_FLX_exact_shift` → `ulp_FLX_exact_shift` (exact-name)\n402 : - `succ_FLX_exact_shift` → (no match)\n403 : - `pred_FLX_exact_shift` → (no match)\n404 : \n405 : ## File: FTZ.v\n406 : - Coq file: FTZ.v\n407 : - Lean file(s): FTZ.lean\n408 : \n409 : ### Coq Declarations\n410 : - Theorem: `FLXN_format_FTZ`\n411 : - Theorem: `generic_format_FTZ`\n412 : - Theorem: `FTZ_format_generic`\n413 : - Theorem: `FTZ_format_satisfies_any`\n414 : - Theorem: `FTZ_format_FLXN`\n415 : - Theorem: `ulp_FTZ_0`\n416 : - Theorem: `round_FTZ_FLX`\n417 : - Theorem: `round_FTZ_small`\n418 : \n419 : ### Lean Declarations\n420 : - theorem: `FTZ_exp_spec`\n421 : - theorem: `FTZ_format_spec`\n422 : - theorem: `FTZ_exp_correct_spec`\n423 : - theorem: `FTZ_format_0_spec`\n424 : - theorem: `FTZ_format_opp_spec`\n425 : - theorem: `FTZ_format_abs_spec`\n426 : \n427 : ### Mapping (Coq → Lean)\n428 : - `FLXN_format_FTZ` → `FLXN_format_FTZ` (exact-name)\n429 : - `generic_format_FTZ` → `generic_format_FTZ` (exact-name)\n430 : - `FTZ_format_generic` → `FTZ_format_generic` (exact-name)\n431 : - `FTZ_format_satisfies_any` → `FTZ_format_satisfies_any` (exact-name)\n432 : - `FTZ_format_FLXN` → `FTZ_format_FLXN` (exact-name)\n433 : - `ulp_FTZ_0` → `ulp_FTZ_0` (exact-name)\n434 : - `round_FTZ_FLX` → `round_FTZ_FLX` (exact-name)\n435 : - `round_FTZ_small` → `round_FTZ_small` (exact-name)\n436 : \n437 : ## File: Float_prop.v\n438 : - Coq file: Float_prop.v\n439 : - Lean file(s): Float_prop.lean\n440 : \n441 : ### Coq Declarations\n442 : - Theorem: `Rcompare_F2R`\n443 : - Theorem: `le_F2R`\n444 : - Theorem: `F2R_le`\n445 : - Theorem: `lt_F2R`\n446 : - Theorem: `F2R_lt`\n447 : - Theorem: `F2R_eq`\n448 : - Theorem: `eq_F2R`\n449 : - Theorem: `F2R_Zabs`\n450 : - Theorem: `F2R_Zopp`\n451 : - Theorem: `F2R_cond_Zopp`\n452 : - Theorem: `F2R_0`\n453 : - Theorem: `eq_0_F2R`\n454 : - Theorem: `ge_0_F2R`\n455 : - Theorem: `le_0_F2R`\n456 : - Theorem: `gt_0_F2R`\n457 : - Theorem: `lt_0_F2R`\n458 : - Theorem: `F2R_ge_0`\n459 : - Theorem: `F2R_le_0`\n460 : - Theorem: `F2R_gt_0`\n461 : - Theorem: `F2R_lt_0`\n462 : - Theorem: `F2R_neq_0`\n463 : - Lemma: `Fnum_ge_0`\n464 : - Lemma: `Fnum_le_0`\n465 : - Theorem: `F2R_bpow`\n466 : - Theorem: `bpow_le_F2R`\n467 : - Theorem: `F2R_p1_le_bpow`\n468 : - Theorem: `bpow_le_F2R_m1`\n469 : - Theorem: `F2R_lt_bpow`\n470 : - Theorem: `F2R_change_exp`\n471 : - Theorem: `F2R_prec_normalize`\n472 : - Theorem: `mag_F2R_bounds`\n473 : - Theorem: `mag_F2R`\n474 : - Theorem: `Zdigits_mag`\n475 : - Theorem: `mag_F2R_Zdigits`\n476 : - Theorem: `mag_F2R_bounds_Zdigits`\n477 : - Theorem: `float_distribution_pos`\n478 : \n479 : ### Lean Declarations\n480 : - theorem: `Rcompare_F2R`\n481 : - theorem: `le_F2R`\n482 : - theorem: `F2R_le`\n483 : - theorem: `lt_F2R`\n484 : - theorem: `F2R_lt`\n485 : - theorem: `F2R_eq`\n486 : - theorem: `eq_F2R`\n487 : - theorem: `F2R_Zabs`\n488 : - theorem: `F2R_Zopp`\n489 : - theorem: `F2R_cond_Zopp`\n490 : - theorem: `F2R_0`\n491 : - theorem: `eq_0_F2R`\n492 : - theorem: `ge_0_F2R`\n493 : - theorem: `le_0_F2R`\n494 : - theorem: `gt_0_F2R`\n495 : - theorem: `lt_0_F2R`\n496 : - theorem: `F2R_ge_0`\n497 : - theorem: `F2R_le_0`\n498 : - theorem: `F2R_gt_0`\n499 : - theorem: `F2R_lt_0`\n500 : - theorem: `F2R_neq_0`\n501 : - theorem: `F2R_bpow`\n502 : - theorem: `bpow_le_F2R`\n503 : - theorem: `F2R_p1_le_bpow`\n504 : - theorem: `bpow_le_F2R_m1`\n505 : - theorem: `F2R_lt_bpow`\n506 : - theorem: `F2R_change_exp`\n507 : - theorem: `F2R_prec_normalize`\n508 : - theorem: `mag_F2R_bounds`\n509 : - theorem: `mag_F2R`\n510 : - theorem: `Zdigits_mag`\n511 : - theorem: `mag_F2R_Zdigits`\n512 : - theorem: `mag_F2R_bounds_Zdigits`\n513 : - theorem: `float_distribution_pos`\n514 : \n515 : ### Mapping (Coq → Lean)\n516 : - `Rcompare_F2R` → `Rcompare_F2R` (exact-name)\n517 : - `le_F2R` → `le_F2R` (exact-name)\n518 : - `F2R_le` → `F2R_le` (exact-name)\n519 : - `lt_F2R` → `lt_F2R` (exact-name)\n520 : - `F2R_lt` → `F2R_lt` (exact-name)\n521 : - `F2R_eq` → `F2R_eq` (exact-name)\n522 : - `eq_F2R` → `eq_F2R` (exact-name)\n523 : - `F2R_Zabs` → `F2R_Zabs` (exact-name)\n524 : - `F2R_Zopp` → `F2R_Zopp` (exact-name)\n525 : - `F2R_cond_Zopp` → `F2R_cond_Zopp` (exact-name)\n526 : - `F2R_0` → `F2R_0` (exact-name)\n527 : - `eq_0_F2R` → `eq_0_F2R` (exact-name)\n528 : - `ge_0_F2R` → `ge_0_F2R` (exact-name)\n529 : - `le_0_F2R` → `le_0_F2R` (exact-name)\n530 : - `gt_0_F2R` → `gt_0_F2R` (exact-name)\n531 : - `lt_0_F2R` → `lt_0_F2R` (exact-name)\n532 : - `F2R_ge_0` → `F2R_ge_0` (exact-name)\n533 : - `F2R_le_0` → `F2R_le_0` (exact-name)\n534 : - `F2R_gt_0` → `F2R_gt_0` (exact-name)\n535 : - `F2R_lt_0` → `F2R_lt_0` (exact-name)\n536 : - `F2R_neq_0` → `F2R_neq_0` (exact-name)\n537 : - `Fnum_ge_0` → `Fnum_ge_0` (exact-name)\n538 : - `Fnum_le_0` → `Fnum_le_0` (exact-name)\n539 : - `F2R_bpow` → `F2R_bpow` (exact-name)\n540 : - `bpow_le_F2R` → `bpow_le_F2R` (exact-name)\n541 : - `F2R_p1_le_bpow` → `F2R_p1_le_bpow` (exact-name)\n542 : - `bpow_le_F2R_m1` → `bpow_le_F2R_m1` (exact-name)\n543 : - `F2R_lt_bpow` → `F2R_lt_bpow` (exact-name)\n544 : - `F2R_change_exp` → `F2R_change_exp` (exact-name)\n545 : - `F2R_prec_normalize` → `F2R_prec_normalize` (exact-name)\n546 : - `mag_F2R_bounds` → `mag_F2R_bounds` (exact-name)\n547 : - `mag_F2R` → `mag_F2R` (exact-name)\n548 : - `Zdigits_mag` → `Zdigits_mag` (exact-name)\n549 : - `mag_F2R_Zdigits` → `mag_F2R_Zdigits` (exact-name)\n550 : - `mag_F2R_bounds_Zdigits` → `mag_F2R_bounds_Zdigits` (exact-name)\n551 : - `float_distribution_pos` → `float_distribution_pos` (exact-name)\n552 : \n553 : ## File: Generic_fmt.v\n554 : - Coq file: Generic_fmt.v\n555 : - Lean file(s): Generic_fmt.lean, Round_generic.lean\n556 : \n557 : ### Coq Declarations\n558 : - Theorem: `valid_exp_large`\n559 : - Theorem: `valid_exp_large'`\n560 : - Theorem: `generic_format_0`\n561 : - Theorem: `cexp_opp`\n562 : - Theorem: `cexp_abs`\n563 : - Theorem: `canonical_generic_format`\n564 : - Theorem: `generic_format_bpow`\n565 : - Theorem: `generic_format_bpow'`\n566 : - Theorem: `generic_format_F2R`\n567 : - Lemma: `generic_format_F2R'`\n568 : - Theorem: `canonical_opp`\n569 : - Theorem: `canonical_abs`\n570 : - Theorem: `canonical_0`\n571 : - Theorem: `canonical_unique`\n572 : - Theorem: `scaled_mantissa_generic`\n573 : - Theorem: `scaled_mantissa_mult_bpow`\n574 : - Theorem: `scaled_mantissa_0`\n575 : - Theorem: `scaled_mantissa_opp`\n576 : - Theorem: `scaled_mantissa_abs`\n577 : - Theorem: `generic_format_opp`\n578 : - Theorem: `generic_format_abs`\n579 : - Theorem: `generic_format_abs_inv`\n580 : - Theorem: `cexp_fexp`\n581 : - Theorem: `cexp_fexp_pos`\n582 : - Theorem: `mantissa_small_pos`\n583 : - Theorem: `scaled_mantissa_lt_1`\n584 : - Theorem: `scaled_mantissa_lt_bpow`\n585 : - Theorem: `mag_generic_gt`\n586 : - Lemma: `mantissa_DN_small_pos`\n587 : - Lemma: `mantissa_UP_small_pos`\n588 : - Theorem: `generic_format_discrete`\n589 : - Theorem: `generic_format_canonical`\n590 : - Theorem: `generic_format_ge_bpow`\n591 : - Theorem: `abs_lt_bpow_prec`\n592 : - Theorem: `generic_format_bpow_inv'`\n593 : - Theorem: `generic_format_bpow_inv`\n594 : - Theorem: `Zrnd_DN_or_UP`\n595 : - Theorem: `Zrnd_ZR_or_AW`\n596 : - Theorem: `round_bounded_large_pos`\n597 : - Theorem: `round_bounded_small_pos`\n598 : - Lemma: `round_le_pos`\n599 : - Theorem: `round_generic`\n600 : - Theorem: `round_0`\n601 : - Theorem: `exp_small_round_0_pos`\n602 : - Lemma: `generic_format_round_pos`\n603 : - Theorem: `round_ext`\n604 : - Theorem: `round_opp`\n605 : - Theorem: `round_DN_or_UP`\n606 : - Theorem: `round_ZR_or_AW`\n607 : - Theorem: `round_le`\n608 : - Theorem: `round_ge_generic`\n609 : - Theorem: `round_le_generic`\n610 : - Theorem: `round_abs_abs`\n611 : - Theorem: `round_bounded_large`\n612 : - Theorem: `exp_small_round_0`\n613 : - Theorem: `abs_round_ge_generic`\n614 : - Theorem: `abs_round_le_generic`\n615 : - Theorem: `round_DN_opp`\n616 : - Theorem: `round_UP_opp`\n617 : - Theorem: `round_ZR_opp`\n618 : - Theorem: `round_ZR_abs`\n619 : - Theorem: `round_AW_opp`\n620 : - Theorem: `round_AW_abs`\n621 : - Theorem: `round_ZR_DN`\n622 : - Theorem: `round_ZR_UP`\n623 : - Theorem: `round_AW_UP`\n624 : - Theorem: `round_AW_DN`\n625 : - Theorem: `generic_format_round`\n626 : - Theorem: `round_DN_pt`\n627 : - Theorem: `generic_format_satisfies_any`\n628 : - Theorem: `round_UP_pt`\n629 : - Theorem: `round_ZR_pt`\n630 : - Lemma: `round_DN_small_pos`\n631 : - Theorem: `round_DN_UP_lt`\n632 : - Lemma: `round_UP_small_pos`\n633 : - Theorem: `generic_format_EM`\n634 : - Lemma: `round_large_pos_ge_bpow`\n635 : - Theorem: `mag_round_ZR`\n636 : - Theorem: `mag_round`\n637 : - Theorem: `mag_DN`\n638 : - Theorem: `cexp_DN`\n639 : - Theorem: `scaled_mantissa_DN`\n640 : - Theorem: `generic_N_pt_DN_or_UP`\n641 : - Theorem: `subnormal_exponent`\n642 : - Lemma: `cexp_le_bpow`\n643 : - Lemma: `cexp_ge_bpow`\n644 : - Lemma: `lt_cexp_pos`\n645 : - Theorem: `lt_cexp`\n646 : - Theorem: `mag_round_ge`\n647 : - Theorem: `cexp_round_ge`\n648 : - Theorem: `Znearest_DN_or_UP`\n649 : - Theorem: `Znearest_ge_floor`\n650 : - Theorem: `Znearest_le_ceil`\n651 : - Theorem: `Znearest_N_strict`\n652 : - Theorem: `Znearest_half`\n653 : - Theorem: `Znearest_imp`\n654 : - Theorem: `round_N_pt`\n655 : - Theorem: `round_N_middle`\n656 : - Lemma: `round_N_small_pos`\n657 : - Theorem: `round_NA_pt`\n658 : - Theorem: `round_N0_pt`\n659 : - Theorem: `Znearest_opp`\n660 : - Theorem: `round_N_opp`\n661 : - Lemma: `round_N0_opp`\n662 : - Lemma: `round_N_small`\n663 : - Theorem: `generic_inclusion_mag`\n664 : - Theorem: `generic_inclusion_lt_ge`\n665 : - Theorem: `generic_inclusion`\n666 : - Theorem: `generic_inclusion_le_ge`\n667 : - Theorem: `generic_inclusion_le`\n668 : - Theorem: `generic_inclusion_ge`\n669 : - Theorem: `generic_round_generic`\n670 : - Lemma: `round_NA_opp`\n671 : \n672 : ### Lean Declarations\n673 : - lemma: `Ztrunc_int`\n674 : - lemma: `zpow_ne_zero_of_pos`\n675 : - theorem: `valid_exp_large`\n676 : - theorem: `cexp_spec`\n677 : - theorem: `scaled_mantissa_spec`\n678 : - theorem: `generic_format_spec`\n679 : - theorem: `Ztrunc_neg`\n680 : - theorem: `Ztrunc_intCast`\n681 : - theorem: `zpow_mul_sub`\n682 : - theorem: `zpow_sub_add`\n683 : - theorem: `zpow_nonneg_toNat`\n684 : - theorem: `generic_format_0`\n685 : - theorem: `cexp_opp`\n686 : - theorem: `cexp_abs`\n687 : - theorem: `canonical_generic_format`\n688 : - theorem: `scaled_mantissa_mult_bpow`\n689 : - lemma: `Ztrunc_zero`\n690 : - theorem: `generic_format_F2R`\n691 : - theorem: `canonical_opp`\n692 : - theorem: `canonical_abs`\n693 : - theorem: `canonical_0`\n694 : - theorem: `canonical_unique`\n695 : - theorem: `scaled_mantissa_0`\n696 : - theorem: `scaled_mantissa_opp`\n697 : - theorem: `scaled_mantissa_abs`\n698 : - theorem: `generic_format_opp`\n699 : - theorem: `generic_format_abs`\n700 : - theorem: `generic_format_abs_inv`\n701 : - theorem: `generic_format_satisfies_any`\n702 : - theorem: `round_UP_exists`\n703 : - theorem: `generic_format_bpow`\n704 : - theorem: `scaled_mantissa_generic`\n705 : - theorem: `cexp_fexp`\n706 : - theorem: `cexp_fexp_pos`\n707 : - theorem: `mantissa_small_pos`\n708 : - theorem: `scaled_mantissa_lt_1`\n709 : - theorem: `scaled_mantissa_lt_bpow`\n710 : - theorem: `generic_format_round_DN`\n711 : - theorem: `generic_format_round_UP`\n712 : - theorem: `generic_format_precision_bound`\n713 : - theorem: `fexp_monotone`\n714 : - theorem: `generic_format_equiv`\n715 : - theorem: `round_to_generic_spec`\n716 : - theorem: `generic_format_inter_valid`\n717 : - theorem: `mag_generic_format`\n718 : - theorem: `precision_generic_format`\n719 : - theorem: `generic_format_error_bound`\n720 : - theorem: `generic_format_relative_error`\n721 : - theorem: `round_to_format_properties`\n722 : - theorem: `generic_format_neg_closed`\n723 : - theorem: `Rnd_UP_to_DN_via_neg`\n724 : \n725 : ### Mapping (Coq → Lean)\n726 : - `valid_exp_large` → `valid_exp_large` (exact-name)\n727 : - `valid_exp_large'` → `valid_exp_large` (normalized-name)\n728 : - `generic_format_0` → `generic_format_0` (exact-name)\n729 : - `cexp_opp` → `cexp_opp` (exact-name)\n730 : - `cexp_abs` → `cexp_abs` (exact-name)\n731 : - `canonical_generic_format` → `canonical_generic_format` (exact-name)\n732 : - `generic_format_bpow` → `generic_format_bpow` (exact-name)\n733 : - `generic_format_bpow'` → `generic_format_bpow` (normalized-name)\n734 : - `generic_format_F2R` → `generic_format_F2R` (exact-name)\n735 : - `generic_format_F2R'` → `generic_format_F2R` (normalized-name)\n736 : - `canonical_opp` → `canonical_opp` (exact-name)\n737 : - `canonical_abs` → `canonical_abs` (exact-name)\n738 : - `canonical_0` → `canonical_0` (exact-name)\n739 : - `canonical_unique` → `canonical_unique` (exact-name)\n740 : - `scaled_mantissa_generic` → `scaled_mantissa_generic` (exact-name)\n741 : - `scaled_mantissa_mult_bpow` → `scaled_mantissa_mult_bpow` (exact-name)\n742 : - `scaled_mantissa_0` → `scaled_mantissa_0` (exact-name)\n743 : - `scaled_mantissa_opp` → `scaled_mantissa_opp` (exact-name)\n744 : - `scaled_mantissa_abs` → `scaled_mantissa_abs` (exact-name)\n745 : - `generic_format_opp` → `generic_format_opp` (exact-name)\n746 : - `generic_format_abs` → `generic_format_abs` (exact-name)\n747 : - `generic_format_abs_inv` → `generic_format_abs_inv` (exact-name)\n748 : - `cexp_fexp` → `cexp_fexp` (exact-name)\n749 : - `cexp_fexp_pos` → `cexp_fexp_pos` (exact-name)\n750 : - `mantissa_small_pos` → `mantissa_small_pos` (exact-name)\n751 : - `scaled_mantissa_lt_1` → `scaled_mantissa_lt_1` (exact-name)\n752 : - `mag_generic_gt` → `mag_generic_gt` (exact-name)\n753 : - `mantissa_DN_small_pos` → (no match)\n754 : - `mantissa_UP_small_pos` → (no match)\n755 : - `generic_format_discrete` → (no match)\n756 : - `generic_format_canonical` → (no match)\n757 : - `generic_format_ge_bpow` → (no match)\n758 : - `abs_lt_bpow_prec` → (no match)\n759 : - `generic_format_bpow_inv'` → `generic_format_bpow` (substring-name)\n760 : - `generic_format_bpow_inv` → `generic_format_bpow` (substring-name)\n761 : - `Zrnd_DN_or_UP` → (no match)\n762 : - `Zrnd_ZR_or_AW` → (no match)\n763 : - `round_bounded_large_pos` → (no match)\n764 : - `round_bounded_small_pos` → (no match)\n765 : - `round_le_pos` → (no match)\n766 : - `round_generic` → (no match)\n767 : - `round_0` → `round_0` (exact-name)\n768 : - `exp_small_round_0_pos` → (no match)\n769 : - `generic_format_round_pos` → (no match)\n770 : - `round_ext` → (no match)\n771 : - `round_opp` → (no match)\n772 : - `round_DN_or_UP` → (no match)\n773 : - `round_ZR_or_AW` → (no match)\n774 : - `round_le` → (no match)\n775 : - `round_ge_generic` → (no match)\n776 : - `round_le_generic` → (no match)\n777 : - `round_abs_abs` → (no match)\n778 : - `round_bounded_large` → (no match)\n779 : - `exp_small_round_0` → (no match)\n780 : - `abs_round_ge_generic` → (no match)\n781 : - `abs_round_le_generic` → (no match)\n782 : - `round_DN_opp` → (no match)\n783 : - `round_UP_opp` → (no match)\n784 : - `round_ZR_opp` → (no match)\n785 : - `round_ZR_abs` → (no match)\n786 : - `round_AW_opp` → (no match)\n787 : - `round_AW_abs` → (no match)\n788 : - `round_ZR_DN` → (no match)\n789 : - `round_ZR_UP` → (no match)\n790 : - `round_AW_UP` → (no match)\n791 : - `round_AW_DN` → (no match)\n792 : - `generic_format_round` → `generic_format_round_DN` (substring-name)\n793 : - `round_DN_pt` → (no match)\n794 : - `generic_format_satisfies_any` → `generic_format_satisfies_any` (exact-name)\n795 : - `round_UP_pt` → (no match)\n796 : - `round_ZR_pt` → (no match)\n797 : - `round_DN_small_pos` → (no match)\n798 : - `round_DN_UP_lt` → (no match)\n799 : - `round_UP_small_pos` → (no match)\n800 : - `generic_format_EM` → (no match)\n801 : - `round_large_pos_ge_bpow` → (no match)\n802 : - `mag_round_ZR` → (no match)\n803 : - `mag_round` → (no match)\n804 : - `mag_DN` → (no match)\n805 : - `cexp_DN` → (no match)\n806 : - `scaled_mantissa_DN` → (no match)\n807 : - `generic_N_pt_DN_or_UP` → (no match)\n808 : - `subnormal_exponent` → (no match)\n809 : - `cexp_le_bpow` → (no match)\n810 : - `cexp_ge_bpow` → (no match)\n811 : - `lt_cexp_pos` → (no match)\n812 : - `lt_cexp` → (no match)\n813 : - `mag_round_ge` → (no match)\n814 : - `cexp_round_ge` → (no match)\n815 : - `Znearest_DN_or_UP` → (no match)\n816 : - `Znearest_ge_floor` → (no match)\n817 : - `Znearest_le_ceil` → (no match)\n818 : - `Znearest_N_strict` → (no match)\n819 : - `Znearest_half` → (no match)\n820 : - `Znearest_imp` → (no match)\n821 : - `round_N_pt` → (no match)\n822 : - `round_N_middle` → (no match)\n823 : - `round_N_small_pos` → (no match)\n824 : - `round_NA_pt` → (no match)\n825 : - `round_N0_pt` → (no match)\n826 : - `Znearest_opp` → (no match)\n827 : - `round_N_opp` → (no match)\n828 : - `round_N0_opp` → (no match)\n829 : - `round_N_small` → (no match)\n830 : - `generic_inclusion_mag` → (no match)\n831 : - `generic_inclusion_lt_ge` → (no match)\n832 : - `generic_inclusion` → (no match)\n833 : - `generic_inclusion_le_ge` → (no match)\n834 : - `generic_inclusion_le` → (no match)\n835 : - `generic_inclusion_ge` → (no match)\n836 : - `generic_round_generic` → (no match)\n837 : - `round_NA_opp` → (no match)\n838 : \n839 : ## File: Raux.v\n840 : - Coq file: Raux.v\n841 : - Lean file(s): Raux.lean\n842 : \n843 : ### Coq Declarations\n844 : - Theorem: `Rle_0_minus`\n845 : - Theorem: `Rabs_eq_Rabs`\n846 : - Theorem: `Rabs_minus_le`\n847 : - Theorem: `Rabs_eq_R0`\n848 : - Theorem: `Rmult_lt_compat`\n849 : - Lemma: `Rmult_neq_reg_r`\n850 : - Lemma: `Rmult_neq_compat_r`\n851 : - Theorem: `Rmult_min_distr_r`\n852 : - Theorem: `Rmult_min_distr_l`\n853 : - Lemma: `Rmin_opp`\n854 : - Lemma: `Rmax_opp`\n855 : - Theorem: `exp_le`\n856 : - Theorem: `Rinv_lt`\n857 : - Theorem: `Rinv_le`\n858 : - Theorem: `sqrt_ge_0`\n859 : - Lemma: `sqrt_neg`\n860 : - Lemma: `Rsqr_le_abs_0_alt`\n861 : - Theorem: `Rabs_le_inv`\n862 : - Theorem: `Rabs_ge`\n863 : - Theorem: `Rabs_ge_inv`\n864 : - Theorem: `Rabs_lt`\n865 : - Theorem: `Rabs_lt_inv`\n866 : - Theorem: `Rabs_gt`\n867 : - Theorem: `Rabs_gt_inv`\n868 : - Theorem: `IZR_le_lt`\n869 : - Theorem: `le_lt_IZR`\n870 : - Theorem: `neq_IZR`\n871 : - Theorem: `Rcompare_spec`\n872 : - Theorem: `Rcompare_Lt`\n873 : - Theorem: `Rcompare_Lt_inv`\n874 : - Theorem: `Rcompare_not_Lt`\n875 : - Theorem: `Rcompare_not_Lt_inv`\n876 : - Theorem: `Rcompare_Eq`\n877 : - Theorem: `Rcompare_Eq_inv`\n878 : - Theorem: `Rcompare_Gt`\n879 : - Theorem: `Rcompare_Gt_inv`\n880 : - Theorem: `Rcompare_not_Gt`\n881 : - Theorem: `Rcompare_not_Gt_inv`\n882 : - Theorem: `Rcompare_IZR`\n883 : - Theorem: `Rcompare_sym`\n884 : - Lemma: `Rcompare_opp`\n885 : - Theorem: `Rcompare_plus_r`\n886 : - Theorem: `Rcompare_plus_l`\n887 : - Theorem: `Rcompare_mult_r`\n888 : - Theorem: `Rcompare_mult_l`\n889 : - Theorem: `Rcompare_middle`\n890 : - Theorem: `Rcompare_half_l`\n891 : - Theorem: `Rcompare_half_r`\n892 : - Theorem: `Rcompare_sqr`\n893 : - Theorem: `Rmin_compare`\n894 : - Theorem: `Rle_bool_spec`\n895 : - Theorem: `Rle_bool_true`\n896 : - Theorem: `Rle_bool_false`\n897 : - Theorem: `Rlt_bool_spec`\n898 : - Theorem: `negb_Rlt_bool`\n899 : - Theorem: `negb_Rle_bool`\n900 : - Theorem: `Rlt_bool_true`\n901 : - Theorem: `Rlt_bool_false`\n902 : - Lemma: `Rlt_bool_opp`\n903 : - Theorem: `Req_bool_spec`\n904 : - Theorem: `Req_bool_true`\n905 : - Theorem: `Req_bool_false`\n906 : - Theorem: `Zfloor_lb`\n907 : - Theorem: `Zfloor_ub`\n908 : - Theorem: `Zfloor_lub`\n909 : - Theorem: `Zfloor_imp`\n910 : - Theorem: `Zfloor_IZR`\n911 : - Theorem: `Zfloor_le`\n912 : - Theorem: `Zceil_ub`\n913 : - Theorem: `Zceil_lb`\n914 : - Theorem: `Zceil_glb`\n915 : - Theorem: `Zceil_imp`\n916 : - Theorem: `Zceil_IZR`\n917 : - Theorem: `Zceil_le`\n918 : - Theorem: `Zceil_floor_neq`\n919 : - Theorem: `Ztrunc_IZR`\n920 : - Theorem: `Ztrunc_floor`\n921 : - Theorem: `Ztrunc_ceil`\n922 : - Theorem: `Ztrunc_le`\n923 : - Theorem: `Ztrunc_opp`\n924 : - Theorem: `Ztrunc_abs`\n925 : - Theorem: `Ztrunc_lub`\n926 : - Theorem: `Zaway_IZR`\n927 : - Theorem: `Zaway_ceil`\n928 : - Theorem: `Zaway_floor`\n929 : - Theorem: `Zaway_le`\n930 : - Theorem: `Zaway_opp`\n931 : - Theorem: `Zaway_abs`\n932 : - Theorem: `Rcompare_floor_ceil_middle`\n933 : - Theorem: `Rcompare_ceil_floor_middle`\n934 : - Theorem: `Zfloor_div`\n935 : - Theorem: `Ztrunc_div`\n936 : - Theorem: `radix_pos`\n937 : - Theorem: `IZR_Zpower_pos`\n938 : - Theorem: `bpow_powerRZ`\n939 : - Theorem: `bpow_ge_0`\n940 : - Theorem: `bpow_gt_0`\n941 : - Theorem: `bpow_plus`\n942 : - Theorem: `bpow_1`\n943 : - Theorem: `bpow_plus_1`\n944 : - Theorem: `bpow_opp`\n945 : - Theorem: `IZR_Zpower_nat`\n946 : - Theorem: `IZR_Zpower`\n947 : - Theorem: `bpow_lt`\n948 : - Theorem: `lt_bpow`\n949 : - Theorem: `bpow_le`\n950 : - Theorem: `le_bpow`\n951 : - Theorem: `bpow_inj`\n952 : - Theorem: `bpow_exp`\n953 : - Lemma: `sqrt_bpow`\n954 : - Lemma: `sqrt_bpow_ge`\n955 : - Theorem: `bpow_lt_bpow`\n956 : - Theorem: `bpow_unique`\n957 : - Theorem: `mag_unique`\n958 : - Theorem: `mag_opp`\n959 : - Theorem: `mag_abs`\n960 : - Theorem: `mag_unique_pos`\n961 : - Theorem: `mag_le_abs`\n962 : - Theorem: `mag_le`\n963 : - Lemma: `lt_mag`\n964 : - Theorem: `mag_bpow`\n965 : - Theorem: `mag_mult_bpow`\n966 : - Theorem: `mag_le_bpow`\n967 : - Theorem: `mag_gt_bpow`\n968 : - Theorem: `mag_ge_bpow`\n969 : - Theorem: `bpow_mag_gt`\n970 : - Theorem: `bpow_mag_le`\n971 : - Theorem: `mag_le_Zpower`\n972 : - Theorem: `mag_gt_Zpower`\n973 : - Lemma: `mag_mult`\n974 : - Lemma: `mag_plus`\n975 : - Lemma: `mag_minus`\n976 : - Lemma: `mag_minus_lb`\n977 : - Theorem: `mag_plus_ge`\n978 : - Lemma: `mag_div`\n979 : - Lemma: `mag_sqrt`\n980 : - Lemma: `mag_1`\n981 : - Theorem: `eqb_sym`\n982 : - Theorem: `eqb_false`\n983 : - Theorem: `eqb_true`\n984 : - Theorem: `IZR_cond_Zopp`\n985 : - Theorem: `abs_cond_Ropp`\n986 : - Theorem: `cond_Ropp_Rlt_bool`\n987 : - Theorem: `Rlt_bool_cond_Ropp`\n988 : - Theorem: `cond_Ropp_involutive`\n989 : - Theorem: `cond_Ropp_inj`\n990 : - Theorem: `cond_Ropp_mult_l`\n991 : - Theorem: `cond_Ropp_mult_r`\n992 : - Theorem: `cond_Ropp_plus`\n993 : - Theorem: `LPO_min`\n994 : - Theorem: `LPO`\n995 : - Lemma: `LPO_Z`\n996 : \n997 : ### Lean Declarations\n998 : - theorem: `Rle_0_minus_spec`\n999 : - theorem: `Rmult_lt_compat_spec`\n1000: - theorem: `Rmult_neq_reg_r_spec`\n1001: - theorem: `Rmult_neq_compat_r_spec`\n1002: - theorem: `Rmult_min_distr_r_spec`\n1003: - theorem: `Rmult_min_distr_l_spec`\n1004: - theorem: `Rmin_opp_spec`\n1005: - theorem: `Rmax_opp_spec`\n1006: - theorem: `Rabs_eq_Rabs_spec`\n1007: - theorem: `Rabs_minus_le_spec`\n1008:  - theorem: `Rabs_ge_spec`\n1009:  - theorem: `Rabs_ge_inv_spec`\n1010: - theorem: `Rcompare_spec`\n1011: - theorem: `Rcompare_sym_spec`\n1012: - theorem: `Rcompare_opp_spec`\n1013: - theorem: `Rcompare_plus_r_spec`\n1014: - theorem: `Rcompare_plus_l_spec`\n1015: - theorem: `Rcompare_mult_r_spec`\n1016: - theorem: `Rcompare_mult_l_spec`\n1017: - theorem: `Rle_bool_spec`\n1018: - theorem: `Rle_bool_true`\n1019: - theorem: `Rle_bool_false`\n1020: - theorem: `Rlt_bool_spec`\n1021: - theorem: `negb_Rlt_bool_spec`\n1022: - theorem: `negb_Rle_bool_spec`\n1023: - theorem: `Req_bool_spec`\n1024: - theorem: `eqb_sym_spec`\n1025: - theorem: `cond_Ropp_spec`\n1026: - theorem: `cond_Ropp_involutive_spec`\n1027: - theorem: `cond_Ropp_inj_spec`\n1028: \n1029: ### Mapping (Coq → Lean)\n1030: - `Rle_0_minus` → `Rle_0_minus_spec` (substring-name)\n1031: - `Rabs_eq_Rabs` → (no match)\n1032: - `Rabs_eq_Rabs` → `Rabs_eq_Rabs_spec` (substring-name)\n1033: - `Rabs_minus_le` → `Rabs_minus_le_spec` (substring-name)\n1034: - `Rabs_eq_R0` → `Rabs_eq_R0_spec` (substring-name)\n1035: - `Rmult_lt_compat` → `Rmult_lt_compat_spec` (substring-name)\n1036: - `Rmult_neq_reg_r` → `Rmult_neq_reg_r_spec` (substring-name)\n1037: - `Rmult_neq_compat_r` → `Rmult_neq_compat_r_spec` (substring-name)\n1038: - `Rmult_min_distr_r` → `Rmult_min_distr_r_spec` (substring-name)\n1039: - `Rmult_min_distr_l` → `Rmult_min_distr_l_spec` (substring-name)\n1040: - `Rmin_opp` → `Rmin_opp_spec` (substring-name)\n1041: - `Rmax_opp` → `Rmax_opp_spec` (substring-name)\n1042: - `exp_le` → `exp_le_spec` (substring-name)\n1043: - `Rinv_lt` → `Rinv_lt_spec` (substring-name)\n1044: - `Rinv_le` → `Rinv_le_spec` (substring-name)\n1045: - `sqrt_ge_0` → `sqrt_ge_0_spec` (substring-name)\n1046: - `sqrt_neg` → (no match)\n1047: - `Rsqr_le_abs_0_alt` → (no match)\n1048: - `Rabs_le_inv` → (no match)\n1049: - `Rabs_ge` → `Rabs_ge_spec` (substring-name)\n1050: - `Rabs_ge_inv` → `Rabs_ge_inv_spec` (substring-name)\n1051: - `Rabs_lt` → `Rabs_lt_spec` (substring-name)\n1052: - `Rabs_lt_inv` → (no match)\n1053: - `Rabs_gt` → `Rabs_gt_spec` (substring-name)\n1054: - `Rabs_gt_inv` → (no match)\n1055: - `IZR_le_lt` → (no match)\n1056: - `le_lt_IZR` → (no match)\n1057: - `neq_IZR` → (no match)\n1058: - `Rcompare_spec` → `Rcompare_spec` (exact-name)\n1059: - `Rcompare_Lt` → (no match)\n1060: - `Rcompare_Lt_inv` → (no match)\n1061: - `Rcompare_not_Lt` → (no match)\n1062: - `Rcompare_not_Lt_inv` → (no match)\n1063: - `Rcompare_Eq` → (no match)\n1064: - `Rcompare_Eq_inv` → (no match)\n1065: - `Rcompare_Gt` → (no match)\n1066: - `Rcompare_Gt_inv` → (no match)\n1067: - `Rcompare_not_Gt` → (no match)\n1068: - `Rcompare_not_Gt_inv` → (no match)\n1069: - `Rcompare_IZR` → (no match)\n1070: - `Rcompare_sym` → `Rcompare_sym_spec` (substring-name)\n1071: - `Rcompare_opp` → `Rcompare_opp_spec` (substring-name)\n1072: - `Rcompare_plus_r` → `Rcompare_plus_r_spec` (substring-name)\n1073: - `Rcompare_plus_l` → `Rcompare_plus_l_spec` (substring-name)\n1074: - `Rcompare_mult_r` → `Rcompare_mult_r_spec` (substring-name)\n1075: - `Rcompare_mult_l` → `Rcompare_mult_l_spec` (substring-name)\n1076: - `Rcompare_middle` → (no match)\n1077: - `Rcompare_half_l` → (no match)\n1078: - `Rcompare_half_r` → (no match)\n1079: - `Rcompare_sqr` → (no match)\n1080: - `Rmin_compare` → (no match)\n1081: - `Rle_bool_spec` → `Rle_bool_spec` (exact-name)\n1082: - `Rle_bool_true` → `Rle_bool_true` (exact-name)\n1083: - `Rle_bool_false` → `Rle_bool_false` (exact-name)\n1084: - `Rlt_bool_spec` → `Rlt_bool_spec` (exact-name)\n1085: - `negb_Rlt_bool` → `negb_Rlt_bool_spec` (substring-name)\n1086: - `negb_Rle_bool` → `negb_Rle_bool_spec` (substring-name)\n1087: - `Rlt_bool_true` → (no match)\n1088: - `Rlt_bool_false` → (no match)\n1089: - `Rlt_bool_opp` → (no match)\n1090: - `Req_bool_spec` → `Req_bool_spec` (exact-name)\n1091: - `Req_bool_true` → (no match)\n1092: - `Req_bool_false` → (no match)\n1093: - `Zfloor_lb` → (no match)\n1094: - `Zfloor_ub` → (no match)\n1095: - `Zfloor_lub` → (no match)\n1096: - `Zfloor_imp` → (no match)\n1097: - `Zfloor_IZR` → (no match)\n1098: - `Zfloor_le` → (no match)\n1099: - `Zceil_ub` → (no match)\n1100: - `Zceil_lb` → (no match)\n1101: - `Zceil_glb` → (no match)\n1102: - `Zceil_imp` → (no match)\n1103: - `Zceil_IZR` → (no match)\n1104: - `Zceil_le` → (no match)\n1105: - `Zceil_floor_neq` → (no match)\n1106: - `Ztrunc_IZR` → (no match)\n1107: - `Ztrunc_floor` → (no match)\n1108: - `Ztrunc_ceil` → (no match)\n1109: - `Ztrunc_le` → (no match)\n1110: - `Ztrunc_opp` → (no match)\n1111: - `Ztrunc_abs` → (no match)\n1112: - `Ztrunc_lub` → (no match)\n1113: - `Zaway_IZR` → (no match)\n1114: - `Zaway_ceil` → (no match)\n1115: - `Zaway_floor` → (no match)\n1116: - `Zaway_le` → (no match)\n1117: - `Zaway_opp` → (no match)\n1118: - `Zaway_abs` → (no match)\n1119: - `Rcompare_floor_ceil_middle` → (no match)\n1120: - `Rcompare_ceil_floor_middle` → (no match)\n1121: - `Zfloor_div` → (no match)\n1122: - `Ztrunc_div` → (no match)\n1123: - `radix_pos` → (no match)\n1124: - `IZR_Zpower_pos` → (no match)\n1125: - `bpow_powerRZ` → (no match)\n1126: - `bpow_ge_0` → (no match)\n1127: - `bpow_gt_0` → (no match)\n1128: - `bpow_plus` → (no match)\n1129: - `bpow_1` → (no match)\n1130: - `bpow_plus_1` → (no match)\n1131: - `bpow_opp` → (no match)\n1132: - `IZR_Zpower_nat` → (no match)\n1133: - `IZR_Zpower` → (no match)\n1134: - `bpow_lt` → (no match)\n1135: - `lt_bpow` → (no match)\n1136: - `bpow_le` → (no match)\n1137: - `le_bpow` → (no match)\n1138: - `bpow_inj` → (no match)\n1139: - `bpow_exp` → (no match)\n1140: - `sqrt_bpow` → (no match)\n1141: - `sqrt_bpow_ge` → (no match)\n1142: - `bpow_lt_bpow` → (no match)\n1143: - `bpow_unique` → (no match)\n1144: - `mag_unique` → (no match)\n1145: - `mag_opp` → (no match)\n1146: - `mag_abs` → (no match)\n1147: - `mag_unique_pos` → (no match)\n1148: - `mag_le_abs` → (no match)\n1149: - `mag_le` → (no match)\n1150: - `lt_mag` → (no match)\n1151: - `mag_bpow` → (no match)\n1152: - `mag_mult_bpow` → (no match)\n1153: - `mag_le_bpow` → (no match)\n1154: - `mag_gt_bpow` → (no match)\n1155: - `mag_ge_bpow` → (no match)\n1156: - `bpow_mag_gt` → (no match)\n1157: - `bpow_mag_le` → (no match)\n1158: - `mag_le_Zpower` → (no match)\n1159: - `mag_gt_Zpower` → (no match)\n1160: - `mag_mult` → (no match)\n1161: - `mag_plus` → (no match)\n1162: - `mag_minus` → (no match)\n1163: - `mag_minus_lb` → (no match)\n1164: - `mag_plus_ge` → (no match)\n1165: - `mag_div` → (no match)\n1166: - `mag_sqrt` → (no match)\n1167: - `mag_1` → (no match)\n1168: - `eqb_sym` → `eqb_sym_spec` (substring-name)\n1169: - `eqb_false` → (no match)\n1170: - `eqb_true` → (no match)\n1171: - `IZR_cond_Zopp` → (no match)\n1172: - `abs_cond_Ropp` → (no match)\n1173: - `cond_Ropp_Rlt_bool` → (no match)\n1174: - `Rlt_bool_cond_Ropp` → (no match)\n1175: - `cond_Ropp_involutive` → `cond_Ropp_involutive_spec` (substring-name)\n1176: - `cond_Ropp_inj` → `cond_Ropp_inj_spec` (substring-name)\n1177: - `cond_Ropp_mult_l` → (no match)\n1178: - `cond_Ropp_mult_r` → (no match)\n1179: - `cond_Ropp_plus` → (no match)\n1180: - `LPO_min` → (no match)\n1181: - `LPO` → (no match)\n1182: - `LPO_Z` → (no match)\n1183: \n1184: ## File: Round_NE.v\n1185: - Coq file: Round_NE.v\n1186: - Lean file(s): Round_NE.lean\n1187: \n1188: ### Coq Declarations\n1189: - Lemma: `DN_UP_parity_aux`\n1190: - Theorem: `DN_UP_parity_generic_pos`\n1191: - Theorem: `DN_UP_parity_generic`\n1192: - Theorem: `Rnd_NE_pt_total`\n1193: - Theorem: `Rnd_NE_pt_monotone`\n1194: - Theorem: `Rnd_NE_pt_round`\n1195: - Lemma: `round_NE_pt_pos`\n1196: - Theorem: `round_NE_opp`\n1197: - Lemma: `round_NE_abs`\n1198: - Theorem: `round_NE_pt`\n1199: \n1200: ### Lean Declarations\n1201: - theorem: `DN_UP_parity_aux`\n1202: - theorem: `DN_UP_parity_generic_pos`\n1203: - theorem: `DN_UP_parity_generic`\n1204: - theorem: `Rnd_NE_pt_unique_prop`\n1205: - theorem: `Rnd_NE_pt_unique`\n1206: - theorem: `Rnd_NE_pt_monotone`\n1207: - theorem: `Rnd_NE_pt_total`\n1208: - theorem: `Rnd_NE_pt_round`\n1209: - theorem: `satisfies_any_imp_NE`\n1210: - theorem: `Rnd_NE_pt_refl`\n1211: - theorem: `Rnd_NE_pt_idempotent`\n1212: - theorem: `DN_UP_parity_pos_holds`\n1213: - theorem: `Rnd_NE_pt_sign`\n1214: - theorem: `Rnd_NE_pt_abs`\n1215: - theorem: `round_NE_pt_pos`\n1216: - theorem: `round_NE_opp`\n1217: - theorem: `round_NE_abs`\n1218: - theorem: `round_NE_pt`\n1219: - theorem: `Rnd_NE_pt_error_bound`\n1220: - theorem: `Rnd_NE_pt_minimal_error`\n1221: \n1222: ### Mapping (Coq → Lean)\n1223: - `DN_UP_parity_aux` → `DN_UP_parity_aux` (exact-name)\n1224: - `DN_UP_parity_generic_pos` → `DN_UP_parity_generic_pos` (exact-name)\n1225: - `DN_UP_parity_generic` → `DN_UP_parity_generic` (exact-name)\n1226: - `Rnd_NE_pt_total` → `Rnd_NE_pt_total` (exact-name)\n1227: - `Rnd_NE_pt_monotone` → `Rnd_NE_pt_monotone` (exact-name)\n1228: - `Rnd_NE_pt_round` → `Rnd_NE_pt_round` (exact-name)\n1229: - `round_NE_pt_pos` → `round_NE_pt_pos` (exact-name)\n1230: - `round_NE_opp` → `round_NE_opp` (exact-name)\n1231: - `round_NE_abs` → `round_NE_abs` (exact-name)\n1232: - `round_NE_pt` → `round_NE_pt` (exact-name)\n1233: \n1234: ## File: Round_pred.v\n1235: - Coq file: Round_pred.v\n1236: - Lean file(s): Round_pred.lean\n1237: \n1238: ### Coq Declarations\n1239: - Theorem: `round_val_of_pred`\n1240: - Theorem: `round_fun_of_pred`\n1241: - Theorem: `round_unique`\n1242: - Theorem: `Rnd_DN_pt_monotone`\n1243: - Theorem: `Rnd_DN_pt_unique`\n1244: - Theorem: `Rnd_DN_unique`\n1245: - Theorem: `Rnd_UP_pt_monotone`\n1246: - Theorem: `Rnd_UP_pt_unique`\n1247: - Theorem: `Rnd_UP_unique`\n1248: - Theorem: `Rnd_UP_pt_opp`\n1249: - Theorem: `Rnd_DN_pt_opp`\n1250: - Theorem: `Rnd_DN_opp`\n1251: - Theorem: `Rnd_DN_UP_pt_split`\n1252: - Theorem: `Rnd_DN_pt_refl`\n1253: - Theorem: `Rnd_DN_pt_idempotent`\n1254: - Theorem: `Rnd_UP_pt_refl`\n1255: - Theorem: `Rnd_UP_pt_idempotent`\n1256: - Theorem: `Only_DN_or_UP`\n1257: - Theorem: `Rnd_ZR_abs`\n1258: - Theorem: `Rnd_ZR_pt_monotone`\n1259: - Theorem: `Rnd_N_pt_DN_or_UP`\n1260: - Theorem: `Rnd_N_pt_DN_or_UP_eq`\n1261: - Theorem: `Rnd_N_pt_opp_inv`\n1262: - Theorem: `Rnd_N_pt_monotone`\n1263: - Theorem: `Rnd_N_pt_unique`\n1264: - Theorem: `Rnd_N_pt_refl`\n1265: - Theorem: `Rnd_N_pt_idempotent`\n1266: - Theorem: `Rnd_N_pt_0`\n1267: - Theorem: `Rnd_N_pt_ge_0`\n1268: - Theorem: `Rnd_N_pt_le_0`\n1269: - Theorem: `Rnd_N_pt_abs`\n1270: - Theorem: `Rnd_N_pt_DN_UP`\n1271: - Theorem: `Rnd_N_pt_DN`\n1272: - Theorem: `Rnd_N_pt_UP`\n1273: - Theorem: `Rnd_NG_pt_unique`\n1274: - Theorem: `Rnd_NG_pt_monotone`\n1275: - Theorem: `Rnd_NG_pt_refl`\n1276: - Theorem: `Rnd_NG_pt_opp_inv`\n1277: - Theorem: `Rnd_NG_unique`\n1278: - Theorem: `Rnd_NA_NG_pt`\n1279: - Lemma: `Rnd_NA_pt_unique_prop`\n1280: - Theorem: `Rnd_NA_pt_unique`\n1281: - Theorem: `Rnd_NA_pt_N`\n1282: - Theorem: `Rnd_NA_unique`\n1283: - Theorem: `Rnd_NA_pt_monotone`\n1284: - Theorem: `Rnd_NA_pt_refl`\n1285: - Theorem: `Rnd_NA_pt_idempotent`\n1286: - Theorem: `Rnd_N0_NG_pt`\n1287: - Lemma: `Rnd_N0_pt_unique_prop`\n1288: - Theorem: `Rnd_N0_pt_unique`\n1289: - Theorem: `Rnd_N0_pt_N`\n1290: - Theorem: `Rnd_N0_unique`\n1291: - Theorem: `Rnd_N0_pt_monotone`\n1292: - Theorem: `Rnd_N0_pt_refl`\n1293: - Theorem: `Rnd_N0_pt_idempotent`\n1294: - Theorem: `round_pred_ge_0`\n1295: - Theorem: `round_pred_gt_0`\n1296: - Theorem: `round_pred_le_0`\n1297: - Theorem: `round_pred_lt_0`\n1298: - Theorem: `Rnd_DN_pt_equiv_format`\n1299: - Theorem: `Rnd_UP_pt_equiv_format`\n1300: - Theorem: `satisfies_any_eq`\n1301: - Theorem: `satisfies_any_imp_DN`\n1302: - Theorem: `satisfies_any_imp_UP`\n1303: - Theorem: `satisfies_any_imp_ZR`\n1304: - Theorem: `satisfies_any_imp_NG`\n1305: - Theorem: `satisfies_any_imp_NA`\n1306: - Theorem: `satisfies_any_imp_N0`\n1307: \n1308: ### Lean Declarations\n1309: - theorem: `Rnd_DN_spec`\n1310: - theorem: `Rnd_UP_spec`\n1311: - theorem: `Rnd_ZR_spec`\n1312: - theorem: `Rnd_N_spec`\n1313: - theorem: `Rnd_NG_spec`\n1314: - theorem: `Rnd_NA_spec`\n1315: - theorem: `Rnd_N0_spec`\n1316: - theorem: `round_val_of_pred_spec`\n1317: - theorem: `round_fun_of_pred_spec`\n1318: - theorem: `round_unique_spec`\n1319: - theorem: `Rnd_DN_pt_monotone_spec`\n1320: - theorem: `Rnd_DN_pt_unique_spec`\n1321: - theorem: `Rnd_DN_unique_spec`\n1322: - theorem: `Rnd_UP_pt_monotone_spec`\n1323: - theorem: `Rnd_UP_pt_unique_spec`\n1324: - theorem: `Rnd_UP_unique_spec`\n1325: - theorem: `Rnd_UP_pt_opp_spec`\n1326: - theorem: `Rnd_DN_pt_opp_spec`\n1327: - theorem: `Rnd_DN_pt_refl_spec`\n1328: - theorem: `Rnd_DN_pt_idempotent_spec`\n1329: - theorem: `Rnd_UP_pt_refl_spec`\n1330: - theorem: `Rnd_UP_pt_idempotent_spec`\n1331: - theorem: `Rnd_ZR_abs_spec`\n1332: \n1333: ### Mapping (Coq → Lean)\n1334: - `round_val_of_pred` → `round_val_of_pred_spec` (substring-name)\n1335: - `round_fun_of_pred` → `round_fun_of_pred_spec` (substring-name)\n1336: - `round_unique` → `round_unique_spec` (substring-name)\n1337: - `Rnd_DN_pt_monotone` → `Rnd_DN_pt_monotone_spec` (substring-name)\n1338: - `Rnd_DN_pt_unique` → `Rnd_DN_pt_unique_spec` (substring-name)\n1339: - `Rnd_DN_unique` → `Rnd_DN_unique_spec` (substring-name)\n1340: - `Rnd_UP_pt_monotone` → `Rnd_UP_pt_monotone_spec` (substring-name)\n1341: - `Rnd_UP_pt_unique` → `Rnd_UP_pt_unique_spec` (substring-name)\n1342: - `Rnd_UP_unique` → `Rnd_UP_unique_spec` (substring-name)\n1343: - `Rnd_UP_pt_opp` → `Rnd_UP_pt_opp_spec` (substring-name)\n1344: - `Rnd_DN_pt_opp` → `Rnd_DN_pt_opp_spec` (substring-name)\n1345: - `Rnd_DN_opp` → (no match)\n1346: - `Rnd_DN_UP_pt_split` → (no match)\n1347: - `Rnd_DN_pt_refl` → `Rnd_DN_pt_refl_spec` (substring-name)\n1348: - `Rnd_DN_pt_idempotent` → `Rnd_DN_pt_idempotent_spec` (substring-name)\n1349: - `Rnd_UP_pt_refl` → `Rnd_UP_pt_refl_spec` (substring-name)\n1350: - `Rnd_UP_pt_idempotent` → `Rnd_UP_pt_idempotent_spec` (substring-name)\n1351: - `Only_DN_or_UP` → (no match)\n1352: - `Rnd_ZR_abs` → `Rnd_ZR_abs_spec` (substring-name)\n1353: - `Rnd_ZR_pt_monotone` → (no match)\n1354: - `Rnd_N_pt_DN_or_UP` → (no match)\n1355: - `Rnd_N_pt_DN_or_UP_eq` → (no match)\n1356: - `Rnd_N_pt_opp_inv` → (no match)\n1357: - `Rnd_N_pt_monotone` → (no match)\n1358: - `Rnd_N_pt_unique` → (no match)\n1359: - `Rnd_N_pt_refl` → (no match)\n1360: - `Rnd_N_pt_idempotent` → (no match)\n1361: - `Rnd_N_pt_0` → (no match)\n1362: - `Rnd_N_pt_ge_0` → (no match)\n1363: - `Rnd_N_pt_le_0` → (no match)\n1364: - `Rnd_N_pt_abs` → (no match)\n1365: - `Rnd_N_pt_DN_UP` → (no match)\n1366: - `Rnd_N_pt_DN` → (no match)\n1367: - `Rnd_N_pt_UP` → (no match)\n1368: - `Rnd_NG_pt_unique` → (no match)\n1369: - `Rnd_NG_pt_monotone` → (no match)\n1370: - `Rnd_NG_pt_refl` → (no match)\n1371: - `Rnd_NG_pt_opp_inv` → (no match)\n1372: - `Rnd_NG_unique` → (no match)\n1373: - `Rnd_NA_NG_pt` → (no match)\n1374: - `Rnd_NA_pt_unique_prop` → (no match)\n1375: - `Rnd_NA_pt_unique` → (no match)\n1376: - `Rnd_NA_pt_N` → (no match)\n1377: - `Rnd_NA_unique` → (no match)\n1378: - `Rnd_NA_pt_monotone` → (no match)\n1379: - `Rnd_NA_pt_refl` → (no match)\n1380: - `Rnd_NA_pt_idempotent` → (no match)\n1381: - `Rnd_N0_NG_pt` → (no match)\n1382: - `Rnd_N0_pt_unique_prop` → (no match)\n1383: - `Rnd_N0_pt_unique` → (no match)\n1384: - `Rnd_N0_pt_N` → (no match)\n1385: - `Rnd_N0_unique` → (no match)\n1386: - `Rnd_N0_pt_monotone` → (no match)\n1387: - `Rnd_N0_pt_refl` → (no match)\n1388: - `Rnd_N0_pt_idempotent` → (no match)\n1389: - `round_pred_ge_0` → (no match)\n1390: - `round_pred_gt_0` → (no match)\n1391: - `round_pred_le_0` → (no match)\n1392: - `round_pred_lt_0` → (no match)\n1393: - `Rnd_DN_pt_equiv_format` → (no match)\n1394: - `Rnd_UP_pt_equiv_format` → (no match)\n1395: - `satisfies_any_eq` → (no match)\n1396: - `satisfies_any_imp_DN` → (no match)\n1397: - `satisfies_any_imp_UP` → (no match)\n1398: - `satisfies_any_imp_ZR` → (no match)\n1399: - `satisfies_any_imp_NG` → (no match)\n1400: - `satisfies_any_imp_NA` → (no match)\n1401: - `satisfies_any_imp_N0` → (no match)\n1402: \n1403: ## File: Ulp.v\n1404: - Coq file: Ulp.v\n1405: - Lean file(s): Ulp.lean\n1406: \n1407: ### Coq Declarations\n1408: - Lemma: `Z_le_dec_aux`\n1409: - Lemma: `negligible_exp_spec`\n1410: - Lemma: `negligible_exp_spec'`\n1411: - Lemma: `fexp_negligible_exp_eq`\n1412: - Lemma: `ulp_neq_0`\n1413: - Theorem: `ulp_opp`\n1414: - Theorem: `ulp_abs`\n1415: - Theorem: `ulp_ge_0`\n1416: - Theorem: `ulp_le_id`\n1417: - Theorem: `ulp_le_abs`\n1418: - Theorem: `round_UP_DN_ulp`\n1419: - Theorem: `ulp_canonical`\n1420: - Theorem: `ulp_bpow`\n1421: - Lemma: `generic_format_ulp_0`\n1422: - Lemma: `generic_format_bpow_ge_ulp_0`\n1423: - Lemma: `generic_format_ulp`\n1424: - Lemma: `not_FTZ_generic_format_ulp`\n1425: - Lemma: `ulp_ge_ulp_0`\n1426: - Lemma: `not_FTZ_ulp_ge_ulp_0`\n1427: - Lemma: `ulp_le_pos`\n1428: - Theorem: `ulp_le`\n1429: - Theorem: `eq_0_round_0_negligible_exp`\n1430: - Theorem: `pred_eq_pos`\n1431: - Theorem: `succ_eq_pos`\n1432: - Theorem: `succ_opp`\n1433: - Theorem: `pred_opp`\n1434: - Theorem: `pred_bpow`\n1435: - Theorem: `id_m_ulp_ge_bpow`\n1436: - Theorem: `id_p_ulp_le_bpow`\n1437: - Lemma: `generic_format_pred_aux1`\n1438: - Lemma: `generic_format_pred_aux2`\n1439: - Lemma: `generic_format_succ_aux1`\n1440: - Lemma: `generic_format_pred_pos`\n1441: - Theorem: `generic_format_succ`\n1442: - Theorem: `generic_format_pred`\n1443: - Lemma: `pred_pos_lt_id`\n1444: - Theorem: `succ_gt_id`\n1445: - Theorem: `pred_lt_id`\n1446: - Theorem: `succ_ge_id`\n1447: - Theorem: `pred_le_id`\n1448: - Lemma: `pred_pos_ge_0`\n1449: - Theorem: `pred_ge_0`\n1450: - Lemma: `pred_pos_plus_ulp_aux1`\n1451: - Lemma: `pred_pos_plus_ulp_aux2`\n1452: - Lemma: `pred_pos_plus_ulp_aux3`\n1453: - Lemma: `pred_pos_plus_ulp`\n1454: - Theorem: `pred_plus_ulp`\n1455: - Theorem: `mag_plus_eps`\n1456: - Theorem: `round_DN_plus_eps_pos`\n1457: - Theorem: `round_UP_plus_eps_pos`\n1458: - Theorem: `round_UP_pred_plus_eps_pos`\n1459: - Theorem: `round_DN_minus_eps_pos`\n1460: - Theorem: `round_DN_plus_eps`\n1461: - Theorem: `round_UP_plus_eps`\n1462: - Lemma: `le_pred_pos_lt`\n1463: - Lemma: `succ_le_lt_aux`\n1464: - Theorem: `succ_le_lt`\n1465: - Theorem: `pred_ge_gt`\n1466: - Theorem: `succ_gt_ge`\n1467: - Theorem: `pred_lt_le`\n1468: - Lemma: `succ_pred_pos`\n1469: - Theorem: `pred_ulp_0`\n1470: - Theorem: `succ_0`\n1471: - Theorem: `pred_0`\n1472: - Lemma: `pred_succ_pos`\n1473: - Theorem: `succ_pred`\n1474: - Theorem: `pred_succ`\n1475: - Theorem: `round_UP_pred_plus_eps`\n1476: - Theorem: `round_DN_minus_eps`\n1477: - Theorem: `error_lt_ulp`\n1478: - Theorem: `error_le_ulp`\n1479: - Theorem: `error_le_half_ulp`\n1480: - Theorem: `ulp_DN`\n1481: - Theorem: `round_neq_0_negligible_exp`\n1482: - Theorem: `error_lt_ulp_round`\n1483: - Lemma: `error_le_ulp_round`\n1484: - Theorem: `error_le_half_ulp_round`\n1485: - Theorem: `pred_le`\n1486: - Theorem: `succ_le`\n1487: - Theorem: `pred_le_inv`\n1488: - Theorem: `succ_le_inv`\n1489: - Theorem: `pred_lt`\n1490: - Theorem: `succ_lt`\n1491: - Lemma: `succ_le_plus_ulp`\n1492: - Lemma: `generic_format_plus_ulp`\n1493: - Theorem: `round_DN_ge_UP_gt`\n1494: - Theorem: `round_UP_le_DN_lt`\n1495: - Theorem: `pred_UP_le_DN`\n1496: - Theorem: `UP_le_succ_DN`\n1497: - Theorem: `pred_UP_eq_DN`\n1498: - Theorem: `succ_DN_eq_UP`\n1499: - Theorem: `round_DN_eq`\n1500: - Theorem: `round_UP_eq`\n1501: - Lemma: `ulp_ulp_0`\n1502: - Lemma: `ulp_succ_pos`\n1503: - Theorem: `ulp_pred_pos`\n1504: - Lemma: `ulp_round_pos`\n1505: - Theorem: `ulp_round`\n1506: - Lemma: `succ_round_ge_id`\n1507: - Lemma: `pred_round_le_id`\n1508: - Theorem: `round_N_le_midp`\n1509: - Theorem: `round_N_ge_midp`\n1510: - Lemma: `round_N_ge_ge_midp`\n1511: - Lemma: `round_N_le_le_midp`\n1512: - Lemma: `round_N_eq_DN`\n1513: - Lemma: `round_N_eq_DN_pt`\n1514: - Lemma: `round_N_eq_UP`\n1515: - Lemma: `round_N_eq_UP_pt`\n1516: - Lemma: `round_N_plus_ulp_ge`\n1517: - Lemma: `round_N_eq_ties`\n1518: \n1519: ### Lean Declarations\n1520: - theorem: `ulp_neq_0`\n1521: - theorem: `ulp_opp`\n1522: - theorem: `ulp_abs`\n1523: - theorem: `ulp_ge_0`\n1524: - theorem: `ulp_le_id`\n1525: - theorem: `ulp_le_abs`\n1526: - theorem: `ulp_bpow`\n1527: - theorem: `generic_format_ulp_0`\n1528: - theorem: `generic_format_bpow_ge_ulp_0`\n1529: \n1530: ### Mapping (Coq → Lean)\n1531: - `Z_le_dec_aux` → (no match)\n1532: - `negligible_exp_spec` → (no match)\n1533: - `negligible_exp_spec'` → (no match)\n1534: - `fexp_negligible_exp_eq` → (no match)\n1535: - `ulp_neq_0` → `ulp_neq_0` (exact-name)\n1536: - `ulp_opp` → `ulp_opp` (exact-name)\n1537: - `ulp_abs` → `ulp_abs` (exact-name)\n1538: - `ulp_ge_0` → `ulp_ge_0` (exact-name)\n1539: - `ulp_le_id` → `ulp_le_id` (exact-name)\n1540: - `ulp_le_abs` → `ulp_le_abs` (exact-name)\n1541: - `round_UP_DN_ulp` → (no match)\n1542: - `ulp_canonical` → (no match)\n1543: - `ulp_bpow` → `ulp_bpow` (exact-name)\n1544: - `generic_format_ulp_0` → `generic_format_ulp_0` (exact-name)\n1545: - `generic_format_bpow_ge_ulp_0` → `generic_format_bpow_ge_ulp_0` (exact-name)\n1546: - `generic_format_ulp` → `generic_format_ulp_0` (substring-name)\n1547: - `not_FTZ_generic_format_ulp` → (no match)\n1548: - `ulp_ge_ulp_0` → (no match)\n1549: - `not_FTZ_ulp_ge_ulp_0` → (no match)\n1550: - `ulp_le_pos` → (no match)\n1551: - `ulp_le` → `ulp_le_id` (substring-name)\n1552: - `eq_0_round_0_negligible_exp` → (no match)\n1553: - `pred_eq_pos` → (no match)\n1554: - `succ_eq_pos` → (no match)\n1555: - `succ_opp` → (no match)\n1556: - `pred_opp` → (no match)\n1557: - `pred_bpow` → (no match)\n1558: - `id_m_ulp_ge_bpow` → (no match)\n1559: - `id_p_ulp_le_bpow` → (no match)\n1560: - `generic_format_pred_aux1` → (no match)\n1561: - `generic_format_pred_aux2` → (no match)\n1562: - `generic_format_succ_aux1` → (no match)\n1563: - `generic_format_pred_pos` → (no match)\n1564: - `generic_format_succ` → (no match)\n1565: - `generic_format_pred` → (no match)\n1566: - `pred_pos_lt_id` → (no match)\n1567: - `succ_gt_id` → (no match)\n1568: - `pred_lt_id` → (no match)\n1569: - `succ_ge_id` → (no match)\n1570: - `pred_le_id` → (no match)\n1571: - `pred_pos_ge_0` → (no match)\n1572: - `pred_ge_0` → (no match)\n1573: - `pred_pos_plus_ulp_aux1` → (no match)\n1574: - `pred_pos_plus_ulp_aux2` → (no match)\n1575: - `pred_pos_plus_ulp_aux3` → (no match)\n1576: - `pred_pos_plus_ulp` → (no match)\n1577: - `pred_plus_ulp` → (no match)\n1578: - `mag_plus_eps` → (no match)\n1579: - `round_DN_plus_eps_pos` → (no match)\n1580: - `round_UP_plus_eps_pos` → (no match)\n1581: - `round_UP_pred_plus_eps_pos` → (no match)\n1582: - `round_DN_minus_eps_pos` → (no match)\n1583: - `round_DN_plus_eps` → (no match)\n1584: - `round_UP_plus_eps` → (no match)\n1585: - `le_pred_pos_lt` → (no match)\n1586: - `succ_le_lt_aux` → (no match)\n1587: - `succ_le_lt` → (no match)\n1588: - `pred_ge_gt` → (no match)\n1589: - `succ_gt_ge` → (no match)\n1590: - `pred_lt_le` → (no match)\n1591: - `succ_pred_pos` → (no match)\n1592: - `pred_ulp_0` → (no match)\n1593: - `succ_0` → (no match)\n1594: - `pred_0` → (no match)\n1595: - `pred_succ_pos` → (no match)\n1596: - `succ_pred` → (no match)\n1597: - `pred_succ` → (no match)\n1598: - `round_UP_pred_plus_eps` → (no match)\n1599: - `round_DN_minus_eps` → (no match)\n1600: - `error_lt_ulp` → (no match)\n1601: - `error_le_ulp` → (no match)\n1602: - `error_le_half_ulp` → (no match)\n1603: - `ulp_DN` → (no match)\n1604: - `round_neq_0_negligible_exp` → (no match)\n1605: - `error_lt_ulp_round` → (no match)\n1606: - `error_le_ulp_round` → (no match)\n1607: - `error_le_half_ulp_round` → (no match)\n1608: - `pred_le` → (no match)\n1609: - `succ_le` → (no match)\n1610: - `pred_le_inv` → (no match)\n1611: - `succ_le_inv` → (no match)\n1612: - `pred_lt` → (no match)\n1613: - `succ_lt` → (no match)\n1614: - `succ_le_plus_ulp` → (no match)\n1615: - `generic_format_plus_ulp` → (no match)\n1616: - `round_DN_ge_UP_gt` → (no match)\n1617: - `round_UP_le_DN_lt` → (no match)\n1618: - `pred_UP_le_DN` → (no match)\n1619: - `UP_le_succ_DN` → (no match)\n1620: - `pred_UP_eq_DN` → (no match)\n1621: - `succ_DN_eq_UP` → (no match)\n1622: - `round_DN_eq` → (no match)\n1623: - `round_UP_eq` → (no match)\n1624: - `ulp_ulp_0` → (no match)\n1625: - `ulp_succ_pos` → (no match)\n1626: - `ulp_pred_pos` → (no match)\n1627: - `ulp_round_pos` → (no match)\n1628: - `ulp_round` → (no match)\n1629: - `succ_round_ge_id` → (no match)\n1630: - `pred_round_le_id` → (no match)\n1631: - `round_N_le_midp` → (no match)\n1632: - `round_N_ge_midp` → (no match)\n1633: - `round_N_ge_ge_midp` → (no match)\n1634: - `round_N_le_le_midp` → (no match)\n1635: - `round_N_eq_DN` → (no match)\n1636: - `round_N_eq_DN_pt` → (no match)\n1637: - `round_N_eq_UP` → (no match)\n1638: - `round_N_eq_UP_pt` → (no match)\n1639: - `round_N_plus_ulp_ge` → (no match)\n1640: - `round_N_eq_ties` → (no match)\n1641: \n1642: ## File: Zaux.v\n1643: - Coq file: Zaux.v\n1644: - Lean file(s): Zaux.lean\n1645: \n1646: ### Coq Declarations\n1647: - Theorem: `Zopp_le_cancel`\n1648: - Theorem: `Zgt_not_eq`\n1649: - Lemma: `eqbool_irrelevance`\n1650: - Theorem: `Zeven_ex`\n1651: - Theorem: `Zpower_plus`\n1652: - Theorem: `Zpower_Zpower_nat`\n1653: - Theorem: `Zpower_nat_S`\n1654: - Theorem: `Zpower_pos_gt_0`\n1655: - Theorem: `Zeven_Zpower_odd`\n1656: - Theorem: `radix_val_inj`\n1657: - Theorem: `radix_gt_0`\n1658: - Theorem: `radix_gt_1`\n1659: - Theorem: `Zpower_gt_1`\n1660: - Theorem: `Zpower_gt_0`\n1661: - Theorem: `Zpower_ge_0`\n1662: - Theorem: `Zpower_le`\n1663: - Theorem: `Zpower_lt`\n1664: - Theorem: `Zpower_lt_Zpower`\n1665: - Theorem: `Zpower_gt_id`\n1666: - Theorem: `Zmod_mod_mult`\n1667: - Theorem: `ZOmod_eq`\n1668: - Theorem: `ZOmod_mod_mult`\n1669: - Theorem: `Zdiv_mod_mult`\n1670: - Theorem: `ZOdiv_mod_mult`\n1671: - Theorem: `ZOdiv_small_abs`\n1672: - Theorem: `ZOmod_small_abs`\n1673: - Theorem: `ZOdiv_plus`\n1674: - Theorem: `Zsame_sign_trans`\n1675: - Theorem: `Zsame_sign_trans_weak`\n1676: - Theorem: `Zsame_sign_imp`\n1677: - Theorem: `Zsame_sign_odiv`\n1678: - Theorem: `Zeq_bool_spec`\n1679: - Theorem: `Zeq_bool_true`\n1680: - Theorem: `Zeq_bool_false`\n1681: - Theorem: `Zeq_bool_diag`\n1682: - Theorem: `Zeq_bool_opp`\n1683: - Theorem: `Zeq_bool_opp'`\n1684: - Theorem: `Zle_bool_spec`\n1685: - Theorem: `Zle_bool_true`\n1686: - Theorem: `Zle_bool_false`\n1687: - Theorem: `Zle_bool_opp_l`\n1688: - Theorem: `Zle_bool_opp`\n1689: - Theorem: `Zle_bool_opp_r`\n1690: - Theorem: `Zlt_bool_spec`\n1691: - Theorem: `Zlt_bool_true`\n1692: - Theorem: `Zlt_bool_false`\n1693: - Theorem: `negb_Zle_bool`\n1694: - Theorem: `negb_Zlt_bool`\n1695: - Theorem: `Zlt_bool_opp_l`\n1696: - Theorem: `Zlt_bool_opp_r`\n1697: - Theorem: `Zlt_bool_opp`\n1698: - Theorem: `Zcompare_spec`\n1699: - Theorem: `Zcompare_Lt`\n1700: - Theorem: `Zcompare_Eq`\n1701: - Theorem: `Zcompare_Gt`\n1702: - Theorem: `cond_Zopp_0`\n1703: - Theorem: `cond_Zopp_negb`\n1704: - Theorem: `abs_cond_Zopp`\n1705: - Theorem: `cond_Zopp_Zlt_bool`\n1706: - Theorem: `Zeq_bool_cond_Zopp`\n1707: - Theorem: `Zfast_pow_pos_correct`\n1708: - Lemma: `Zdiv_eucl_unique`\n1709: - Lemma: `Zpos_div_eucl_aux1_correct`\n1710: - Lemma: `Zpos_div_eucl_aux_correct`\n1711: - Theorem: `Zfast_div_eucl_correct`\n1712: - Lemma: `iter_nat_plus`\n1713: - Lemma: `iter_nat_S`\n1714: - Lemma: `iter_pos_nat`\n1715: \n1716: ### Lean Declarations\n1717: - theorem: `Zopp_le_cancel_spec`\n1718: - theorem: `Zgt_not_eq_spec`\n1719: - theorem: `eqbool_irrelevance_spec`\n1720: - theorem: `Zeven_ex_spec`\n1721: - theorem: `Zpower_plus_spec`\n1722: - theorem: `Zpower_Zpower_nat_spec`\n1723: - theorem: `Zpower_nat_S_spec`\n1724: - theorem: `Zmod_mod_mult_spec`\n1725: - theorem: `ZOmod_eq_spec`\n1726: - theorem: `Zdiv_mod_mult_spec`\n1727: - theorem: `ZOmod_mod_mult_spec`\n1728: - theorem: `ZOdiv_plus_spec`\n1729: - theorem: `Zeq_bool_spec`\n1730: - theorem: `Zle_bool_spec`\n1731: - theorem: `Zlt_bool_spec`\n1732: - theorem: `Zeq_bool_true_spec`\n1733: - theorem: `Zeq_bool_false_spec`\n1734: - theorem: `Zeq_bool_diag_spec`\n1735: - theorem: `Zeq_bool_opp_spec`\n1736: - theorem: `Zeq_bool_opp`\n1737: - theorem: `Zle_bool_true_spec`\n1738: - theorem: `Zle_bool_false_spec`\n1739: - theorem: `Zle_bool_opp_l_spec`\n1740: - theorem: `Zle_bool_opp_spec`\n1741: - theorem: `Zle_bool_opp_r_spec`\n1742: - theorem: `negb_Zle_bool_spec`\n1743: - theorem: `negb_Zlt_bool_spec`\n1744: - theorem: `Zlt_bool_true_spec`\n1745: - theorem: `Zlt_bool_false_spec`\n1746: - theorem: `Zlt_bool_opp_l_spec`\n1747: - theorem: `Zlt_bool_opp_r_spec`\n1748: - theorem: `Zlt_bool_opp_spec`\n1749: - theorem: `Zcompare_spec`\n1750: - theorem: `Zcompare_Lt_spec`\n1751: - theorem: `Zcompare_Eq_spec`\n1752: - theorem: `Zcompare_Gt_spec`\n1753: - theorem: `cond_Zopp_spec`\n1754: - theorem: `cond_Zopp_0_spec`\n1755: - theorem: `cond_Zopp_negb_spec`\n1756: - theorem: `abs_cond_Zopp_spec`\n1757: - theorem: `cond_Zopp_Zlt_bool_spec`\n1758: - theorem: `Zeq_bool_cond_Zopp_spec`\n1759: - theorem: `Zfast_pow_pos_spec`\n1760: - theorem: `Zfast_div_eucl_spec`\n1761: - theorem: `iter_nat_spec`\n1762: - theorem: `iter_nat_S_spec`\n1763: - theorem: `iter_nat_plus_spec`\n1764: - theorem: `iter_pos_nat_spec`\n1765: \n1766: ### Mapping (Coq → Lean)\n1767: - `Zopp_le_cancel` → `Zopp_le_cancel_spec` (substring-name)\n1768: - `Zgt_not_eq` → `Zgt_not_eq_spec` (substring-name)\n1769: - `eqbool_irrelevance` → `eqbool_irrelevance_spec` (substring-name)\n1770: - `Zeven_ex` → `Zeven_ex_spec` (substring-name)\n1771: - `Zpower_plus` → `Zpower_plus_spec` (substring-name)\n1772: - `Zpower_Zpower_nat` → `Zpower_Zpower_nat_spec` (substring-name)\n1773: - `Zpower_nat_S` → `Zpower_Zpower_nat_spec` (substring-name)\n1774: - `Zpower_pos_gt_0` → (no match)\n1775: - `Zeven_Zpower_odd` → (no match)\n1776: - `radix_val_inj` → (no match)\n1777: - `radix_gt_0` → (no match)\n1778: - `radix_gt_1` → (no match)\n1779: - `Zpower_gt_1` → (no match)\n1780: - `Zpower_gt_0` → (no match)\n1781: - `Zpower_ge_0` → (no match)\n1782: - `Zpower_le` → (no match)\n1783: - `Zpower_lt` → (no match)\n1784: - `Zpower_lt_Zpower` → (no match)\n1785: - `Zpower_gt_id` → (no match)\n1786: - `Zmod_mod_mult` → `Zmod_mod_mult_spec` (substring-name)\n1787: - `ZOmod_eq` → `ZOmod_eq_spec` (substring-name)\n1788: - `ZOmod_mod_mult` → `ZOmod_mod_mult_spec` (substring-name)\n1789: - `Zdiv_mod_mult` → `Zdiv_mod_mult_spec` (substring-name)\n1790: - `ZOdiv_mod_mult` → (no match)\n1791: - `ZOdiv_small_abs` → (no match)\n1792: - `ZOmod_small_abs` → (no match)\n1793: - `ZOdiv_plus` → `ZOdiv_plus_spec` (substring-name)\n1794: - `Zsame_sign_trans` → (no match)\n1795: - `Zsame_sign_trans_weak` → (no match)\n1796: - `Zsame_sign_imp` → (no match)\n1797: - `Zsame_sign_odiv` → (no match)\n1798: - `Zeq_bool_spec` → `Zeq_bool_spec` (exact-name)\n1799: - `Zeq_bool_true` → `Zeq_bool_true_spec` (substring-name)\n1800: - `Zeq_bool_false` → `Zeq_bool_false_spec` (substring-name)\n1801: - `Zeq_bool_diag` → `Zeq_bool_diag_spec` (substring-name)\n1802: - `Zeq_bool_opp` → `Zeq_bool_opp` (exact-name)\n1803: - `Zeq_bool_opp'` → `Zeq_bool_opp` (normalized-name)\n1804: - `Zle_bool_spec` → `Zle_bool_spec` (exact-name)\n1805: - `Zle_bool_true` → `Zle_bool_true_spec` (substring-name)\n1806: - `Zle_bool_false` → `Zle_bool_false_spec` (substring-name)\n1807: - `Zle_bool_opp_l` → `Zle_bool_opp_l_spec` (substring-name)\n1808: - `Zle_bool_opp` → `Zle_bool_opp_l_spec` (substring-name)\n1809: - `Zle_bool_opp_r` → `Zle_bool_opp_r_spec` (substring-name)\n1810: - `Zlt_bool_spec` → `Zlt_bool_spec` (exact-name)\n1811: - `Zlt_bool_true` → `Zlt_bool_true_spec` (substring-name)\n1812: - `Zlt_bool_false` → `Zlt_bool_false_spec` (substring-name)\n1813: - `negb_Zle_bool` → `negb_Zle_bool_spec` (substring-name)\n1814: - `negb_Zlt_bool` → `negb_Zlt_bool_spec` (substring-name)\n1815: - `Zlt_bool_opp_l` → `Zlt_bool_opp_l_spec` (substring-name)\n1816: - `Zlt_bool_opp_r` → `Zlt_bool_opp_r_spec` (substring-name)\n1817: - `Zlt_bool_opp` → `Zlt_bool_opp_l_spec` (substring-name)\n1818: - `Zcompare_spec` → `Zcompare_spec` (exact-name)\n1819: - `Zcompare_Lt` → `Zcompare_Lt_spec` (substring-name)\n1820: - `Zcompare_Eq` → `Zcompare_Eq_spec` (substring-name)\n1821: - `Zcompare_Gt` → `Zcompare_Gt_spec` (substring-name)\n1822: - `cond_Zopp_0` → `cond_Zopp_0_spec` (substring-name)\n1823: - `cond_Zopp_negb` → `cond_Zopp_negb_spec` (substring-name)\n1824: - `abs_cond_Zopp` → `abs_cond_Zopp_spec` (substring-name)\n1825: - `cond_Zopp_Zlt_bool` → `cond_Zopp_Zlt_bool_spec` (substring-name)\n1826: - `Zeq_bool_cond_Zopp` → `Zeq_bool_cond_Zopp_spec` (substring-name)\n1827: - `Zfast_pow_pos_correct` → (no match)\n1828: - `Zdiv_eucl_unique` → (no match)\n1829: - `Zpos_div_eucl_aux1_correct` → (no match)\n1830: - `Zpos_div_eucl_aux_correct` → (no match)\n1831: - `Zfast_div_eucl_correct` → (no match)\n1832: - `iter_nat_plus` → `iter_nat_plus_spec` (substring-name)\n1833: - `iter_nat_S` → `iter_nat_spec` (substring-name)\n1834: - `iter_pos_nat` → `iter_pos_nat_spec` (substring-name)\n1835: \n"
  }
}
[2025-09-16T03:36:21] tokens used: 7183
[2025-09-16T03:36:27] thinking

**Analyzing file structure and mappings**

The line indicates that we should follow a specific example in Zaux.lean, but I need to clarify which file the user wants to work in. I think it’s worth opening a file to check for placeholders, although I see that they mention 'pure true' statements that need to be eliminated. This likely relates to using "wp" or hoare triple syntax. I’m noticing some inconsistencies in the mappings, like duplicate entries which could be a problem.**Choosing a file for theorem application**

I'm feeling a bit uncertain, but I think it might be best to pick a file with clear "no match" items, like FLT, since there are many missing elements. The instructions say to check with the mcp tool or lake build after writing each theorem. I need to ensure I follow the hoare triple syntax introduced in PIPELINE.md and CLAUDE.md. To get a better idea of the style, I’ll open a Lean file from FloatSpec/src/Core, particularly looking at Zaux.lean.
[2025-09-16T03:36:32] codex
**Choosing a file for theorem application**

I'm feeling a bit uncertain, but I think it might be best to pick a file with clear "no match" items, like FLT, since there are many missing elements. The instructions say to check with the mcp tool or lake build after writing each theorem. I need to ensure I follow the hoare triple syntax introduced in PIPELINE.md and CLAUDE.md. To get a better idea of the style, I’ll open a Lean file from FloatSpec/src/Core, particularly looking at Zaux.lean.
[2025-09-16T03:36:32] codex

I’ll open Zaux.lean to copy the theorem style and hoare triple syntax used.
[2025-09-16T03:36:32] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Zaux.lean","annotate_lines":true})
[2025-09-16T03:36:32] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Zaux.lean","annotate_lines":true}) success in 4ms:
{
  "content": [
    {
      "text": "1   : /-\n2   : This file is part of the Flocq formalization of floating-point\n3   : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4   : \n5   : Original Copyright (C) 2011-2018 Sylvie Boldo\n6   : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7   : \n8   : This library is free software; you can redistribute it and/or\n9   : modify it under the terms of the GNU Lesser General Public\n10  : License as published by the Free Software Foundation; either\n11  : version 3 of the License, or (at your option) any later version.\n12  : \n13  : This library is distributed in the hope that it will be useful,\n14  : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15  : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16  : COPYING file for more details.\n17  : -/\n18  : \n19  : import Std.Do.Triple\n20  : import Std.Tactic.Do\n21  : import Mathlib.Tactic\n22  : \n23  : open Std.Do\n24  : \n25  : namespace FloatSpec.Core.Zaux\n26  : \n27  : section Zmissing\n28  : \n29  : /-- Cancellation law for opposite in integer inequalities\n30  : \n31  :     If -y ≤ -x, then x ≤ y. This is a basic property used throughout\n32  :     the formalization for manipulating integer inequalities.\n33  : -/\n34  : def Zopp_le_cancel (x y : Int) : Id Int :=\n35  :   if x ≤ y then 1 else 0\n36  : \n37  : /-- Specification: Opposite cancellation preserves order\n38  : \n39  :     The cancellation operation ensures that if the negatives are ordered,\n40  :     then the original values have the reverse order relationship.\n41  : -/\n42  : theorem Zopp_le_cancel_spec (x y : Int) :\n43  :     ⦃⌜-y ≤ -x⌝⦄\n44  :     Zopp_le_cancel x y\n45  :     ⦃⇓result => ⌜result = if x ≤ y then 1 else 0⌝⦄ := by\n46  :   intro h\n47  :   unfold Zopp_le_cancel\n48  :   -- From -y ≤ -x, we can deduce x ≤ y\n49  :   have : x ≤ y := Int.neg_le_neg_iff.mp h\n50  :   simp [this]\n51  :   rfl\n52  : \n53  : /-- Greater-than implies not equal for integers\n54  : \n55  :     If y < x, then x ≠ y. This captures the asymmetry of the\n56  :     less-than relation on integers.\n57  : -/\n58  : def Zgt_not_eq (x y : Int) : Id Bool :=\n59  :   decide (x ≠ y)\n60  : \n61  : /-- Specification: Strict inequality implies non-equality\n62  : \n63  :     The operation verifies that strict ordering relationships\n64  :     guarantee distinctness of values.\n65  : -/\n66  : theorem Zgt_not_eq_spec (x y : Int) :\n67  :     ⦃⌜y < x⌝⦄\n68  :     Zgt_not_eq x y\n69  :     ⦃⇓result => ⌜result = (x ≠ y)⌝⦄ := by\n70  :   intro h\n71  :   unfold Zgt_not_eq\n72  :   -- From y < x, we can deduce x ≠ y\n73  :   have : x ≠ y := ne_of_gt h\n74  :   simp [this]\n75  :   rfl\n76  : \n77  : end Zmissing\n78  : \n79  : section ProofIrrelevance\n80  : \n81  : /-- Boolean equality irrelevance principle\n82  : \n83  :     Establishes that all proofs of boolean equality are equal.\n84  :     This is fundamental for working with decidable propositions.\n85  : -/\n86  : def eqbool_irrelevance (b : Bool) (_h1 _h2 : b = true) : Id Bool :=\n87  :   true\n88  : \n89  : /-- Specification: Boolean proof irrelevance\n90  : \n91  :     Any two proofs that a boolean equals true are themselves equal.\n92  :     This captures the principle of proof irrelevance for booleans.\n93  : -/\n94  : theorem eqbool_irrelevance_spec (b : Bool) (h1 h2 : b = true) :\n95  :     ⦃⌜b = true⌝⦄\n96  :     eqbool_irrelevance b h1 h2\n97  :     ⦃⇓result => ⌜result = true⌝⦄ := by\n98  :   intro _\n99  :   unfold eqbool_irrelevance\n100 :   rfl\n101 : \n102 : end ProofIrrelevance\n103 : \n104 : section EvenOdd\n105 : \n106 : /-- Existence of even/odd decomposition for integers\n107 : \n108 :     Every integer can be written as 2*p + r where r is 0 or 1\n109 :     depending on whether the integer is even or odd.\n110 : -/\n111 : def Zeven_ex (x : Int) : Id (Int × Int) :=\n112 :   let p := x / 2\n113 :   let r := x % 2\n114 :   (p, r)\n115 : \n116 : /-- Specification: Even/odd decomposition exists\n117 : \n118 :     For any integer x, there exists p such that:\n119 :     - x = 2*p if x is even\n120 :     - x = 2*p + 1 if x is odd\n121 : \n122 :     This captures the fundamental division algorithm for base 2.\n123 : -/\n124 : theorem Zeven_ex_spec (x : Int) :\n125 :     ⦃⌜True⌝⦄\n126 :     Zeven_ex x\n127 :     ⦃⇓result => ⌜let (p, r) := result\n128 :                 x = 2 * p + r ∧ (r = 0 ∨ r = 1)⌝⦄ := by\n129 :   intro _\n130 :   unfold Zeven_ex\n131 :   -- After unfolding, the goal should be about (x / 2, x % 2)\n132 :   -- We need to show x = 2 * (x / 2) + x % 2 ∧ (x % 2 = 0 ∨ x % 2 = 1)\n133 :   show x = 2 * (Id.run (x / 2, x % 2)).1 + (Id.run (x / 2, x % 2)).2 ∧\n134 :        ((Id.run (x / 2, x % 2)).2 = 0 ∨ (Id.run (x / 2, x % 2)).2 = 1)\n135 :   simp only [Id.run]\n136 :   constructor\n137 :   · -- Prove: x = 2 * (x / 2) + (x % 2)\n138 :     -- Use Lean's theorem: b * (a / b) + a % b = a\n139 :     have h := Int.emod_add_ediv x 2\n140 :     -- h: x % 2 + 2 * (x / 2) = x\n141 :     rw [Int.add_comm] at h\n142 :     exact h.symm\n143 :   · -- Prove: x % 2 = 0 ∨ x % 2 = 1\n144 :     exact Int.emod_two_eq_zero_or_one x\n145 : \n146 : end EvenOdd\n147 : \n148 : section Zpower\n149 : \n150 : /-- Power addition formula for integers\n151 : \n152 :     Computes the product of powers: n^(k1+k2) = n^k1 * n^k2\n153 :     when both exponents are non-negative.\n154 : -/\n155 : def Zpower_plus (n k1 k2 : Int) : Id Int :=\n156 :   if k1 ≥ 0 && k2 ≥ 0 then\n157 :     n^(k1.natAbs + k2.natAbs)\n158 :   else\n159 :     0  -- Undefined for negative exponents in this context\n160 : \n161 : /-- Specification: Power addition rule\n162 : \n163 :     The power operation satisfies the exponential law:\n164 :     n^(k1 + k2) = n^k1 * n^k2 for non-negative exponents.\n165 : \n166 :     This is a fundamental property of exponentiation used\n167 :     throughout floating-point arithmetic.\n168 : -/\n169 : theorem Zpower_plus_spec (n k1 k2 : Int) :\n170 :     ⦃⌜0 ≤ k1 ∧ 0 ≤ k2⌝⦄\n171 :     Zpower_plus n k1 k2\n172 :     ⦃⇓result => ⌜result = n^(k1.natAbs + k2.natAbs)⌝⦄ := by\n173 :   intro ⟨h1, h2⟩\n174 :   unfold Zpower_plus\n175 :   simp [h1, h2]\n176 :   rfl\n177 : \n178 : /-- Radix type for floating-point bases\n179 : \n180 :     A radix must be at least 2. This structure captures the\n181 :     constraint that floating-point number systems need a base\n182 :     greater than 1 for meaningful representation.\n183 : -/\n184 : structure Radix where\n185 :   /-- The radix value, must be at least 2 -/\n186 :   val : Int\n187 :   /-- Proof that the radix is at least 2 -/\n188 :   prop : 2 ≤ val\n189 : \n190 : /-- Standard binary radix\n191 : \n192 :     The most common radix for floating-point arithmetic is base 2.\n193 :     This definition provides the standard binary radix.\n194 : -/\n195 : def radix2 : Radix :=\n196 :   ⟨2, by simp⟩\n197 : \n198 : /-- Relationship between integer power and natural power\n199 : \n200 :     For non-negative exponents, Zpower equals Zpower_nat\n201 :     composed with absolute value conversion.\n202 : -/\n203 : def Zpower_Zpower_nat (b e : Int) : Id Int :=\n204 :   if e ≥ 0 then\n205 :     b^e.natAbs\n206 :   else\n207 :     0  -- Undefined for negative exponents\n208 : \n209 : /-- Specification: Integer and natural powers coincide\n210 : \n211 :     When the exponent is non-negative, the integer power\n212 :     function agrees with the natural number power function\n213 :     applied to the absolute value of the exponent.\n214 : -/\n215 : theorem Zpower_Zpower_nat_spec (b e : Int) :\n216 :     ⦃⌜0 ≤ e⌝⦄\n217 :     Zpower_Zpower_nat b e\n218 :     ⦃⇓result => ⌜result = b^e.natAbs⌝⦄ := by\n219 :   intro h\n220 :   unfold Zpower_Zpower_nat\n221 :   split\n222 :   · -- Case: e ≥ 0 (which is true given our precondition)\n223 :     rfl\n224 :   · -- Case: ¬(e ≥ 0) (impossible given our precondition)\n225 :     rename_i h_neg\n226 :     -- This case contradicts our precondition\n227 :     exact absurd h h_neg\n228 : \n229 : /-- Successor property for natural power\n230 : \n231 :     Shows that b^(n+1) = b * b^n for natural number exponents.\n232 :     This is the fundamental recursive property of exponentiation.\n233 : -/\n234 : def Zpower_nat_S (b : Int) (e : Nat) : Id Int :=\n235 :   b * b^e\n236 : \n237 : /-- Specification: Power successor formula\n238 : \n239 :     The power function satisfies the recursive relation:\n240 :     b^(S e) = b * b^e. This allows inductive reasoning\n241 :     about powers with natural number exponents.\n242 : -/\n243 : theorem Zpower_nat_S_spec (b : Int) (e : Nat) :\n244 :     ⦃⌜True⌝⦄\n245 :     Zpower_nat_S b e\n246 :     ⦃⇓result => ⌜result = b * b^e⌝⦄ := by\n247 :   intro _\n248 :   unfold Zpower_nat_S\n249 :   rfl\n250 : \n251 : end Zpower\n252 : \n253 : section DivMod\n254 : \n255 : /-- Modulo operation with multiple\n256 : \n257 :     Computes (n mod (a*b)) mod b, which equals n mod b\n258 :     when a > 0 and b ≥ 0.\n259 : -/\n260 : def Zmod_mod_mult (n _a b : Int) : Id Int :=\n261 :   n % b\n262 : \n263 : /-- Specification: Nested modulo simplification\n264 : \n265 :     The modulo operation satisfies: (n mod (a*b)) mod b = n mod b\n266 :     when a is positive and b is non-negative. This allows\n267 :     simplification of nested modulo operations.\n268 : -/\n269 : theorem Zmod_mod_mult_spec (n a b : Int) :\n270 :     ⦃⌜0 < a ∧ 0 ≤ b⌝⦄\n271 :     Zmod_mod_mult n a b\n272 :     ⦃⇓result => ⌜result = n % b⌝⦄ := by\n273 :   intro h\n274 :   unfold Zmod_mod_mult\n275 :   rfl\n276 : \n277 : /-- Division and modulo relationship\n278 : \n279 :     Expresses the quotient-remainder theorem: a = q*b + r\n280 :     where q is the quotient and r is the remainder.\n281 : -/\n282 : def ZOmod_eq (a b : Int) : Id Int :=\n283 :   a % b\n284 : \n285 : /-- Specification: Quotient-remainder decomposition\n286 : \n287 :     Every integer a can be uniquely written as a = q*b + r\n288 :     where q is the quotient and r is the remainder with\n289 :     0 ≤ r < |b| for b ≠ 0.\n290 : -/\n291 : theorem ZOmod_eq_spec (a b : Int) :\n292 :     ⦃⌜b ≠ 0⌝⦄\n293 :     ZOmod_eq a b\n294 :     ⦃⇓result => ⌜result = a % b⌝⦄ := by\n295 :   intro h\n296 :   unfold ZOmod_eq\n297 :   rfl\n298 : \n299 : /-- Division of nested modulo\n300 : \n301 :     Computes (n mod (a*b)) / a, which equals (n/a) mod b\n302 :     under appropriate conditions.\n303 : -/\n304 : def Zdiv_mod_mult (n a b : Int) : Id Int :=\n305 :   if a ≠ 0 && b ≠ 0 then\n306 :     (n / a) % b\n307 :   else\n308 :     0\n309 : \n310 : /-- Specification: Division distributes over modulo\n311 : \n312 :     The operation satisfies: (n mod (a*b)) / a = (n/a) mod b\n313 :     when a and b are non-negative. This is useful for\n314 :     decomposing multi-precision arithmetic operations.\n315 : -/\n316 : theorem Zdiv_mod_mult_spec (n a b : Int) :\n317 :     ⦃⌜0 ≤ a ∧ 0 ≤ b⌝⦄\n318 :     Zdiv_mod_mult n a b\n319 :     ⦃⇓result => ⌜result = if a = 0 || b = 0 then 0 else (n / a) % b⌝⦄ := by\n320 :   intro ⟨ha, hb⟩\n321 :   unfold Zdiv_mod_mult\n322 :   -- Case split on whether a ≠ 0 && b ≠ 0\n323 :   split\n324 :   · -- Case: a ≠ 0 && b ≠ 0\n325 :     rename_i h_both_nonzero\n326 :     -- When both are non-zero, a = 0 || b = 0 is false\n327 :     -- So if a = 0 || b = 0 then 0 else (n / a) % b reduces to (n / a) % b\n328 :     have ha_nonzero : a ≠ 0 := by\n329 :       simp at h_both_nonzero\n330 :       exact h_both_nonzero.1\n331 :     have hb_nonzero : b ≠ 0 := by\n332 :       simp at h_both_nonzero\n333 :       exact h_both_nonzero.2\n334 :     simp [ha_nonzero, hb_nonzero]\n335 :     rfl\n336 :   · -- Case: ¬(a ≠ 0 && b ≠ 0), which means a = 0 || b = 0\n337 :     rename_i h_some_zero\n338 :     -- When at least one is zero, a = 0 || b = 0 is true\n339 :     -- So if a = 0 || b = 0 then 0 else (n / a) % b reduces to 0\n340 :     simp at h_some_zero\n341 :     push_neg at h_some_zero\n342 :     -- h_some_zero : a ≠ 0 → b = 0, which is equivalent to a = 0 ∨ b = 0\n343 :     -- We need to show: if a = 0 ∨ b = 0 then 0 else (n / a) % b = 0\n344 :     by_cases ha_zero : a = 0\n345 :     · -- Case: a = 0\n346 :       simp [ha_zero]\n347 :       rfl\n348 :     · -- Case: a ≠ 0, then by h_some_zero, b = 0\n349 :       have hb_zero : b = 0 := h_some_zero ha_zero\n350 :       simp [hb_zero]\n351 :       rfl\n352 : \n353 : /-- Nested modulo with multiplication\n354 : \n355 :     Computes (n mod (a*b)) mod b using the quotient-based\n356 :     remainder formula. This is equivalent to n mod b for\n357 :     appropriate signs.\n358 : -/\n359 : def ZOmod_mod_mult (n _a b : Int) : Id Int :=\n360 :   n % b\n361 : \n362 : /-- Specification: Nested modulo simplification (quotient version)\n363 : \n364 :     The quotient-based modulo operation satisfies:\n365 :     (n mod (a*b)) mod b = n mod b. This allows simplification\n366 :     of nested modulo operations in quotient arithmetic.\n367 : -/\n368 : theorem ZOmod_mod_mult_spec (n a b : Int) :\n369 :     ⦃⌜b ≠ 0⌝⦄\n370 :     ZOmod_mod_mult n a b\n371 :     ⦃⇓result => ⌜result = n % b⌝⦄ := by\n372 :   intro h\n373 :   unfold ZOmod_mod_mult\n374 :   rfl\n375 : \n376 : /-- Quotient addition with sign consideration\n377 : \n378 :     Computes quot(a+b, c) in terms of individual quotients\n379 :     and the quotient of remainders, considering signs.\n380 : -/\n381 : def ZOdiv_plus (a b c : Int) : Id Int :=\n382 :   if c ≠ 0 then\n383 :     a / c + b / c + ((a % c + b % c) / c)\n384 :   else\n385 :     0\n386 : \n387 : /-- Specification: Quotient of sum decomposition\n388 : \n389 :     The quotient of a sum can be expressed as:\n390 :     quot(a+b, c) = quot(a, c) + quot(b, c) + quot(rem(a, c) + rem(b, c), c)\n391 :     when a*b ≥ 0. This decomposition is crucial for multi-precision\n392 :     arithmetic operations.\n393 : -/\n394 : theorem ZOdiv_plus_spec (a b c : Int) :\n395 :     ⦃⌜0 ≤ a * b ∧ c ≠ 0⌝⦄\n396 :     ZOdiv_plus a b c\n397 :     ⦃⇓result => ⌜result = a / c + b / c + ((a % c + b % c) / c)⌝⦄ := by\n398 :   intro ⟨hab, hc⟩\n399 :   unfold ZOdiv_plus\n400 :   -- Since c ≠ 0, the if condition is true\n401 :   simp [hc]\n402 :   rfl\n403 : \n404 : end DivMod\n405 : \n406 : section BooleanComparisons\n407 : \n408 : /-- Boolean equality test for integers\n409 : \n410 :     Tests whether two integers are equal, returning a boolean.\n411 :     This provides a decidable equality test.\n412 : -/\n413 : def Zeq_bool (x y : Int) : Id Bool :=\n414 :   decide (x = y)\n415 : \n416 : /-- Specification: Boolean equality test\n417 : \n418 :     The boolean equality test returns true if and only if\n419 :     the integers are equal. This provides a computational\n420 :     version of equality.\n421 : -/\n422 : theorem Zeq_bool_spec (x y : Int) :\n423 :     ⦃⌜True⌝⦄\n424 :     Zeq_bool x y\n425 :     ⦃⇓result => ⌜result = decide (x = y)⌝⦄ := by\n426 :   intro _\n427 :   unfold Zeq_bool\n428 :   rfl\n429 : \n430 : /-- Boolean less-or-equal test for integers\n431 : \n432 :     Tests whether x ≤ y, returning a boolean result.\n433 :     This provides a decidable ordering test.\n434 : -/\n435 : def Zle_bool (x y : Int) : Id Bool :=\n436 :   decide (x ≤ y)\n437 : \n438 : /-- Specification: Boolean ordering test\n439 : \n440 :     The boolean less-or-equal test returns true if and only if\n441 :     x ≤ y. This provides a computational version of the ordering.\n442 : -/\n443 : theorem Zle_bool_spec (x y : Int) :\n444 :     ⦃⌜True⌝⦄\n445 :     Zle_bool x y\n446 :     ⦃⇓result => ⌜result = decide (x ≤ y)⌝⦄ := by\n447 :   intro _\n448 :   unfold Zle_bool\n449 :   rfl\n450 : \n451 : /-- Boolean strict less-than test for integers\n452 : \n453 :     Tests whether x < y, returning a boolean result.\n454 :     This provides a decidable strict ordering test.\n455 : -/\n456 : def Zlt_bool (x y : Int) : Id Bool :=\n457 :   decide (x < y)\n458 : \n459 : /-- Specification: Boolean strict ordering test\n460 : \n461 :     The boolean less-than test returns true if and only if\n462 :     x < y. This provides a computational version of strict ordering.\n463 : -/\n464 : theorem Zlt_bool_spec (x y : Int) :\n465 :     ⦃⌜True⌝⦄\n466 :     Zlt_bool x y\n467 :     ⦃⇓result => ⌜result = decide (x < y)⌝⦄ := by\n468 :   intro _\n469 :   unfold Zlt_bool\n470 :   rfl\n471 : \n472 : /-- Boolean equality is true when equal\n473 : \n474 :     x = y implies Zeq_bool x y = true. This provides\n475 :     the forward direction of boolean equality correctness.\n476 : -/\n477 : def Zeq_bool_true (_ _ : Int) : Id Bool :=\n478 :   true\n479 : \n480 : /-- Specification: Equality implies true\n481 : \n482 :     When two integers are equal, the boolean equality test\n483 :     returns true. This is half of the correctness property\n484 :     for boolean equality.\n485 : -/\n486 : theorem Zeq_bool_true_spec (x y : Int) :\n487 :     ⦃⌜x = y⌝⦄\n488 :     Zeq_bool_true x y\n489 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n490 :   intro _\n491 :   unfold Zeq_bool_true\n492 :   rfl\n493 : \n494 : /-- Boolean equality is false when not equal\n495 : \n496 :     x ≠ y implies Zeq_bool x y = false. This provides\n497 :     the reverse direction of boolean equality correctness.\n498 : -/\n499 : def Zeq_bool_false (_ _ : Int) : Id Bool :=\n500 :   false\n501 : \n502 : /-- Specification: Inequality implies false\n503 : \n504 :     When two integers are not equal, the boolean equality test\n505 :     returns false. This completes the correctness property\n506 :     for boolean equality.\n507 : -/\n508 : theorem Zeq_bool_false_spec (x y : Int) :\n509 :     ⦃⌜x ≠ y⌝⦄\n510 :     Zeq_bool_false x y\n511 :     ⦃⇓result => ⌜result = false⌝⦄ := by\n512 :   intro _\n513 :   unfold Zeq_bool_false\n514 :   rfl\n515 : \n516 : /-- Boolean equality is reflexive\n517 : \n518 :     Zeq_bool x x = true for all x. This captures\n519 :     the reflexivity of equality in boolean form.\n520 : -/\n521 : def Zeq_bool_diag (_ : Int) : Id Bool :=\n522 :   true\n523 : \n524 : /-- Specification: Reflexivity of boolean equality\n525 : \n526 :     The boolean equality test always returns true when\n527 :     comparing a value with itself. This is the boolean\n528 :     version of reflexivity.\n529 : -/\n530 : theorem Zeq_bool_diag_spec (x : Int) :\n531 :     ⦃⌜True⌝⦄\n532 :     Zeq_bool_diag x\n533 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n534 :   intro _\n535 :   unfold Zeq_bool_diag\n536 :   rfl\n537 : \n538 : /-- Opposite preserves equality testing\n539 : \n540 :     Zeq_bool(-x, y) = Zeq_bool(x, -y). This shows that\n541 :     negation can be moved between arguments in equality tests.\n542 : -/\n543 : def Zeq_bool_opp (x y : Int) : Id Bool :=\n544 :   decide ((-x = y) = (x = -y))\n545 : \n546 : /-- Specification: Negation commutes with equality\n547 : \n548 :     The equality test is preserved when negating both sides\n549 :     or moving negation between arguments. This is useful for\n550 :     simplifying equality tests involving negations.\n551 : -/\n552 : theorem Zeq_bool_opp_spec (x y : Int) :\n553 :     ⦃⌜True⌝⦄\n554 :     Zeq_bool_opp x y\n555 :     ⦃⇓result => ⌜result = decide ((-x = y) = (x = -y))⌝⦄ := by\n556 :   intro _\n557 :   unfold Zeq_bool_opp\n558 :   rfl\n559 : \n560 : /-- Double opposite preserves equality testing\n561 : \n562 :     Zeq_bool(-x, -y) = Zeq_bool(x, y). This shows that\n563 :     negating both arguments preserves the equality test.\n564 : -/\n565 : def Zeq_bool_opp' (x y : Int) : Id Bool :=\n566 :   decide ((-x = -y) = (x = y))\n567 : \n568 : /-- Specification: Double negation preserves equality\n569 : \n570 :     The equality test is preserved when negating both\n571 :     arguments. This follows from the fact that negation\n572 :     is an injection on integers.\n573 : -/\n574 : theorem Zeq_bool_opp'_spec (x y : Int) :\n575 :     ⦃⌜True⌝⦄\n576 :     Zeq_bool_opp' x y\n577 :     ⦃⇓result => ⌜result = decide ((-x = -y) = (x = y))⌝⦄ := by\n578 :   intro _\n579 :   unfold Zeq_bool_opp'\n580 :   rfl\n581 : \n582 : /-- Boolean less-or-equal is true when satisfied\n583 : \n584 :     x ≤ y implies Zle_bool x y = true. This provides\n585 :     the forward direction of boolean ordering correctness.\n586 : -/\n587 : def Zle_bool_true (_ _ : Int) : Id Bool :=\n588 :   true\n589 : \n590 : /-- Specification: Less-or-equal implies true\n591 : \n592 :     When x ≤ y holds, the boolean less-or-equal test\n593 :     returns true. This is the soundness property for\n594 :     boolean ordering.\n595 : -/\n596 : theorem Zle_bool_true_spec (x y : Int) :\n597 :     ⦃⌜x ≤ y⌝⦄\n598 :     Zle_bool_true x y\n599 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n600 :   intro _\n601 :   unfold Zle_bool_true\n602 :   rfl\n603 : \n604 : /-- Boolean less-or-equal is false when violated\n605 : \n606 :     y < x implies Zle_bool x y = false. This provides\n607 :     the reverse direction of boolean ordering correctness.\n608 : -/\n609 : def Zle_bool_false (_ _ : Int) : Id Bool :=\n610 :   false\n611 : \n612 : /-- Specification: Greater-than implies false\n613 : \n614 :     When y < x holds, the boolean less-or-equal test\n615 :     returns false. This is the completeness property\n616 :     for boolean ordering.\n617 : -/\n618 : theorem Zle_bool_false_spec (x y : Int) :\n619 :     ⦃⌜y < x⌝⦄\n620 :     Zle_bool_false x y\n621 :     ⦃⇓result => ⌜result = false⌝⦄ := by\n622 :   intro _\n623 :   unfold Zle_bool_false\n624 :   rfl\n625 : \n626 : /-- Boolean less-or-equal with opposite on left\n627 : \n628 :     Zle_bool(-x, y) = Zle_bool(-y, x). This shows how\n629 :     negation on the left relates to swapping with negation.\n630 : -/\n631 : def Zle_bool_opp_l (x y : Int) : Id Bool :=\n632 :   decide ((- x ≤ y) = (- y ≤ x))\n633 : \n634 : /-- Specification: Left negation swaps comparison\n635 : \n636 :     Negating the left argument and swapping gives the same\n637 :     result: Zle_bool(-x, y) = Zle_bool(-y, x).\n638 : -/\n639 : theorem Zle_bool_opp_l_spec (x y : Int) :\n640 :     ⦃⌜True⌝⦄\n641 :     Zle_bool_opp_l x y\n642 :     ⦃⇓result => ⌜result = decide ((- x ≤ y) = (- y ≤ x))⌝⦄ := by\n643 :   intro _\n644 :   unfold Zle_bool_opp_l\n645 :   rfl\n646 : \n647 : /-- Boolean less-or-equal with double opposite\n648 : \n649 :     Zle_bool(-x, -y) = Zle_bool(y, x). This shows that\n650 :     double negation reverses the comparison.\n651 : -/\n652 : def Zle_bool_opp (x y : Int) : Id Bool :=\n653 :   decide ((- x ≤ - y) = (y ≤ x))\n654 : \n655 : /-- Specification: Double negation reverses ordering\n656 : \n657 :     Negating both arguments reverses the comparison:\n658 :     Zle_bool(-x, -y) = Zle_bool(y, x).\n659 : -/\n660 : theorem Zle_bool_opp_spec (x y : Int) :\n661 :     ⦃⌜True⌝⦄\n662 :     Zle_bool_opp x y\n663 :     ⦃⇓result => ⌜result = decide ((- x ≤ - y) = (y ≤ x))⌝⦄ := by\n664 :   intro _\n665 :   unfold Zle_bool_opp\n666 :   rfl\n667 : \n668 : /-- Boolean less-or-equal with opposite on right\n669 : \n670 :     Zle_bool(x, -y) = Zle_bool(y, -x). This shows how\n671 :     negation on the right relates to swapping with negation.\n672 : -/\n673 : def Zle_bool_opp_r (x y : Int) : Id Bool :=\n674 :   decide ((x ≤ - y) = (y ≤ - x))\n675 : \n676 : /-- Specification: Right negation swaps comparison\n677 : \n678 :     Negating the right argument relates to swapping with\n679 :     left negation: Zle_bool(x, -y) = Zle_bool(y, -x).\n680 : -/\n681 : theorem Zle_bool_opp_r_spec (x y : Int) :\n682 :     ⦃⌜True⌝⦄\n683 :     Zle_bool_opp_r x y\n684 :     ⦃⇓result => ⌜result = decide ((x ≤ - y) = (y ≤ - x))⌝⦄ := by\n685 :   intro _\n686 :   unfold Zle_bool_opp_r\n687 :   rfl\n688 : \n689 : /-- Negation of less-or-equal is strict greater-than\n690 : \n691 :     Shows that negb (Zle_bool x y) = Zlt_bool y x.\n692 :     This captures the duality between ≤ and >.\n693 : -/\n694 : def negb_Zle_bool (x y : Int) : Id Bool :=\n695 :   decide (!(x ≤ y) = (y < x))\n696 : \n697 : /-- Specification: Negated ≤ equals strict >\n698 : \n699 :     The negation of x ≤ y is equivalent to y < x. This duality\n700 :     is fundamental for simplifying boolean comparisons.\n701 : -/\n702 : theorem negb_Zle_bool_spec (x y : Int) :\n703 :     ⦃⌜True⌝⦄\n704 :     negb_Zle_bool x y\n705 :     ⦃⇓result => ⌜result = decide (!(x ≤ y) = (y < x))⌝⦄ := by\n706 :   intro _\n707 :   unfold negb_Zle_bool\n708 :   rfl\n709 : \n710 : /-- Negation of strict less-than is greater-or-equal\n711 : \n712 :     Shows that negb (Zlt_bool x y) = Zle_bool y x.\n713 :     This captures the duality between < and ≥.\n714 : -/\n715 : def negb_Zlt_bool (x y : Int) : Id Bool :=\n716 :   decide (!(x < y) = (y ≤ x))\n717 : \n718 : /-- Specification: Negated < equals ≥\n719 : \n720 :     The negation of x < y is equivalent to y ≤ x. This duality\n721 :     allows conversion between strict and non-strict comparisons.\n722 : -/\n723 : theorem negb_Zlt_bool_spec (x y : Int) :\n724 :     ⦃⌜True⌝⦄\n725 :     negb_Zlt_bool x y\n726 :     ⦃⇓result => ⌜result = decide (!(x < y) = (y ≤ x))⌝⦄ := by\n727 :   intro _\n728 :   unfold negb_Zlt_bool\n729 :   rfl\n730 : \n731 : /-- Boolean less-than is true when satisfied\n732 : \n733 :     x < y implies Zlt_bool x y = true. This provides\n734 :     the forward direction of boolean strict ordering correctness.\n735 : -/\n736 : def Zlt_bool_true (_ _ : Int) : Id Bool :=\n737 :   true\n738 : \n739 : /-- Specification: Less-than implies true\n740 : \n741 :     When x < y holds, the boolean less-than test\n742 :     returns true. This is the soundness property for\n743 :     boolean strict ordering.\n744 : -/\n745 : theorem Zlt_bool_true_spec (x y : Int) :\n746 :     ⦃⌜x < y⌝⦄\n747 :     Zlt_bool_true x y\n748 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n749 :   intro _\n750 :   unfold Zlt_bool_true\n751 :   rfl\n752 : \n753 : /-- Boolean less-than is false when violated\n754 : \n755 :     y ≤ x implies Zlt_bool x y = false. This provides\n756 :     the reverse direction of boolean strict ordering correctness.\n757 : -/\n758 : def Zlt_bool_false (_ _ : Int) : Id Bool :=\n759 :   false\n760 : \n761 : /-- Specification: Greater-or-equal implies false\n762 : \n763 :     When y ≤ x holds, the boolean less-than test\n764 :     returns false. This is the completeness property\n765 :     for boolean strict ordering.\n766 : -/\n767 : theorem Zlt_bool_false_spec (x y : Int) :\n768 :     ⦃⌜y ≤ x⌝⦄\n769 :     Zlt_bool_false x y\n770 :     ⦃⇓result => ⌜result = false⌝⦄ := by\n771 :   intro _\n772 :   unfold Zlt_bool_false\n773 :   rfl\n774 : \n775 : /-- Boolean less-than with opposite on left\n776 : \n777 :     Zlt_bool(-x, y) = Zlt_bool(-y, x). This shows how\n778 :     negation on the left relates to swapping with negation.\n779 : -/\n780 : def Zlt_bool_opp_l (x y : Int) : Id Bool :=\n781 :   decide ((- x < y) = (- y < x))\n782 : \n783 : /-- Specification: Left negation swaps strict comparison\n784 : \n785 :     Negating the left argument and swapping gives the same\n786 :     result: Zlt_bool(-x, y) = Zlt_bool(-y, x).\n787 : -/\n788 : theorem Zlt_bool_opp_l_spec (x y : Int) :\n789 :     ⦃⌜True⌝⦄\n790 :     Zlt_bool_opp_l x y\n791 :     ⦃⇓result => ⌜result = decide ((- x < y) = (- y < x))⌝⦄ := by\n792 :   intro _\n793 :   unfold Zlt_bool_opp_l\n794 :   rfl\n795 : \n796 : /-- Boolean less-than with opposite on right\n797 : \n798 :     Zlt_bool(x, -y) = Zlt_bool(y, -x). This shows how\n799 :     negation on the right relates to swapping with negation.\n800 : -/\n801 : def Zlt_bool_opp_r (x y : Int) : Id Bool :=\n802 :   decide ((x < - y) = (y < - x))\n803 : \n804 : /-- Specification: Right negation swaps strict comparison\n805 : \n806 :     Negating the right argument relates to swapping with\n807 :     left negation: Zlt_bool(x, -y) = Zlt_bool(y, -x).\n808 : -/\n809 : theorem Zlt_bool_opp_r_spec (x y : Int) :\n810 :     ⦃⌜True⌝⦄\n811 :     Zlt_bool_opp_r x y\n812 :     ⦃⇓result => ⌜result = decide ((x < - y) = (y < - x))⌝⦄ := by\n813 :   intro _\n814 :   unfold Zlt_bool_opp_r\n815 :   rfl\n816 : \n817 : /-- Boolean less-than with double opposite\n818 : \n819 :     Zlt_bool(-x, -y) = Zlt_bool(y, x). This shows that\n820 :     double negation reverses the strict comparison.\n821 : -/\n822 : def Zlt_bool_opp (x y : Int) : Id Bool :=\n823 :   decide ((- x < - y) = (y < x))\n824 : \n825 : /-- Specification: Double negation reverses strict ordering\n826 : \n827 :     Negating both arguments reverses the comparison:\n828 :     Zlt_bool(-x, -y) = Zlt_bool(y, x).\n829 : -/\n830 : theorem Zlt_bool_opp_spec (x y : Int) :\n831 :     ⦃⌜True⌝⦄\n832 :     Zlt_bool_opp x y\n833 :     ⦃⇓result => ⌜result = decide ((- x < - y) = (y < x))⌝⦄ := by\n834 :   intro _\n835 :   unfold Zlt_bool_opp\n836 :   rfl\n837 : \n838 : end BooleanComparisons\n839 : \n840 : section Zcompare\n841 : \n842 : /-- Three-way comparison for integers\n843 : \n844 :     Returns Lt if x < y, Eq if x = y, and Gt if x > y.\n845 :     This provides a complete ordering comparison in one operation.\n846 : -/\n847 : def Zcompare (x y : Int) : Id Ordering :=\n848 :   if x < y then Ordering.lt\n849 :   else if x = y then Ordering.eq\n850 :   else Ordering.gt\n851 : \n852 : /-- Specification: Three-way comparison correctness\n853 : \n854 :     The comparison function returns:\n855 :     - Lt when x < y\n856 :     - Eq when x = y\n857 :     - Gt when x > y\n858 : \n859 :     This captures the complete ordering of integers.\n860 : -/\n861 : theorem Zcompare_spec (x y : Int) :\n862 :     ⦃⌜True⌝⦄\n863 :     Zcompare x y\n864 :     ⦃⇓result => ⌜(result = Ordering.lt ↔ x < y) ∧\n865 :                 (result = Ordering.eq ↔ x = y) ∧\n866 :                 (result = Ordering.gt ↔ y < x)⌝⦄ := by\n867 :   intro _\n868 :   unfold Zcompare\n869 : \n870 :   -- Split on whether x < y\n871 :   split\n872 :   · -- Case: x < y\n873 :     rename_i h_lt\n874 :     constructor\n875 :     · -- Prove: Ordering.lt = Ordering.lt ↔ x < y\n876 :       exact ⟨fun _ => h_lt, fun _ => rfl⟩\n877 :     constructor\n878 :     · -- Prove: Ordering.lt = Ordering.eq ↔ x = y\n879 :       constructor\n880 :       · intro h_eq\n881 :         -- Ordering.lt = Ordering.eq is impossible\n882 :         cases h_eq\n883 :       · intro h_eq\n884 :         -- If x = y and x < y, contradiction\n885 :         rw [h_eq] at h_lt\n886 :         exact absurd h_lt (lt_irrefl y)\n887 :     · -- Prove: Ordering.lt = Ordering.gt ↔ y < x\n888 :       constructor\n889 :       · intro h_eq\n890 :         -- Ordering.lt = Ordering.gt is impossible\n891 :         cases h_eq\n892 :       · intro h_gt\n893 :         -- If y < x and x < y, contradiction\n894 :         exact absurd h_lt (not_lt.mpr (le_of_lt h_gt))\n895 : \n896 :   · -- Case: ¬(x < y), split on whether x = y\n897 :     rename_i h_not_lt\n898 :     split\n899 :     · -- Case: x = y\n900 :       rename_i h_eq\n901 :       constructor\n902 :       · -- Prove: Ordering.eq = Ordering.lt ↔ x < y\n903 :         constructor\n904 :         · intro h_ord_eq\n905 :           -- Ordering.eq = Ordering.lt is impossible\n906 :           cases h_ord_eq\n907 :         · intro h_lt\n908 :           -- If x < y but ¬(x < y), contradiction\n909 :           exact absurd h_lt h_not_lt\n910 :       constructor\n911 :       · -- Prove: Ordering.eq = Ordering.eq ↔ x = y\n912 :         exact ⟨fun _ => h_eq, fun _ => rfl⟩\n913 :       · -- Prove: Ordering.eq = Ordering.gt ↔ y < x\n914 :         constructor\n915 :         · intro h_ord_eq\n916 :           -- Ordering.eq = Ordering.gt is impossible\n917 :           cases h_ord_eq\n918 :         · intro h_gt\n919 :           -- If y < x and x = y, contradiction\n920 :           rw [← h_eq] at h_gt\n921 :           exact absurd h_gt (lt_irrefl x)\n922 : \n923 :     · -- Case: ¬(x < y) ∧ ¬(x = y), so y < x\n924 :       rename_i h_not_eq\n925 :       -- In this case, y < x\n926 :       have h_gt : y < x := by\n927 :         -- Since ¬(x < y) and ¬(x = y), we must have y < x\n928 :         cases' lt_trichotomy x y with h h\n929 :         · exact absurd h h_not_lt\n930 :         · cases' h with h h\n931 :           · exact absurd h h_not_eq\n932 :           · exact h\n933 : \n934 :       constructor\n935 :       · -- Prove: Ordering.gt = Ordering.lt ↔ x < y\n936 :         constructor\n937 :         · intro h_ord_eq\n938 :           -- Ordering.gt = Ordering.lt is impossible\n939 :           cases h_ord_eq\n940 :         · intro h_lt\n941 :           -- If x < y but ¬(x < y), contradiction\n942 :           exact absurd h_lt h_not_lt\n943 :       constructor\n944 :       · -- Prove: Ordering.gt = Ordering.eq ↔ x = y\n945 :         constructor\n946 :         · intro h_ord_eq\n947 :           -- Ordering.gt = Ordering.eq is impossible\n948 :           cases h_ord_eq\n949 :         · intro h_eq\n950 :           -- If x = y but ¬(x = y), contradiction\n951 :           exact absurd h_eq h_not_eq\n952 :       · -- Prove: Ordering.gt = Ordering.gt ↔ y < x\n953 :         exact ⟨fun _ => h_gt, fun _ => rfl⟩\n954 : \n955 : /-- Comparison returns Lt for less-than\n956 : \n957 :     When x < y, Zcompare returns Lt. This provides\n958 :     a computational witness for the less-than relation.\n959 : -/\n960 : def Zcompare_Lt (_ _ : Int) : Id Ordering :=\n961 :   Ordering.lt\n962 : \n963 : /-- Specification: Less-than yields Lt\n964 : \n965 :     The comparison function returns Lt exactly when x < y.\n966 :     This provides the forward direction of the comparison specification.\n967 : -/\n968 : theorem Zcompare_Lt_spec (x y : Int) :\n969 :     ⦃⌜x < y⌝⦄\n970 :     Zcompare_Lt x y\n971 :     ⦃⇓result => ⌜result = Ordering.lt⌝⦄ := by\n972 :   intro _\n973 :   unfold Zcompare_Lt\n974 :   rfl\n975 : \n976 : /-- Comparison returns Eq for equality\n977 : \n978 :     When x = y, Zcompare returns Eq. This provides\n979 :     a computational witness for equality.\n980 : -/\n981 : def Zcompare_Eq (_ _ : Int) : Id Ordering :=\n982 :   Ordering.eq\n983 : \n984 : /-- Specification: Equality yields Eq\n985 : \n986 :     The comparison function returns Eq exactly when x = y.\n987 :     This provides decidable equality through comparison.\n988 : -/\n989 : theorem Zcompare_Eq_spec (x y : Int) :\n990 :     ⦃⌜x = y⌝⦄\n991 :     Zcompare_Eq x y\n992 :     ⦃⇓result => ⌜result = Ordering.eq⌝⦄ := by\n993 :   intro _\n994 :   unfold Zcompare_Eq\n995 :   rfl\n996 : \n997 : /-- Comparison returns Gt for greater-than\n998 : \n999 :     When y < x, Zcompare returns Gt. This provides\n1000:     a computational witness for the greater-than relation.\n1001: -/\n1002: def Zcompare_Gt (_ _ : Int) : Id Ordering :=\n1003:   Ordering.gt\n1004: \n1005: /-- Specification: Greater-than yields Gt\n1006: \n1007:     The comparison function returns Gt exactly when y < x.\n1008:     This completes the three cases of integer comparison.\n1009: -/\n1010: theorem Zcompare_Gt_spec (x y : Int) :\n1011:     ⦃⌜y < x⌝⦄\n1012:     Zcompare_Gt x y\n1013:     ⦃⇓result => ⌜result = Ordering.gt⌝⦄ := by\n1014:   intro _\n1015:   unfold Zcompare_Gt\n1016:   rfl\n1017: \n1018: end Zcompare\n1019: \n1020: section CondZopp\n1021: \n1022: /-- Conditional opposite based on sign\n1023: \n1024:     Returns -x if the condition is true, x otherwise.\n1025:     This is used for conditional negation in floating-point\n1026:     sign handling.\n1027: -/\n1028: def cond_Zopp (b : Bool) (x : Int) : Id Int :=\n1029:   if b then -x else x\n1030: \n1031: /-- Specification: Conditional negation\n1032: \n1033:     The conditional opposite operation returns:\n1034:     - -x when b is true\n1035:     - x when b is false\n1036: \n1037:     This is fundamental for handling signs in floating-point.\n1038: -/\n1039: theorem cond_Zopp_spec (b : Bool) (x : Int) :\n1040:     ⦃⌜True⌝⦄\n1041:     cond_Zopp b x\n1042:     ⦃⇓result => ⌜result = if b then -x else x⌝⦄ := by\n1043:   intro _\n1044:   unfold cond_Zopp\n1045:   rfl\n1046: \n1047: /-- Conditional opposite of zero\n1048: \n1049:     cond_Zopp of zero is always zero, regardless of the condition.\n1050:     This captures the invariance of zero under negation.\n1051: -/\n1052: def cond_Zopp_0 (_ : Bool) : Id Int :=\n1053:   0\n1054: \n1055: /-- Specification: Zero invariance under conditional opposite\n1056: \n1057:     The conditional opposite of zero is always zero:\n1058:     cond_Zopp sx 0 = 0 for any boolean sx.\n1059: -/\n1060: theorem cond_Zopp_0_spec (sx : Bool) :\n1061:     ⦃⌜True⌝⦄\n1062:     cond_Zopp_0 sx\n1063:     ⦃⇓result => ⌜result = 0⌝⦄ := by\n1064:   intro _\n1065:   unfold cond_Zopp_0\n1066:   rfl\n1067: \n1068: /-- Negated condition flips conditional opposite\n1069: \n1070:     cond_Zopp (negb x) y = -cond_Zopp x y. This shows how\n1071:     negating the condition relates to negating the result.\n1072: -/\n1073: def cond_Zopp_negb (x : Bool) (y : Int) : Id Int :=\n1074:   -(if x then -y else y)\n1075: \n1076: /-- Specification: Condition negation flips result\n1077: \n1078:     Negating the boolean condition is equivalent to negating\n1079:     the result: cond_Zopp (!x) y = -(cond_Zopp x y).\n1080: -/\n1081: theorem cond_Zopp_negb_spec (x : Bool) (y : Int) :\n1082:     ⦃⌜True⌝⦄\n1083:     cond_Zopp_negb x y\n1084:     ⦃⇓result => ⌜result = -(if x then -y else y)⌝⦄ := by\n1085:   intro _\n1086:   unfold cond_Zopp_negb\n1087:   rfl\n1088: \n1089: /-- Absolute value preservation under conditional opposite\n1090: \n1091:     The absolute value of cond_Zopp b m equals |m|.\n1092:     This shows that conditional negation preserves magnitude.\n1093: -/\n1094: def abs_cond_Zopp (_b : Bool) (m : Int) : Id Int :=\n1095:   (Int.natAbs m : Int)\n1096: \n1097: /-- Specification: Conditional opposite preserves magnitude\n1098: \n1099:     The absolute value is preserved: |cond_Zopp b m| = |m|\n1100:     regardless of the boolean condition b.\n1101: -/\n1102: theorem abs_cond_Zopp_spec (b : Bool) (m : Int) :\n1103:     ⦃⌜True⌝⦄\n1104:     abs_cond_Zopp b m\n1105:     ⦃⇓result => ⌜result = (Int.natAbs m : Int)⌝⦄ := by\n1106:   intro _\n1107:   unfold abs_cond_Zopp\n1108:   rfl\n1109: \n1110: /-- Absolute value via conditional opposite\n1111: \n1112:     Computes |m| using cond_Zopp based on the sign test.\n1113:     This shows how absolute value can be implemented using\n1114:     conditional negation.\n1115: -/\n1116: def cond_Zopp_Zlt_bool (m : Int) : Id Int :=\n1117:   (Int.natAbs m : Int)\n1118: \n1119: /-- Specification: Absolute value computation\n1120: \n1121:     Using conditional opposite with a sign test computes the\n1122:     absolute value: cond_Zopp (m < 0) m = |m|.\n1123: -/\n1124: theorem cond_Zopp_Zlt_bool_spec (m : Int) :\n1125:     ⦃⌜True⌝⦄\n1126:     cond_Zopp_Zlt_bool m\n1127:     ⦃⇓result => ⌜result = (Int.natAbs m : Int)⌝⦄ := by\n1128:   intro _\n1129:   unfold cond_Zopp_Zlt_bool\n1130:   rfl\n1131: \n1132: /-- Equality test with conditional opposite\n1133: \n1134:     Shows that Zeq_bool (cond_Zopp s m) n = Zeq_bool m (cond_Zopp s n).\n1135:     This demonstrates the symmetry of conditional negation in equality tests.\n1136: -/\n1137: def Zeq_bool_cond_Zopp (s : Bool) (m n : Int) : Id Bool :=\n1138:   decide (((if s then -m else m) = n) = (m = (if s then -n else n)))\n1139: \n1140: /-- Specification: Conditional opposite commutes with equality\n1141: \n1142:     The equality test is preserved when moving conditional negation\n1143:     between arguments: Zeq_bool (cond_Zopp s m) n = Zeq_bool m (cond_Zopp s n).\n1144: -/\n1145: theorem Zeq_bool_cond_Zopp_spec (s : Bool) (m n : Int) :\n1146:     ⦃⌜True⌝⦄\n1147:     Zeq_bool_cond_Zopp s m n\n1148:     ⦃⇓result => ⌜result = decide (((if s then -m else m) = n) = (m = (if s then -n else n)))⌝⦄ := by\n1149:   intro _\n1150:   unfold Zeq_bool_cond_Zopp\n1151:   rfl\n1152: \n1153: end CondZopp\n1154: \n1155: section FastPower\n1156: \n1157: /-- Fast exponentiation for positive exponents\n1158: \n1159:     Computes v^e efficiently using repeated squaring.\n1160:     This provides O(log e) complexity instead of O(e).\n1161: -/\n1162: def Zfast_pow_pos (v : Int) (e : Nat) : Id Int :=\n1163:   v^e  -- Lean's built-in power is already efficient\n1164: \n1165: /-- Specification: Fast power computes correct result\n1166: \n1167:     The fast exponentiation algorithm computes the same result\n1168:     as naive exponentiation but with better complexity.\n1169: -/\n1170: theorem Zfast_pow_pos_spec (v : Int) (e : Nat) :\n1171:     ⦃⌜True⌝⦄\n1172:     Zfast_pow_pos v e\n1173:     ⦃⇓result => ⌜result = v^e⌝⦄ := by\n1174:   intro _\n1175:   unfold Zfast_pow_pos\n1176:   rfl\n1177: \n1178: end FastPower\n1179: \n1180: section FasterDiv\n1181: \n1182: /-- Fast Euclidean division for integers\n1183: \n1184:     Implements Euclidean division that always returns a non-negative remainder.\n1185:     For integers a and b with b ≠ 0, returns (q, r) such that:\n1186:     - a = b * q + r\n1187:     - 0 ≤ r < |b|\n1188: \n1189:     This implementation uses Lean's built-in Euclidean division operators.\n1190: -/\n1191: def Zfast_div_eucl (a b : Int) : Id (Int × Int) :=\n1192:   if b = 0 then\n1193:     return (0, a)\n1194:   else\n1195:     -- Lean's built-in division is already Euclidean division\n1196:     return (a / b, a % b)\n1197: \n1198: /-- Specification: Fast division computes correct quotient and remainder\n1199: \n1200:     The fast division algorithm produces the same result as the\n1201:     standard Euclidean division with guaranteed non-negative remainder.\n1202: -/\n1203: theorem Zfast_div_eucl_spec (a b : Int) :\n1204:     ⦃⌜b ≠ 0⌝⦄\n1205:     Zfast_div_eucl a b\n1206:     ⦃⇓result => ⌜let (q, r) := result\n1207:                 a = b * q + r ∧ 0 ≤ r ∧ r < b.natAbs⌝⦄ := by\n1208:   intro hb\n1209:   unfold Zfast_div_eucl\n1210: \n1211:   -- Split on b = 0 case (contradicts precondition)\n1212:   split\n1213:   · -- Case: b = 0\n1214:     rename_i h_bzero\n1215:     exact absurd h_bzero hb\n1216: \n1217:   · -- Case: b ≠ 0\n1218:     -- Use Lean's built-in Euclidean division properties\n1219:     constructor\n1220:     · -- Prove: a = b * (a / b) + (a % b)\n1221:       calc a = a % b + b * (a / b) := (Int.emod_add_ediv a b).symm\n1222:            _ = a % b + (a / b) * b := by rw [Int.mul_comm b]\n1223:            _ = b * (a / b) + a % b := by rw [Int.add_comm, Int.mul_comm]\n1224: \n1225:     constructor\n1226:     · -- Prove: 0 ≤ a % b\n1227:       exact Int.emod_nonneg a hb\n1228: \n1229:     · -- Prove: a % b < b.natAbs\n1230:       exact Int.emod_lt a hb\n1231: \n1232: end FasterDiv\n1233: \n1234: section Iteration\n1235: \n1236: /-- Generic iteration of a function\n1237: \n1238:     Applies function f to x a total of n times.\n1239:     This provides a generic iteration construct used\n1240:     throughout the formalization.\n1241: -/\n1242: def iter_nat {A : Type} (f : A → A) (n : Nat) (x : A) : Id A :=\n1243:   match n with\n1244:   | 0 => x\n1245:   | n'+1 => f (iter_nat f n' x).run\n1246: \n1247: /-- Specification: Iteration applies function n times\n1248: \n1249:     The iteration operation satisfies:\n1250:     - iter_nat f 0 x = x\n1251:     - iter_nat f (n+1) x = f (iter_nat f n x)\n1252: \n1253:     This captures the fundamental iteration pattern.\n1254: -/\n1255: theorem iter_nat_spec {A : Type} (f : A → A) (n : Nat) (x : A) :\n1256:     ⦃⌜True⌝⦄\n1257:     iter_nat f n x\n1258:     ⦃⇓result => ⌜result = f^[n] x⌝⦄ := by\n1259:   intro _\n1260:   induction n with\n1261:   | zero =>\n1262:     unfold iter_nat\n1263:     simp [Function.iterate_zero]\n1264:     rfl\n1265:   | succ n' ih =>\n1266:     unfold iter_nat\n1267:     simp [Function.iterate_succ_apply']\n1268:     -- Need to relate f (iter_nat f n' x).run to f (f^[n'] x)\n1269:     -- This should follow from ih\n1270:     have h : (iter_nat f n' x).run = f^[n'] x := by\n1271:       exact ih\n1272:     rw [h]\n1273:     rfl\n1274: \n1275: /-- Successor property for iteration\n1276: \n1277:     Shows that iter_nat f (S p) x = f (iter_nat f p x).\n1278:     This is the successor case of the iteration recursion.\n1279: -/\n1280: def iter_nat_S {A : Type} (f : A → A) (p : Nat) (x : A) : Id A :=\n1281:   f (iter_nat f p x).run\n1282: \n1283: /-- Specification: Iteration successor formula\n1284: \n1285:     Iterating S p times is equivalent to iterating p times\n1286:     followed by one more application of f. This captures\n1287:     the recursive nature of iteration.\n1288: -/\n1289: theorem iter_nat_S_spec {A : Type} (f : A → A) (p : Nat) (x : A) :\n1290:     ⦃⌜True⌝⦄\n1291:     iter_nat_S f p x\n1292:     ⦃⇓result => ⌜result = f (iter_nat f p x).run⌝⦄ := by\n1293:   intro _\n1294:   unfold iter_nat_S\n1295:   rfl\n1296: \n1297: /-- Iteration addition formula\n1298: \n1299:     Shows that iter_nat f (p + q) x = iter_nat f p (iter_nat f q x).\n1300:     This captures the additive property of iteration counts.\n1301: -/\n1302: def iter_nat_plus {A : Type} (f : A → A) (p q : Nat) (x : A) : Id A :=\n1303:   (iter_nat f p (iter_nat f q x).run).run\n1304: \n1305: /-- Specification: Iteration count addition\n1306: \n1307:     Iterating p + q times is equivalent to iterating q times\n1308:     followed by iterating p times. This fundamental property\n1309:     allows decomposition of iterations.\n1310: -/\n1311: theorem iter_nat_plus_spec {A : Type} (f : A → A) (p q : Nat) (x : A) :\n1312:     ⦃⌜True⌝⦄\n1313:     iter_nat_plus f p q x\n1314:     ⦃⇓result => ⌜result = (iter_nat f p (iter_nat f q x).run).run⌝⦄ := by\n1315:   intro _\n1316:   unfold iter_nat_plus\n1317:   rfl\n1318: \n1319: /-- Relationship between positive and natural iteration\n1320: \n1321:     For positive numbers, iter_pos equals iter_nat composed\n1322:     with conversion to natural numbers.\n1323: -/\n1324: def iter_pos_nat {A : Type} (f : A → A) (p : Nat) (x : A) : Id A :=\n1325:   (iter_nat f p x).run\n1326: \n1327: /-- Specification: Positive iteration via naturals\n1328: \n1329:     Iteration with positive numbers can be expressed through\n1330:     natural number iteration after conversion. This allows\n1331:     unified reasoning about different iteration types.\n1332: -/\n1333: theorem iter_pos_nat_spec {A : Type} (f : A → A) (p : Nat) (x : A) :\n1334:     ⦃⌜p > 0⌝⦄\n1335:     iter_pos_nat f p x\n1336:     ⦃⇓result => ⌜result = (iter_nat f p x).run⌝⦄ := by\n1337:   intro _\n1338:   unfold iter_pos_nat\n1339:   rfl\n1340: \n1341: end Iteration\n1342: \n1343: end FloatSpec.Core.Zaux\n1344: \n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "1   : /-\n2   : This file is part of the Flocq formalization of floating-point\n3   : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4   : \n5   : Original Copyright (C) 2011-2018 Sylvie Boldo\n6   : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7   : \n8   : This library is free software; you can redistribute it and/or\n9   : modify it under the terms of the GNU Lesser General Public\n10  : License as published by the Free Software Foundation; either\n11  : version 3 of the License, or (at your option) any later version.\n12  : \n13  : This library is distributed in the hope that it will be useful,\n14  : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15  : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16  : COPYING file for more details.\n17  : -/\n18  : \n19  : import Std.Do.Triple\n20  : import Std.Tactic.Do\n21  : import Mathlib.Tactic\n22  : \n23  : open Std.Do\n24  : \n25  : namespace FloatSpec.Core.Zaux\n26  : \n27  : section Zmissing\n28  : \n29  : /-- Cancellation law for opposite in integer inequalities\n30  : \n31  :     If -y ≤ -x, then x ≤ y. This is a basic property used throughout\n32  :     the formalization for manipulating integer inequalities.\n33  : -/\n34  : def Zopp_le_cancel (x y : Int) : Id Int :=\n35  :   if x ≤ y then 1 else 0\n36  : \n37  : /-- Specification: Opposite cancellation preserves order\n38  : \n39  :     The cancellation operation ensures that if the negatives are ordered,\n40  :     then the original values have the reverse order relationship.\n41  : -/\n42  : theorem Zopp_le_cancel_spec (x y : Int) :\n43  :     ⦃⌜-y ≤ -x⌝⦄\n44  :     Zopp_le_cancel x y\n45  :     ⦃⇓result => ⌜result = if x ≤ y then 1 else 0⌝⦄ := by\n46  :   intro h\n47  :   unfold Zopp_le_cancel\n48  :   -- From -y ≤ -x, we can deduce x ≤ y\n49  :   have : x ≤ y := Int.neg_le_neg_iff.mp h\n50  :   simp [this]\n51  :   rfl\n52  : \n53  : /-- Greater-than implies not equal for integers\n54  : \n55  :     If y < x, then x ≠ y. This captures the asymmetry of the\n56  :     less-than relation on integers.\n57  : -/\n58  : def Zgt_not_eq (x y : Int) : Id Bool :=\n59  :   decide (x ≠ y)\n60  : \n61  : /-- Specification: Strict inequality implies non-equality\n62  : \n63  :     The operation verifies that strict ordering relationships\n64  :     guarantee distinctness of values.\n65  : -/\n66  : theorem Zgt_not_eq_spec (x y : Int) :\n67  :     ⦃⌜y < x⌝⦄\n68  :     Zgt_not_eq x y\n69  :     ⦃⇓result => ⌜result = (x ≠ y)⌝⦄ := by\n70  :   intro h\n71  :   unfold Zgt_not_eq\n72  :   -- From y < x, we can deduce x ≠ y\n73  :   have : x ≠ y := ne_of_gt h\n74  :   simp [this]\n75  :   rfl\n76  : \n77  : end Zmissing\n78  : \n79  : section ProofIrrelevance\n80  : \n81  : /-- Boolean equality irrelevance principle\n82  : \n83  :     Establishes that all proofs of boolean equality are equal.\n84  :     This is fundamental for working with decidable propositions.\n85  : -/\n86  : def eqbool_irrelevance (b : Bool) (_h1 _h2 : b = true) : Id Bool :=\n87  :   true\n88  : \n89  : /-- Specification: Boolean proof irrelevance\n90  : \n91  :     Any two proofs that a boolean equals true are themselves equal.\n92  :     This captures the principle of proof irrelevance for booleans.\n93  : -/\n94  : theorem eqbool_irrelevance_spec (b : Bool) (h1 h2 : b = true) :\n95  :     ⦃⌜b = true⌝⦄\n96  :     eqbool_irrelevance b h1 h2\n97  :     ⦃⇓result => ⌜result = true⌝⦄ := by\n98  :   intro _\n99  :   unfold eqbool_irrelevance\n100 :   rfl\n101 : \n102 : end ProofIrrelevance\n103 : \n104 : section EvenOdd\n105 : \n106 : /-- Existence of even/odd decomposition for integers\n107 : \n108 :     Every integer can be written as 2*p + r where r is 0 or 1\n109 :     depending on whether the integer is even or odd.\n110 : -/\n111 : def Zeven_ex (x : Int) : Id (Int × Int) :=\n112 :   let p := x / 2\n113 :   let r := x % 2\n114 :   (p, r)\n115 : \n116 : /-- Specification: Even/odd decomposition exists\n117 : \n118 :     For any integer x, there exists p such that:\n119 :     - x = 2*p if x is even\n120 :     - x = 2*p + 1 if x is odd\n121 : \n122 :     This captures the fundamental division algorithm for base 2.\n123 : -/\n124 : theorem Zeven_ex_spec (x : Int) :\n125 :     ⦃⌜True⌝⦄\n126 :     Zeven_ex x\n127 :     ⦃⇓result => ⌜let (p, r) := result\n128 :                 x = 2 * p + r ∧ (r = 0 ∨ r = 1)⌝⦄ := by\n129 :   intro _\n130 :   unfold Zeven_ex\n131 :   -- After unfolding, the goal should be about (x / 2, x % 2)\n132 :   -- We need to show x = 2 * (x / 2) + x % 2 ∧ (x % 2 = 0 ∨ x % 2 = 1)\n133 :   show x = 2 * (Id.run (x / 2, x % 2)).1 + (Id.run (x / 2, x % 2)).2 ∧\n134 :        ((Id.run (x / 2, x % 2)).2 = 0 ∨ (Id.run (x / 2, x % 2)).2 = 1)\n135 :   simp only [Id.run]\n136 :   constructor\n137 :   · -- Prove: x = 2 * (x / 2) + (x % 2)\n138 :     -- Use Lean's theorem: b * (a / b) + a % b = a\n139 :     have h := Int.emod_add_ediv x 2\n140 :     -- h: x % 2 + 2 * (x / 2) = x\n141 :     rw [Int.add_comm] at h\n142 :     exact h.symm\n143 :   · -- Prove: x % 2 = 0 ∨ x % 2 = 1\n144 :     exact Int.emod_two_eq_zero_or_one x\n145 : \n146 : end EvenOdd\n147 : \n148 : section Zpower\n149 : \n150 : /-- Power addition formula for integers\n151 : \n152 :     Computes the product of powers: n^(k1+k2) = n^k1 * n^k2\n153 :     when both exponents are non-negative.\n154 : -/\n155 : def Zpower_plus (n k1 k2 : Int) : Id Int :=\n156 :   if k1 ≥ 0 && k2 ≥ 0 then\n157 :     n^(k1.natAbs + k2.natAbs)\n158 :   else\n159 :     0  -- Undefined for negative exponents in this context\n160 : \n161 : /-- Specification: Power addition rule\n162 : \n163 :     The power operation satisfies the exponential law:\n164 :     n^(k1 + k2) = n^k1 * n^k2 for non-negative exponents.\n165 : \n166 :     This is a fundamental property of exponentiation used\n167 :     throughout floating-point arithmetic.\n168 : -/\n169 : theorem Zpower_plus_spec (n k1 k2 : Int) :\n170 :     ⦃⌜0 ≤ k1 ∧ 0 ≤ k2⌝⦄\n171 :     Zpower_plus n k1 k2\n172 :     ⦃⇓result => ⌜result = n^(k1.natAbs + k2.natAbs)⌝⦄ := by\n173 :   intro ⟨h1, h2⟩\n174 :   unfold Zpower_plus\n175 :   simp [h1, h2]\n176 :   rfl\n177 : \n178 : /-- Radix type for floating-point bases\n179 : \n180 :     A radix must be at least 2. This structure captures the\n181 :     constraint that floating-point number systems need a base\n182 :     greater than 1 for meaningful representation.\n183 : -/\n184 : structure Radix where\n185 :   /-- The radix value, must be at least 2 -/\n186 :   val : Int\n187 :   /-- Proof that the radix is at least 2 -/\n188 :   prop : 2 ≤ val\n189 : \n190 : /-- Standard binary radix\n191 : \n192 :     The most common radix for floating-point arithmetic is base 2.\n193 :     This definition provides the standard binary radix.\n194 : -/\n195 : def radix2 : Radix :=\n196 :   ⟨2, by simp⟩\n197 : \n198 : /-- Relationship between integer power and natural power\n199 : \n200 :     For non-negative exponents, Zpower equals Zpower_nat\n201 :     composed with absolute value conversion.\n202 : -/\n203 : def Zpower_Zpower_nat (b e : Int) : Id Int :=\n204 :   if e ≥ 0 then\n205 :     b^e.natAbs\n206 :   else\n207 :     0  -- Undefined for negative exponents\n208 : \n209 : /-- Specification: Integer and natural powers coincide\n210 : \n211 :     When the exponent is non-negative, the integer power\n212 :     function agrees with the natural number power function\n213 :     applied to the absolute value of the exponent.\n214 : -/\n215 : theorem Zpower_Zpower_nat_spec (b e : Int) :\n216 :     ⦃⌜0 ≤ e⌝⦄\n217 :     Zpower_Zpower_nat b e\n218 :     ⦃⇓result => ⌜result = b^e.natAbs⌝⦄ := by\n219 :   intro h\n220 :   unfold Zpower_Zpower_nat\n221 :   split\n222 :   · -- Case: e ≥ 0 (which is true given our precondition)\n223 :     rfl\n224 :   · -- Case: ¬(e ≥ 0) (impossible given our precondition)\n225 :     rename_i h_neg\n226 :     -- This case contradicts our precondition\n227 :     exact absurd h h_neg\n228 : \n229 : /-- Successor property for natural power\n230 : \n231 :     Shows that b^(n+1) = b * b^n for natural number exponents.\n232 :     This is the fundamental recursive property of exponentiation.\n233 : -/\n234 : def Zpower_nat_S (b : Int) (e : Nat) : Id Int :=\n235 :   b * b^e\n236 : \n237 : /-- Specification: Power successor formula\n238 : \n239 :     The power function satisfies the recursive relation:\n240 :     b^(S e) = b * b^e. This allows inductive reasoning\n241 :     about powers with natural number exponents.\n242 : -/\n243 : theorem Zpower_nat_S_spec (b : Int) (e : Nat) :\n244 :     ⦃⌜True⌝⦄\n245 :     Zpower_nat_S b e\n246 :     ⦃⇓result => ⌜result = b * b^e⌝⦄ := by\n247 :   intro _\n248 :   unfold Zpower_nat_S\n249 :   rfl\n250 : \n251 : end Zpower\n252 : \n253 : section DivMod\n254 : \n255 : /-- Modulo operation with multiple\n256 : \n257 :     Computes (n mod (a*b)) mod b, which equals n mod b\n258 :     when a > 0 and b ≥ 0.\n259 : -/\n260 : def Zmod_mod_mult (n _a b : Int) : Id Int :=\n261 :   n % b\n262 : \n263 : /-- Specification: Nested modulo simplification\n264 : \n265 :     The modulo operation satisfies: (n mod (a*b)) mod b = n mod b\n266 :     when a is positive and b is non-negative. This allows\n267 :     simplification of nested modulo operations.\n268 : -/\n269 : theorem Zmod_mod_mult_spec (n a b : Int) :\n270 :     ⦃⌜0 < a ∧ 0 ≤ b⌝⦄\n271 :     Zmod_mod_mult n a b\n272 :     ⦃⇓result => ⌜result = n % b⌝⦄ := by\n273 :   intro h\n274 :   unfold Zmod_mod_mult\n275 :   rfl\n276 : \n277 : /-- Division and modulo relationship\n278 : \n279 :     Expresses the quotient-remainder theorem: a = q*b + r\n280 :     where q is the quotient and r is the remainder.\n281 : -/\n282 : def ZOmod_eq (a b : Int) : Id Int :=\n283 :   a % b\n284 : \n285 : /-- Specification: Quotient-remainder decomposition\n286 : \n287 :     Every integer a can be uniquely written as a = q*b + r\n288 :     where q is the quotient and r is the remainder with\n289 :     0 ≤ r < |b| for b ≠ 0.\n290 : -/\n291 : theorem ZOmod_eq_spec (a b : Int) :\n292 :     ⦃⌜b ≠ 0⌝⦄\n293 :     ZOmod_eq a b\n294 :     ⦃⇓result => ⌜result = a % b⌝⦄ := by\n295 :   intro h\n296 :   unfold ZOmod_eq\n297 :   rfl\n298 : \n299 : /-- Division of nested modulo\n300 : \n301 :     Computes (n mod (a*b)) / a, which equals (n/a) mod b\n302 :     under appropriate conditions.\n303 : -/\n304 : def Zdiv_mod_mult (n a b : Int) : Id Int :=\n305 :   if a ≠ 0 && b ≠ 0 then\n306 :     (n / a) % b\n307 :   else\n308 :     0\n309 : \n310 : /-- Specification: Division distributes over modulo\n311 : \n312 :     The operation satisfies: (n mod (a*b)) / a = (n/a) mod b\n313 :     when a and b are non-negative. This is useful for\n314 :     decomposing multi-precision arithmetic operations.\n315 : -/\n316 : theorem Zdiv_mod_mult_spec (n a b : Int) :\n317 :     ⦃⌜0 ≤ a ∧ 0 ≤ b⌝⦄\n318 :     Zdiv_mod_mult n a b\n319 :     ⦃⇓result => ⌜result = if a = 0 || b = 0 then 0 else (n / a) % b⌝⦄ := by\n320 :   intro ⟨ha, hb⟩\n321 :   unfold Zdiv_mod_mult\n322 :   -- Case split on whether a ≠ 0 && b ≠ 0\n323 :   split\n324 :   · -- Case: a ≠ 0 && b ≠ 0\n325 :     rename_i h_both_nonzero\n326 :     -- When both are non-zero, a = 0 || b = 0 is false\n327 :     -- So if a = 0 || b = 0 then 0 else (n / a) % b reduces to (n / a) % b\n328 :     have ha_nonzero : a ≠ 0 := by\n329 :       simp at h_both_nonzero\n330 :       exact h_both_nonzero.1\n331 :     have hb_nonzero : b ≠ 0 := by\n332 :       simp at h_both_nonzero\n333 :       exact h_both_nonzero.2\n334 :     simp [ha_nonzero, hb_nonzero]\n335 :     rfl\n336 :   · -- Case: ¬(a ≠ 0 && b ≠ 0), which means a = 0 || b = 0\n337 :     rename_i h_some_zero\n338 :     -- When at least one is zero, a = 0 || b = 0 is true\n339 :     -- So if a = 0 || b = 0 then 0 else (n / a) % b reduces to 0\n340 :     simp at h_some_zero\n341 :     push_neg at h_some_zero\n342 :     -- h_some_zero : a ≠ 0 → b = 0, which is equivalent to a = 0 ∨ b = 0\n343 :     -- We need to show: if a = 0 ∨ b = 0 then 0 else (n / a) % b = 0\n344 :     by_cases ha_zero : a = 0\n345 :     · -- Case: a = 0\n346 :       simp [ha_zero]\n347 :       rfl\n348 :     · -- Case: a ≠ 0, then by h_some_zero, b = 0\n349 :       have hb_zero : b = 0 := h_some_zero ha_zero\n350 :       simp [hb_zero]\n351 :       rfl\n352 : \n353 : /-- Nested modulo with multiplication\n354 : \n355 :     Computes (n mod (a*b)) mod b using the quotient-based\n356 :     remainder formula. This is equivalent to n mod b for\n357 :     appropriate signs.\n358 : -/\n359 : def ZOmod_mod_mult (n _a b : Int) : Id Int :=\n360 :   n % b\n361 : \n362 : /-- Specification: Nested modulo simplification (quotient version)\n363 : \n364 :     The quotient-based modulo operation satisfies:\n365 :     (n mod (a*b)) mod b = n mod b. This allows simplification\n366 :     of nested modulo operations in quotient arithmetic.\n367 : -/\n368 : theorem ZOmod_mod_mult_spec (n a b : Int) :\n369 :     ⦃⌜b ≠ 0⌝⦄\n370 :     ZOmod_mod_mult n a b\n371 :     ⦃⇓result => ⌜result = n % b⌝⦄ := by\n372 :   intro h\n373 :   unfold ZOmod_mod_mult\n374 :   rfl\n375 : \n376 : /-- Quotient addition with sign consideration\n377 : \n378 :     Computes quot(a+b, c) in terms of individual quotients\n379 :     and the quotient of remainders, considering signs.\n380 : -/\n381 : def ZOdiv_plus (a b c : Int) : Id Int :=\n382 :   if c ≠ 0 then\n383 :     a / c + b / c + ((a % c + b % c) / c)\n384 :   else\n385 :     0\n386 : \n387 : /-- Specification: Quotient of sum decomposition\n388 : \n389 :     The quotient of a sum can be expressed as:\n390 :     quot(a+b, c) = quot(a, c) + quot(b, c) + quot(rem(a, c) + rem(b, c), c)\n391 :     when a*b ≥ 0. This decomposition is crucial for multi-precision\n392 :     arithmetic operations.\n393 : -/\n394 : theorem ZOdiv_plus_spec (a b c : Int) :\n395 :     ⦃⌜0 ≤ a * b ∧ c ≠ 0⌝⦄\n396 :     ZOdiv_plus a b c\n397 :     ⦃⇓result => ⌜result = a / c + b / c + ((a % c + b % c) / c)⌝⦄ := by\n398 :   intro ⟨hab, hc⟩\n399 :   unfold ZOdiv_plus\n400 :   -- Since c ≠ 0, the if condition is true\n401 :   simp [hc]\n402 :   rfl\n403 : \n404 : end DivMod\n405 : \n406 : section BooleanComparisons\n407 : \n408 : /-- Boolean equality test for integers\n409 : \n410 :     Tests whether two integers are equal, returning a boolean.\n411 :     This provides a decidable equality test.\n412 : -/\n413 : def Zeq_bool (x y : Int) : Id Bool :=\n414 :   decide (x = y)\n415 : \n416 : /-- Specification: Boolean equality test\n417 : \n418 :     The boolean equality test returns true if and only if\n419 :     the integers are equal. This provides a computational\n420 :     version of equality.\n421 : -/\n422 : theorem Zeq_bool_spec (x y : Int) :\n423 :     ⦃⌜True⌝⦄\n424 :     Zeq_bool x y\n425 :     ⦃⇓result => ⌜result = decide (x = y)⌝⦄ := by\n426 :   intro _\n427 :   unfold Zeq_bool\n428 :   rfl\n429 : \n430 : /-- Boolean less-or-equal test for integers\n431 : \n432 :     Tests whether x ≤ y, returning a boolean result.\n433 :     This provides a decidable ordering test.\n434 : -/\n435 : def Zle_bool (x y : Int) : Id Bool :=\n436 :   decide (x ≤ y)\n437 : \n438 : /-- Specification: Boolean ordering test\n439 : \n440 :     The boolean less-or-equal test returns true if and only if\n441 :     x ≤ y. This provides a computational version of the ordering.\n442 : -/\n443 : theorem Zle_bool_spec (x y : Int) :\n444 :     ⦃⌜True⌝⦄\n445 :     Zle_bool x y\n446 :     ⦃⇓result => ⌜result = decide (x ≤ y)⌝⦄ := by\n447 :   intro _\n448 :   unfold Zle_bool\n449 :   rfl\n450 : \n451 : /-- Boolean strict less-than test for integers\n452 : \n453 :     Tests whether x < y, returning a boolean result.\n454 :     This provides a decidable strict ordering test.\n455 : -/\n456 : def Zlt_bool (x y : Int) : Id Bool :=\n457 :   decide (x < y)\n458 : \n459 : /-- Specification: Boolean strict ordering test\n460 : \n461 :     The boolean less-than test returns true if and only if\n462 :     x < y. This provides a computational version of strict ordering.\n463 : -/\n464 : theorem Zlt_bool_spec (x y : Int) :\n465 :     ⦃⌜True⌝⦄\n466 :     Zlt_bool x y\n467 :     ⦃⇓result => ⌜result = decide (x < y)⌝⦄ := by\n468 :   intro _\n469 :   unfold Zlt_bool\n470 :   rfl\n471 : \n472 : /-- Boolean equality is true when equal\n473 : \n474 :     x = y implies Zeq_bool x y = true. This provides\n475 :     the forward direction of boolean equality correctness.\n476 : -/\n477 : def Zeq_bool_true (_ _ : Int) : Id Bool :=\n478 :   true\n479 : \n480 : /-- Specification: Equality implies true\n481 : \n482 :     When two integers are equal, the boolean equality test\n483 :     returns true. This is half of the correctness property\n484 :     for boolean equality.\n485 : -/\n486 : theorem Zeq_bool_true_spec (x y : Int) :\n487 :     ⦃⌜x = y⌝⦄\n488 :     Zeq_bool_true x y\n489 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n490 :   intro _\n491 :   unfold Zeq_bool_true\n492 :   rfl\n493 : \n494 : /-- Boolean equality is false when not equal\n495 : \n496 :     x ≠ y implies Zeq_bool x y = false. This provides\n497 :     the reverse direction of boolean equality correctness.\n498 : -/\n499 : def Zeq_bool_false (_ _ : Int) : Id Bool :=\n500 :   false\n501 : \n502 : /-- Specification: Inequality implies false\n503 : \n504 :     When two integers are not equal, the boolean equality test\n505 :     returns false. This completes the correctness property\n506 :     for boolean equality.\n507 : -/\n508 : theorem Zeq_bool_false_spec (x y : Int) :\n509 :     ⦃⌜x ≠ y⌝⦄\n510 :     Zeq_bool_false x y\n511 :     ⦃⇓result => ⌜result = false⌝⦄ := by\n512 :   intro _\n513 :   unfold Zeq_bool_false\n514 :   rfl\n515 : \n516 : /-- Boolean equality is reflexive\n517 : \n518 :     Zeq_bool x x = true for all x. This captures\n519 :     the reflexivity of equality in boolean form.\n520 : -/\n521 : def Zeq_bool_diag (_ : Int) : Id Bool :=\n522 :   true\n523 : \n524 : /-- Specification: Reflexivity of boolean equality\n525 : \n526 :     The boolean equality test always returns true when\n527 :     comparing a value with itself. This is the boolean\n528 :     version of reflexivity.\n529 : -/\n530 : theorem Zeq_bool_diag_spec (x : Int) :\n531 :     ⦃⌜True⌝⦄\n532 :     Zeq_bool_diag x\n533 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n534 :   intro _\n535 :   unfold Zeq_bool_diag\n536 :   rfl\n537 : \n538 : /-- Opposite preserves equality testing\n539 : \n540 :     Zeq_bool(-x, y) = Zeq_bool(x, -y). This shows that\n541 :     negation can be moved between arguments in equality tests.\n542 : -/\n543 : def Zeq_bool_opp (x y : Int) : Id Bool :=\n544 :   decide ((-x = y) = (x = -y))\n545 : \n546 : /-- Specification: Negation commutes with equality\n547 : \n548 :     The equality test is preserved when negating both sides\n549 :     or moving negation between arguments. This is useful for\n550 :     simplifying equality tests involving negations.\n551 : -/\n552 : theorem Zeq_bool_opp_spec (x y : Int) :\n553 :     ⦃⌜True⌝⦄\n554 :     Zeq_bool_opp x y\n555 :     ⦃⇓result => ⌜result = decide ((-x = y) = (x = -y))⌝⦄ := by\n556 :   intro _\n557 :   unfold Zeq_bool_opp\n558 :   rfl\n559 : \n560 : /-- Double opposite preserves equality testing\n561 : \n562 :     Zeq_bool(-x, -y) = Zeq_bool(x, y). This shows that\n563 :     negating both arguments preserves the equality test.\n564 : -/\n565 : def Zeq_bool_opp' (x y : Int) : Id Bool :=\n566 :   decide ((-x = -y) = (x = y))\n567 : \n568 : /-- Specification: Double negation preserves equality\n569 : \n570 :     The equality test is preserved when negating both\n571 :     arguments. This follows from the fact that negation\n572 :     is an injection on integers.\n573 : -/\n574 : theorem Zeq_bool_opp'_spec (x y : Int) :\n575 :     ⦃⌜True⌝⦄\n576 :     Zeq_bool_opp' x y\n577 :     ⦃⇓result => ⌜result = decide ((-x = -y) = (x = y))⌝⦄ := by\n578 :   intro _\n579 :   unfold Zeq_bool_opp'\n580 :   rfl\n581 : \n582 : /-- Boolean less-or-equal is true when satisfied\n583 : \n584 :     x ≤ y implies Zle_bool x y = true. This provides\n585 :     the forward direction of boolean ordering correctness.\n586 : -/\n587 : def Zle_bool_true (_ _ : Int) : Id Bool :=\n588 :   true\n589 : \n590 : /-- Specification: Less-or-equal implies true\n591 : \n592 :     When x ≤ y holds, the boolean less-or-equal test\n593 :     returns true. This is the soundness property for\n594 :     boolean ordering.\n595 : -/\n596 : theorem Zle_bool_true_spec (x y : Int) :\n597 :     ⦃⌜x ≤ y⌝⦄\n598 :     Zle_bool_true x y\n599 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n600 :   intro _\n601 :   unfold Zle_bool_true\n602 :   rfl\n603 : \n604 : /-- Boolean less-or-equal is false when violated\n605 : \n606 :     y < x implies Zle_bool x y = false. This provides\n607 :     the reverse direction of boolean ordering correctness.\n608 : -/\n609 : def Zle_bool_false (_ _ : Int) : Id Bool :=\n610 :   false\n611 : \n612 : /-- Specification: Greater-than implies false\n613 : \n614 :     When y < x holds, the boolean less-or-equal test\n615 :     returns false. This is the completeness property\n616 :     for boolean ordering.\n617 : -/\n618 : theorem Zle_bool_false_spec (x y : Int) :\n619 :     ⦃⌜y < x⌝⦄\n620 :     Zle_bool_false x y\n621 :     ⦃⇓result => ⌜result = false⌝⦄ := by\n622 :   intro _\n623 :   unfold Zle_bool_false\n624 :   rfl\n625 : \n626 : /-- Boolean less-or-equal with opposite on left\n627 : \n628 :     Zle_bool(-x, y) = Zle_bool(-y, x). This shows how\n629 :     negation on the left relates to swapping with negation.\n630 : -/\n631 : def Zle_bool_opp_l (x y : Int) : Id Bool :=\n632 :   decide ((- x ≤ y) = (- y ≤ x))\n633 : \n634 : /-- Specification: Left negation swaps comparison\n635 : \n636 :     Negating the left argument and swapping gives the same\n637 :     result: Zle_bool(-x, y) = Zle_bool(-y, x).\n638 : -/\n639 : theorem Zle_bool_opp_l_spec (x y : Int) :\n640 :     ⦃⌜True⌝⦄\n641 :     Zle_bool_opp_l x y\n642 :     ⦃⇓result => ⌜result = decide ((- x ≤ y) = (- y ≤ x))⌝⦄ := by\n643 :   intro _\n644 :   unfold Zle_bool_opp_l\n645 :   rfl\n646 : \n647 : /-- Boolean less-or-equal with double opposite\n648 : \n649 :     Zle_bool(-x, -y) = Zle_bool(y, x). This shows that\n650 :     double negation reverses the comparison.\n651 : -/\n652 : def Zle_bool_opp (x y : Int) : Id Bool :=\n653 :   decide ((- x ≤ - y) = (y ≤ x))\n654 : \n655 : /-- Specification: Double negation reverses ordering\n656 : \n657 :     Negating both arguments reverses the comparison:\n658 :     Zle_bool(-x, -y) = Zle_bool(y, x).\n659 : -/\n660 : theorem Zle_bool_opp_spec (x y : Int) :\n661 :     ⦃⌜True⌝⦄\n662 :     Zle_bool_opp x y\n663 :     ⦃⇓result => ⌜result = decide ((- x ≤ - y) = (y ≤ x))⌝⦄ := by\n664 :   intro _\n665 :   unfold Zle_bool_opp\n666 :   rfl\n667 : \n668 : /-- Boolean less-or-equal with opposite on right\n669 : \n670 :     Zle_bool(x, -y) = Zle_bool(y, -x). This shows how\n671 :     negation on the right relates to swapping with negation.\n672 : -/\n673 : def Zle_bool_opp_r (x y : Int) : Id Bool :=\n674 :   decide ((x ≤ - y) = (y ≤ - x))\n675 : \n676 : /-- Specification: Right negation swaps comparison\n677 : \n678 :     Negating the right argument relates to swapping with\n679 :     left negation: Zle_bool(x, -y) = Zle_bool(y, -x).\n680 : -/\n681 : theorem Zle_bool_opp_r_spec (x y : Int) :\n682 :     ⦃⌜True⌝⦄\n683 :     Zle_bool_opp_r x y\n684 :     ⦃⇓result => ⌜result = decide ((x ≤ - y) = (y ≤ - x))⌝⦄ := by\n685 :   intro _\n686 :   unfold Zle_bool_opp_r\n687 :   rfl\n688 : \n689 : /-- Negation of less-or-equal is strict greater-than\n690 : \n691 :     Shows that negb (Zle_bool x y) = Zlt_bool y x.\n692 :     This captures the duality between ≤ and >.\n693 : -/\n694 : def negb_Zle_bool (x y : Int) : Id Bool :=\n695 :   decide (!(x ≤ y) = (y < x))\n696 : \n697 : /-- Specification: Negated ≤ equals strict >\n698 : \n699 :     The negation of x ≤ y is equivalent to y < x. This duality\n700 :     is fundamental for simplifying boolean comparisons.\n701 : -/\n702 : theorem negb_Zle_bool_spec (x y : Int) :\n703 :     ⦃⌜True⌝⦄\n704 :     negb_Zle_bool x y\n705 :     ⦃⇓result => ⌜result = decide (!(x ≤ y) = (y < x))⌝⦄ := by\n706 :   intro _\n707 :   unfold negb_Zle_bool\n708 :   rfl\n709 : \n710 : /-- Negation of strict less-than is greater-or-equal\n711 : \n712 :     Shows that negb (Zlt_bool x y) = Zle_bool y x.\n713 :     This captures the duality between < and ≥.\n714 : -/\n715 : def negb_Zlt_bool (x y : Int) : Id Bool :=\n716 :   decide (!(x < y) = (y ≤ x))\n717 : \n718 : /-- Specification: Negated < equals ≥\n719 : \n720 :     The negation of x < y is equivalent to y ≤ x. This duality\n721 :     allows conversion between strict and non-strict comparisons.\n722 : -/\n723 : theorem negb_Zlt_bool_spec (x y : Int) :\n724 :     ⦃⌜True⌝⦄\n725 :     negb_Zlt_bool x y\n726 :     ⦃⇓result => ⌜result = decide (!(x < y) = (y ≤ x))⌝⦄ := by\n727 :   intro _\n728 :   unfold negb_Zlt_bool\n729 :   rfl\n730 : \n731 : /-- Boolean less-than is true when satisfied\n732 : \n733 :     x < y implies Zlt_bool x y = true. This provides\n734 :     the forward direction of boolean strict ordering correctness.\n735 : -/\n736 : def Zlt_bool_true (_ _ : Int) : Id Bool :=\n737 :   true\n738 : \n739 : /-- Specification: Less-than implies true\n740 : \n741 :     When x < y holds, the boolean less-than test\n742 :     returns true. This is the soundness property for\n743 :     boolean strict ordering.\n744 : -/\n745 : theorem Zlt_bool_true_spec (x y : Int) :\n746 :     ⦃⌜x < y⌝⦄\n747 :     Zlt_bool_true x y\n748 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n749 :   intro _\n750 :   unfold Zlt_bool_true\n751 :   rfl\n752 : \n753 : /-- Boolean less-than is false when violated\n754 : \n755 :     y ≤ x implies Zlt_bool x y = false. This provides\n756 :     the reverse direction of boolean strict ordering correctness.\n757 : -/\n758 : def Zlt_bool_false (_ _ : Int) : Id Bool :=\n759 :   false\n760 : \n761 : /-- Specification: Greater-or-equal implies false\n762 : \n763 :     When y ≤ x holds, the boolean less-than test\n764 :     returns false. This is the completeness property\n765 :     for boolean strict ordering.\n766 : -/\n767 : theorem Zlt_bool_false_spec (x y : Int) :\n768 :     ⦃⌜y ≤ x⌝⦄\n769 :     Zlt_bool_false x y\n770 :     ⦃⇓result => ⌜result = false⌝⦄ := by\n771 :   intro _\n772 :   unfold Zlt_bool_false\n773 :   rfl\n774 : \n775 : /-- Boolean less-than with opposite on left\n776 : \n777 :     Zlt_bool(-x, y) = Zlt_bool(-y, x). This shows how\n778 :     negation on the left relates to swapping with negation.\n779 : -/\n780 : def Zlt_bool_opp_l (x y : Int) : Id Bool :=\n781 :   decide ((- x < y) = (- y < x))\n782 : \n783 : /-- Specification: Left negation swaps strict comparison\n784 : \n785 :     Negating the left argument and swapping gives the same\n786 :     result: Zlt_bool(-x, y) = Zlt_bool(-y, x).\n787 : -/\n788 : theorem Zlt_bool_opp_l_spec (x y : Int) :\n789 :     ⦃⌜True⌝⦄\n790 :     Zlt_bool_opp_l x y\n791 :     ⦃⇓result => ⌜result = decide ((- x < y) = (- y < x))⌝⦄ := by\n792 :   intro _\n793 :   unfold Zlt_bool_opp_l\n794 :   rfl\n795 : \n796 : /-- Boolean less-than with opposite on right\n797 : \n798 :     Zlt_bool(x, -y) = Zlt_bool(y, -x). This shows how\n799 :     negation on the right relates to swapping with negation.\n800 : -/\n801 : def Zlt_bool_opp_r (x y : Int) : Id Bool :=\n802 :   decide ((x < - y) = (y < - x))\n803 : \n804 : /-- Specification: Right negation swaps strict comparison\n805 : \n806 :     Negating the right argument relates to swapping with\n807 :     left negation: Zlt_bool(x, -y) = Zlt_bool(y, -x).\n808 : -/\n809 : theorem Zlt_bool_opp_r_spec (x y : Int) :\n810 :     ⦃⌜True⌝⦄\n811 :     Zlt_bool_opp_r x y\n812 :     ⦃⇓result => ⌜result = decide ((x < - y) = (y < - x))⌝⦄ := by\n813 :   intro _\n814 :   unfold Zlt_bool_opp_r\n815 :   rfl\n816 : \n817 : /-- Boolean less-than with double opposite\n818 : \n819 :     Zlt_bool(-x, -y) = Zlt_bool(y, x). This shows that\n820 :     double negation reverses the strict comparison.\n821 : -/\n822 : def Zlt_bool_opp (x y : Int) : Id Bool :=\n823 :   decide ((- x < - y) = (y < x))\n824 : \n825 : /-- Specification: Double negation reverses strict ordering\n826 : \n827 :     Negating both arguments reverses the comparison:\n828 :     Zlt_bool(-x, -y) = Zlt_bool(y, x).\n829 : -/\n830 : theorem Zlt_bool_opp_spec (x y : Int) :\n831 :     ⦃⌜True⌝⦄\n832 :     Zlt_bool_opp x y\n833 :     ⦃⇓result => ⌜result = decide ((- x < - y) = (y < x))⌝⦄ := by\n834 :   intro _\n835 :   unfold Zlt_bool_opp\n836 :   rfl\n837 : \n838 : end BooleanComparisons\n839 : \n840 : section Zcompare\n841 : \n842 : /-- Three-way comparison for integers\n843 : \n844 :     Returns Lt if x < y, Eq if x = y, and Gt if x > y.\n845 :     This provides a complete ordering comparison in one operation.\n846 : -/\n847 : def Zcompare (x y : Int) : Id Ordering :=\n848 :   if x < y then Ordering.lt\n849 :   else if x = y then Ordering.eq\n850 :   else Ordering.gt\n851 : \n852 : /-- Specification: Three-way comparison correctness\n853 : \n854 :     The comparison function returns:\n855 :     - Lt when x < y\n856 :     - Eq when x = y\n857 :     - Gt when x > y\n858 : \n859 :     This captures the complete ordering of integers.\n860 : -/\n861 : theorem Zcompare_spec (x y : Int) :\n862 :     ⦃⌜True⌝⦄\n863 :     Zcompare x y\n864 :     ⦃⇓result => ⌜(result = Ordering.lt ↔ x < y) ∧\n865 :                 (result = Ordering.eq ↔ x = y) ∧\n866 :                 (result = Ordering.gt ↔ y < x)⌝⦄ := by\n867 :   intro _\n868 :   unfold Zcompare\n869 : \n870 :   -- Split on whether x < y\n871 :   split\n872 :   · -- Case: x < y\n873 :     rename_i h_lt\n874 :     constructor\n875 :     · -- Prove: Ordering.lt = Ordering.lt ↔ x < y\n876 :       exact ⟨fun _ => h_lt, fun _ => rfl⟩\n877 :     constructor\n878 :     · -- Prove: Ordering.lt = Ordering.eq ↔ x = y\n879 :       constructor\n880 :       · intro h_eq\n881 :         -- Ordering.lt = Ordering.eq is impossible\n882 :         cases h_eq\n883 :       · intro h_eq\n884 :         -- If x = y and x < y, contradiction\n885 :         rw [h_eq] at h_lt\n886 :         exact absurd h_lt (lt_irrefl y)\n887 :     · -- Prove: Ordering.lt = Ordering.gt ↔ y < x\n888 :       constructor\n889 :       · intro h_eq\n890 :         -- Ordering.lt = Ordering.gt is impossible\n891 :         cases h_eq\n892 :       · intro h_gt\n893 :         -- If y < x and x < y, contradiction\n894 :         exact absurd h_lt (not_lt.mpr (le_of_lt h_gt))\n895 : \n896 :   · -- Case: ¬(x < y), split on whether x = y\n897 :     rename_i h_not_lt\n898 :     split\n899 :     · -- Case: x = y\n900 :       rename_i h_eq\n901 :       constructor\n902 :       · -- Prove: Ordering.eq = Ordering.lt ↔ x < y\n903 :         constructor\n904 :         · intro h_ord_eq\n905 :           -- Ordering.eq = Ordering.lt is impossible\n906 :           cases h_ord_eq\n907 :         · intro h_lt\n908 :           -- If x < y but ¬(x < y), contradiction\n909 :           exact absurd h_lt h_not_lt\n910 :       constructor\n911 :       · -- Prove: Ordering.eq = Ordering.eq ↔ x = y\n912 :         exact ⟨fun _ => h_eq, fun _ => rfl⟩\n913 :       · -- Prove: Ordering.eq = Ordering.gt ↔ y < x\n914 :         constructor\n915 :         · intro h_ord_eq\n916 :           -- Ordering.eq = Ordering.gt is impossible\n917 :           cases h_ord_eq\n918 :         · intro h_gt\n919 :           -- If y < x and x = y, contradiction\n920 :           rw [← h_eq] at h_gt\n921 :           exact absurd h_gt (lt_irrefl x)\n922 : \n923 :     · -- Case: ¬(x < y) ∧ ¬(x = y), so y < x\n924 :       rename_i h_not_eq\n925 :       -- In this case, y < x\n926 :       have h_gt : y < x := by\n927 :         -- Since ¬(x < y) and ¬(x = y), we must have y < x\n928 :         cases' lt_trichotomy x y with h h\n929 :         · exact absurd h h_not_lt\n930 :         · cases' h with h h\n931 :           · exact absurd h h_not_eq\n932 :           · exact h\n933 : \n934 :       constructor\n935 :       · -- Prove: Ordering.gt = Ordering.lt ↔ x < y\n936 :         constructor\n937 :         · intro h_ord_eq\n938 :           -- Ordering.gt = Ordering.lt is impossible\n939 :           cases h_ord_eq\n940 :         · intro h_lt\n941 :           -- If x < y but ¬(x < y), contradiction\n942 :           exact absurd h_lt h_not_lt\n943 :       constructor\n944 :       · -- Prove: Ordering.gt = Ordering.eq ↔ x = y\n945 :         constructor\n946 :         · intro h_ord_eq\n947 :           -- Ordering.gt = Ordering.eq is impossible\n948 :           cases h_ord_eq\n949 :         · intro h_eq\n950 :           -- If x = y but ¬(x = y), contradiction\n951 :           exact absurd h_eq h_not_eq\n952 :       · -- Prove: Ordering.gt = Ordering.gt ↔ y < x\n953 :         exact ⟨fun _ => h_gt, fun _ => rfl⟩\n954 : \n955 : /-- Comparison returns Lt for less-than\n956 : \n957 :     When x < y, Zcompare returns Lt. This provides\n958 :     a computational witness for the less-than relation.\n959 : -/\n960 : def Zcompare_Lt (_ _ : Int) : Id Ordering :=\n961 :   Ordering.lt\n962 : \n963 : /-- Specification: Less-than yields Lt\n964 : \n965 :     The comparison function returns Lt exactly when x < y.\n966 :     This provides the forward direction of the comparison specification.\n967 : -/\n968 : theorem Zcompare_Lt_spec (x y : Int) :\n969 :     ⦃⌜x < y⌝⦄\n970 :     Zcompare_Lt x y\n971 :     ⦃⇓result => ⌜result = Ordering.lt⌝⦄ := by\n972 :   intro _\n973 :   unfold Zcompare_Lt\n974 :   rfl\n975 : \n976 : /-- Comparison returns Eq for equality\n977 : \n978 :     When x = y, Zcompare returns Eq. This provides\n979 :     a computational witness for equality.\n980 : -/\n981 : def Zcompare_Eq (_ _ : Int) : Id Ordering :=\n982 :   Ordering.eq\n983 : \n984 : /-- Specification: Equality yields Eq\n985 : \n986 :     The comparison function returns Eq exactly when x = y.\n987 :     This provides decidable equality through comparison.\n988 : -/\n989 : theorem Zcompare_Eq_spec (x y : Int) :\n990 :     ⦃⌜x = y⌝⦄\n991 :     Zcompare_Eq x y\n992 :     ⦃⇓result => ⌜result = Ordering.eq⌝⦄ := by\n993 :   intro _\n994 :   unfold Zcompare_Eq\n995 :   rfl\n996 : \n997 : /-- Comparison returns Gt for greater-than\n998 : \n999 :     When y < x, Zcompare returns Gt. This provides\n1000:     a computational witness for the greater-than relation.\n1001: -/\n1002: def Zcompare_Gt (_ _ : Int) : Id Ordering :=\n1003:   Ordering.gt\n1004: \n1005: /-- Specification: Greater-than yields Gt\n1006: \n1007:     The comparison function returns Gt exactly when y < x.\n1008:     This completes the three cases of integer comparison.\n1009: -/\n1010: theorem Zcompare_Gt_spec (x y : Int) :\n1011:     ⦃⌜y < x⌝⦄\n1012:     Zcompare_Gt x y\n1013:     ⦃⇓result => ⌜result = Ordering.gt⌝⦄ := by\n1014:   intro _\n1015:   unfold Zcompare_Gt\n1016:   rfl\n1017: \n1018: end Zcompare\n1019: \n1020: section CondZopp\n1021: \n1022: /-- Conditional opposite based on sign\n1023: \n1024:     Returns -x if the condition is true, x otherwise.\n1025:     This is used for conditional negation in floating-point\n1026:     sign handling.\n1027: -/\n1028: def cond_Zopp (b : Bool) (x : Int) : Id Int :=\n1029:   if b then -x else x\n1030: \n1031: /-- Specification: Conditional negation\n1032: \n1033:     The conditional opposite operation returns:\n1034:     - -x when b is true\n1035:     - x when b is false\n1036: \n1037:     This is fundamental for handling signs in floating-point.\n1038: -/\n1039: theorem cond_Zopp_spec (b : Bool) (x : Int) :\n1040:     ⦃⌜True⌝⦄\n1041:     cond_Zopp b x\n1042:     ⦃⇓result => ⌜result = if b then -x else x⌝⦄ := by\n1043:   intro _\n1044:   unfold cond_Zopp\n1045:   rfl\n1046: \n1047: /-- Conditional opposite of zero\n1048: \n1049:     cond_Zopp of zero is always zero, regardless of the condition.\n1050:     This captures the invariance of zero under negation.\n1051: -/\n1052: def cond_Zopp_0 (_ : Bool) : Id Int :=\n1053:   0\n1054: \n1055: /-- Specification: Zero invariance under conditional opposite\n1056: \n1057:     The conditional opposite of zero is always zero:\n1058:     cond_Zopp sx 0 = 0 for any boolean sx.\n1059: -/\n1060: theorem cond_Zopp_0_spec (sx : Bool) :\n1061:     ⦃⌜True⌝⦄\n1062:     cond_Zopp_0 sx\n1063:     ⦃⇓result => ⌜result = 0⌝⦄ := by\n1064:   intro _\n1065:   unfold cond_Zopp_0\n1066:   rfl\n1067: \n1068: /-- Negated condition flips conditional opposite\n1069: \n1070:     cond_Zopp (negb x) y = -cond_Zopp x y. This shows how\n1071:     negating the condition relates to negating the result.\n1072: -/\n1073: def cond_Zopp_negb (x : Bool) (y : Int) : Id Int :=\n1074:   -(if x then -y else y)\n1075: \n1076: /-- Specification: Condition negation flips result\n1077: \n1078:     Negating the boolean condition is equivalent to negating\n1079:     the result: cond_Zopp (!x) y = -(cond_Zopp x y).\n1080: -/\n1081: theorem cond_Zopp_negb_spec (x : Bool) (y : Int) :\n1082:     ⦃⌜True⌝⦄\n1083:     cond_Zopp_negb x y\n1084:     ⦃⇓result => ⌜result = -(if x then -y else y)⌝⦄ := by\n1085:   intro _\n1086:   unfold cond_Zopp_negb\n1087:   rfl\n1088: \n1089: /-- Absolute value preservation under conditional opposite\n1090: \n1091:     The absolute value of cond_Zopp b m equals |m|.\n1092:     This shows that conditional negation preserves magnitude.\n1093: -/\n1094: def abs_cond_Zopp (_b : Bool) (m : Int) : Id Int :=\n1095:   (Int.natAbs m : Int)\n1096: \n1097: /-- Specification: Conditional opposite preserves magnitude\n1098: \n1099:     The absolute value is preserved: |cond_Zopp b m| = |m|\n1100:     regardless of the boolean condition b.\n1101: -/\n1102: theorem abs_cond_Zopp_spec (b : Bool) (m : Int) :\n1103:     ⦃⌜True⌝⦄\n1104:     abs_cond_Zopp b m\n1105:     ⦃⇓result => ⌜result = (Int.natAbs m : Int)⌝⦄ := by\n1106:   intro _\n1107:   unfold abs_cond_Zopp\n1108:   rfl\n1109: \n1110: /-- Absolute value via conditional opposite\n1111: \n1112:     Computes |m| using cond_Zopp based on the sign test.\n1113:     This shows how absolute value can be implemented using\n1114:     conditional negation.\n1115: -/\n1116: def cond_Zopp_Zlt_bool (m : Int) : Id Int :=\n1117:   (Int.natAbs m : Int)\n1118: \n1119: /-- Specification: Absolute value computation\n1120: \n1121:     Using conditional opposite with a sign test computes the\n1122:     absolute value: cond_Zopp (m < 0) m = |m|.\n1123: -/\n1124: theorem cond_Zopp_Zlt_bool_spec (m : Int) :\n1125:     ⦃⌜True⌝⦄\n1126:     cond_Zopp_Zlt_bool m\n1127:     ⦃⇓result => ⌜result = (Int.natAbs m : Int)⌝⦄ := by\n1128:   intro _\n1129:   unfold cond_Zopp_Zlt_bool\n1130:   rfl\n1131: \n1132: /-- Equality test with conditional opposite\n1133: \n1134:     Shows that Zeq_bool (cond_Zopp s m) n = Zeq_bool m (cond_Zopp s n).\n1135:     This demonstrates the symmetry of conditional negation in equality tests.\n1136: -/\n1137: def Zeq_bool_cond_Zopp (s : Bool) (m n : Int) : Id Bool :=\n1138:   decide (((if s then -m else m) = n) = (m = (if s then -n else n)))\n1139: \n1140: /-- Specification: Conditional opposite commutes with equality\n1141: \n1142:     The equality test is preserved when moving conditional negation\n1143:     between arguments: Zeq_bool (cond_Zopp s m) n = Zeq_bool m (cond_Zopp s n).\n1144: -/\n1145: theorem Zeq_bool_cond_Zopp_spec (s : Bool) (m n : Int) :\n1146:     ⦃⌜True⌝⦄\n1147:     Zeq_bool_cond_Zopp s m n\n1148:     ⦃⇓result => ⌜result = decide (((if s then -m else m) = n) = (m = (if s then -n else n)))⌝⦄ := by\n1149:   intro _\n1150:   unfold Zeq_bool_cond_Zopp\n1151:   rfl\n1152: \n1153: end CondZopp\n1154: \n1155: section FastPower\n1156: \n1157: /-- Fast exponentiation for positive exponents\n1158: \n1159:     Computes v^e efficiently using repeated squaring.\n1160:     This provides O(log e) complexity instead of O(e).\n1161: -/\n1162: def Zfast_pow_pos (v : Int) (e : Nat) : Id Int :=\n1163:   v^e  -- Lean's built-in power is already efficient\n1164: \n1165: /-- Specification: Fast power computes correct result\n1166: \n1167:     The fast exponentiation algorithm computes the same result\n1168:     as naive exponentiation but with better complexity.\n1169: -/\n1170: theorem Zfast_pow_pos_spec (v : Int) (e : Nat) :\n1171:     ⦃⌜True⌝⦄\n1172:     Zfast_pow_pos v e\n1173:     ⦃⇓result => ⌜result = v^e⌝⦄ := by\n1174:   intro _\n1175:   unfold Zfast_pow_pos\n1176:   rfl\n1177: \n1178: end FastPower\n1179: \n1180: section FasterDiv\n1181: \n1182: /-- Fast Euclidean division for integers\n1183: \n1184:     Implements Euclidean division that always returns a non-negative remainder.\n1185:     For integers a and b with b ≠ 0, returns (q, r) such that:\n1186:     - a = b * q + r\n1187:     - 0 ≤ r < |b|\n1188: \n1189:     This implementation uses Lean's built-in Euclidean division operators.\n1190: -/\n1191: def Zfast_div_eucl (a b : Int) : Id (Int × Int) :=\n1192:   if b = 0 then\n1193:     return (0, a)\n1194:   else\n1195:     -- Lean's built-in division is already Euclidean division\n1196:     return (a / b, a % b)\n1197: \n1198: /-- Specification: Fast division computes correct quotient and remainder\n1199: \n1200:     The fast division algorithm produces the same result as the\n1201:     standard Euclidean division with guaranteed non-negative remainder.\n1202: -/\n1203: theorem Zfast_div_eucl_spec (a b : Int) :\n1204:     ⦃⌜b ≠ 0⌝⦄\n1205:     Zfast_div_eucl a b\n1206:     ⦃⇓result => ⌜let (q, r) := result\n1207:                 a = b * q + r ∧ 0 ≤ r ∧ r < b.natAbs⌝⦄ := by\n1208:   intro hb\n1209:   unfold Zfast_div_eucl\n1210: \n1211:   -- Split on b = 0 case (contradicts precondition)\n1212:   split\n1213:   · -- Case: b = 0\n1214:     rename_i h_bzero\n1215:     exact absurd h_bzero hb\n1216: \n1217:   · -- Case: b ≠ 0\n1218:     -- Use Lean's built-in Euclidean division properties\n1219:     constructor\n1220:     · -- Prove: a = b * (a / b) + (a % b)\n1221:       calc a = a % b + b * (a / b) := (Int.emod_add_ediv a b).symm\n1222:            _ = a % b + (a / b) * b := by rw [Int.mul_comm b]\n1223:            _ = b * (a / b) + a % b := by rw [Int.add_comm, Int.mul_comm]\n1224: \n1225:     constructor\n1226:     · -- Prove: 0 ≤ a % b\n1227:       exact Int.emod_nonneg a hb\n1228: \n1229:     · -- Prove: a % b < b.natAbs\n1230:       exact Int.emod_lt a hb\n1231: \n1232: end FasterDiv\n1233: \n1234: section Iteration\n1235: \n1236: /-- Generic iteration of a function\n1237: \n1238:     Applies function f to x a total of n times.\n1239:     This provides a generic iteration construct used\n1240:     throughout the formalization.\n1241: -/\n1242: def iter_nat {A : Type} (f : A → A) (n : Nat) (x : A) : Id A :=\n1243:   match n with\n1244:   | 0 => x\n1245:   | n'+1 => f (iter_nat f n' x).run\n1246: \n1247: /-- Specification: Iteration applies function n times\n1248: \n1249:     The iteration operation satisfies:\n1250:     - iter_nat f 0 x = x\n1251:     - iter_nat f (n+1) x = f (iter_nat f n x)\n1252: \n1253:     This captures the fundamental iteration pattern.\n1254: -/\n1255: theorem iter_nat_spec {A : Type} (f : A → A) (n : Nat) (x : A) :\n1256:     ⦃⌜True⌝⦄\n1257:     iter_nat f n x\n1258:     ⦃⇓result => ⌜result = f^[n] x⌝⦄ := by\n1259:   intro _\n1260:   induction n with\n1261:   | zero =>\n1262:     unfold iter_nat\n1263:     simp [Function.iterate_zero]\n1264:     rfl\n1265:   | succ n' ih =>\n1266:     unfold iter_nat\n1267:     simp [Function.iterate_succ_apply']\n1268:     -- Need to relate f (iter_nat f n' x).run to f (f^[n'] x)\n1269:     -- This should follow from ih\n1270:     have h : (iter_nat f n' x).run = f^[n'] x := by\n1271:       exact ih\n1272:     rw [h]\n1273:     rfl\n1274: \n1275: /-- Successor property for iteration\n1276: \n1277:     Shows that iter_nat f (S p) x = f (iter_nat f p x).\n1278:     This is the successor case of the iteration recursion.\n1279: -/\n1280: def iter_nat_S {A : Type} (f : A → A) (p : Nat) (x : A) : Id A :=\n1281:   f (iter_nat f p x).run\n1282: \n1283: /-- Specification: Iteration successor formula\n1284: \n1285:     Iterating S p times is equivalent to iterating p times\n1286:     followed by one more application of f. This captures\n1287:     the recursive nature of iteration.\n1288: -/\n1289: theorem iter_nat_S_spec {A : Type} (f : A → A) (p : Nat) (x : A) :\n1290:     ⦃⌜True⌝⦄\n1291:     iter_nat_S f p x\n1292:     ⦃⇓result => ⌜result = f (iter_nat f p x).run⌝⦄ := by\n1293:   intro _\n1294:   unfold iter_nat_S\n1295:   rfl\n1296: \n1297: /-- Iteration addition formula\n1298: \n1299:     Shows that iter_nat f (p + q) x = iter_nat f p (iter_nat f q x).\n1300:     This captures the additive property of iteration counts.\n1301: -/\n1302: def iter_nat_plus {A : Type} (f : A → A) (p q : Nat) (x : A) : Id A :=\n1303:   (iter_nat f p (iter_nat f q x).run).run\n1304: \n1305: /-- Specification: Iteration count addition\n1306: \n1307:     Iterating p + q times is equivalent to iterating q times\n1308:     followed by iterating p times. This fundamental property\n1309:     allows decomposition of iterations.\n1310: -/\n1311: theorem iter_nat_plus_spec {A : Type} (f : A → A) (p q : Nat) (x : A) :\n1312:     ⦃⌜True⌝⦄\n1313:     iter_nat_plus f p q x\n1314:     ⦃⇓result => ⌜result = (iter_nat f p (iter_nat f q x).run).run⌝⦄ := by\n1315:   intro _\n1316:   unfold iter_nat_plus\n1317:   rfl\n1318: \n1319: /-- Relationship between positive and natural iteration\n1320: \n1321:     For positive numbers, iter_pos equals iter_nat composed\n1322:     with conversion to natural numbers.\n1323: -/\n1324: def iter_pos_nat {A : Type} (f : A → A) (p : Nat) (x : A) : Id A :=\n1325:   (iter_nat f p x).run\n1326: \n1327: /-- Specification: Positive iteration via naturals\n1328: \n1329:     Iteration with positive numbers can be expressed through\n1330:     natural number iteration after conversion. This allows\n1331:     unified reasoning about different iteration types.\n1332: -/\n1333: theorem iter_pos_nat_spec {A : Type} (f : A → A) (p : Nat) (x : A) :\n1334:     ⦃⌜p > 0⌝⦄\n1335:     iter_pos_nat f p x\n1336:     ⦃⇓result => ⌜result = (iter_nat f p x).run⌝⦄ := by\n1337:   intro _\n1338:   unfold iter_pos_nat\n1339:   rfl\n1340: \n1341: end Iteration\n1342: \n1343: end FloatSpec.Core.Zaux\n1344: \n"
  }
}
[2025-09-16T03:36:33] tokens used: 35702
[2025-09-16T03:36:38] codex

I’ll open `FIX.lean` to see current theorems and spot missing ones to add.
[2025-09-16T03:36:38] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FIX.lean","annotate_lines":true})
[2025-09-16T03:36:38] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FIX.lean","annotate_lines":true}) success in 2ms:
{
  "content": [
    {
      "text": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Defs\n20 : import FloatSpec.src.Core.Generic_fmt\n21 : import FloatSpec.src.Core.Round_generic\n22 : import FloatSpec.src.Core.Ulp\n23 : import Mathlib.Data.Real.Basic\n24 : import Std.Do.Triple\n25 : import Std.Tactic.Do\n26 : \n27 : open Real\n28 : open Std.Do\n29 : open FloatSpec.Core.Generic_fmt\n30 : open FloatSpec.Core.Round_generic\n31 : \n32 : namespace FloatSpec.Core.FIX\n33 : \n34 : variable (emin : Int)\n35 : \n36 : /-- Fixed-point exponent function\n37 : \n38 :     In fixed-point format, all numbers have the same exponent emin.\n39 :     This creates a uniform representation where the position of\n40 :     the binary/decimal point is fixed across all values.\n41 : -/\n42 : def FIX_exp (_ : Int) : Int :=\n43 :   emin\n44 : \n45 : /-- Check FIX format correctness\n46 : \n47 :     Verify the fundamental property that FIX_exp always\n48 :     returns emin regardless of input. This validates\n49 :     the fixed-point nature of the format.\n50 : -/\n51 : def FIX_exp_correct_check (e : Int) : Id Bool :=\n52 :   pure (FIX_exp emin e = emin)\n53 : \n54 : /-- Specification: Fixed exponent always returns emin\n55 : \n56 :     The fixed-point exponent function ignores its input and\n57 :     always returns the fixed exponent emin. This ensures\n58 :     uniform scaling across all representable values.\n59 : -/\n60 : theorem FIX_exp_spec (e : Int) :\n61 :     ⦃⌜True⌝⦄\n62 :     FIX_exp_correct_check emin e\n63 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n64 :   sorry\n65 : \n66 : /-- Fixed-point format predicate\n67 : \n68 :     A real number x is in FIX format if it can be represented\n69 :     using the generic format with the fixed exponent function.\n70 :     This means x = m × β^emin for some integer mantissa m.\n71 : -/\n72 : def FIX_format (beta : Int) (x : ℝ) : Id Prop :=\n73 :   FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x\n74 : \n75 : /-- Valid_exp instance for the fixed exponent function (placeholder). -/\n76 : instance FIX_exp_valid (beta : Int) :\n77 :     FloatSpec.Core.Generic_fmt.Valid_exp beta (FIX_exp emin) := by\n78 :   refine ⟨?_⟩\n79 :   intro k\n80 :   refine And.intro ?h1 ?h2\n81 :   · intro _; \n82 :     -- Proof omitted for now\n83 :     sorry\n84 :   · intro _\n85 :     refine And.intro ?hA ?hB\n86 :     · -- Proof omitted for now\n87 :       sorry\n88 :     · intro _ _\n89 :       -- Proof omitted for now\n90 :       sorry\n91 : \n92 : /-- Specification: FIX format using generic format\n93 : \n94 :     The FIX format is defined in terms of the generic format\n95 :     with a fixed exponent function. This provides a concrete\n96 :     characterization of fixed-point representable numbers.\n97 : -/\n98 : theorem FIX_format_spec (beta : Int) (x : ℝ) :\n99 :     ⦃⌜True⌝⦄\n100:     FIX_format emin beta x\n101:     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x).run⌝⦄ := by\n102:   sorry\n103: \n104: /-- Specification: FIX exponent function correctness\n105: \n106:     The FIX exponent function satisfies its specification:\n107:     it always returns emin for any input e. This establishes\n108:     the correctness of the fixed-point implementation.\n109: -/\n110: theorem FIX_exp_correct_spec (e : Int) :\n111:     ⦃⌜True⌝⦄\n112:     FIX_exp_correct_check emin e\n113:     ⦃⇓result => ⌜result = true⌝⦄ := by\n114:   sorry\n115: \n116: /-- Check if zero is in FIX format\n117: \n118:     Verify that zero is representable in the fixed-point format.\n119:     Zero should always be representable as 0 × β^emin = 0.\n120: -/\n121: def FIX_format_0_check (beta : Int) : Id Bool :=\n122:   pure true  -- Zero is always in format\n123: \n124: /-- Specification: Zero is in FIX format\n125: \n126:     Zero is always representable in fixed-point format since\n127:     it can be expressed as 0 × β^emin. This ensures that\n128:     fixed-point formats always contain the additive identity.\n129: -/\n130: theorem FIX_format_0_spec (beta : Int) :\n131:     ⦃⌜beta > 1⌝⦄\n132:     FIX_format_0_check beta\n133:     ⦃⇓result => ⌜result = true⌝⦄ := by\n134:   sorry\n135: \n136: /-- Check closure under negation\n137: \n138:     Verify that if x is in FIX format, then -x is also in FIX format.\n139:     This tests the closure property under additive inverse.\n140: -/\n141: def FIX_format_opp_check (beta : Int) (x : ℝ) : Id Bool :=\n142:   pure true  -- Always true for fixed-point formats\n143: \n144: /-- Specification: FIX format closed under negation\n145: \n146:     Fixed-point formats are closed under negation: if x is\n147:     representable, then -x is also representable. This follows\n148:     from the fact that if x = m × β^emin, then -x = (-m) × β^emin.\n149: -/\n150: theorem FIX_format_opp_spec (beta : Int) (x : ℝ) :\n151:     ⦃⌜(FIX_format emin beta x).run⌝⦄\n152:     FIX_format_opp_check beta x\n153:     ⦃⇓result => ⌜result = true⌝⦄ := by\n154:   sorry\n155: \n156: /-\n157: Coq (FIX.v):\n158: Theorem generic_format_FIX :\n159:   forall x, FIX_format x -> generic_format beta FIX_exp x.\n160: -/\n161: theorem generic_format_FIX (beta : Int) (x : ℝ) :\n162:     ⦃⌜(FIX_format emin beta x).run⌝⦄\n163:     FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x\n164:     ⦃⇓result => ⌜result⌝⦄ := by\n165:   intro hx\n166:   simpa [FIX_format]\n167: \n168: /-\n169: Coq (FIX.v):\n170: Theorem FIX_format_generic :\n171:   forall x, generic_format beta FIX_exp x -> FIX_format x.\n172: -/\n173: theorem FIX_format_generic (beta : Int) (x : ℝ) :\n174:     ⦃⌜(FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x).run⌝⦄\n175:     FIX_format emin beta x\n176:     ⦃⇓result => ⌜result⌝⦄ := by\n177:   intro hx\n178:   simpa [FIX_format] using hx\n179: \n180: /-\n181: Coq (FIX.v):\n182: Theorem FIX_format_satisfies_any :\n183:   satisfies_any FIX_format.\n184: -/\n185: theorem FIX_format_satisfies_any (beta : Int) :\n186:     FloatSpec.Core.Generic_fmt.satisfies_any (fun y => (FIX_format emin beta y).run) := by\n187:   -- Immediate from the generic format version\n188:   simpa [FIX_format]\n189:     using FloatSpec.Core.Generic_fmt.generic_format_satisfies_any (beta := beta) (fexp := FIX_exp emin)\n190: \n191: /-- Coq (FIX.v):\n192: Theorem ulp_FIX : forall x, ulp beta FIX_exp x = bpow emin.\n193: \n194: Lean (spec): For any real `x`, the ULP under FIX exponent equals `β^emin`.\n195: -/\n196: theorem ulp_FIX (beta : Int) (x : ℝ) :\n197:     ⦃⌜True⌝⦄\n198:     FloatSpec.Core.Ulp.ulp beta (FIX_exp emin) x\n199:     ⦃⇓r => ⌜r = (beta : ℝ) ^ emin⌝⦄ := by\n200:   sorry\n201: \n202: end FloatSpec.Core.FIX\n203: \n204: namespace FloatSpec.Core.FIX\n205: \n206: /-- Coq (FIX.v):\n207: Theorem round_FIX_IZR : forall f x, round radix2 (FIX_exp 0) f x = IZR (f x).\n208: \n209: Lean (spec): For base 2 and fixed exponent 0, rounding yields the\n210: real embedding of the integer produced by `f` at `x`.\n211: -/\n212: theorem round_FIX_IZR (f : ℝ → Int) (x : ℝ) :\n213:     ⦃⌜True⌝⦄\n214:     (pure (FloatSpec.Core.Round_generic.round_to_generic (beta := 2) (fexp := FIX_exp (emin := (0 : Int))) (mode := fun _ _ => True) x) : Id ℝ)\n215:     ⦃⇓r => ⌜r = (f x : ℝ)⌝⦄ := by\n216:   sorry\n217: \n218: end FloatSpec.Core.FIX\n219: \n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Defs\n20 : import FloatSpec.src.Core.Generic_fmt\n21 : import FloatSpec.src.Core.Round_generic\n22 : import FloatSpec.src.Core.Ulp\n23 : import Mathlib.Data.Real.Basic\n24 : import Std.Do.Triple\n25 : import Std.Tactic.Do\n26 : \n27 : open Real\n28 : open Std.Do\n29 : open FloatSpec.Core.Generic_fmt\n30 : open FloatSpec.Core.Round_generic\n31 : \n32 : namespace FloatSpec.Core.FIX\n33 : \n34 : variable (emin : Int)\n35 : \n36 : /-- Fixed-point exponent function\n37 : \n38 :     In fixed-point format, all numbers have the same exponent emin.\n39 :     This creates a uniform representation where the position of\n40 :     the binary/decimal point is fixed across all values.\n41 : -/\n42 : def FIX_exp (_ : Int) : Int :=\n43 :   emin\n44 : \n45 : /-- Check FIX format correctness\n46 : \n47 :     Verify the fundamental property that FIX_exp always\n48 :     returns emin regardless of input. This validates\n49 :     the fixed-point nature of the format.\n50 : -/\n51 : def FIX_exp_correct_check (e : Int) : Id Bool :=\n52 :   pure (FIX_exp emin e = emin)\n53 : \n54 : /-- Specification: Fixed exponent always returns emin\n55 : \n56 :     The fixed-point exponent function ignores its input and\n57 :     always returns the fixed exponent emin. This ensures\n58 :     uniform scaling across all representable values.\n59 : -/\n60 : theorem FIX_exp_spec (e : Int) :\n61 :     ⦃⌜True⌝⦄\n62 :     FIX_exp_correct_check emin e\n63 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n64 :   sorry\n65 : \n66 : /-- Fixed-point format predicate\n67 : \n68 :     A real number x is in FIX format if it can be represented\n69 :     using the generic format with the fixed exponent function.\n70 :     This means x = m × β^emin for some integer mantissa m.\n71 : -/\n72 : def FIX_format (beta : Int) (x : ℝ) : Id Prop :=\n73 :   FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x\n74 : \n75 : /-- Valid_exp instance for the fixed exponent function (placeholder). -/\n76 : instance FIX_exp_valid (beta : Int) :\n77 :     FloatSpec.Core.Generic_fmt.Valid_exp beta (FIX_exp emin) := by\n78 :   refine ⟨?_⟩\n79 :   intro k\n80 :   refine And.intro ?h1 ?h2\n81 :   · intro _; \n82 :     -- Proof omitted for now\n83 :     sorry\n84 :   · intro _\n85 :     refine And.intro ?hA ?hB\n86 :     · -- Proof omitted for now\n87 :       sorry\n88 :     · intro _ _\n89 :       -- Proof omitted for now\n90 :       sorry\n91 : \n92 : /-- Specification: FIX format using generic format\n93 : \n94 :     The FIX format is defined in terms of the generic format\n95 :     with a fixed exponent function. This provides a concrete\n96 :     characterization of fixed-point representable numbers.\n97 : -/\n98 : theorem FIX_format_spec (beta : Int) (x : ℝ) :\n99 :     ⦃⌜True⌝⦄\n100:     FIX_format emin beta x\n101:     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x).run⌝⦄ := by\n102:   sorry\n103: \n104: /-- Specification: FIX exponent function correctness\n105: \n106:     The FIX exponent function satisfies its specification:\n107:     it always returns emin for any input e. This establishes\n108:     the correctness of the fixed-point implementation.\n109: -/\n110: theorem FIX_exp_correct_spec (e : Int) :\n111:     ⦃⌜True⌝⦄\n112:     FIX_exp_correct_check emin e\n113:     ⦃⇓result => ⌜result = true⌝⦄ := by\n114:   sorry\n115: \n116: /-- Check if zero is in FIX format\n117: \n118:     Verify that zero is representable in the fixed-point format.\n119:     Zero should always be representable as 0 × β^emin = 0.\n120: -/\n121: def FIX_format_0_check (beta : Int) : Id Bool :=\n122:   pure true  -- Zero is always in format\n123: \n124: /-- Specification: Zero is in FIX format\n125: \n126:     Zero is always representable in fixed-point format since\n127:     it can be expressed as 0 × β^emin. This ensures that\n128:     fixed-point formats always contain the additive identity.\n129: -/\n130: theorem FIX_format_0_spec (beta : Int) :\n131:     ⦃⌜beta > 1⌝⦄\n132:     FIX_format_0_check beta\n133:     ⦃⇓result => ⌜result = true⌝⦄ := by\n134:   sorry\n135: \n136: /-- Check closure under negation\n137: \n138:     Verify that if x is in FIX format, then -x is also in FIX format.\n139:     This tests the closure property under additive inverse.\n140: -/\n141: def FIX_format_opp_check (beta : Int) (x : ℝ) : Id Bool :=\n142:   pure true  -- Always true for fixed-point formats\n143: \n144: /-- Specification: FIX format closed under negation\n145: \n146:     Fixed-point formats are closed under negation: if x is\n147:     representable, then -x is also representable. This follows\n148:     from the fact that if x = m × β^emin, then -x = (-m) × β^emin.\n149: -/\n150: theorem FIX_format_opp_spec (beta : Int) (x : ℝ) :\n151:     ⦃⌜(FIX_format emin beta x).run⌝⦄\n152:     FIX_format_opp_check beta x\n153:     ⦃⇓result => ⌜result = true⌝⦄ := by\n154:   sorry\n155: \n156: /-\n157: Coq (FIX.v):\n158: Theorem generic_format_FIX :\n159:   forall x, FIX_format x -> generic_format beta FIX_exp x.\n160: -/\n161: theorem generic_format_FIX (beta : Int) (x : ℝ) :\n162:     ⦃⌜(FIX_format emin beta x).run⌝⦄\n163:     FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x\n164:     ⦃⇓result => ⌜result⌝⦄ := by\n165:   intro hx\n166:   simpa [FIX_format]\n167: \n168: /-\n169: Coq (FIX.v):\n170: Theorem FIX_format_generic :\n171:   forall x, generic_format beta FIX_exp x -> FIX_format x.\n172: -/\n173: theorem FIX_format_generic (beta : Int) (x : ℝ) :\n174:     ⦃⌜(FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x).run⌝⦄\n175:     FIX_format emin beta x\n176:     ⦃⇓result => ⌜result⌝⦄ := by\n177:   intro hx\n178:   simpa [FIX_format] using hx\n179: \n180: /-\n181: Coq (FIX.v):\n182: Theorem FIX_format_satisfies_any :\n183:   satisfies_any FIX_format.\n184: -/\n185: theorem FIX_format_satisfies_any (beta : Int) :\n186:     FloatSpec.Core.Generic_fmt.satisfies_any (fun y => (FIX_format emin beta y).run) := by\n187:   -- Immediate from the generic format version\n188:   simpa [FIX_format]\n189:     using FloatSpec.Core.Generic_fmt.generic_format_satisfies_any (beta := beta) (fexp := FIX_exp emin)\n190: \n191: /-- Coq (FIX.v):\n192: Theorem ulp_FIX : forall x, ulp beta FIX_exp x = bpow emin.\n193: \n194: Lean (spec): For any real `x`, the ULP under FIX exponent equals `β^emin`.\n195: -/\n196: theorem ulp_FIX (beta : Int) (x : ℝ) :\n197:     ⦃⌜True⌝⦄\n198:     FloatSpec.Core.Ulp.ulp beta (FIX_exp emin) x\n199:     ⦃⇓r => ⌜r = (beta : ℝ) ^ emin⌝⦄ := by\n200:   sorry\n201: \n202: end FloatSpec.Core.FIX\n203: \n204: namespace FloatSpec.Core.FIX\n205: \n206: /-- Coq (FIX.v):\n207: Theorem round_FIX_IZR : forall f x, round radix2 (FIX_exp 0) f x = IZR (f x).\n208: \n209: Lean (spec): For base 2 and fixed exponent 0, rounding yields the\n210: real embedding of the integer produced by `f` at `x`.\n211: -/\n212: theorem round_FIX_IZR (f : ℝ → Int) (x : ℝ) :\n213:     ⦃⌜True⌝⦄\n214:     (pure (FloatSpec.Core.Round_generic.round_to_generic (beta := 2) (fexp := FIX_exp (emin := (0 : Int))) (mode := fun _ _ => True) x) : Id ℝ)\n215:     ⦃⇓r => ⌜r = (f x : ℝ)⌝⦄ := by\n216:   sorry\n217: \n218: end FloatSpec.Core.FIX\n219: \n"
  }
}
[2025-09-16T03:36:39] tokens used: 52286
[2025-09-16T03:36:45] codex

I’ll open `FLT.lean` to see what’s already present and what’s missing.
[2025-09-16T03:36:46] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLT.lean","annotate_lines":true})
[2025-09-16T03:36:46] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLT.lean","annotate_lines":true}) success in 5ms:
{
  "content": [
    {
      "text": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Defs\n20 : import FloatSpec.src.Core.Generic_fmt\n21 : import FloatSpec.src.Core.Round_generic\n22 : import FloatSpec.src.Core.Ulp\n23 : import FloatSpec.src.Core.FLX\n24 : import FloatSpec.src.Core.FIX\n25 : import Mathlib.Data.Real.Basic\n26 : import Std.Do.Triple\n27 : import Std.Tactic.Do\n28 : \n29 : open Real\n30 : open Std.Do\n31 : open FloatSpec.Core.Generic_fmt\n32 : open FloatSpec.Core.Round_generic\n33 : \n34 : namespace FloatSpec.Core.FLT\n35 : \n36 : variable (prec emin : Int)\n37 : \n38 : /-- Floating-point exponent function\n39 : \n40 :     The FLT exponent function combines fixed-precision behavior\n41 :     with a minimum exponent bound. It returns max(e - prec, emin),\n42 :     providing precision when possible but limiting underflow.\n43 : -/\n44 : def FLT_exp (e : Int) : Int :=\n45 :   max (e - prec) emin\n46 : \n47 : /-- Check FLT exponent function correctness\n48 : \n49 :     Verify that the FLT exponent function correctly computes\n50 :     the maximum of (e - prec) and emin. This validates the\n51 :     IEEE 754-style exponent calculation.\n52 : -/\n53 : def FLT_exp_correct_check (e : Int) : Id Bool :=\n54 :   pure (FLT_exp prec emin e = max (e - prec) emin)\n55 : \n56 : /-- Specification: FLT exponent calculation\n57 : \n58 :     The FLT exponent function implements IEEE 754-style floating-point\n59 :     exponent calculation: it maintains precision by using e - prec\n60 :     when possible, but enforces a minimum exponent emin to prevent\n61 :     excessive underflow and maintain gradual underflow behavior.\n62 : -/\n63 : theorem FLT_exp_spec (e : Int) :\n64 :     ⦃⌜True⌝⦄\n65 :     FLT_exp_correct_check prec emin e\n66 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n67 :   sorry\n68 : \n69 : /-- Floating-point format predicate\n70 : \n71 :     A real number x is in FLT format if it can be represented\n72 :     using the generic format with the FLT exponent function.\n73 :     This gives IEEE 754-style floating-point representation\n74 :     with both precision and minimum exponent constraints.\n75 : -/\n76 : def FLT_format (beta : Int) (x : ℝ) : Id Prop :=\n77 :   pure (generic_format beta (FLT_exp prec emin) x)\n78 : \n79 : /-- Valid_exp instance for the FLT exponent function (placeholder). -/\n80 : instance FLT_exp_valid (beta : Int) :\n81 :     FloatSpec.Core.Generic_fmt.Valid_exp beta (FLT_exp prec emin) := by\n82 :   refine ⟨?_⟩\n83 :   intro k\n84 :   refine And.intro ?h1 ?h2\n85 :   · intro _\n86 :     -- Proof omitted for now\n87 :     sorry\n88 :   · intro _\n89 :     refine And.intro ?hA ?hB\n90 :     · -- Proof omitted for now\n91 :       sorry\n92 :     · intro _ _\n93 :       -- Proof omitted for now\n94 :       sorry\n95 : \n96 : /-- Specification: FLT format using generic format\n97 : \n98 :     The FLT format combines the benefits of fixed-precision\n99 :     (for normal numbers) with minimum exponent protection\n100:     (for subnormal numbers), matching IEEE 754 behavior.\n101: -/\n102: theorem FLT_format_spec (beta : Int) (x : ℝ) :\n103:     ⦃⌜True⌝⦄\n104:     FLT_format prec emin beta x\n105:     ⦃⇓result => ⌜result = (generic_format beta (FLT_exp prec emin) x)⌝⦄ := by\n106:   sorry\n107: \n108: /-- Specification: FLT exponent function correctness\n109: \n110:     The FLT exponent function correctly implements the IEEE 754\n111:     exponent selection logic, choosing between precision-based\n112:     and minimum-bounded exponents as appropriate.\n113: -/\n114: theorem FLT_exp_correct_spec (e : Int) :\n115:     ⦃⌜True⌝⦄\n116:     FLT_exp_correct_check prec emin e\n117:     ⦃⇓result => ⌜result = true⌝⦄ := by\n118:   sorry\n119: \n120: /-- Check if zero is in FLT format\n121: \n122:     Verify that zero is representable in the floating-point format.\n123:     Zero should always be representable as 0 × β^e for any\n124:     allowed exponent e, making it universal across FLT formats.\n125: -/\n126: def FLT_format_0_check (beta : Int) : Id Bool :=\n127:   pure true  -- Zero is always in format\n128: \n129: /-- Specification: Zero is in FLT format\n130: \n131:     Zero is always representable in FLT format since it can\n132:     be expressed as 0 × β^e for any exponent e, regardless\n133:     of precision or minimum exponent constraints.\n134: -/\n135: theorem FLT_format_0_spec (beta : Int) :\n136:     ⦃⌜beta > 1⌝⦄\n137:     FLT_format_0_check beta\n138:     ⦃⇓result => ⌜result = true⌝⦄ := by\n139:   sorry\n140: \n141: /-- Check closure under negation\n142: \n143:     Verify that if x is in FLT format, then -x is also in FLT format.\n144:     This tests the sign symmetry property of IEEE 754-style\n145:     floating-point representation.\n146: -/\n147: def FLT_format_opp_check (beta : Int) (x : ℝ) : Id Bool :=\n148:   pure true  -- Always true for FLT formats\n149: \n150: /-- Specification: FLT format closed under negation\n151: \n152:     FLT formats are closed under negation. If x = m × β^e\n153:     is representable, then -x = (-m) × β^e is also representable\n154:     using the same exponent and negated mantissa.\n155: -/\n156: theorem FLT_format_opp_spec (beta : Int) (x : ℝ) :\n157:     ⦃⌜(FLT_format prec emin beta x).run⌝⦄\n158:     FLT_format_opp_check beta x\n159:     ⦃⇓result => ⌜result = true⌝⦄ := by\n160:   sorry\n161: \n162: /-- Check closure under absolute value\n163: \n164:     Verify that if x is in FLT format, then |x| is also in FLT format.\n165:     This tests the magnitude preservation property, ensuring that\n166:     absolute values remain representable.\n167: -/\n168: def FLT_format_abs_check (beta : Int) (x : ℝ) : Id Bool :=\n169:   pure true  -- Always true for FLT formats\n170: \n171: /-- Specification: FLT format closed under absolute value\n172: \n173:     FLT formats are closed under absolute value operations.\n174:     The magnitude of a representable number is always\n175:     representable using the same exponent structure.\n176: -/\n177: theorem FLT_format_abs_spec (beta : Int) (x : ℝ) :\n178:     ⦃⌜(FLT_format prec emin beta x).run⌝⦄\n179:     FLT_format_abs_check beta x\n180:     ⦃⇓result => ⌜result = true⌝⦄ := by\n181:   sorry\n182: \n183: /-- Check relationship between FLT and FLX formats\n184: \n185:     When the minimum exponent constraint is not active\n186:     (i.e., emin ≤ e - prec), FLT behaves exactly like FLX.\n187:     This verifies the normal number behavior of IEEE 754.\n188: -/\n189: def FLT_exp_FLX_check (e : Int) : Id Bool :=\n190:   pure (emin ≤ e - prec → FLT_exp prec emin e = FLX.FLX_exp prec e)\n191: \n192: /-- Specification: FLT reduces to FLX for normal numbers\n193: \n194:     When the precision-based exponent e - prec exceeds emin,\n195:     FLT format behaves identically to FLX format. This captures\n196:     the normal number range of IEEE 754 floating-point.\n197: -/\n198: theorem FLT_exp_FLX_spec (e : Int) :\n199:     ⦃⌜emin ≤ e - prec⌝⦄\n200:     FLT_exp_FLX_check prec emin e\n201:     ⦃⇓result => ⌜result = true⌝⦄ := by\n202:   sorry\n203: \n204: /-\n205: Coq (FLT.v):\n206: Theorem generic_format_FLT :\n207:   forall x, FLT_format x -> generic_format beta FLT_exp x.\n208: -/\n209: theorem generic_format_FLT (beta : Int) (x : ℝ) :\n210:     ⦃⌜(FLT_format prec emin beta x).run⌝⦄\n211:     generic_format beta (FLT_exp prec emin) x\n212:     ⦃⇓result => ⌜result⌝⦄ := by\n213:   intro hx\n214:   simpa [FLT_format]\n215: \n216: /-\n217: Coq (FLT.v):\n218: Theorem FLT_format_generic :\n219:   forall x, generic_format beta FLT_exp x -> FLT_format x.\n220: -/\n221: theorem FLT_format_generic (beta : Int) (x : ℝ) :\n222:     ⦃⌜(generic_format beta (FLT_exp prec emin) x).run⌝⦄\n223:     FLT_format prec emin beta x\n224:     ⦃⇓result => ⌜result⌝⦄ := by\n225:   intro hx\n226:   simpa [FLT_format] using hx\n227: \n228: /-\n229: Coq (FLT.v):\n230: Theorem FLT_format_satisfies_any :\n231:   satisfies_any FLT_format.\n232: -/\n233: theorem FLT_format_satisfies_any (beta : Int) :\n234:     FloatSpec.Core.Generic_fmt.satisfies_any (fun y => (FLT_format prec emin beta y).run) := by\n235:   simpa [FLT_format]\n236:     using FloatSpec.Core.Generic_fmt.generic_format_satisfies_any (beta := beta) (fexp := FLT_exp prec emin)\n237: \n238: /-\n239: Coq (FLT.v):\n240: Theorem generic_format_FLT_bpow :\n241:   forall e, (emin <= e)%Z -> generic_format beta FLT_exp (bpow e).\n242: -/\n243: theorem generic_format_FLT_bpow (beta : Int) (e : Int) :\n244:     ⦃⌜emin ≤ e⌝⦄\n245:     generic_format beta (FLT_exp prec emin) ((beta : ℝ) ^ e)\n246:     ⦃⇓result => ⌜result⌝⦄ := by\n247:   intro _\n248:   sorry\n249: \n250: /-\n251: Coq (FLT.v):\n252: Theorem FLT_format_bpow :\n253:   forall e, (emin <= e)%Z -> FLT_format (bpow e).\n254: -/\n255: theorem FLT_format_bpow (beta : Int) (e : Int) :\n256:     ⦃⌜emin ≤ e⌝⦄\n257:     FLT_format prec emin beta ((beta : ℝ) ^ e)\n258:     ⦃⇓result => ⌜result⌝⦄ := by\n259:   intro _\n260:   sorry\n261: \n262: /-\n263: Coq (FLT.v):\n264: Theorem generic_format_FLT_FLX :\n265:   forall x : R,\n266:   (bpow (emin + prec - 1) <= Rabs x)%R ->\n267:   generic_format beta (FLX_exp prec) x ->\n268:   generic_format beta FLT_exp x.\n269: -/\n270: theorem generic_format_FLT_FLX (beta : Int) (x : ℝ) :\n271:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x| ∧ (generic_format beta (FLX.FLX_exp prec) x).run⌝⦄\n272:     generic_format beta (FLT_exp prec emin) x\n273:     ⦃⇓result => ⌜result⌝⦄ := by\n274:   intro _\n275:   sorry\n276: \n277: /-\n278: Coq (FLT.v):\n279: Theorem cexp_FLT_FLX :\n280:   forall x,\n281:   (bpow (emin + prec - 1) <= Rabs x)%R ->\n282:   cexp beta FLT_exp x = cexp beta (FLX_exp prec) x.\n283: -/\n284: theorem cexp_FLT_FLX (beta : Int) (x : ℝ) :\n285:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄\n286:     FloatSpec.Core.Generic_fmt.cexp beta (FLT_exp prec emin) x\n287:     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.cexp beta (FLX.FLX_exp prec) x).run⌝⦄ := by\n288:   intro _\n289:   sorry\n290: \n291: end FloatSpec.Core.FLT\n292: \n293: namespace FloatSpec.Core.FLT\n294: \n295: variable (prec emin : Int)\n296: \n297: /-\n298: Coq (FLT.v):\n299: Theorem generic_format_FIX_FLT :\n300:   forall x : R,\n301:   generic_format beta FLT_exp x ->\n302:   generic_format beta (FIX_exp emin) x.\n303: -/\n304: theorem generic_format_FIX_FLT (beta : Int) (x : ℝ) :\n305:     ⦃⌜(generic_format beta (FLT_exp prec emin) x).run⌝⦄\n306:     generic_format beta (FloatSpec.Core.FIX.FIX_exp (emin := emin)) x\n307:     ⦃⇓result => ⌜result⌝⦄ := by\n308:   intro _\n309:   sorry\n310: \n311: end FloatSpec.Core.FLT\n312: \n313: namespace FloatSpec.Core.FLT\n314: \n315: variable (prec emin : Int)\n316: \n317: /-\n318: Coq (FLT.v):\n319: Theorem generic_format_FLT_FIX :\n320:   forall x : R,\n321:   (Rabs x <= bpow (emin + prec))%R ->\n322:   generic_format beta (FIX_exp emin) x ->\n323:   generic_format beta FLT_exp x.\n324: -/\n325: theorem generic_format_FLT_FIX (beta : Int) (x : ℝ) :\n326:     ⦃⌜|x| ≤ (beta : ℝ) ^ (emin + prec) ∧ (generic_format beta (FloatSpec.Core.FIX.FIX_exp (emin := emin)) x).run⌝⦄\n327:     generic_format beta (FLT_exp prec emin) x\n328:     ⦃⇓result => ⌜result⌝⦄ := by\n329:   intro _\n330:   sorry\n331: \n332: end FloatSpec.Core.FLT\n333: \n334: namespace FloatSpec.Core.FLT\n335: \n336: variable (prec emin : Int)\n337: \n338: /-- Coq (FLT.v):\n339: Theorem ulp_FLT_0 : ulp beta FLT_exp 0 = bpow emin.\n340: \n341: Lean (spec): The ULP under FLT at 0 equals `β^emin`.\n342: -/\n343: theorem ulp_FLT_0 (beta : Int) :\n344:     ⦃⌜True⌝⦄\n345:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) 0\n346:     ⦃⇓r => ⌜r = (beta : ℝ) ^ emin⌝⦄ := by\n347:   sorry\n348: \n349: /-- Coq (FLT.v):\n350: Theorem ulp_FLT_small:\n351:   forall x, Rabs x < bpow (emin + prec) -> ulp beta FLT_exp x = bpow emin.\n352: \n353: Lean (spec): If |x| < β^(emin+prec), then ULP under FLT at x equals `β^emin`.\n354: -/\n355: theorem ulp_FLT_small (beta : Int) (x : ℝ) :\n356:     ⦃⌜|x| < (beta : ℝ) ^ (emin + prec)⌝⦄\n357:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n358:     ⦃⇓r => ⌜r = (beta : ℝ) ^ emin⌝⦄ := by\n359:   intro _\n360:   sorry\n361: \n362: /-\n363: Coq (FLT.v):\n364: Theorem cexp_FLT_FIX :\n365:   forall x, x <> 0%R ->\n366:   (Rabs x < bpow (emin + prec))%R ->\n367:   cexp beta FLT_exp x = cexp beta (FIX_exp emin) x.\n368: -/\n369: theorem cexp_FLT_FIX (beta : Int) (x : ℝ) :\n370:     ⦃⌜x ≠ 0 ∧ |x| < (beta : ℝ) ^ (emin + prec)⌝⦄\n371:     FloatSpec.Core.Generic_fmt.cexp beta (FLT_exp prec emin) x\n372:     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.cexp beta (FloatSpec.Core.FIX.FIX_exp (emin := emin)) x).run⌝⦄ := by\n373:   intro _\n374:   sorry\n375: \n376: end FloatSpec.Core.FLT\n377: \n378: namespace FloatSpec.Core.FLT\n379: \n380: variable (prec emin : Int)\n381: \n382: /-\n383: Coq (FLT.v):\n384: Theorem generic_format_FLT_1 :\n385:   (emin <= 0)%Z ->\n386:   generic_format beta FLT_exp 1.\n387: -/\n388: theorem generic_format_FLT_1 (beta : Int) :\n389:     ⦃⌜emin ≤ 0⌝⦄\n390:     generic_format beta (FLT_exp prec emin) 1\n391:     ⦃⇓result => ⌜result⌝⦄ := by\n392:   intro _\n393:   sorry\n394: \n395: end FloatSpec.Core.FLT\n396: \n397: namespace FloatSpec.Core.FLT\n398: \n399: variable (prec emin : Int)\n400: \n401: /-\n402: Coq (FLT.v):\n403: Theorem generic_format_FLX_FLT :\n404:   forall x : R,\n405:   generic_format beta FLT_exp x -> generic_format beta (FLX_exp prec) x.\n406: -/\n407: theorem generic_format_FLX_FLT (beta : Int) (x : ℝ) :\n408:     ⦃⌜(generic_format beta (FLT_exp prec emin) x).run⌝⦄\n409:     generic_format beta (FLX.FLX_exp prec) x\n410:     ⦃⇓result => ⌜result⌝⦄ := by\n411:   intro hx\n412:   sorry\n413: \n414: end FloatSpec.Core.FLT\n415: \n416: namespace FloatSpec.Core.FLT\n417: \n418: variable (prec emin : Int)\n419: \n420: /-\n421: Coq (FLT.v):\n422: Theorem ulp_FLT_le:\n423:   forall x, (bpow (emin + prec - 1) <= Rabs x)%R ->\n424:   (ulp beta FLT_exp x <= Rabs x * bpow (1 - prec))%R.\n425: -/\n426: theorem ulp_FLT_le (beta : Int) (x : ℝ) :\n427:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄\n428:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n429:     ⦃⇓r => ⌜r ≤ |x| * (beta : ℝ) ^ (1 - prec)⌝⦄ := by\n430:   intro _\n431:   sorry\n432: \n433: /-\n434: Coq (FLT.v):\n435: Theorem ulp_FLT_gt:\n436:   forall x, (Rabs x * bpow (-prec) < ulp beta FLT_exp x)%R.\n437: -/\n438: theorem ulp_FLT_gt (beta : Int) (x : ℝ) :\n439:     ⦃⌜True⌝⦄\n440:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n441:     ⦃⇓r => ⌜|x| * (beta : ℝ) ^ (-prec) < r⌝⦄ := by\n442:   intro _\n443:   sorry\n444: \n445: /-\n446: Coq (FLT.v):\n447: Lemma ulp_FLT_exact_shift:\n448:   forall x e,\n449:   (x <> 0)%R ->\n450:   (emin + prec <= mag beta x)%Z ->\n451:   (emin + prec - mag beta x <= e)%Z ->\n452:   (ulp beta FLT_exp (x * bpow e) = ulp beta FLT_exp x * bpow e)%R.\n453: -/\n454: theorem ulp_FLT_exact_shift (beta : Int) (x : ℝ) (e : Int) :\n455:     ⦃⌜x ≠ 0 ∧ emin + prec ≤ FloatSpec.Core.Generic_fmt.mag beta x ∧ emin + prec - FloatSpec.Core.Generic_fmt.mag beta x ≤ e⌝⦄\n456:     (do\n457:       let u1 ← FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) (x * (beta : ℝ) ^ e)\n458:       let u2 ← FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n459:       pure (u1, u2))\n460:     ⦃⇓p => ⌜p.1 = p.2 * (beta : ℝ) ^ e⌝⦄ := by\n461:   intro _\n462:   sorry\n463: \n464: end FloatSpec.Core.FLT\n465: \n466: namespace FloatSpec.Core.FLT\n467: \n468: variable (prec emin : Int)\n469: \n470: /-\n471: Coq (FLT.v):\n472: Theorem round_FLT_FLX : forall rnd x,\n473:   (bpow (emin + prec - 1) <= Rabs x)%R ->\n474:   round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x.\n475: \n476: Lean (spec): Under the lower-bound condition on |x|, rounding in\n477: FLT equals rounding in FLX for any rounding predicate `rnd`.\n478: -/\n479: theorem round_FLT_FLX (beta : Int) (rnd : ℝ → ℝ → Prop) (x : ℝ) :\n480:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄\n481:     (pure (\n482:       FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x,\n483:       FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x) : Id (ℝ × ℝ))\n484:     ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by\n485:   intro _\n486:   sorry\n487: \n488: end FloatSpec.Core.FLT\n489: \n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Defs\n20 : import FloatSpec.src.Core.Generic_fmt\n21 : import FloatSpec.src.Core.Round_generic\n22 : import FloatSpec.src.Core.Ulp\n23 : import FloatSpec.src.Core.FLX\n24 : import FloatSpec.src.Core.FIX\n25 : import Mathlib.Data.Real.Basic\n26 : import Std.Do.Triple\n27 : import Std.Tactic.Do\n28 : \n29 : open Real\n30 : open Std.Do\n31 : open FloatSpec.Core.Generic_fmt\n32 : open FloatSpec.Core.Round_generic\n33 : \n34 : namespace FloatSpec.Core.FLT\n35 : \n36 : variable (prec emin : Int)\n37 : \n38 : /-- Floating-point exponent function\n39 : \n40 :     The FLT exponent function combines fixed-precision behavior\n41 :     with a minimum exponent bound. It returns max(e - prec, emin),\n42 :     providing precision when possible but limiting underflow.\n43 : -/\n44 : def FLT_exp (e : Int) : Int :=\n45 :   max (e - prec) emin\n46 : \n47 : /-- Check FLT exponent function correctness\n48 : \n49 :     Verify that the FLT exponent function correctly computes\n50 :     the maximum of (e - prec) and emin. This validates the\n51 :     IEEE 754-style exponent calculation.\n52 : -/\n53 : def FLT_exp_correct_check (e : Int) : Id Bool :=\n54 :   pure (FLT_exp prec emin e = max (e - prec) emin)\n55 : \n56 : /-- Specification: FLT exponent calculation\n57 : \n58 :     The FLT exponent function implements IEEE 754-style floating-point\n59 :     exponent calculation: it maintains precision by using e - prec\n60 :     when possible, but enforces a minimum exponent emin to prevent\n61 :     excessive underflow and maintain gradual underflow behavior.\n62 : -/\n63 : theorem FLT_exp_spec (e : Int) :\n64 :     ⦃⌜True⌝⦄\n65 :     FLT_exp_correct_check prec emin e\n66 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n67 :   sorry\n68 : \n69 : /-- Floating-point format predicate\n70 : \n71 :     A real number x is in FLT format if it can be represented\n72 :     using the generic format with the FLT exponent function.\n73 :     This gives IEEE 754-style floating-point representation\n74 :     with both precision and minimum exponent constraints.\n75 : -/\n76 : def FLT_format (beta : Int) (x : ℝ) : Id Prop :=\n77 :   pure (generic_format beta (FLT_exp prec emin) x)\n78 : \n79 : /-- Valid_exp instance for the FLT exponent function (placeholder). -/\n80 : instance FLT_exp_valid (beta : Int) :\n81 :     FloatSpec.Core.Generic_fmt.Valid_exp beta (FLT_exp prec emin) := by\n82 :   refine ⟨?_⟩\n83 :   intro k\n84 :   refine And.intro ?h1 ?h2\n85 :   · intro _\n86 :     -- Proof omitted for now\n87 :     sorry\n88 :   · intro _\n89 :     refine And.intro ?hA ?hB\n90 :     · -- Proof omitted for now\n91 :       sorry\n92 :     · intro _ _\n93 :       -- Proof omitted for now\n94 :       sorry\n95 : \n96 : /-- Specification: FLT format using generic format\n97 : \n98 :     The FLT format combines the benefits of fixed-precision\n99 :     (for normal numbers) with minimum exponent protection\n100:     (for subnormal numbers), matching IEEE 754 behavior.\n101: -/\n102: theorem FLT_format_spec (beta : Int) (x : ℝ) :\n103:     ⦃⌜True⌝⦄\n104:     FLT_format prec emin beta x\n105:     ⦃⇓result => ⌜result = (generic_format beta (FLT_exp prec emin) x)⌝⦄ := by\n106:   sorry\n107: \n108: /-- Specification: FLT exponent function correctness\n109: \n110:     The FLT exponent function correctly implements the IEEE 754\n111:     exponent selection logic, choosing between precision-based\n112:     and minimum-bounded exponents as appropriate.\n113: -/\n114: theorem FLT_exp_correct_spec (e : Int) :\n115:     ⦃⌜True⌝⦄\n116:     FLT_exp_correct_check prec emin e\n117:     ⦃⇓result => ⌜result = true⌝⦄ := by\n118:   sorry\n119: \n120: /-- Check if zero is in FLT format\n121: \n122:     Verify that zero is representable in the floating-point format.\n123:     Zero should always be representable as 0 × β^e for any\n124:     allowed exponent e, making it universal across FLT formats.\n125: -/\n126: def FLT_format_0_check (beta : Int) : Id Bool :=\n127:   pure true  -- Zero is always in format\n128: \n129: /-- Specification: Zero is in FLT format\n130: \n131:     Zero is always representable in FLT format since it can\n132:     be expressed as 0 × β^e for any exponent e, regardless\n133:     of precision or minimum exponent constraints.\n134: -/\n135: theorem FLT_format_0_spec (beta : Int) :\n136:     ⦃⌜beta > 1⌝⦄\n137:     FLT_format_0_check beta\n138:     ⦃⇓result => ⌜result = true⌝⦄ := by\n139:   sorry\n140: \n141: /-- Check closure under negation\n142: \n143:     Verify that if x is in FLT format, then -x is also in FLT format.\n144:     This tests the sign symmetry property of IEEE 754-style\n145:     floating-point representation.\n146: -/\n147: def FLT_format_opp_check (beta : Int) (x : ℝ) : Id Bool :=\n148:   pure true  -- Always true for FLT formats\n149: \n150: /-- Specification: FLT format closed under negation\n151: \n152:     FLT formats are closed under negation. If x = m × β^e\n153:     is representable, then -x = (-m) × β^e is also representable\n154:     using the same exponent and negated mantissa.\n155: -/\n156: theorem FLT_format_opp_spec (beta : Int) (x : ℝ) :\n157:     ⦃⌜(FLT_format prec emin beta x).run⌝⦄\n158:     FLT_format_opp_check beta x\n159:     ⦃⇓result => ⌜result = true⌝⦄ := by\n160:   sorry\n161: \n162: /-- Check closure under absolute value\n163: \n164:     Verify that if x is in FLT format, then |x| is also in FLT format.\n165:     This tests the magnitude preservation property, ensuring that\n166:     absolute values remain representable.\n167: -/\n168: def FLT_format_abs_check (beta : Int) (x : ℝ) : Id Bool :=\n169:   pure true  -- Always true for FLT formats\n170: \n171: /-- Specification: FLT format closed under absolute value\n172: \n173:     FLT formats are closed under absolute value operations.\n174:     The magnitude of a representable number is always\n175:     representable using the same exponent structure.\n176: -/\n177: theorem FLT_format_abs_spec (beta : Int) (x : ℝ) :\n178:     ⦃⌜(FLT_format prec emin beta x).run⌝⦄\n179:     FLT_format_abs_check beta x\n180:     ⦃⇓result => ⌜result = true⌝⦄ := by\n181:   sorry\n182: \n183: /-- Check relationship between FLT and FLX formats\n184: \n185:     When the minimum exponent constraint is not active\n186:     (i.e., emin ≤ e - prec), FLT behaves exactly like FLX.\n187:     This verifies the normal number behavior of IEEE 754.\n188: -/\n189: def FLT_exp_FLX_check (e : Int) : Id Bool :=\n190:   pure (emin ≤ e - prec → FLT_exp prec emin e = FLX.FLX_exp prec e)\n191: \n192: /-- Specification: FLT reduces to FLX for normal numbers\n193: \n194:     When the precision-based exponent e - prec exceeds emin,\n195:     FLT format behaves identically to FLX format. This captures\n196:     the normal number range of IEEE 754 floating-point.\n197: -/\n198: theorem FLT_exp_FLX_spec (e : Int) :\n199:     ⦃⌜emin ≤ e - prec⌝⦄\n200:     FLT_exp_FLX_check prec emin e\n201:     ⦃⇓result => ⌜result = true⌝⦄ := by\n202:   sorry\n203: \n204: /-\n205: Coq (FLT.v):\n206: Theorem generic_format_FLT :\n207:   forall x, FLT_format x -> generic_format beta FLT_exp x.\n208: -/\n209: theorem generic_format_FLT (beta : Int) (x : ℝ) :\n210:     ⦃⌜(FLT_format prec emin beta x).run⌝⦄\n211:     generic_format beta (FLT_exp prec emin) x\n212:     ⦃⇓result => ⌜result⌝⦄ := by\n213:   intro hx\n214:   simpa [FLT_format]\n215: \n216: /-\n217: Coq (FLT.v):\n218: Theorem FLT_format_generic :\n219:   forall x, generic_format beta FLT_exp x -> FLT_format x.\n220: -/\n221: theorem FLT_format_generic (beta : Int) (x : ℝ) :\n222:     ⦃⌜(generic_format beta (FLT_exp prec emin) x).run⌝⦄\n223:     FLT_format prec emin beta x\n224:     ⦃⇓result => ⌜result⌝⦄ := by\n225:   intro hx\n226:   simpa [FLT_format] using hx\n227: \n228: /-\n229: Coq (FLT.v):\n230: Theorem FLT_format_satisfies_any :\n231:   satisfies_any FLT_format.\n232: -/\n233: theorem FLT_format_satisfies_any (beta : Int) :\n234:     FloatSpec.Core.Generic_fmt.satisfies_any (fun y => (FLT_format prec emin beta y).run) := by\n235:   simpa [FLT_format]\n236:     using FloatSpec.Core.Generic_fmt.generic_format_satisfies_any (beta := beta) (fexp := FLT_exp prec emin)\n237: \n238: /-\n239: Coq (FLT.v):\n240: Theorem generic_format_FLT_bpow :\n241:   forall e, (emin <= e)%Z -> generic_format beta FLT_exp (bpow e).\n242: -/\n243: theorem generic_format_FLT_bpow (beta : Int) (e : Int) :\n244:     ⦃⌜emin ≤ e⌝⦄\n245:     generic_format beta (FLT_exp prec emin) ((beta : ℝ) ^ e)\n246:     ⦃⇓result => ⌜result⌝⦄ := by\n247:   intro _\n248:   sorry\n249: \n250: /-\n251: Coq (FLT.v):\n252: Theorem FLT_format_bpow :\n253:   forall e, (emin <= e)%Z -> FLT_format (bpow e).\n254: -/\n255: theorem FLT_format_bpow (beta : Int) (e : Int) :\n256:     ⦃⌜emin ≤ e⌝⦄\n257:     FLT_format prec emin beta ((beta : ℝ) ^ e)\n258:     ⦃⇓result => ⌜result⌝⦄ := by\n259:   intro _\n260:   sorry\n261: \n262: /-\n263: Coq (FLT.v):\n264: Theorem generic_format_FLT_FLX :\n265:   forall x : R,\n266:   (bpow (emin + prec - 1) <= Rabs x)%R ->\n267:   generic_format beta (FLX_exp prec) x ->\n268:   generic_format beta FLT_exp x.\n269: -/\n270: theorem generic_format_FLT_FLX (beta : Int) (x : ℝ) :\n271:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x| ∧ (generic_format beta (FLX.FLX_exp prec) x).run⌝⦄\n272:     generic_format beta (FLT_exp prec emin) x\n273:     ⦃⇓result => ⌜result⌝⦄ := by\n274:   intro _\n275:   sorry\n276: \n277: /-\n278: Coq (FLT.v):\n279: Theorem cexp_FLT_FLX :\n280:   forall x,\n281:   (bpow (emin + prec - 1) <= Rabs x)%R ->\n282:   cexp beta FLT_exp x = cexp beta (FLX_exp prec) x.\n283: -/\n284: theorem cexp_FLT_FLX (beta : Int) (x : ℝ) :\n285:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄\n286:     FloatSpec.Core.Generic_fmt.cexp beta (FLT_exp prec emin) x\n287:     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.cexp beta (FLX.FLX_exp prec) x).run⌝⦄ := by\n288:   intro _\n289:   sorry\n290: \n291: end FloatSpec.Core.FLT\n292: \n293: namespace FloatSpec.Core.FLT\n294: \n295: variable (prec emin : Int)\n296: \n297: /-\n298: Coq (FLT.v):\n299: Theorem generic_format_FIX_FLT :\n300:   forall x : R,\n301:   generic_format beta FLT_exp x ->\n302:   generic_format beta (FIX_exp emin) x.\n303: -/\n304: theorem generic_format_FIX_FLT (beta : Int) (x : ℝ) :\n305:     ⦃⌜(generic_format beta (FLT_exp prec emin) x).run⌝⦄\n306:     generic_format beta (FloatSpec.Core.FIX.FIX_exp (emin := emin)) x\n307:     ⦃⇓result => ⌜result⌝⦄ := by\n308:   intro _\n309:   sorry\n310: \n311: end FloatSpec.Core.FLT\n312: \n313: namespace FloatSpec.Core.FLT\n314: \n315: variable (prec emin : Int)\n316: \n317: /-\n318: Coq (FLT.v):\n319: Theorem generic_format_FLT_FIX :\n320:   forall x : R,\n321:   (Rabs x <= bpow (emin + prec))%R ->\n322:   generic_format beta (FIX_exp emin) x ->\n323:   generic_format beta FLT_exp x.\n324: -/\n325: theorem generic_format_FLT_FIX (beta : Int) (x : ℝ) :\n326:     ⦃⌜|x| ≤ (beta : ℝ) ^ (emin + prec) ∧ (generic_format beta (FloatSpec.Core.FIX.FIX_exp (emin := emin)) x).run⌝⦄\n327:     generic_format beta (FLT_exp prec emin) x\n328:     ⦃⇓result => ⌜result⌝⦄ := by\n329:   intro _\n330:   sorry\n331: \n332: end FloatSpec.Core.FLT\n333: \n334: namespace FloatSpec.Core.FLT\n335: \n336: variable (prec emin : Int)\n337: \n338: /-- Coq (FLT.v):\n339: Theorem ulp_FLT_0 : ulp beta FLT_exp 0 = bpow emin.\n340: \n341: Lean (spec): The ULP under FLT at 0 equals `β^emin`.\n342: -/\n343: theorem ulp_FLT_0 (beta : Int) :\n344:     ⦃⌜True⌝⦄\n345:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) 0\n346:     ⦃⇓r => ⌜r = (beta : ℝ) ^ emin⌝⦄ := by\n347:   sorry\n348: \n349: /-- Coq (FLT.v):\n350: Theorem ulp_FLT_small:\n351:   forall x, Rabs x < bpow (emin + prec) -> ulp beta FLT_exp x = bpow emin.\n352: \n353: Lean (spec): If |x| < β^(emin+prec), then ULP under FLT at x equals `β^emin`.\n354: -/\n355: theorem ulp_FLT_small (beta : Int) (x : ℝ) :\n356:     ⦃⌜|x| < (beta : ℝ) ^ (emin + prec)⌝⦄\n357:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n358:     ⦃⇓r => ⌜r = (beta : ℝ) ^ emin⌝⦄ := by\n359:   intro _\n360:   sorry\n361: \n362: /-\n363: Coq (FLT.v):\n364: Theorem cexp_FLT_FIX :\n365:   forall x, x <> 0%R ->\n366:   (Rabs x < bpow (emin + prec))%R ->\n367:   cexp beta FLT_exp x = cexp beta (FIX_exp emin) x.\n368: -/\n369: theorem cexp_FLT_FIX (beta : Int) (x : ℝ) :\n370:     ⦃⌜x ≠ 0 ∧ |x| < (beta : ℝ) ^ (emin + prec)⌝⦄\n371:     FloatSpec.Core.Generic_fmt.cexp beta (FLT_exp prec emin) x\n372:     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.cexp beta (FloatSpec.Core.FIX.FIX_exp (emin := emin)) x).run⌝⦄ := by\n373:   intro _\n374:   sorry\n375: \n376: end FloatSpec.Core.FLT\n377: \n378: namespace FloatSpec.Core.FLT\n379: \n380: variable (prec emin : Int)\n381: \n382: /-\n383: Coq (FLT.v):\n384: Theorem generic_format_FLT_1 :\n385:   (emin <= 0)%Z ->\n386:   generic_format beta FLT_exp 1.\n387: -/\n388: theorem generic_format_FLT_1 (beta : Int) :\n389:     ⦃⌜emin ≤ 0⌝⦄\n390:     generic_format beta (FLT_exp prec emin) 1\n391:     ⦃⇓result => ⌜result⌝⦄ := by\n392:   intro _\n393:   sorry\n394: \n395: end FloatSpec.Core.FLT\n396: \n397: namespace FloatSpec.Core.FLT\n398: \n399: variable (prec emin : Int)\n400: \n401: /-\n402: Coq (FLT.v):\n403: Theorem generic_format_FLX_FLT :\n404:   forall x : R,\n405:   generic_format beta FLT_exp x -> generic_format beta (FLX_exp prec) x.\n406: -/\n407: theorem generic_format_FLX_FLT (beta : Int) (x : ℝ) :\n408:     ⦃⌜(generic_format beta (FLT_exp prec emin) x).run⌝⦄\n409:     generic_format beta (FLX.FLX_exp prec) x\n410:     ⦃⇓result => ⌜result⌝⦄ := by\n411:   intro hx\n412:   sorry\n413: \n414: end FloatSpec.Core.FLT\n415: \n416: namespace FloatSpec.Core.FLT\n417: \n418: variable (prec emin : Int)\n419: \n420: /-\n421: Coq (FLT.v):\n422: Theorem ulp_FLT_le:\n423:   forall x, (bpow (emin + prec - 1) <= Rabs x)%R ->\n424:   (ulp beta FLT_exp x <= Rabs x * bpow (1 - prec))%R.\n425: -/\n426: theorem ulp_FLT_le (beta : Int) (x : ℝ) :\n427:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄\n428:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n429:     ⦃⇓r => ⌜r ≤ |x| * (beta : ℝ) ^ (1 - prec)⌝⦄ := by\n430:   intro _\n431:   sorry\n432: \n433: /-\n434: Coq (FLT.v):\n435: Theorem ulp_FLT_gt:\n436:   forall x, (Rabs x * bpow (-prec) < ulp beta FLT_exp x)%R.\n437: -/\n438: theorem ulp_FLT_gt (beta : Int) (x : ℝ) :\n439:     ⦃⌜True⌝⦄\n440:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n441:     ⦃⇓r => ⌜|x| * (beta : ℝ) ^ (-prec) < r⌝⦄ := by\n442:   intro _\n443:   sorry\n444: \n445: /-\n446: Coq (FLT.v):\n447: Lemma ulp_FLT_exact_shift:\n448:   forall x e,\n449:   (x <> 0)%R ->\n450:   (emin + prec <= mag beta x)%Z ->\n451:   (emin + prec - mag beta x <= e)%Z ->\n452:   (ulp beta FLT_exp (x * bpow e) = ulp beta FLT_exp x * bpow e)%R.\n453: -/\n454: theorem ulp_FLT_exact_shift (beta : Int) (x : ℝ) (e : Int) :\n455:     ⦃⌜x ≠ 0 ∧ emin + prec ≤ FloatSpec.Core.Generic_fmt.mag beta x ∧ emin + prec - FloatSpec.Core.Generic_fmt.mag beta x ≤ e⌝⦄\n456:     (do\n457:       let u1 ← FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) (x * (beta : ℝ) ^ e)\n458:       let u2 ← FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n459:       pure (u1, u2))\n460:     ⦃⇓p => ⌜p.1 = p.2 * (beta : ℝ) ^ e⌝⦄ := by\n461:   intro _\n462:   sorry\n463: \n464: end FloatSpec.Core.FLT\n465: \n466: namespace FloatSpec.Core.FLT\n467: \n468: variable (prec emin : Int)\n469: \n470: /-\n471: Coq (FLT.v):\n472: Theorem round_FLT_FLX : forall rnd x,\n473:   (bpow (emin + prec - 1) <= Rabs x)%R ->\n474:   round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x.\n475: \n476: Lean (spec): Under the lower-bound condition on |x|, rounding in\n477: FLT equals rounding in FLX for any rounding predicate `rnd`.\n478: -/\n479: theorem round_FLT_FLX (beta : Int) (rnd : ℝ → ℝ → Prop) (x : ℝ) :\n480:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄\n481:     (pure (\n482:       FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x,\n483:       FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x) : Id (ℝ × ℝ))\n484:     ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by\n485:   intro _\n486:   sorry\n487: \n488: end FloatSpec.Core.FLT\n489: \n"
  }
}
[2025-09-16T03:36:46] tokens used: 55346
[2025-09-16T03:36:50] codex

Now I’ll open `Raux.lean` to find missing theorems we can introduce.
[2025-09-16T03:36:51] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Raux.lean","annotate_lines":true})
[2025-09-16T03:36:51] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Raux.lean","annotate_lines":true}) success in 3ms:
{
  "content": [
    {
      "text": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Zaux\n20 : import Mathlib.Data.Real.Basic\n21 : import Mathlib.Data.Real.Sqrt\n22 : import Std.Do.Triple\n23 : import Std.Tactic.Do\n24 : \n25 : open Real\n26 : open Std.Do\n27 : \n28 : namespace FloatSpec.Core.Raux\n29 : \n30 : section Rmissing\n31 : \n32 : /-- Subtraction ordering principle\n33 : \n34 :     If x ≤ y, then the difference y - x is non-negative.\n35 :     This is a fundamental property used throughout real analysis.\n36 : -/\n37 : def Rle_0_minus (x y : ℝ) : Id ℝ :=\n38 :   y - x\n39 : \n40 : /-- Specification: Subtraction ordering principle\n41 : \n42 :     The operation ensures that if x ≤ y, then y - x ≥ 0.\n43 :     This captures the relationship between ordering and subtraction.\n44 : -/\n45 : theorem Rle_0_minus_spec (x y : ℝ) :\n46 :     ⦃⌜x ≤ y⌝⦄\n47 :     Rle_0_minus x y\n48 :     ⦃⇓result => ⌜0 ≤ result⌝⦄ := by\n49 :   intro h\n50 :   unfold Rle_0_minus\n51 :   exact sub_nonneg_of_le h\n52 : \n53 : /-- Absolute values equal implies values are equal up to sign\n54 : \n55 :     If |x| = |y|, then either x = y or x = -y.\n56 :     This captures the two possible cases for equal magnitudes.\n57 : -/\n58 : def Rabs_eq_Rabs_case (x y : ℝ) : Id (ℝ × ℝ) :=\n59 :   (x, y)\n60 : \n61 : /-- Specification: Equal absolute values give equality up to sign\n62 : \n63 :     Under the precondition |x| = |y|, the pair (x, y) satisfies\n64 :     x = y or x = -y.\n65 : -/\n66 : theorem Rabs_eq_Rabs_spec (x y : ℝ) :\n67 :     ⦃⌜|x| = |y|⌝⦄\n68 :     Rabs_eq_Rabs_case x y\n69 :     ⦃⇓p => ⌜p.1 = p.2 ∨ p.1 = -p.2⌝⦄ := by\n70 :   intro _\n71 :   unfold Rabs_eq_Rabs_case\n72 :   -- Proof follows Coq's Rabs_eq_Rabs; omitted for now\n73 :   sorry\n74 : \n75 : /-- Absolute value of difference bounded under simple conditions\n76 : \n77 :     If 0 ≤ y and y ≤ 2*x, then |x - y| ≤ x.\n78 : -/\n79 : def Rabs_minus_le_val (x y : ℝ) : Id ℝ :=\n80 :   pure (abs (x - y))\n81 : \n82 : /-- Specification: Bound on |x - y|\n83 : \n84 :     Under 0 ≤ y and y ≤ 2*x, the value |x - y| is bounded by x.\n85 : -/\n86 : theorem Rabs_minus_le_spec (x y : ℝ) :\n87 :     ⦃⌜0 ≤ y ∧ y ≤ 2 * x⌝⦄\n88 :     Rabs_minus_le_val x y\n89 :     ⦃⇓r => ⌜r ≤ x⌝⦄ := by\n90 :   intro _\n91 :   unfold Rabs_minus_le_val\n92 :   -- Proof follows Coq's Rabs_minus_le; omitted for now\n93 :   sorry\n94 : \n95 : /-- Lower bound characterization via absolute value\n96 : \n97 :     If y ≤ -x or x ≤ y, then x ≤ |y|.\n98 : -/\n99 : def Rabs_ge_case (x y : ℝ) : Id (ℝ × ℝ) :=\n100:   (x, y)\n101: \n102: theorem Rabs_ge_spec (x y : ℝ) :\n103:     ⦃⌜y ≤ -x ∨ x ≤ y⌝⦄\n104:     Rabs_ge_case x y\n105:     ⦃⇓p => ⌜p.1 ≤ |p.2|⌝⦄ := by\n106:   intro _\n107:   unfold Rabs_ge_case\n108:   -- Proof follows Coq's Rabs_ge; omitted for now\n109:   sorry\n110: \n111: /-- Inverse characterization: x ≤ |y| implies y ≤ -x or x ≤ y. -/\n112: def Rabs_ge_inv_case (x y : ℝ) : Id (ℝ × ℝ) :=\n113:   (x, y)\n114: \n115: theorem Rabs_ge_inv_spec (x y : ℝ) :\n116:     ⦃⌜x ≤ |y|⌝⦄\n117:     Rabs_ge_inv_case x y\n118:     ⦃⇓p => ⌜p.2 ≤ -p.1 ∨ p.1 ≤ p.2⌝⦄ := by\n119:   intro _\n120:   unfold Rabs_ge_inv_case\n121:   -- Proof follows Coq's Rabs_ge_inv; omitted for now\n122:   sorry\n123: \n124: /-- Multiplication preserves strict inequalities\n125: \n126:     For non-negative values, strict inequalities are preserved\n127:     under multiplication. This is essential for scaling arguments\n128:     in floating-point proofs.\n129: -/\n130: def Rmult_lt_compat (r1 r2 r3 r4 : ℝ) : Id (ℝ × ℝ) :=\n131:   (r1 * r3, r2 * r4)\n132: \n133: /-- Specification: Multiplication preserves strict inequalities\n134: \n135:     If 0 ≤ r1, 0 ≤ r3, r1 < r2, and r3 < r4, then r1 * r3 < r2 * r4.\n136:     This property is crucial for analyzing products of bounds.\n137: -/\n138: theorem Rmult_lt_compat_spec (r1 r2 r3 r4 : ℝ) :\n139:     ⦃⌜0 ≤ r1 ∧ 0 ≤ r3 ∧ r1 < r2 ∧ r3 < r4⌝⦄\n140:     Rmult_lt_compat r1 r2 r3 r4\n141:     ⦃⇓result => ⌜result.1 < result.2⌝⦄ := by\n142:   intro h\n143:   unfold Rmult_lt_compat\n144:   have ⟨h1, h3, h12, h34⟩ := h\n145:   by_cases hr3 : r3 = 0\n146:   · subst hr3\n147:     simp\n148:     exact mul_pos (h1.trans_lt h12) h34\n149:   · have h3_pos : 0 < r3 := lt_of_le_of_ne h3 (Ne.symm hr3)\n150:     exact mul_lt_mul h12 (le_of_lt h34) h3_pos (le_of_lt (h1.trans_lt h12))\n151: \n152: /-- Right multiplication cancellation for inequality\n153: \n154:     If products are unequal and the right factor is the same,\n155:     then the left factors must be unequal.\n156: -/\n157: def Rmult_neq_reg_r (_r1 r2 r3 : ℝ) : Id (ℝ × ℝ) :=\n158:   (r2, r3)\n159: \n160: /-- Specification: Right multiplication cancellation\n161: \n162:     If r2 * r1 ≠ r3 * r1, then r2 ≠ r3.\n163:     This allows cancellation in multiplication inequalities.\n164: -/\n165: theorem Rmult_neq_reg_r_spec (r1 r2 r3 : ℝ) :\n166:     ⦃⌜r2 * r1 ≠ r3 * r1⌝⦄\n167:     Rmult_neq_reg_r r1 r2 r3\n168:     ⦃⇓result => ⌜result.1 ≠ result.2⌝⦄ := by\n169:   intro h\n170:   unfold Rmult_neq_reg_r\n171:   simp\n172:   intro h_eq\n173:   -- h_eq : r2 = r3, but we need to prove False from r2 * r1 ≠ r3 * r1\n174:   apply h\n175:   -- Convert r2 = r3 to r2 * r1 = r3 * r1\n176:   congr 1\n177: \n178: /-- Multiplication preserves non-equality\n179: \n180:     Multiplying unequal numbers by a non-zero value\n181:     preserves the inequality.\n182: -/\n183: def Rmult_neq_compat_r (r1 r2 r3 : ℝ) : Id (ℝ × ℝ) :=\n184:   (r2 * r1, r3 * r1)\n185: \n186: /-- Specification: Multiplication preserves non-equality\n187: \n188:     If r1 ≠ 0 and r2 ≠ r3, then r2 * r1 ≠ r3 * r1.\n189: -/\n190: theorem Rmult_neq_compat_r_spec (r1 r2 r3 : ℝ) :\n191:     ⦃⌜r1 ≠ 0 ∧ r2 ≠ r3⌝⦄\n192:     Rmult_neq_compat_r r1 r2 r3\n193:     ⦃⇓result => ⌜result.1 ≠ result.2⌝⦄ := by\n194:   intro h\n195:   unfold Rmult_neq_compat_r\n196:   simp\n197:   have ⟨h1_ne, h23_ne⟩ := h\n198:   intro h_eq\n199:   -- h_eq : r2 * r1 = r3 * r1\n200:   -- This would imply r2 = r3 when r1 ≠ 0, contradicting h23_ne\n201:   have : r2 = r3 := mul_right_cancel₀ h1_ne h_eq\n202:   exact h23_ne this\n203: \n204: /-- Right distributivity of minimum over multiplication\n205: \n206:     For non-negative multipliers, minimum distributes over\n207:     multiplication from the right.\n208: -/\n209: def Rmult_min_distr_r (x y z : ℝ) : Id (ℝ × ℝ) :=\n210:   (min (x * z) (y * z), min x y * z)\n211: \n212: /-- Specification: Right distributivity of minimum\n213: \n214:     If 0 ≤ z, then min (x * z) (y * z) = min x y * z.\n215: -/\n216: theorem Rmult_min_distr_r_spec (x y z : ℝ) :\n217:     ⦃⌜0 ≤ z⌝⦄\n218:     Rmult_min_distr_r x y z\n219:     ⦃⇓result => ⌜result.1 = result.2⌝⦄ := by\n220:   intro h\n221:   unfold Rmult_min_distr_r\n222:   -- We need to prove: min (x * z) (y * z) = min x y * z\n223:   rw [min_mul_of_nonneg _ _ h]\n224:   rfl\n225: \n226: /-- Left distributivity of minimum over multiplication\n227: \n228:     For non-negative multipliers, minimum distributes over\n229:     multiplication from the left.\n230: -/\n231: def Rmult_min_distr_l (x y z : ℝ) : Id (ℝ × ℝ) :=\n232:   (min (x * y) (x * z), x * min y z)\n233: \n234: /-- Specification: Left distributivity of minimum\n235: \n236:     If 0 ≤ x, then min (x * y) (x * z) = x * min y z.\n237: -/\n238: theorem Rmult_min_distr_l_spec (x y z : ℝ) :\n239:     ⦃⌜0 ≤ x⌝⦄\n240:     Rmult_min_distr_l x y z\n241:     ⦃⇓result => ⌜result.1 = result.2⌝⦄ := by\n242:   intro h\n243:   unfold Rmult_min_distr_l\n244:   -- We need to prove: min (x * y) (x * z) = x * min y z\n245:   rw [mul_min_of_nonneg _ _ h]\n246:   rfl\n247: \n248: /-- Minimum of opposites equals negative maximum\n249: \n250:     Taking the minimum of negated values is equivalent\n251:     to negating the maximum of the original values.\n252: -/\n253: def Rmin_opp (x y : ℝ) : Id (ℝ × ℝ) :=\n254:   (min (-x) (-y), -(max x y))\n255: \n256: /-- Specification: Minimum of opposites\n257: \n258:     min (-x) (-y) = -(max x y).\n259:     This duality between min and max under negation is fundamental.\n260: -/\n261: theorem Rmin_opp_spec (x y : ℝ) :\n262:     ⦃⌜True⌝⦄\n263:     Rmin_opp x y\n264:     ⦃⇓result => ⌜result.1 = result.2⌝⦄ := by\n265:   intro _\n266:   unfold Rmin_opp\n267:   -- We need to prove: min (-x) (-y) = -(max x y)\n268:   exact min_neg_neg x y\n269: \n270: /-- Maximum of opposites equals negative minimum\n271: \n272:     Taking the maximum of negated values is equivalent\n273:     to negating the minimum of the original values.\n274: -/\n275: def Rmax_opp (x y : ℝ) : Id (ℝ × ℝ) :=\n276:   (max (-x) (-y), -(min x y))\n277: \n278: /-- Specification: Maximum of opposites\n279: \n280:     max (-x) (-y) = -(min x y).\n281:     This completes the duality between min/max under negation.\n282: -/\n283: theorem Rmax_opp_spec (x y : ℝ) :\n284:     ⦃⌜True⌝⦄\n285:     Rmax_opp x y\n286:     ⦃⇓result => ⌜result.1 = result.2⌝⦄ := by\n287:   intro _\n288:   unfold Rmax_opp\n289:   -- We need to prove: max (-x) (-y) = -(min x y)\n290:   exact max_neg_neg x y\n291: \n292: /-- Monotonicity of the exponential function\n293: \n294:     If x ≤ y, then exp x ≤ exp y. This captures the\n295:     strict monotonicity of the real exponential function.\n296: -/\n297: noncomputable def exp_le_check (x y : ℝ) : Id ℝ :=\n298:   pure (Real.exp x)\n299: \n300: /-- Specification: Exponential is monotone increasing\n301: \n302:     Given x ≤ y, the value exp x is bounded above by exp y.\n303: -/\n304: theorem exp_le_spec (x y : ℝ) :\n305:     ⦃⌜x ≤ y⌝⦄\n306:     exp_le_check x y\n307:     ⦃⇓ex => ⌜ex ≤ Real.exp y⌝⦄ := by\n308:   intro _\n309:   -- Follows from monotonicity of Real.exp\n310:   sorry\n311: \n312: end Rmissing\n313: \n314: section Rrecip\n315: \n316: /-- Reciprocal comparison on positives: if 0 < x < y then 1/y < 1/x -/\n317: noncomputable def Rinv_lt_check (x y : ℝ) : Id (ℝ × ℝ) :=\n318:   (1 / y, 1 / x)\n319: \n320: /-- Specification: Reciprocal reverses order on positive reals -/\n321: theorem Rinv_lt_spec (x y : ℝ) :\n322:     ⦃⌜0 < x ∧ x < y⌝⦄\n323:     Rinv_lt_check x y\n324:     ⦃⇓p => ⌜p.1 < p.2⌝⦄ := by\n325:   intro _\n326:   -- Standard property: for 0 < x < y, we have 1/y < 1/x\n327:   sorry\n328: \n329: /-- Reciprocal comparison (≤) on positives: if 0 < x ≤ y then 1/y ≤ 1/x -/\n330: noncomputable def Rinv_le_check (x y : ℝ) : Id (ℝ × ℝ) :=\n331:   (1 / y, 1 / x)\n332: \n333: /-- Specification: Reciprocal is antitone on positive reals (≤ version) -/\n334: theorem Rinv_le_spec (x y : ℝ) :\n335:     ⦃⌜0 < x ∧ x ≤ y⌝⦄\n336:     Rinv_le_check x y\n337:     ⦃⇓p => ⌜p.1 ≤ p.2⌝⦄ := by\n338:   intro _\n339:   -- Standard property: for 0 < x ≤ y, we have 1/y ≤ 1/x\n340:   sorry\n341: \n342: end Rrecip\n343: \n344: section Sqrt\n345: \n346: /-- Nonnegativity of square root\n347: \n348:     The square root of a non-negative real number is itself non-negative.\n349:     This captures the standard property of the real square root function.\n350: -/\n351: noncomputable def sqrt_ge_0_check (x : ℝ) : Id ℝ :=\n352:   Real.sqrt x\n353: \n354: /-- Specification: sqrt is non-negative on ℝ≥0\n355: \n356:     Given 0 ≤ x, the computed value satisfies 0 ≤ sqrt x.\n357: -/\n358: theorem sqrt_ge_0_spec (x : ℝ) :\n359:     ⦃⌜0 ≤ x⌝⦄\n360:     sqrt_ge_0_check x\n361:     ⦃⇓r => ⌜0 ≤ r⌝⦄ := by\n362:   intro _\n363:   unfold sqrt_ge_0_check\n364:   exact Real.sqrt_nonneg x\n365: \n366: end Sqrt\n367: \n368: section Abs\n369: \n370: /-- Check for zero absolute value\n371: \n372:     Encodes the predicate |x| = 0 as a boolean value for specification.\n373: -/\n374: noncomputable def Rabs_eq_R0_check (x : ℝ) : Id Bool :=\n375:   pure (|x| = 0)\n376: \n377: /-- Specification: Absolute value equals zero iff the number is zero\n378: \n379:     The absolute value of a real number is zero if and only if the number itself is zero.\n380: -/\n381: theorem Rabs_eq_R0_spec (x : ℝ) :\n382:     ⦃⌜True⌝⦄\n383:     Rabs_eq_R0_check x\n384:     ⦃⇓b => ⌜b ↔ x = 0⌝⦄ := by\n385:   intro _\n386:   unfold Rabs_eq_R0_check\n387:   -- Standard property: |x| = 0 ↔ x = 0\n388:   sorry\n389: \n390: end Abs\n391: \n392: section AbsMore\n393: \n394: /-- Boolean check for strict inequality on absolute value: |x| < y -/\n395: noncomputable def Rabs_lt_check (x y : ℝ) : Id Bool :=\n396:   pure (|x| < y)\n397: \n398: /-- Specification: |x| < y iff the boolean returns true -/\n399: theorem Rabs_lt_spec (x y : ℝ) :\n400:     ⦃⌜True⌝⦄\n401:     Rabs_lt_check x y\n402:     ⦃⇓b => ⌜b ↔ |x| < y⌝⦄ := by\n403:   intro _\n404:   unfold Rabs_lt_check\n405:   -- Follows from decidability of (<) on ℝ\n406:   sorry\n407: \n408: end AbsMore\n409: \n410: section AbsGt\n411: \n412: /-- Boolean check for strict lower bound on |x|: y < |x| -/\n413: noncomputable def Rabs_gt_check (x y : ℝ) : Id Bool :=\n414:   pure (y < |x|)\n415: \n416: /-- Specification: y < |x| iff the boolean returns true -/\n417: theorem Rabs_gt_spec (x y : ℝ) :\n418:     ⦃⌜True⌝⦄\n419:     Rabs_gt_check x y\n420:     ⦃⇓b => ⌜b ↔ y < |x|⌝⦄ := by\n421:   intro _\n422:   unfold Rabs_gt_check\n423:   -- Follows from decidability of (<) on ℝ\n424:   sorry\n425: \n426: end AbsGt\n427: \n428: section Rcompare\n429: \n430: /-- Three-way comparison for real numbers\n431: \n432:     Returns -1 if x < y, 0 if x = y, and 1 if x > y.\n433:     This provides a complete ordering comparison in one operation.\n434: -/\n435: noncomputable def Rcompare (x y : ℝ) : Id Int :=\n436:   pure (if x < y then -1\n437:         else if x = y then 0\n438:         else 1)\n439: \n440: /-- Specification: Three-way comparison correctness\n441: \n442:     The comparison function returns:\n443:     - -1 when x < y\n444:     - 0 when x = y\n445:     - 1 when x > y\n446: \n447:     This captures the complete ordering of real numbers.\n448: -/\n449: theorem Rcompare_spec (x y : ℝ) :\n450:     ⦃⌜True⌝⦄\n451:     Rcompare x y\n452:     ⦃⇓result => ⌜(result = -1 ↔ x < y) ∧\n453:                 (result = 0 ↔ x = y) ∧\n454:                 (result = 1 ↔ y < x)⌝⦄ := by\n455:   intro _\n456:   unfold Rcompare\n457:   simp only [pure]\n458:   by_cases h1 : x < y\n459:   · simp only [if_pos h1]\n460:     constructor\n461:     · constructor\n462:       · intro _; exact h1\n463:       · intro _; rfl\n464:     · constructor\n465:       · constructor\n466:         · intro h_eq; cases h_eq\n467:         · intro h_eq; exact absurd h_eq (ne_of_lt h1)\n468:       · constructor\n469:         · intro h_eq; cases h_eq\n470:         · intro h_lt; exact absurd h_lt (not_lt.mpr (le_of_lt h1))\n471:   · simp only [if_neg h1]\n472:     by_cases h2 : x = y\n473:     · simp only [if_pos h2]\n474:       subst h2\n475:       constructor\n476:       · constructor\n477:         · intro h_eq; cases h_eq\n478:         · intro h_lt; exact absurd h_lt h1\n479:       · constructor\n480:         · constructor\n481:           · intro _; rfl\n482:           · intro _; rfl\n483:         · constructor\n484:           · intro h_eq; cases h_eq\n485:           · intro h_lt; exact absurd h_lt (lt_irrefl x)\n486:     · simp only [if_neg h2]\n487:       have h3 : y < x := lt_of_le_of_ne (le_of_not_gt h1) (Ne.symm h2)\n488:       constructor\n489:       · constructor\n490:         · intro h_eq; cases h_eq\n491:         · intro h_lt; exact absurd h_lt (not_lt.mpr (le_of_lt h3))\n492:       · constructor\n493:         · constructor\n494:           · intro h_eq; cases h_eq\n495:           · intro h_eq; exact absurd h_eq (Ne.symm (ne_of_lt h3))\n496:         · constructor\n497:           · intro _; exact h3\n498:           · intro _; rfl\n499: \n500: /-- Rcompare is antisymmetric\n501: \n502:     Swapping arguments negates the result, reflecting\n503:     the antisymmetry of the ordering relation.\n504: -/\n505: noncomputable def Rcompare_sym (x y : ℝ) : Id Int :=\n506:   do\n507:     let c ← Rcompare y x\n508:     pure (-c)\n509: \n510: /-- Specification: Comparison antisymmetry\n511: \n512:     Rcompare x y = -(Rcompare y x).\n513:     This captures the antisymmetric nature of ordering.\n514: -/\n515: theorem Rcompare_sym_spec (x y : ℝ) :\n516:     ⦃⌜True⌝⦄\n517:     Rcompare_sym x y\n518:     ⦃⇓result => ⌜result = -(Rcompare y x).run⌝⦄ := by\n519:   intro _\n520:   unfold Rcompare_sym\n521:   simp [bind, pure]\n522:   rfl\n523: \n524: /-- Comparison with opposites reverses order\n525: \n526:     Comparing negated values reverses the comparison,\n527:     reflecting that negation reverses order.\n528: -/\n529: noncomputable def Rcompare_opp (x y : ℝ) : Id Int :=\n530:   Rcompare y x\n531: \n532: /-- Specification: Opposite comparison\n533: \n534:     Rcompare (-x) (-y) = Rcompare y x.\n535:     Negating both arguments reverses the comparison.\n536: -/\n537: theorem Rcompare_opp_spec (x y : ℝ) :\n538:     ⦃⌜True⌝⦄\n539:     Rcompare_opp x y\n540:     ⦃⇓result => ⌜result = (Rcompare y x).run⌝⦄ := by\n541:   intro _\n542:   unfold Rcompare_opp\n543:   rfl\n544: \n545: /-- Comparison is invariant under translation\n546: \n547:     Adding the same value to both arguments doesn't\n548:     change the comparison result.\n549: -/\n550: noncomputable def Rcompare_plus_r (x y _z: ℝ) : Id Int :=\n551:   Rcompare x y\n552: \n553: /-- Specification: Translation invariance\n554: \n555:     Rcompare (x + z) (y + z) = Rcompare x y.\n556:     Translation preserves ordering relationships.\n557: -/\n558: theorem Rcompare_plus_r_spec (x y z : ℝ) :\n559:     ⦃⌜True⌝⦄\n560:     Rcompare_plus_r x y z\n561:     ⦃⇓result => ⌜result = (Rcompare x y).run⌝⦄ := by\n562:   intro _\n563:   unfold Rcompare_plus_r\n564:   rfl\n565: \n566: /-- Left addition preserves comparison\n567: \n568:     Adding a value on the left preserves the comparison.\n569: -/\n570: noncomputable def Rcompare_plus_l (x y _z : ℝ) : Id Int :=\n571:   Rcompare x y\n572: \n573: /-- Specification: Left translation invariance\n574: \n575:     Rcompare (z + x) (z + y) = Rcompare x y.\n576: -/\n577: theorem Rcompare_plus_l_spec (x y z : ℝ) :\n578:     ⦃⌜True⌝⦄\n579:     Rcompare_plus_l x y z\n580:     ⦃⇓result => ⌜result = (Rcompare x y).run⌝⦄ := by\n581:   intro _\n582:   unfold Rcompare_plus_l\n583:   rfl\n584: \n585: /-- Comparison is preserved by positive scaling\n586: \n587:     Multiplying by a positive value preserves the comparison.\n588: -/\n589: noncomputable def Rcompare_mult_r (x y _z : ℝ) : Id Int :=\n590:   Rcompare x y\n591: \n592: /-- Specification: Positive scaling preserves comparison\n593: \n594:     If 0 < z, then Rcompare (x * z) (y * z) = Rcompare x y.\n595: -/\n596: theorem Rcompare_mult_r_spec (x y z : ℝ) :\n597:     ⦃⌜0 < z⌝⦄\n598:     Rcompare_mult_r x y z\n599:     ⦃⇓result => ⌜result = (Rcompare x y).run⌝⦄ := by\n600:   intro _\n601:   unfold Rcompare_mult_r\n602:   rfl\n603: \n604: /-- Left multiplication by positive preserves comparison\n605: \n606:     Multiplying on the left by a positive value preserves comparison.\n607: -/\n608: noncomputable def Rcompare_mult_l (x y _z : ℝ) : Id Int :=\n609:   Rcompare x y\n610: \n611: /-- Specification: Left positive scaling preserves comparison\n612: \n613:     If 0 < z, then Rcompare (z * x) (z * y) = Rcompare x y.\n614: -/\n615: theorem Rcompare_mult_l_spec (x y z : ℝ) :\n616:     ⦃⌜0 < z⌝⦄\n617:     Rcompare_mult_l x y z\n618:     ⦃⇓result => ⌜result = (Rcompare x y).run⌝⦄ := by\n619:   intro _\n620:   unfold Rcompare_mult_l\n621:   rfl\n622: \n623: end Rcompare\n624: \n625: section BooleanComparisons\n626: \n627: /-- Boolean less-or-equal test for real numbers\n628: \n629:     Tests whether x ≤ y, returning a boolean result.\n630:     This provides a decidable ordering test.\n631: -/\n632: noncomputable def Rle_bool (x y : ℝ) : Id Bool :=\n633:   pure (x ≤ y)\n634: \n635: /-- Specification: Boolean ordering test\n636: \n637:     The boolean less-or-equal test returns true if and only if\n638:     x ≤ y. This provides a computational version of the ordering.\n639: -/\n640: theorem Rle_bool_spec (x y : ℝ) :\n641:     ⦃⌜True⌝⦄\n642:     Rle_bool x y\n643:     ⦃⇓result => ⌜result = true ↔ x ≤ y⌝⦄ := by\n644:   intro _\n645:   unfold Rle_bool\n646:   simp [pure]\n647:   -- The decidable instance for ℝ gives us this\n648:   exact decide_eq_true_iff\n649: \n650: /-- Monotone case: if x ≤ y then `Rle_bool x y = true` -/\n651: theorem Rle_bool_true (x y : ℝ) :\n652:     ⦃⌜x ≤ y⌝⦄\n653:     Rle_bool x y\n654:     ⦃⇓result => ⌜result = true⌝⦄ := by\n655:   intro _\n656:   unfold Rle_bool\n657:   -- Follows from decidability of (≤) on ℝ\n658:   sorry\n659: \n660: /-- Antitone case: if y < x then `Rle_bool x y = false` -/\n661: theorem Rle_bool_false (x y : ℝ) :\n662:     ⦃⌜y < x⌝⦄\n663:     Rle_bool x y\n664:     ⦃⇓result => ⌜result = false⌝⦄ := by\n665:   intro _\n666:   unfold Rle_bool\n667:   -- Follows from decidability of (≤) on ℝ and `¬(x ≤ y)` from `y < x`\n668:   sorry\n669: \n670: /-- Boolean strict less-than test for real numbers\n671: \n672:     Tests whether x < y, returning a boolean result.\n673:     This provides a decidable strict ordering test.\n674: -/\n675: noncomputable def Rlt_bool (x y : ℝ) : Id Bool :=\n676:   pure (x < y)\n677: \n678: /-- Specification: Boolean strict ordering test\n679: \n680:     The boolean less-than test returns true if and only if\n681:     x < y. This provides a computational version of strict ordering.\n682: -/\n683: theorem Rlt_bool_spec (x y : ℝ) :\n684:     ⦃⌜True⌝⦄\n685:     Rlt_bool x y\n686:     ⦃⇓result => ⌜result = true ↔ x < y⌝⦄ := by\n687:   intro _\n688:   unfold Rlt_bool\n689:   simp [pure]\n690:   -- The decidable instance for ℝ gives us this\n691:   exact decide_eq_true_iff\n692: \n693: /-- Negation of strict less-than is greater-or-equal\n694: \n695:     Shows that negb (Rlt_bool x y) = true ↔ y ≤ x.\n696:     This captures the duality between < and ≥.\n697: -/\n698: noncomputable def negb_Rlt_bool (x y : ℝ) : Id Bool :=\n699:   pure (y ≤ x)\n700: \n701: /-- Specification: Negated < equals ≥\n702: \n703:     !Rlt_bool x y ↔ y ≤ x.\n704:     This duality is fundamental for simplifying comparisons.\n705: -/\n706: theorem negb_Rlt_bool_spec (x y : ℝ) :\n707:     ⦃⌜True⌝⦄\n708:     negb_Rlt_bool x y\n709:     ⦃⇓result => ⌜result ↔ y ≤ x⌝⦄ := by\n710:   intro _\n711:   unfold negb_Rlt_bool\n712:   simp [pure]\n713:   -- The decidable instance for ℝ gives us this\n714:   exact decide_eq_true_iff\n715: \n716: /-- Negation of less-or-equal is strict greater-than\n717: \n718:     Shows that negb (Rle_bool x y) = true ↔ y < x.\n719:     This captures the duality between ≤ and >.\n720: -/\n721: noncomputable def negb_Rle_bool (x y : ℝ) : Id Bool :=\n722:   pure (y < x)\n723: \n724: /-- Specification: Negated ≤ equals >\n725: \n726:     !Rle_bool x y ↔ y < x.\n727:     This completes the duality between orderings.\n728: -/\n729: theorem negb_Rle_bool_spec (x y : ℝ) :\n730:     ⦃⌜True⌝⦄\n731:     negb_Rle_bool x y\n732:     ⦃⇓result => ⌜result ↔ y < x⌝⦄ := by\n733:   intro _\n734:   unfold negb_Rle_bool\n735:   simp [pure]\n736:   -- The decidable instance for ℝ gives us this\n737:   exact decide_eq_true_iff\n738: \n739: /-- Boolean equality test for real numbers\n740: \n741:     Tests whether two real numbers are equal, returning a boolean.\n742:     This provides a decidable equality test.\n743: -/\n744: noncomputable def Req_bool (x y : ℝ) : Id Bool :=\n745:   pure (x = y)\n746: \n747: /-- Specification: Boolean equality test\n748: \n749:     The boolean equality test returns true if and only if\n750:     the real numbers are equal. This provides a computational\n751:     version of equality.\n752: -/\n753: theorem Req_bool_spec (x y : ℝ) :\n754:     ⦃⌜True⌝⦄\n755:     Req_bool x y\n756:     ⦃⇓result => ⌜result = true ↔ x = y⌝⦄ := by\n757:   intro _\n758:   unfold Req_bool\n759:   simp [pure]\n760:   -- The decidable instance for ℝ gives us this\n761:   exact decide_eq_true_iff\n762: \n763: end BooleanComparisons\n764: \n765: section BooleanOperations\n766: \n767: /-- Boolean equality is symmetric\n768: \n769:     The equality test for booleans is symmetric:\n770:     (a == b) = (b == a).\n771: -/\n772: def eqb_sym (a b : Bool) : Id (Bool × Bool) :=\n773:   ((a == b), (b == a))\n774: \n775: /-- Specification: Boolean equality symmetry\n776: \n777:     a == b equals b == a for all booleans.\n778: -/\n779: theorem eqb_sym_spec (a b : Bool) :\n780:     ⦃⌜True⌝⦄\n781:     eqb_sym a b\n782:     ⦃⇓result => ⌜result.1 = result.2⌝⦄ := by\n783:   intro _\n784:   unfold eqb_sym\n785:   -- Boolean equality is symmetric\n786:   exact Bool.beq_comm\n787: \n788: end BooleanOperations\n789: \n790: section ConditionalOpposite\n791: \n792: /-- Conditional opposite based on sign\n793: \n794:     Returns -m if the condition is true, m otherwise.\n795:     This is used for conditional negation in floating-point\n796:     sign handling.\n797: -/\n798: def cond_Ropp (b : Bool) (m : ℝ) : Id ℝ :=\n799:   if b then -m else m\n800: \n801: /-- Specification: Conditional negation\n802: \n803:     The conditional opposite operation returns:\n804:     - -m when b is true\n805:     - m when b is false\n806: \n807:     This is fundamental for handling signs in floating-point.\n808: -/\n809: theorem cond_Ropp_spec (b : Bool) (m : ℝ) :\n810:     ⦃⌜True⌝⦄\n811:     cond_Ropp b m\n812:     ⦃⇓result => ⌜result = if b then -m else m⌝⦄ := by\n813:   intro _\n814:   unfold cond_Ropp\n815:   rfl\n816: \n817: /-- Conditional opposite is involutive\n818: \n819:     Applying conditional opposite twice with the same\n820:     boolean returns the original value.\n821: -/\n822: def cond_Ropp_involutive (b : Bool) (m : ℝ) : Id ℝ :=\n823:   do\n824:     let x ← cond_Ropp b m\n825:     cond_Ropp b x\n826: \n827: /-- Specification: Involutive property\n828: \n829:     cond_Ropp b (cond_Ropp b m) = m.\n830:     Double application cancels out.\n831: -/\n832: theorem cond_Ropp_involutive_spec (b : Bool) (m : ℝ) :\n833:     ⦃⌜True⌝⦄\n834:     cond_Ropp_involutive b m\n835:     ⦃⇓result => ⌜result = m⌝⦄ := by\n836:   intro _\n837:   unfold cond_Ropp_involutive\n838:   simp [cond_Ropp, bind]\n839:   by_cases h : b\n840:   · simp [h]\n841:     rfl\n842:   · simp [h]\n843:     rfl\n844: \n845: /-- Conditional opposite is injective\n846: \n847:     If conditional opposites are equal with the same boolean,\n848:     then the original values must be equal.\n849: -/\n850: def cond_Ropp_inj (_b : Bool) (m1 m2 : ℝ) : Id (ℝ × ℝ) :=\n851:   (m1, m2)\n852: \n853: /-- Specification: Injectivity\n854: \n855:     If cond_Ropp b m1 = cond_Ropp b m2, then m1 = m2.\n856: -/\n857: theorem cond_Ropp_inj_spec (b : Bool) (m1 m2 : ℝ) :\n858:     ⦃⌜(cond_Ropp b m1).run = (cond_Ropp b m2).run⌝⦄\n859:     cond_Ropp_inj b m1 m2\n860:     ⦃⇓result => ⌜result.1 = result.2⌝⦄ := by\n861:   intro h\n862:   unfold cond_Ropp_inj\n863:   -- h states that cond_Ropp b m1 = cond_Ropp b m2\n864:   -- We need to prove m1 = m2\n865:   simp [cond_Ropp, Id.run] at h\n866:   by_cases hb : b\n867:   · simp [hb] at h\n868:     -- h : -m1 = -m2, need to prove m1 = m2\n869:     have : m1 = m2 := by linarith\n870:     exact this\n871:   · simp [hb] at h\n872:     exact h\n873: \n874: end ConditionalOpposite\n875: \n876: end FloatSpec.Core.Raux\n877: \n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Zaux\n20 : import Mathlib.Data.Real.Basic\n21 : import Mathlib.Data.Real.Sqrt\n22 : import Std.Do.Triple\n23 : import Std.Tactic.Do\n24 : \n25 : open Real\n26 : open Std.Do\n27 : \n28 : namespace FloatSpec.Core.Raux\n29 : \n30 : section Rmissing\n31 : \n32 : /-- Subtraction ordering principle\n33 : \n34 :     If x ≤ y, then the difference y - x is non-negative.\n35 :     This is a fundamental property used throughout real analysis.\n36 : -/\n37 : def Rle_0_minus (x y : ℝ) : Id ℝ :=\n38 :   y - x\n39 : \n40 : /-- Specification: Subtraction ordering principle\n41 : \n42 :     The operation ensures that if x ≤ y, then y - x ≥ 0.\n43 :     This captures the relationship between ordering and subtraction.\n44 : -/\n45 : theorem Rle_0_minus_spec (x y : ℝ) :\n46 :     ⦃⌜x ≤ y⌝⦄\n47 :     Rle_0_minus x y\n48 :     ⦃⇓result => ⌜0 ≤ result⌝⦄ := by\n49 :   intro h\n50 :   unfold Rle_0_minus\n51 :   exact sub_nonneg_of_le h\n52 : \n53 : /-- Absolute values equal implies values are equal up to sign\n54 : \n55 :     If |x| = |y|, then either x = y or x = -y.\n56 :     This captures the two possible cases for equal magnitudes.\n57 : -/\n58 : def Rabs_eq_Rabs_case (x y : ℝ) : Id (ℝ × ℝ) :=\n59 :   (x, y)\n60 : \n61 : /-- Specification: Equal absolute values give equality up to sign\n62 : \n63 :     Under the precondition |x| = |y|, the pair (x, y) satisfies\n64 :     x = y or x = -y.\n65 : -/\n66 : theorem Rabs_eq_Rabs_spec (x y : ℝ) :\n67 :     ⦃⌜|x| = |y|⌝⦄\n68 :     Rabs_eq_Rabs_case x y\n69 :     ⦃⇓p => ⌜p.1 = p.2 ∨ p.1 = -p.2⌝⦄ := by\n70 :   intro _\n71 :   unfold Rabs_eq_Rabs_case\n72 :   -- Proof follows Coq's Rabs_eq_Rabs; omitted for now\n73 :   sorry\n74 : \n75 : /-- Absolute value of difference bounded under simple conditions\n76 : \n77 :     If 0 ≤ y and y ≤ 2*x, then |x - y| ≤ x.\n78 : -/\n79 : def Rabs_minus_le_val (x y : ℝ) : Id ℝ :=\n80 :   pure (abs (x - y))\n81 : \n82 : /-- Specification: Bound on |x - y|\n83 : \n84 :     Under 0 ≤ y and y ≤ 2*x, the value |x - y| is bounded by x.\n85 : -/\n86 : theorem Rabs_minus_le_spec (x y : ℝ) :\n87 :     ⦃⌜0 ≤ y ∧ y ≤ 2 * x⌝⦄\n88 :     Rabs_minus_le_val x y\n89 :     ⦃⇓r => ⌜r ≤ x⌝⦄ := by\n90 :   intro _\n91 :   unfold Rabs_minus_le_val\n92 :   -- Proof follows Coq's Rabs_minus_le; omitted for now\n93 :   sorry\n94 : \n95 : /-- Lower bound characterization via absolute value\n96 : \n97 :     If y ≤ -x or x ≤ y, then x ≤ |y|.\n98 : -/\n99 : def Rabs_ge_case (x y : ℝ) : Id (ℝ × ℝ) :=\n100:   (x, y)\n101: \n102: theorem Rabs_ge_spec (x y : ℝ) :\n103:     ⦃⌜y ≤ -x ∨ x ≤ y⌝⦄\n104:     Rabs_ge_case x y\n105:     ⦃⇓p => ⌜p.1 ≤ |p.2|⌝⦄ := by\n106:   intro _\n107:   unfold Rabs_ge_case\n108:   -- Proof follows Coq's Rabs_ge; omitted for now\n109:   sorry\n110: \n111: /-- Inverse characterization: x ≤ |y| implies y ≤ -x or x ≤ y. -/\n112: def Rabs_ge_inv_case (x y : ℝ) : Id (ℝ × ℝ) :=\n113:   (x, y)\n114: \n115: theorem Rabs_ge_inv_spec (x y : ℝ) :\n116:     ⦃⌜x ≤ |y|⌝⦄\n117:     Rabs_ge_inv_case x y\n118:     ⦃⇓p => ⌜p.2 ≤ -p.1 ∨ p.1 ≤ p.2⌝⦄ := by\n119:   intro _\n120:   unfold Rabs_ge_inv_case\n121:   -- Proof follows Coq's Rabs_ge_inv; omitted for now\n122:   sorry\n123: \n124: /-- Multiplication preserves strict inequalities\n125: \n126:     For non-negative values, strict inequalities are preserved\n127:     under multiplication. This is essential for scaling arguments\n128:     in floating-point proofs.\n129: -/\n130: def Rmult_lt_compat (r1 r2 r3 r4 : ℝ) : Id (ℝ × ℝ) :=\n131:   (r1 * r3, r2 * r4)\n132: \n133: /-- Specification: Multiplication preserves strict inequalities\n134: \n135:     If 0 ≤ r1, 0 ≤ r3, r1 < r2, and r3 < r4, then r1 * r3 < r2 * r4.\n136:     This property is crucial for analyzing products of bounds.\n137: -/\n138: theorem Rmult_lt_compat_spec (r1 r2 r3 r4 : ℝ) :\n139:     ⦃⌜0 ≤ r1 ∧ 0 ≤ r3 ∧ r1 < r2 ∧ r3 < r4⌝⦄\n140:     Rmult_lt_compat r1 r2 r3 r4\n141:     ⦃⇓result => ⌜result.1 < result.2⌝⦄ := by\n142:   intro h\n143:   unfold Rmult_lt_compat\n144:   have ⟨h1, h3, h12, h34⟩ := h\n145:   by_cases hr3 : r3 = 0\n146:   · subst hr3\n147:     simp\n148:     exact mul_pos (h1.trans_lt h12) h34\n149:   · have h3_pos : 0 < r3 := lt_of_le_of_ne h3 (Ne.symm hr3)\n150:     exact mul_lt_mul h12 (le_of_lt h34) h3_pos (le_of_lt (h1.trans_lt h12))\n151: \n152: /-- Right multiplication cancellation for inequality\n153: \n154:     If products are unequal and the right factor is the same,\n155:     then the left factors must be unequal.\n156: -/\n157: def Rmult_neq_reg_r (_r1 r2 r3 : ℝ) : Id (ℝ × ℝ) :=\n158:   (r2, r3)\n159: \n160: /-- Specification: Right multiplication cancellation\n161: \n162:     If r2 * r1 ≠ r3 * r1, then r2 ≠ r3.\n163:     This allows cancellation in multiplication inequalities.\n164: -/\n165: theorem Rmult_neq_reg_r_spec (r1 r2 r3 : ℝ) :\n166:     ⦃⌜r2 * r1 ≠ r3 * r1⌝⦄\n167:     Rmult_neq_reg_r r1 r2 r3\n168:     ⦃⇓result => ⌜result.1 ≠ result.2⌝⦄ := by\n169:   intro h\n170:   unfold Rmult_neq_reg_r\n171:   simp\n172:   intro h_eq\n173:   -- h_eq : r2 = r3, but we need to prove False from r2 * r1 ≠ r3 * r1\n174:   apply h\n175:   -- Convert r2 = r3 to r2 * r1 = r3 * r1\n176:   congr 1\n177: \n178: /-- Multiplication preserves non-equality\n179: \n180:     Multiplying unequal numbers by a non-zero value\n181:     preserves the inequality.\n182: -/\n183: def Rmult_neq_compat_r (r1 r2 r3 : ℝ) : Id (ℝ × ℝ) :=\n184:   (r2 * r1, r3 * r1)\n185: \n186: /-- Specification: Multiplication preserves non-equality\n187: \n188:     If r1 ≠ 0 and r2 ≠ r3, then r2 * r1 ≠ r3 * r1.\n189: -/\n190: theorem Rmult_neq_compat_r_spec (r1 r2 r3 : ℝ) :\n191:     ⦃⌜r1 ≠ 0 ∧ r2 ≠ r3⌝⦄\n192:     Rmult_neq_compat_r r1 r2 r3\n193:     ⦃⇓result => ⌜result.1 ≠ result.2⌝⦄ := by\n194:   intro h\n195:   unfold Rmult_neq_compat_r\n196:   simp\n197:   have ⟨h1_ne, h23_ne⟩ := h\n198:   intro h_eq\n199:   -- h_eq : r2 * r1 = r3 * r1\n200:   -- This would imply r2 = r3 when r1 ≠ 0, contradicting h23_ne\n201:   have : r2 = r3 := mul_right_cancel₀ h1_ne h_eq\n202:   exact h23_ne this\n203: \n204: /-- Right distributivity of minimum over multiplication\n205: \n206:     For non-negative multipliers, minimum distributes over\n207:     multiplication from the right.\n208: -/\n209: def Rmult_min_distr_r (x y z : ℝ) : Id (ℝ × ℝ) :=\n210:   (min (x * z) (y * z), min x y * z)\n211: \n212: /-- Specification: Right distributivity of minimum\n213: \n214:     If 0 ≤ z, then min (x * z) (y * z) = min x y * z.\n215: -/\n216: theorem Rmult_min_distr_r_spec (x y z : ℝ) :\n217:     ⦃⌜0 ≤ z⌝⦄\n218:     Rmult_min_distr_r x y z\n219:     ⦃⇓result => ⌜result.1 = result.2⌝⦄ := by\n220:   intro h\n221:   unfold Rmult_min_distr_r\n222:   -- We need to prove: min (x * z) (y * z) = min x y * z\n223:   rw [min_mul_of_nonneg _ _ h]\n224:   rfl\n225: \n226: /-- Left distributivity of minimum over multiplication\n227: \n228:     For non-negative multipliers, minimum distributes over\n229:     multiplication from the left.\n230: -/\n231: def Rmult_min_distr_l (x y z : ℝ) : Id (ℝ × ℝ) :=\n232:   (min (x * y) (x * z), x * min y z)\n233: \n234: /-- Specification: Left distributivity of minimum\n235: \n236:     If 0 ≤ x, then min (x * y) (x * z) = x * min y z.\n237: -/\n238: theorem Rmult_min_distr_l_spec (x y z : ℝ) :\n239:     ⦃⌜0 ≤ x⌝⦄\n240:     Rmult_min_distr_l x y z\n241:     ⦃⇓result => ⌜result.1 = result.2⌝⦄ := by\n242:   intro h\n243:   unfold Rmult_min_distr_l\n244:   -- We need to prove: min (x * y) (x * z) = x * min y z\n245:   rw [mul_min_of_nonneg _ _ h]\n246:   rfl\n247: \n248: /-- Minimum of opposites equals negative maximum\n249: \n250:     Taking the minimum of negated values is equivalent\n251:     to negating the maximum of the original values.\n252: -/\n253: def Rmin_opp (x y : ℝ) : Id (ℝ × ℝ) :=\n254:   (min (-x) (-y), -(max x y))\n255: \n256: /-- Specification: Minimum of opposites\n257: \n258:     min (-x) (-y) = -(max x y).\n259:     This duality between min and max under negation is fundamental.\n260: -/\n261: theorem Rmin_opp_spec (x y : ℝ) :\n262:     ⦃⌜True⌝⦄\n263:     Rmin_opp x y\n264:     ⦃⇓result => ⌜result.1 = result.2⌝⦄ := by\n265:   intro _\n266:   unfold Rmin_opp\n267:   -- We need to prove: min (-x) (-y) = -(max x y)\n268:   exact min_neg_neg x y\n269: \n270: /-- Maximum of opposites equals negative minimum\n271: \n272:     Taking the maximum of negated values is equivalent\n273:     to negating the minimum of the original values.\n274: -/\n275: def Rmax_opp (x y : ℝ) : Id (ℝ × ℝ) :=\n276:   (max (-x) (-y), -(min x y))\n277: \n278: /-- Specification: Maximum of opposites\n279: \n280:     max (-x) (-y) = -(min x y).\n281:     This completes the duality between min/max under negation.\n282: -/\n283: theorem Rmax_opp_spec (x y : ℝ) :\n284:     ⦃⌜True⌝⦄\n285:     Rmax_opp x y\n286:     ⦃⇓result => ⌜result.1 = result.2⌝⦄ := by\n287:   intro _\n288:   unfold Rmax_opp\n289:   -- We need to prove: max (-x) (-y) = -(min x y)\n290:   exact max_neg_neg x y\n291: \n292: /-- Monotonicity of the exponential function\n293: \n294:     If x ≤ y, then exp x ≤ exp y. This captures the\n295:     strict monotonicity of the real exponential function.\n296: -/\n297: noncomputable def exp_le_check (x y : ℝ) : Id ℝ :=\n298:   pure (Real.exp x)\n299: \n300: /-- Specification: Exponential is monotone increasing\n301: \n302:     Given x ≤ y, the value exp x is bounded above by exp y.\n303: -/\n304: theorem exp_le_spec (x y : ℝ) :\n305:     ⦃⌜x ≤ y⌝⦄\n306:     exp_le_check x y\n307:     ⦃⇓ex => ⌜ex ≤ Real.exp y⌝⦄ := by\n308:   intro _\n309:   -- Follows from monotonicity of Real.exp\n310:   sorry\n311: \n312: end Rmissing\n313: \n314: section Rrecip\n315: \n316: /-- Reciprocal comparison on positives: if 0 < x < y then 1/y < 1/x -/\n317: noncomputable def Rinv_lt_check (x y : ℝ) : Id (ℝ × ℝ) :=\n318:   (1 / y, 1 / x)\n319: \n320: /-- Specification: Reciprocal reverses order on positive reals -/\n321: theorem Rinv_lt_spec (x y : ℝ) :\n322:     ⦃⌜0 < x ∧ x < y⌝⦄\n323:     Rinv_lt_check x y\n324:     ⦃⇓p => ⌜p.1 < p.2⌝⦄ := by\n325:   intro _\n326:   -- Standard property: for 0 < x < y, we have 1/y < 1/x\n327:   sorry\n328: \n329: /-- Reciprocal comparison (≤) on positives: if 0 < x ≤ y then 1/y ≤ 1/x -/\n330: noncomputable def Rinv_le_check (x y : ℝ) : Id (ℝ × ℝ) :=\n331:   (1 / y, 1 / x)\n332: \n333: /-- Specification: Reciprocal is antitone on positive reals (≤ version) -/\n334: theorem Rinv_le_spec (x y : ℝ) :\n335:     ⦃⌜0 < x ∧ x ≤ y⌝⦄\n336:     Rinv_le_check x y\n337:     ⦃⇓p => ⌜p.1 ≤ p.2⌝⦄ := by\n338:   intro _\n339:   -- Standard property: for 0 < x ≤ y, we have 1/y ≤ 1/x\n340:   sorry\n341: \n342: end Rrecip\n343: \n344: section Sqrt\n345: \n346: /-- Nonnegativity of square root\n347: \n348:     The square root of a non-negative real number is itself non-negative.\n349:     This captures the standard property of the real square root function.\n350: -/\n351: noncomputable def sqrt_ge_0_check (x : ℝ) : Id ℝ :=\n352:   Real.sqrt x\n353: \n354: /-- Specification: sqrt is non-negative on ℝ≥0\n355: \n356:     Given 0 ≤ x, the computed value satisfies 0 ≤ sqrt x.\n357: -/\n358: theorem sqrt_ge_0_spec (x : ℝ) :\n359:     ⦃⌜0 ≤ x⌝⦄\n360:     sqrt_ge_0_check x\n361:     ⦃⇓r => ⌜0 ≤ r⌝⦄ := by\n362:   intro _\n363:   unfold sqrt_ge_0_check\n364:   exact Real.sqrt_nonneg x\n365: \n366: end Sqrt\n367: \n368: section Abs\n369: \n370: /-- Check for zero absolute value\n371: \n372:     Encodes the predicate |x| = 0 as a boolean value for specification.\n373: -/\n374: noncomputable def Rabs_eq_R0_check (x : ℝ) : Id Bool :=\n375:   pure (|x| = 0)\n376: \n377: /-- Specification: Absolute value equals zero iff the number is zero\n378: \n379:     The absolute value of a real number is zero if and only if the number itself is zero.\n380: -/\n381: theorem Rabs_eq_R0_spec (x : ℝ) :\n382:     ⦃⌜True⌝⦄\n383:     Rabs_eq_R0_check x\n384:     ⦃⇓b => ⌜b ↔ x = 0⌝⦄ := by\n385:   intro _\n386:   unfold Rabs_eq_R0_check\n387:   -- Standard property: |x| = 0 ↔ x = 0\n388:   sorry\n389: \n390: end Abs\n391: \n392: section AbsMore\n393: \n394: /-- Boolean check for strict inequality on absolute value: |x| < y -/\n395: noncomputable def Rabs_lt_check (x y : ℝ) : Id Bool :=\n396:   pure (|x| < y)\n397: \n398: /-- Specification: |x| < y iff the boolean returns true -/\n399: theorem Rabs_lt_spec (x y : ℝ) :\n400:     ⦃⌜True⌝⦄\n401:     Rabs_lt_check x y\n402:     ⦃⇓b => ⌜b ↔ |x| < y⌝⦄ := by\n403:   intro _\n404:   unfold Rabs_lt_check\n405:   -- Follows from decidability of (<) on ℝ\n406:   sorry\n407: \n408: end AbsMore\n409: \n410: section AbsGt\n411: \n412: /-- Boolean check for strict lower bound on |x|: y < |x| -/\n413: noncomputable def Rabs_gt_check (x y : ℝ) : Id Bool :=\n414:   pure (y < |x|)\n415: \n416: /-- Specification: y < |x| iff the boolean returns true -/\n417: theorem Rabs_gt_spec (x y : ℝ) :\n418:     ⦃⌜True⌝⦄\n419:     Rabs_gt_check x y\n420:     ⦃⇓b => ⌜b ↔ y < |x|⌝⦄ := by\n421:   intro _\n422:   unfold Rabs_gt_check\n423:   -- Follows from decidability of (<) on ℝ\n424:   sorry\n425: \n426: end AbsGt\n427: \n428: section Rcompare\n429: \n430: /-- Three-way comparison for real numbers\n431: \n432:     Returns -1 if x < y, 0 if x = y, and 1 if x > y.\n433:     This provides a complete ordering comparison in one operation.\n434: -/\n435: noncomputable def Rcompare (x y : ℝ) : Id Int :=\n436:   pure (if x < y then -1\n437:         else if x = y then 0\n438:         else 1)\n439: \n440: /-- Specification: Three-way comparison correctness\n441: \n442:     The comparison function returns:\n443:     - -1 when x < y\n444:     - 0 when x = y\n445:     - 1 when x > y\n446: \n447:     This captures the complete ordering of real numbers.\n448: -/\n449: theorem Rcompare_spec (x y : ℝ) :\n450:     ⦃⌜True⌝⦄\n451:     Rcompare x y\n452:     ⦃⇓result => ⌜(result = -1 ↔ x < y) ∧\n453:                 (result = 0 ↔ x = y) ∧\n454:                 (result = 1 ↔ y < x)⌝⦄ := by\n455:   intro _\n456:   unfold Rcompare\n457:   simp only [pure]\n458:   by_cases h1 : x < y\n459:   · simp only [if_pos h1]\n460:     constructor\n461:     · constructor\n462:       · intro _; exact h1\n463:       · intro _; rfl\n464:     · constructor\n465:       · constructor\n466:         · intro h_eq; cases h_eq\n467:         · intro h_eq; exact absurd h_eq (ne_of_lt h1)\n468:       · constructor\n469:         · intro h_eq; cases h_eq\n470:         · intro h_lt; exact absurd h_lt (not_lt.mpr (le_of_lt h1))\n471:   · simp only [if_neg h1]\n472:     by_cases h2 : x = y\n473:     · simp only [if_pos h2]\n474:       subst h2\n475:       constructor\n476:       · constructor\n477:         · intro h_eq; cases h_eq\n478:         · intro h_lt; exact absurd h_lt h1\n479:       · constructor\n480:         · constructor\n481:           · intro _; rfl\n482:           · intro _; rfl\n483:         · constructor\n484:           · intro h_eq; cases h_eq\n485:           · intro h_lt; exact absurd h_lt (lt_irrefl x)\n486:     · simp only [if_neg h2]\n487:       have h3 : y < x := lt_of_le_of_ne (le_of_not_gt h1) (Ne.symm h2)\n488:       constructor\n489:       · constructor\n490:         · intro h_eq; cases h_eq\n491:         · intro h_lt; exact absurd h_lt (not_lt.mpr (le_of_lt h3))\n492:       · constructor\n493:         · constructor\n494:           · intro h_eq; cases h_eq\n495:           · intro h_eq; exact absurd h_eq (Ne.symm (ne_of_lt h3))\n496:         · constructor\n497:           · intro _; exact h3\n498:           · intro _; rfl\n499: \n500: /-- Rcompare is antisymmetric\n501: \n502:     Swapping arguments negates the result, reflecting\n503:     the antisymmetry of the ordering relation.\n504: -/\n505: noncomputable def Rcompare_sym (x y : ℝ) : Id Int :=\n506:   do\n507:     let c ← Rcompare y x\n508:     pure (-c)\n509: \n510: /-- Specification: Comparison antisymmetry\n511: \n512:     Rcompare x y = -(Rcompare y x).\n513:     This captures the antisymmetric nature of ordering.\n514: -/\n515: theorem Rcompare_sym_spec (x y : ℝ) :\n516:     ⦃⌜True⌝⦄\n517:     Rcompare_sym x y\n518:     ⦃⇓result => ⌜result = -(Rcompare y x).run⌝⦄ := by\n519:   intro _\n520:   unfold Rcompare_sym\n521:   simp [bind, pure]\n522:   rfl\n523: \n524: /-- Comparison with opposites reverses order\n525: \n526:     Comparing negated values reverses the comparison,\n527:     reflecting that negation reverses order.\n528: -/\n529: noncomputable def Rcompare_opp (x y : ℝ) : Id Int :=\n530:   Rcompare y x\n531: \n532: /-- Specification: Opposite comparison\n533: \n534:     Rcompare (-x) (-y) = Rcompare y x.\n535:     Negating both arguments reverses the comparison.\n536: -/\n537: theorem Rcompare_opp_spec (x y : ℝ) :\n538:     ⦃⌜True⌝⦄\n539:     Rcompare_opp x y\n540:     ⦃⇓result => ⌜result = (Rcompare y x).run⌝⦄ := by\n541:   intro _\n542:   unfold Rcompare_opp\n543:   rfl\n544: \n545: /-- Comparison is invariant under translation\n546: \n547:     Adding the same value to both arguments doesn't\n548:     change the comparison result.\n549: -/\n550: noncomputable def Rcompare_plus_r (x y _z: ℝ) : Id Int :=\n551:   Rcompare x y\n552: \n553: /-- Specification: Translation invariance\n554: \n555:     Rcompare (x + z) (y + z) = Rcompare x y.\n556:     Translation preserves ordering relationships.\n557: -/\n558: theorem Rcompare_plus_r_spec (x y z : ℝ) :\n559:     ⦃⌜True⌝⦄\n560:     Rcompare_plus_r x y z\n561:     ⦃⇓result => ⌜result = (Rcompare x y).run⌝⦄ := by\n562:   intro _\n563:   unfold Rcompare_plus_r\n564:   rfl\n565: \n566: /-- Left addition preserves comparison\n567: \n568:     Adding a value on the left preserves the comparison.\n569: -/\n570: noncomputable def Rcompare_plus_l (x y _z : ℝ) : Id Int :=\n571:   Rcompare x y\n572: \n573: /-- Specification: Left translation invariance\n574: \n575:     Rcompare (z + x) (z + y) = Rcompare x y.\n576: -/\n577: theorem Rcompare_plus_l_spec (x y z : ℝ) :\n578:     ⦃⌜True⌝⦄\n579:     Rcompare_plus_l x y z\n580:     ⦃⇓result => ⌜result = (Rcompare x y).run⌝⦄ := by\n581:   intro _\n582:   unfold Rcompare_plus_l\n583:   rfl\n584: \n585: /-- Comparison is preserved by positive scaling\n586: \n587:     Multiplying by a positive value preserves the comparison.\n588: -/\n589: noncomputable def Rcompare_mult_r (x y _z : ℝ) : Id Int :=\n590:   Rcompare x y\n591: \n592: /-- Specification: Positive scaling preserves comparison\n593: \n594:     If 0 < z, then Rcompare (x * z) (y * z) = Rcompare x y.\n595: -/\n596: theorem Rcompare_mult_r_spec (x y z : ℝ) :\n597:     ⦃⌜0 < z⌝⦄\n598:     Rcompare_mult_r x y z\n599:     ⦃⇓result => ⌜result = (Rcompare x y).run⌝⦄ := by\n600:   intro _\n601:   unfold Rcompare_mult_r\n602:   rfl\n603: \n604: /-- Left multiplication by positive preserves comparison\n605: \n606:     Multiplying on the left by a positive value preserves comparison.\n607: -/\n608: noncomputable def Rcompare_mult_l (x y _z : ℝ) : Id Int :=\n609:   Rcompare x y\n610: \n611: /-- Specification: Left positive scaling preserves comparison\n612: \n613:     If 0 < z, then Rcompare (z * x) (z * y) = Rcompare x y.\n614: -/\n615: theorem Rcompare_mult_l_spec (x y z : ℝ) :\n616:     ⦃⌜0 < z⌝⦄\n617:     Rcompare_mult_l x y z\n618:     ⦃⇓result => ⌜result = (Rcompare x y).run⌝⦄ := by\n619:   intro _\n620:   unfold Rcompare_mult_l\n621:   rfl\n622: \n623: end Rcompare\n624: \n625: section BooleanComparisons\n626: \n627: /-- Boolean less-or-equal test for real numbers\n628: \n629:     Tests whether x ≤ y, returning a boolean result.\n630:     This provides a decidable ordering test.\n631: -/\n632: noncomputable def Rle_bool (x y : ℝ) : Id Bool :=\n633:   pure (x ≤ y)\n634: \n635: /-- Specification: Boolean ordering test\n636: \n637:     The boolean less-or-equal test returns true if and only if\n638:     x ≤ y. This provides a computational version of the ordering.\n639: -/\n640: theorem Rle_bool_spec (x y : ℝ) :\n641:     ⦃⌜True⌝⦄\n642:     Rle_bool x y\n643:     ⦃⇓result => ⌜result = true ↔ x ≤ y⌝⦄ := by\n644:   intro _\n645:   unfold Rle_bool\n646:   simp [pure]\n647:   -- The decidable instance for ℝ gives us this\n648:   exact decide_eq_true_iff\n649: \n650: /-- Monotone case: if x ≤ y then `Rle_bool x y = true` -/\n651: theorem Rle_bool_true (x y : ℝ) :\n652:     ⦃⌜x ≤ y⌝⦄\n653:     Rle_bool x y\n654:     ⦃⇓result => ⌜result = true⌝⦄ := by\n655:   intro _\n656:   unfold Rle_bool\n657:   -- Follows from decidability of (≤) on ℝ\n658:   sorry\n659: \n660: /-- Antitone case: if y < x then `Rle_bool x y = false` -/\n661: theorem Rle_bool_false (x y : ℝ) :\n662:     ⦃⌜y < x⌝⦄\n663:     Rle_bool x y\n664:     ⦃⇓result => ⌜result = false⌝⦄ := by\n665:   intro _\n666:   unfold Rle_bool\n667:   -- Follows from decidability of (≤) on ℝ and `¬(x ≤ y)` from `y < x`\n668:   sorry\n669: \n670: /-- Boolean strict less-than test for real numbers\n671: \n672:     Tests whether x < y, returning a boolean result.\n673:     This provides a decidable strict ordering test.\n674: -/\n675: noncomputable def Rlt_bool (x y : ℝ) : Id Bool :=\n676:   pure (x < y)\n677: \n678: /-- Specification: Boolean strict ordering test\n679: \n680:     The boolean less-than test returns true if and only if\n681:     x < y. This provides a computational version of strict ordering.\n682: -/\n683: theorem Rlt_bool_spec (x y : ℝ) :\n684:     ⦃⌜True⌝⦄\n685:     Rlt_bool x y\n686:     ⦃⇓result => ⌜result = true ↔ x < y⌝⦄ := by\n687:   intro _\n688:   unfold Rlt_bool\n689:   simp [pure]\n690:   -- The decidable instance for ℝ gives us this\n691:   exact decide_eq_true_iff\n692: \n693: /-- Negation of strict less-than is greater-or-equal\n694: \n695:     Shows that negb (Rlt_bool x y) = true ↔ y ≤ x.\n696:     This captures the duality between < and ≥.\n697: -/\n698: noncomputable def negb_Rlt_bool (x y : ℝ) : Id Bool :=\n699:   pure (y ≤ x)\n700: \n701: /-- Specification: Negated < equals ≥\n702: \n703:     !Rlt_bool x y ↔ y ≤ x.\n704:     This duality is fundamental for simplifying comparisons.\n705: -/\n706: theorem negb_Rlt_bool_spec (x y : ℝ) :\n707:     ⦃⌜True⌝⦄\n708:     negb_Rlt_bool x y\n709:     ⦃⇓result => ⌜result ↔ y ≤ x⌝⦄ := by\n710:   intro _\n711:   unfold negb_Rlt_bool\n712:   simp [pure]\n713:   -- The decidable instance for ℝ gives us this\n714:   exact decide_eq_true_iff\n715: \n716: /-- Negation of less-or-equal is strict greater-than\n717: \n718:     Shows that negb (Rle_bool x y) = true ↔ y < x.\n719:     This captures the duality between ≤ and >.\n720: -/\n721: noncomputable def negb_Rle_bool (x y : ℝ) : Id Bool :=\n722:   pure (y < x)\n723: \n724: /-- Specification: Negated ≤ equals >\n725: \n726:     !Rle_bool x y ↔ y < x.\n727:     This completes the duality between orderings.\n728: -/\n729: theorem negb_Rle_bool_spec (x y : ℝ) :\n730:     ⦃⌜True⌝⦄\n731:     negb_Rle_bool x y\n732:     ⦃⇓result => ⌜result ↔ y < x⌝⦄ := by\n733:   intro _\n734:   unfold negb_Rle_bool\n735:   simp [pure]\n736:   -- The decidable instance for ℝ gives us this\n737:   exact decide_eq_true_iff\n738: \n739: /-- Boolean equality test for real numbers\n740: \n741:     Tests whether two real numbers are equal, returning a boolean.\n742:     This provides a decidable equality test.\n743: -/\n744: noncomputable def Req_bool (x y : ℝ) : Id Bool :=\n745:   pure (x = y)\n746: \n747: /-- Specification: Boolean equality test\n748: \n749:     The boolean equality test returns true if and only if\n750:     the real numbers are equal. This provides a computational\n751:     version of equality.\n752: -/\n753: theorem Req_bool_spec (x y : ℝ) :\n754:     ⦃⌜True⌝⦄\n755:     Req_bool x y\n756:     ⦃⇓result => ⌜result = true ↔ x = y⌝⦄ := by\n757:   intro _\n758:   unfold Req_bool\n759:   simp [pure]\n760:   -- The decidable instance for ℝ gives us this\n761:   exact decide_eq_true_iff\n762: \n763: end BooleanComparisons\n764: \n765: section BooleanOperations\n766: \n767: /-- Boolean equality is symmetric\n768: \n769:     The equality test for booleans is symmetric:\n770:     (a == b) = (b == a).\n771: -/\n772: def eqb_sym (a b : Bool) : Id (Bool × Bool) :=\n773:   ((a == b), (b == a))\n774: \n775: /-- Specification: Boolean equality symmetry\n776: \n777:     a == b equals b == a for all booleans.\n778: -/\n779: theorem eqb_sym_spec (a b : Bool) :\n780:     ⦃⌜True⌝⦄\n781:     eqb_sym a b\n782:     ⦃⇓result => ⌜result.1 = result.2⌝⦄ := by\n783:   intro _\n784:   unfold eqb_sym\n785:   -- Boolean equality is symmetric\n786:   exact Bool.beq_comm\n787: \n788: end BooleanOperations\n789: \n790: section ConditionalOpposite\n791: \n792: /-- Conditional opposite based on sign\n793: \n794:     Returns -m if the condition is true, m otherwise.\n795:     This is used for conditional negation in floating-point\n796:     sign handling.\n797: -/\n798: def cond_Ropp (b : Bool) (m : ℝ) : Id ℝ :=\n799:   if b then -m else m\n800: \n801: /-- Specification: Conditional negation\n802: \n803:     The conditional opposite operation returns:\n804:     - -m when b is true\n805:     - m when b is false\n806: \n807:     This is fundamental for handling signs in floating-point.\n808: -/\n809: theorem cond_Ropp_spec (b : Bool) (m : ℝ) :\n810:     ⦃⌜True⌝⦄\n811:     cond_Ropp b m\n812:     ⦃⇓result => ⌜result = if b then -m else m⌝⦄ := by\n813:   intro _\n814:   unfold cond_Ropp\n815:   rfl\n816: \n817: /-- Conditional opposite is involutive\n818: \n819:     Applying conditional opposite twice with the same\n820:     boolean returns the original value.\n821: -/\n822: def cond_Ropp_involutive (b : Bool) (m : ℝ) : Id ℝ :=\n823:   do\n824:     let x ← cond_Ropp b m\n825:     cond_Ropp b x\n826: \n827: /-- Specification: Involutive property\n828: \n829:     cond_Ropp b (cond_Ropp b m) = m.\n830:     Double application cancels out.\n831: -/\n832: theorem cond_Ropp_involutive_spec (b : Bool) (m : ℝ) :\n833:     ⦃⌜True⌝⦄\n834:     cond_Ropp_involutive b m\n835:     ⦃⇓result => ⌜result = m⌝⦄ := by\n836:   intro _\n837:   unfold cond_Ropp_involutive\n838:   simp [cond_Ropp, bind]\n839:   by_cases h : b\n840:   · simp [h]\n841:     rfl\n842:   · simp [h]\n843:     rfl\n844: \n845: /-- Conditional opposite is injective\n846: \n847:     If conditional opposites are equal with the same boolean,\n848:     then the original values must be equal.\n849: -/\n850: def cond_Ropp_inj (_b : Bool) (m1 m2 : ℝ) : Id (ℝ × ℝ) :=\n851:   (m1, m2)\n852: \n853: /-- Specification: Injectivity\n854: \n855:     If cond_Ropp b m1 = cond_Ropp b m2, then m1 = m2.\n856: -/\n857: theorem cond_Ropp_inj_spec (b : Bool) (m1 m2 : ℝ) :\n858:     ⦃⌜(cond_Ropp b m1).run = (cond_Ropp b m2).run⌝⦄\n859:     cond_Ropp_inj b m1 m2\n860:     ⦃⇓result => ⌜result.1 = result.2⌝⦄ := by\n861:   intro h\n862:   unfold cond_Ropp_inj\n863:   -- h states that cond_Ropp b m1 = cond_Ropp b m2\n864:   -- We need to prove m1 = m2\n865:   simp [cond_Ropp, Id.run] at h\n866:   by_cases hb : b\n867:   · simp [hb] at h\n868:     -- h : -m1 = -m2, need to prove m1 = m2\n869:     have : m1 = m2 := by linarith\n870:     exact this\n871:   · simp [hb] at h\n872:     exact h\n873: \n874: end ConditionalOpposite\n875: \n876: end FloatSpec.Core.Raux\n877: \n"
  }
}
[2025-09-16T03:36:51] tokens used: 61845
[2025-09-16T03:36:56] codex

I’ll open `FLX.lean` to identify missing theorems we can add skeletons for.
[2025-09-16T03:36:56] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLX.lean","annotate_lines":true})
[2025-09-16T03:36:56] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLX.lean","annotate_lines":true}) success in 2ms:
{
  "content": [
    {
      "text": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Defs\n20 : import FloatSpec.src.Core.Generic_fmt\n21 : import Mathlib.Data.Real.Basic\n22 : import Std.Do.Triple\n23 : import Std.Tactic.Do\n24 : import FloatSpec.src.Core.Round_generic\n25 : import FloatSpec.src.Core.Ulp\n26 : import FloatSpec.src.Core.FIX\n27 : \n28 : \n29 : open Real\n30 : open Std.Do\n31 : open FloatSpec.Core.Generic_fmt\n32 : open FloatSpec.Core.Round_generic\n33 : \n34 : namespace FloatSpec.Core.FLX\n35 : \n36 : variable (prec : Int)\n37 : \n38 : /-- Fixed-precision exponent function\n39 : \n40 :     In fixed-precision format, the exponent is adjusted to maintain\n41 :     a constant precision. The exponent function returns e - prec,\n42 :     which ensures that mantissas have exactly 'prec' significant digits.\n43 : -/\n44 : def FLX_exp (e : Int) : Int :=\n45 :   e - prec\n46 : \n47 : /-- Check FLX exponent function correctness\n48 : \n49 :     Verify that the FLX exponent function computes e - prec\n50 :     correctly for any input e. This validates the precision\n51 :     adjustment mechanism.\n52 : -/\n53 : def FLX_exp_correct_check (e : Int) : Id Bool :=\n54 :   pure (FLX_exp prec e = e - prec)\n55 : \n56 : /-- Specification: Fixed-precision exponent calculation\n57 : \n58 :     The FLX exponent function subtracts the precision from the\n59 :     input exponent. This adjustment ensures that all representable\n60 :     numbers have exactly 'prec' significant digits in their mantissa.\n61 : -/\n62 : theorem FLX_exp_spec (e : Int) :\n63 :     ⦃⌜True⌝⦄\n64 :     FLX_exp_correct_check prec e\n65 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n66 :   sorry\n67 : \n68 : /-- Fixed-precision format predicate\n69 : \n70 :     A real number x is in FLX format if it can be represented\n71 :     using the generic format with the fixed-precision exponent\n72 :     function. This gives x = m × β^(e-prec) where m has bounded magnitude.\n73 : -/\n74 : def FLX_format (beta : Int) (x : ℝ) : Id Prop :=\n75 :   FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x\n76 : \n77 : /-- Unbounded fixed-precision format with normalized mantissas (placeholder).\n78 : \n79 :     This mirrors Coq's `FLXN_format`. For now, we model it using\n80 :     the same underlying generic format predicate as `FLX_format`.\n81 :     Proofs will refine this equivalence later.\n82 : -/\n83 : def FLXN_format (beta : Int) (x : ℝ) : Id Prop :=\n84 :   FLX_format prec beta x\n85 : \n86 : /-- Specification: FLX format using generic format\n87 : \n88 :     The FLX format is defined through the generic format mechanism\n89 :     with the fixed-precision exponent function. This characterizes\n90 :     floating-point numbers with constant precision.\n91 : -/\n92 : theorem FLX_format_spec (beta : Int) (x : ℝ) :\n93 :     ⦃⌜True⌝⦄\n94 :     FLX_format prec beta x\n95 :     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x).run⌝⦄ := by\n96 :   sorry\n97 : \n98 : /-- Specification: FLX exponent function correctness\n99 : \n100:     The FLX exponent function correctly implements the precision\n101:     adjustment by returning e - prec. This ensures the mantissa\n102:     precision remains constant across different magnitudes.\n103: -/\n104: theorem FLX_exp_correct_spec (e : Int) :\n105:     ⦃⌜True⌝⦄\n106:     FLX_exp_correct_check prec e\n107:     ⦃⇓result => ⌜result = true⌝⦄ := by\n108:   sorry\n109: \n110: /-- Check if zero is in FLX format\n111: \n112:     Verify that zero is representable in the fixed-precision format.\n113:     Zero should always be representable regardless of the precision\n114:     since it can be expressed as 0 × β^e for any exponent e.\n115: -/\n116: def FLX_format_0_check (beta : Int) : Id Bool :=\n117:   pure true  -- Zero is always in format\n118: \n119: /-- Specification: Zero is in FLX format\n120: \n121:     Zero is always representable in fixed-precision format.\n122:     This follows from the fact that 0 = 0 × β^(e-prec) for\n123:     any exponent e, making zero universal across all formats.\n124: -/\n125: theorem FLX_format_0_spec (beta : Int) :\n126:     ⦃⌜beta > 1⌝⦄\n127:     FLX_format_0_check beta\n128:     ⦃⇓result => ⌜result = true⌝⦄ := by\n129:   sorry\n130: \n131: /-- Check closure under negation\n132: \n133:     Verify that if x is in FLX format, then -x is also in FLX format.\n134:     This tests the closure property under additive inverse for\n135:     fixed-precision floating-point numbers.\n136: -/\n137: def FLX_format_opp_check (beta : Int) (x : ℝ) : Id Bool :=\n138:   pure true  -- Always true for fixed-precision formats\n139: \n140: /-- Specification: FLX format closed under negation\n141: \n142:     Fixed-precision formats are closed under negation. If x is\n143:     representable as m × β^(e-prec), then -x is representable\n144:     as (-m) × β^(e-prec), preserving precision and format properties.\n145: -/\n146: theorem FLX_format_opp_spec (beta : Int) (x : ℝ) :\n147:     ⦃⌜(FLX_format prec beta x).run⌝⦄\n148:     FLX_format_opp_check beta x\n149:     ⦃⇓result => ⌜result = true⌝⦄ := by\n150:   sorry\n151: \n152: /-- Check closure under absolute value\n153: \n154:     Verify that if x is in FLX format, then |x| is also in FLX format.\n155:     This tests closure under the absolute value operation, which\n156:     should preserve representability in fixed-precision formats.\n157: -/\n158: def FLX_format_abs_check (beta : Int) (x : ℝ) : Id Bool :=\n159:   pure true  -- Always true for fixed-precision formats\n160: \n161: /-- Specification: FLX format closed under absolute value\n162: \n163:     Fixed-precision formats are closed under absolute value.\n164:     If x is representable, then |x| is also representable since\n165:     |x| can use the same mantissa magnitude with appropriate sign.\n166: -/\n167: theorem FLX_format_abs_spec (beta : Int) (x : ℝ) :\n168:     ⦃⌜(FLX_format prec beta x).run⌝⦄\n169:     FLX_format_abs_check beta x\n170:     ⦃⇓result => ⌜result = true⌝⦄ := by\n171:   sorry\n172: \n173: end FloatSpec.Core.FLX\n174: \n175: namespace FloatSpec.Core.FLX\n176: \n177: variable (prec : Int)\n178: \n179: /-\n180: Coq (FLX.v):\n181: Theorem generic_format_FLX :\n182:   forall x, FLX_format x -> generic_format beta FLX_exp x.\n183: -/\n184: theorem generic_format_FLX (beta : Int) (x : ℝ) :\n185:     ⦃⌜(FLX_format prec beta x).run⌝⦄\n186:     FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x\n187:     ⦃⇓result => ⌜result⌝⦄ := by\n188:   intro hx\n189:   simpa [FLX_format]\n190: \n191: end FloatSpec.Core.FLX\n192: \n193: namespace FloatSpec.Core.FLX\n194: \n195: variable (prec : Int)\n196: \n197: /-\n198: Coq (FLX.v):\n199: Theorem FIX_format_FLX :\n200:   forall x e,\n201:   (bpow (e - 1) <= Rabs x <= bpow e)%R ->\n202:   FLX_format x ->\n203:   FIX_format beta (e - prec) x.\n204: \n205: Lean (spec): If |x| lies in [β^(e-1), β^e] and x is in FLX_format,\n206: then x is in FIX_format with minimal exponent (e - prec).\n207: -/\n208: theorem FIX_format_FLX (beta : Int) (x : ℝ) (e : Int) :\n209:     ⦃⌜(beta : ℝ) ^ (e - 1) ≤ |x| ∧ |x| ≤ (beta : ℝ) ^ e ∧ (FLX_format prec beta x).run⌝⦄\n210:     FloatSpec.Core.FIX.FIX_format (emin := e - prec) beta x\n211:     ⦃⇓result => ⌜result⌝⦄ := by\n212:   intro _\n213:   -- Proof follows Coq's FIX_format_FLX; omitted for now\n214:   sorry\n215: \n216: /-\n217: Coq (FLX.v):\n218: Theorem FLX_format_FIX :\n219:   forall x e,\n220:   (bpow (e - 1) <= Rabs x <= bpow e)%R ->\n221:   FIX_format beta (e - prec) x ->\n222:   FLX_format x.\n223: \n224: Lean (spec): If |x| lies in [β^(e-1), β^e] and x is in FIX_format\n225: with minimal exponent (e - prec), then x is in FLX_format.\n226: -/\n227: theorem FLX_format_FIX (beta : Int) (x : ℝ) (e : Int) :\n228:     ⦃⌜(beta : ℝ) ^ (e - 1) ≤ |x| ∧ |x| ≤ (beta : ℝ) ^ e ∧ (FloatSpec.Core.FIX.FIX_format (emin := e - prec) beta x).run⌝⦄\n229:     FLX_format prec beta x\n230:     ⦃⇓result => ⌜result⌝⦄ := by\n231:   intro _\n232:   -- Proof follows Coq's FLX_format_FIX; omitted for now\n233:   sorry\n234: \n235: end FloatSpec.Core.FLX\n236: \n237: namespace FloatSpec.Core.FLX\n238: \n239: variable (prec : Int)\n240: \n241: /- Valid_exp instance for FLX_exp (placeholder). -/\n242: instance FLX_exp_valid (beta : Int) :\n243:     FloatSpec.Core.Generic_fmt.Valid_exp beta (FLX_exp prec) := by\n244:   refine ⟨?_⟩\n245:   intro k\n246:   refine And.intro ?h1 ?h2\n247:   · intro _\n248:     -- Proof omitted for now\n249:     sorry\n250:   · intro _\n251:     refine And.intro ?hA ?hB\n252:     · -- Proof omitted for now\n253:       sorry\n254:     · intro _ _\n255:       -- Proof omitted for now\n256:       sorry\n257: \n258: /-\n259: Coq (FLX.v):\n260: Theorem FLX_format_satisfies_any :\n261:   satisfies_any FLX_format.\n262: -/\n263: theorem FLX_format_satisfies_any (beta : Int) :\n264:     FloatSpec.Core.Generic_fmt.satisfies_any (fun y => (FLX_format prec beta y).run) := by\n265:   simpa [FLX_format]\n266:     using FloatSpec.Core.Generic_fmt.generic_format_satisfies_any (beta := beta) (fexp := FLX_exp prec)\n267: \n268: end FloatSpec.Core.FLX\n269: \n270: namespace FloatSpec.Core.FLX\n271: \n272: variable (prec : Int)\n273: \n274: /-- Coq (FLX.v):\n275: Theorem ulp_FLX_0 : ulp beta (FLX_exp prec) 0 = bpow (1 - prec).\n276: \n277: Lean (spec): The ULP under FLX at 0 equals `β^(1 - prec)`.\n278: -/\n279: theorem ulp_FLX_0 (beta : Int) :\n280:     ⦃⌜True⌝⦄\n281:     FloatSpec.Core.Ulp.ulp beta (FLX_exp prec) 0\n282:     ⦃⇓r => ⌜r = (beta : ℝ) ^ (1 - prec)⌝⦄ := by\n283:   sorry\n284: \n285: /-- Coq (FLX.v):\n286: Lemma ulp_FLX_1 : ulp beta FLX_exp 1 = bpow (-prec + 1).\n287: \n288: Lean (spec): The ULP under FLX at 1 equals `β^(-prec + 1)`.\n289: -/\n290: theorem ulp_FLX_1 (beta : Int) :\n291:     ⦃⌜True⌝⦄\n292:     FloatSpec.Core.Ulp.ulp beta (FLX_exp prec) 1\n293:     ⦃⇓r => ⌜r = (beta : ℝ) ^ (-prec + 1)⌝⦄ := by\n294:   sorry\n295: \n296: /-- Coq (FLX.v):\n297: Theorem ulp_FLX_le:\n298:   forall x, (ulp beta (FLX_exp prec) x <= Rabs x * bpow (1 - prec))%R.\n299: \n300: Lean (spec): ULP under FLX is bounded above by `|x| * β^(1 - prec)`.\n301: -/\n302: theorem ulp_FLX_le (beta : Int) (x : ℝ) :\n303:     ⦃⌜True⌝⦄\n304:     FloatSpec.Core.Ulp.ulp beta (FLX_exp prec) x\n305:     ⦃⇓r => ⌜r ≤ |x| * (beta : ℝ) ^ (1 - prec)⌝⦄ := by\n306:   sorry\n307: \n308: /-\n309: Coq (FLX.v):\n310: Theorem ulp_FLX_ge:\n311:   forall x, (Rabs x * bpow (-prec) <= ulp beta FLX_exp x)%R.\n312: \n313: Lean (spec): ULP under FLX is bounded below by `|x| * β^(-prec)`.\n314: -/\n315: theorem ulp_FLX_ge (beta : Int) (x : ℝ) :\n316:     ⦃⌜True⌝⦄\n317:     FloatSpec.Core.Ulp.ulp beta (FLX_exp prec) x\n318:     ⦃⇓r => ⌜|x| * (beta : ℝ) ^ (-prec) ≤ r⌝⦄ := by\n319:   sorry\n320: \n321: /-\n322: Coq (FLX.v):\n323: Lemma ulp_FLX_exact_shift:\n324:   forall x e,\n325:   (ulp beta FLX_exp (x * bpow e) = ulp beta FLX_exp x * bpow e)%R.\n326: \n327: Lean (spec): ULP under FLX scales exactly under multiplication by β^e.\n328: -/\n329: theorem ulp_FLX_exact_shift (beta : Int) (x : ℝ) (e : Int) :\n330:     ⦃⌜True⌝⦄\n331:     (do\n332:       let u1 ← FloatSpec.Core.Ulp.ulp beta (FLX_exp prec) (x * (beta : ℝ) ^ e)\n333:       let u2 ← FloatSpec.Core.Ulp.ulp beta (FLX_exp prec) x\n334:       pure (u1, u2))\n335:     ⦃⇓p => ⌜p.1 = p.2 * (beta : ℝ) ^ e⌝⦄ := by\n336:   sorry\n337: \n338: end FloatSpec.Core.FLX\n339: \n340: namespace FloatSpec.Core.FLX\n341: \n342: variable (prec : Int)\n343: \n344: /-\n345: Coq (FLX.v):\n346: Theorem FLX_format_generic :\n347:   forall x, generic_format beta FLX_exp x -> FLX_format x.\n348: -/\n349: theorem FLX_format_generic (beta : Int) (x : ℝ) :\n350:     ⦃⌜(FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x).run⌝⦄\n351:     FLX_format prec beta x\n352:     ⦃⇓result => ⌜result⌝⦄ := by\n353:   intro hx\n354:   simpa [FLX_format] using hx\n355: \n356: end FloatSpec.Core.FLX\n357: \n358: namespace FloatSpec.Core.FLX\n359: \n360: variable (prec : Int)\n361: \n362: /-\n363: Coq (FLX.v):\n364: Theorem generic_format_FLX_1 :\n365:   generic_format beta FLX_exp 1.\n366: -/\n367: theorem generic_format_FLX_1 (beta : Int) :\n368:     ⦃⌜True⌝⦄\n369:     FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) 1\n370:     ⦃⇓result => ⌜result⌝⦄ := by\n371:   intro _\n372:   sorry\n373: \n374: end FloatSpec.Core.FLX\n375: \n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Defs\n20 : import FloatSpec.src.Core.Generic_fmt\n21 : import Mathlib.Data.Real.Basic\n22 : import Std.Do.Triple\n23 : import Std.Tactic.Do\n24 : import FloatSpec.src.Core.Round_generic\n25 : import FloatSpec.src.Core.Ulp\n26 : import FloatSpec.src.Core.FIX\n27 : \n28 : \n29 : open Real\n30 : open Std.Do\n31 : open FloatSpec.Core.Generic_fmt\n32 : open FloatSpec.Core.Round_generic\n33 : \n34 : namespace FloatSpec.Core.FLX\n35 : \n36 : variable (prec : Int)\n37 : \n38 : /-- Fixed-precision exponent function\n39 : \n40 :     In fixed-precision format, the exponent is adjusted to maintain\n41 :     a constant precision. The exponent function returns e - prec,\n42 :     which ensures that mantissas have exactly 'prec' significant digits.\n43 : -/\n44 : def FLX_exp (e : Int) : Int :=\n45 :   e - prec\n46 : \n47 : /-- Check FLX exponent function correctness\n48 : \n49 :     Verify that the FLX exponent function computes e - prec\n50 :     correctly for any input e. This validates the precision\n51 :     adjustment mechanism.\n52 : -/\n53 : def FLX_exp_correct_check (e : Int) : Id Bool :=\n54 :   pure (FLX_exp prec e = e - prec)\n55 : \n56 : /-- Specification: Fixed-precision exponent calculation\n57 : \n58 :     The FLX exponent function subtracts the precision from the\n59 :     input exponent. This adjustment ensures that all representable\n60 :     numbers have exactly 'prec' significant digits in their mantissa.\n61 : -/\n62 : theorem FLX_exp_spec (e : Int) :\n63 :     ⦃⌜True⌝⦄\n64 :     FLX_exp_correct_check prec e\n65 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n66 :   sorry\n67 : \n68 : /-- Fixed-precision format predicate\n69 : \n70 :     A real number x is in FLX format if it can be represented\n71 :     using the generic format with the fixed-precision exponent\n72 :     function. This gives x = m × β^(e-prec) where m has bounded magnitude.\n73 : -/\n74 : def FLX_format (beta : Int) (x : ℝ) : Id Prop :=\n75 :   FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x\n76 : \n77 : /-- Unbounded fixed-precision format with normalized mantissas (placeholder).\n78 : \n79 :     This mirrors Coq's `FLXN_format`. For now, we model it using\n80 :     the same underlying generic format predicate as `FLX_format`.\n81 :     Proofs will refine this equivalence later.\n82 : -/\n83 : def FLXN_format (beta : Int) (x : ℝ) : Id Prop :=\n84 :   FLX_format prec beta x\n85 : \n86 : /-- Specification: FLX format using generic format\n87 : \n88 :     The FLX format is defined through the generic format mechanism\n89 :     with the fixed-precision exponent function. This characterizes\n90 :     floating-point numbers with constant precision.\n91 : -/\n92 : theorem FLX_format_spec (beta : Int) (x : ℝ) :\n93 :     ⦃⌜True⌝⦄\n94 :     FLX_format prec beta x\n95 :     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x).run⌝⦄ := by\n96 :   sorry\n97 : \n98 : /-- Specification: FLX exponent function correctness\n99 : \n100:     The FLX exponent function correctly implements the precision\n101:     adjustment by returning e - prec. This ensures the mantissa\n102:     precision remains constant across different magnitudes.\n103: -/\n104: theorem FLX_exp_correct_spec (e : Int) :\n105:     ⦃⌜True⌝⦄\n106:     FLX_exp_correct_check prec e\n107:     ⦃⇓result => ⌜result = true⌝⦄ := by\n108:   sorry\n109: \n110: /-- Check if zero is in FLX format\n111: \n112:     Verify that zero is representable in the fixed-precision format.\n113:     Zero should always be representable regardless of the precision\n114:     since it can be expressed as 0 × β^e for any exponent e.\n115: -/\n116: def FLX_format_0_check (beta : Int) : Id Bool :=\n117:   pure true  -- Zero is always in format\n118: \n119: /-- Specification: Zero is in FLX format\n120: \n121:     Zero is always representable in fixed-precision format.\n122:     This follows from the fact that 0 = 0 × β^(e-prec) for\n123:     any exponent e, making zero universal across all formats.\n124: -/\n125: theorem FLX_format_0_spec (beta : Int) :\n126:     ⦃⌜beta > 1⌝⦄\n127:     FLX_format_0_check beta\n128:     ⦃⇓result => ⌜result = true⌝⦄ := by\n129:   sorry\n130: \n131: /-- Check closure under negation\n132: \n133:     Verify that if x is in FLX format, then -x is also in FLX format.\n134:     This tests the closure property under additive inverse for\n135:     fixed-precision floating-point numbers.\n136: -/\n137: def FLX_format_opp_check (beta : Int) (x : ℝ) : Id Bool :=\n138:   pure true  -- Always true for fixed-precision formats\n139: \n140: /-- Specification: FLX format closed under negation\n141: \n142:     Fixed-precision formats are closed under negation. If x is\n143:     representable as m × β^(e-prec), then -x is representable\n144:     as (-m) × β^(e-prec), preserving precision and format properties.\n145: -/\n146: theorem FLX_format_opp_spec (beta : Int) (x : ℝ) :\n147:     ⦃⌜(FLX_format prec beta x).run⌝⦄\n148:     FLX_format_opp_check beta x\n149:     ⦃⇓result => ⌜result = true⌝⦄ := by\n150:   sorry\n151: \n152: /-- Check closure under absolute value\n153: \n154:     Verify that if x is in FLX format, then |x| is also in FLX format.\n155:     This tests closure under the absolute value operation, which\n156:     should preserve representability in fixed-precision formats.\n157: -/\n158: def FLX_format_abs_check (beta : Int) (x : ℝ) : Id Bool :=\n159:   pure true  -- Always true for fixed-precision formats\n160: \n161: /-- Specification: FLX format closed under absolute value\n162: \n163:     Fixed-precision formats are closed under absolute value.\n164:     If x is representable, then |x| is also representable since\n165:     |x| can use the same mantissa magnitude with appropriate sign.\n166: -/\n167: theorem FLX_format_abs_spec (beta : Int) (x : ℝ) :\n168:     ⦃⌜(FLX_format prec beta x).run⌝⦄\n169:     FLX_format_abs_check beta x\n170:     ⦃⇓result => ⌜result = true⌝⦄ := by\n171:   sorry\n172: \n173: end FloatSpec.Core.FLX\n174: \n175: namespace FloatSpec.Core.FLX\n176: \n177: variable (prec : Int)\n178: \n179: /-\n180: Coq (FLX.v):\n181: Theorem generic_format_FLX :\n182:   forall x, FLX_format x -> generic_format beta FLX_exp x.\n183: -/\n184: theorem generic_format_FLX (beta : Int) (x : ℝ) :\n185:     ⦃⌜(FLX_format prec beta x).run⌝⦄\n186:     FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x\n187:     ⦃⇓result => ⌜result⌝⦄ := by\n188:   intro hx\n189:   simpa [FLX_format]\n190: \n191: end FloatSpec.Core.FLX\n192: \n193: namespace FloatSpec.Core.FLX\n194: \n195: variable (prec : Int)\n196: \n197: /-\n198: Coq (FLX.v):\n199: Theorem FIX_format_FLX :\n200:   forall x e,\n201:   (bpow (e - 1) <= Rabs x <= bpow e)%R ->\n202:   FLX_format x ->\n203:   FIX_format beta (e - prec) x.\n204: \n205: Lean (spec): If |x| lies in [β^(e-1), β^e] and x is in FLX_format,\n206: then x is in FIX_format with minimal exponent (e - prec).\n207: -/\n208: theorem FIX_format_FLX (beta : Int) (x : ℝ) (e : Int) :\n209:     ⦃⌜(beta : ℝ) ^ (e - 1) ≤ |x| ∧ |x| ≤ (beta : ℝ) ^ e ∧ (FLX_format prec beta x).run⌝⦄\n210:     FloatSpec.Core.FIX.FIX_format (emin := e - prec) beta x\n211:     ⦃⇓result => ⌜result⌝⦄ := by\n212:   intro _\n213:   -- Proof follows Coq's FIX_format_FLX; omitted for now\n214:   sorry\n215: \n216: /-\n217: Coq (FLX.v):\n218: Theorem FLX_format_FIX :\n219:   forall x e,\n220:   (bpow (e - 1) <= Rabs x <= bpow e)%R ->\n221:   FIX_format beta (e - prec) x ->\n222:   FLX_format x.\n223: \n224: Lean (spec): If |x| lies in [β^(e-1), β^e] and x is in FIX_format\n225: with minimal exponent (e - prec), then x is in FLX_format.\n226: -/\n227: theorem FLX_format_FIX (beta : Int) (x : ℝ) (e : Int) :\n228:     ⦃⌜(beta : ℝ) ^ (e - 1) ≤ |x| ∧ |x| ≤ (beta : ℝ) ^ e ∧ (FloatSpec.Core.FIX.FIX_format (emin := e - prec) beta x).run⌝⦄\n229:     FLX_format prec beta x\n230:     ⦃⇓result => ⌜result⌝⦄ := by\n231:   intro _\n232:   -- Proof follows Coq's FLX_format_FIX; omitted for now\n233:   sorry\n234: \n235: end FloatSpec.Core.FLX\n236: \n237: namespace FloatSpec.Core.FLX\n238: \n239: variable (prec : Int)\n240: \n241: /- Valid_exp instance for FLX_exp (placeholder). -/\n242: instance FLX_exp_valid (beta : Int) :\n243:     FloatSpec.Core.Generic_fmt.Valid_exp beta (FLX_exp prec) := by\n244:   refine ⟨?_⟩\n245:   intro k\n246:   refine And.intro ?h1 ?h2\n247:   · intro _\n248:     -- Proof omitted for now\n249:     sorry\n250:   · intro _\n251:     refine And.intro ?hA ?hB\n252:     · -- Proof omitted for now\n253:       sorry\n254:     · intro _ _\n255:       -- Proof omitted for now\n256:       sorry\n257: \n258: /-\n259: Coq (FLX.v):\n260: Theorem FLX_format_satisfies_any :\n261:   satisfies_any FLX_format.\n262: -/\n263: theorem FLX_format_satisfies_any (beta : Int) :\n264:     FloatSpec.Core.Generic_fmt.satisfies_any (fun y => (FLX_format prec beta y).run) := by\n265:   simpa [FLX_format]\n266:     using FloatSpec.Core.Generic_fmt.generic_format_satisfies_any (beta := beta) (fexp := FLX_exp prec)\n267: \n268: end FloatSpec.Core.FLX\n269: \n270: namespace FloatSpec.Core.FLX\n271: \n272: variable (prec : Int)\n273: \n274: /-- Coq (FLX.v):\n275: Theorem ulp_FLX_0 : ulp beta (FLX_exp prec) 0 = bpow (1 - prec).\n276: \n277: Lean (spec): The ULP under FLX at 0 equals `β^(1 - prec)`.\n278: -/\n279: theorem ulp_FLX_0 (beta : Int) :\n280:     ⦃⌜True⌝⦄\n281:     FloatSpec.Core.Ulp.ulp beta (FLX_exp prec) 0\n282:     ⦃⇓r => ⌜r = (beta : ℝ) ^ (1 - prec)⌝⦄ := by\n283:   sorry\n284: \n285: /-- Coq (FLX.v):\n286: Lemma ulp_FLX_1 : ulp beta FLX_exp 1 = bpow (-prec + 1).\n287: \n288: Lean (spec): The ULP under FLX at 1 equals `β^(-prec + 1)`.\n289: -/\n290: theorem ulp_FLX_1 (beta : Int) :\n291:     ⦃⌜True⌝⦄\n292:     FloatSpec.Core.Ulp.ulp beta (FLX_exp prec) 1\n293:     ⦃⇓r => ⌜r = (beta : ℝ) ^ (-prec + 1)⌝⦄ := by\n294:   sorry\n295: \n296: /-- Coq (FLX.v):\n297: Theorem ulp_FLX_le:\n298:   forall x, (ulp beta (FLX_exp prec) x <= Rabs x * bpow (1 - prec))%R.\n299: \n300: Lean (spec): ULP under FLX is bounded above by `|x| * β^(1 - prec)`.\n301: -/\n302: theorem ulp_FLX_le (beta : Int) (x : ℝ) :\n303:     ⦃⌜True⌝⦄\n304:     FloatSpec.Core.Ulp.ulp beta (FLX_exp prec) x\n305:     ⦃⇓r => ⌜r ≤ |x| * (beta : ℝ) ^ (1 - prec)⌝⦄ := by\n306:   sorry\n307: \n308: /-\n309: Coq (FLX.v):\n310: Theorem ulp_FLX_ge:\n311:   forall x, (Rabs x * bpow (-prec) <= ulp beta FLX_exp x)%R.\n312: \n313: Lean (spec): ULP under FLX is bounded below by `|x| * β^(-prec)`.\n314: -/\n315: theorem ulp_FLX_ge (beta : Int) (x : ℝ) :\n316:     ⦃⌜True⌝⦄\n317:     FloatSpec.Core.Ulp.ulp beta (FLX_exp prec) x\n318:     ⦃⇓r => ⌜|x| * (beta : ℝ) ^ (-prec) ≤ r⌝⦄ := by\n319:   sorry\n320: \n321: /-\n322: Coq (FLX.v):\n323: Lemma ulp_FLX_exact_shift:\n324:   forall x e,\n325:   (ulp beta FLX_exp (x * bpow e) = ulp beta FLX_exp x * bpow e)%R.\n326: \n327: Lean (spec): ULP under FLX scales exactly under multiplication by β^e.\n328: -/\n329: theorem ulp_FLX_exact_shift (beta : Int) (x : ℝ) (e : Int) :\n330:     ⦃⌜True⌝⦄\n331:     (do\n332:       let u1 ← FloatSpec.Core.Ulp.ulp beta (FLX_exp prec) (x * (beta : ℝ) ^ e)\n333:       let u2 ← FloatSpec.Core.Ulp.ulp beta (FLX_exp prec) x\n334:       pure (u1, u2))\n335:     ⦃⇓p => ⌜p.1 = p.2 * (beta : ℝ) ^ e⌝⦄ := by\n336:   sorry\n337: \n338: end FloatSpec.Core.FLX\n339: \n340: namespace FloatSpec.Core.FLX\n341: \n342: variable (prec : Int)\n343: \n344: /-\n345: Coq (FLX.v):\n346: Theorem FLX_format_generic :\n347:   forall x, generic_format beta FLX_exp x -> FLX_format x.\n348: -/\n349: theorem FLX_format_generic (beta : Int) (x : ℝ) :\n350:     ⦃⌜(FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x).run⌝⦄\n351:     FLX_format prec beta x\n352:     ⦃⇓result => ⌜result⌝⦄ := by\n353:   intro hx\n354:   simpa [FLX_format] using hx\n355: \n356: end FloatSpec.Core.FLX\n357: \n358: namespace FloatSpec.Core.FLX\n359: \n360: variable (prec : Int)\n361: \n362: /-\n363: Coq (FLX.v):\n364: Theorem generic_format_FLX_1 :\n365:   generic_format beta FLX_exp 1.\n366: -/\n367: theorem generic_format_FLX_1 (beta : Int) :\n368:     ⦃⌜True⌝⦄\n369:     FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) 1\n370:     ⦃⇓result => ⌜result⌝⦄ := by\n371:   intro _\n372:   sorry\n373: \n374: end FloatSpec.Core.FLX\n375: \n"
  }
}
[2025-09-16T03:36:57] tokens used: 72644
[2025-09-16T03:37:03] thinking

**Clarifying missing theorems**

I'm trying to identify which file has missing theorems. For example, Generic_fmt.v definitely has many, and while Generic_fmt.lean is implemented with some, there are still many missing theorems. Adding them all seems daunting, so it might be better to ask for the target file. I'll frame my question concisely: "Which Core file should I import missing theorems for? Options include FIX, FLT, FLX, FTZ, Raux, Round_NE, Round_pred, Ulp, etc."
[2025-09-16T03:37:06] codex

Quick check: I’ve reviewed the comparison record and the Core files. There are multiple candidates (e.g., FLT.lean, FLX.lean, FIX.lean, Raux.lean, Ulp.lean, etc.) each with different missing items.

Which specific Core file should I target for introducing the missing theorems? For example: FLT.lean, FLX.lean, FIX.lean, FTZ.lean, Raux.lean, Round_NE.lean, Round_pred.lean, or Ulp.lean.
[2025-09-16T03:37:06] tokens used: 77872
