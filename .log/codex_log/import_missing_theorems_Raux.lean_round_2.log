[2025-09-15T19:50:24] OpenAI Codex v0.20.0 (research preview)
--------
workdir: /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
model: gpt-5
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: medium
reasoning summaries: auto
--------
[2025-09-15T19:50:24] User instructions:
Please ensure your implementation Always Works™ for:

## Task: Introduce Missing Theorems in FloatSpec/src/Core/${file}

## Scope

Introduce missing theorems in the file. You can find the record of missing theorems in file /Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Core_Theorems_Comparison.md, which is generated by comparing the Coq and Lean versions of the file. For all the missing theorems in the file, find their corresponding Coq implementation in /Users/louhantao/Desktop/code/semester_6.5/flocq/src/Core and implement them in Lean, using the same name and similar syntax with existing theorems. Leave the proofs empty for now.

### Prerequisites

1. **Read documentation first:**
    - FloatSpec/PIPELINE.md - understand the overall pipeline
    - ./CLAUDE.md - focus on proof writing instructions and mvcgen info

### Core Requirements

### Theorem Importing Process

1. **Follow the Zfast_div_eucl_spec example** in Zaux.lean and other theorems in current file as your template
2. **ONE-BY-ONE approach is mandatory:**
    - Write ONE theorem
    - Use the hoare triple syntax (introduced in FloatSpec/PIPELINE.md and CLAUDE.md) to write the theorem
    - Check immediately with mcp tool or `lake build`
    - Fix any errors before proceeding to next theorem
    - Never batch multiple theorems without checking
3. After writing each theorem, check whether they are aligned with the Coq implementation. If so, mark them as complete in the record file.

### Before Writing Each Theorem

1. **Verify function implementation** - ensure the function body is correct
2. **Preserve syntax** - do NOT change hoare triple syntax unless absolutely necessary
    - Think multiple times before modifying specs or code body
    - If changes are needed, decompose complex specs rather than rewriting

### Compilation Verification

- **After EVERY theorem:** Run `mcp` (preferred) or `lake build xxx`
- **Definition of complete:** NO errors or 'pure true' statements
- **Never mark as complete if:**
    - Any errors or 'pure true' statements remain
    - Compilation returns errors
    - Sorry is allowed, but only as a placeholder for the proof


### Important Notes

- Use MCP tool instead of bash command to get diagnostic messages!
- Skip already-imported theorems!! There might be warnings be just leave them there!
- You can use exisiting (and proved) theorem to assist your spec writing. If a theorem is necessary but not introduced, you can turn to work on that first. The useful theorems might not be in the same file, but in the import list
- When you are trying to use a certain lemma, check through mcp tools (or https://github.com/leanprover-community/mathlib4) to make sure the lemma exists. Else, write your own implementation of the lemma.

### Success Criteria

✅ All error and 'pure true' statements eliminated
✅ Clean compilation for entire file
✅ Each theorem verified individually before moving on

[2025-09-15T19:50:35] ERROR: MCP client for `LeanTool` failed to start: No such file or directory (os error 2)
[2025-09-15T19:50:35] ERROR: MCP client for `leanexploreRemote` failed to start: request timed out
[2025-09-15T19:50:35] ERROR: MCP client for `leanexploreLocal` failed to start: request timed out
[2025-09-15T19:50:40] thinking

**Working on Lean project**

I need to focus on the Lean project FloatSpec and introduce missing theorems specified in FloatSpec/src/Core/${file}. There's a record in Core_Theorems_Comparison.md that lists these missing theorems. My first step is to read the docs and follow the process. I'll open the comparison markdown to find out which file the missing theorems relate to, and then use the mcp tools for diagnostics and file editing. I’ll make sure to clarify which specific file to work on, as the variable suggests flexibility.**Exploring the repo**

I need to explore the repository, particularly the files in FloatSpec/src/Core. My first step is to list the files there and open the comparison markdown document. I can use functions.shell to execute the "ls" command, but I should remember to include a concise preamble before any tool calls. Following this structure will help ensure everything runs smoothly as I gather the information I need!
[2025-09-15T19:50:44] codex
**Exploring the repo**

I need to explore the repository, particularly the files in FloatSpec/src/Core. My first step is to list the files there and open the comparison markdown document. I can use functions.shell to execute the "ls" command, but I should remember to include a concise preamble before any tool calls. Following this structure will help ensure everything runs smoothly as I gather the information I need!
[2025-09-15T19:50:44] codex

I’ll scan the comparison report and Core folder to locate missing theorems.
[2025-09-15T19:50:45] exec bash -lc "ls -la && echo '---' && ls -la FloatSpec/src/Core && echo '---' && sed -n '1,200p' FloatSpec/src/Core/Core_Theorems_Comparison.md" in /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
[2025-09-15T19:50:45] bash -lc "ls -la && echo '---' && ls -la FloatSpec/src/Core && echo '---' && sed -n '1,200p' FloatSpec/src/Core/Core_Theorems_Comparison.md" succeeded in 527ms:
total 40296
drwxr-xr-x  25 louhantao  staff       800 Sep 16 02:07 .
drwxr-xr-x@ 16 louhantao  staff       512 Sep 12 22:07 ..
-rw-r--r--@  1 louhantao  staff      6148 Sep  8 11:59 .DS_Store
drwxr-xr-x   3 louhantao  staff        96 Sep  9 11:39 .claude
drwxr-xr-x  14 louhantao  staff       448 Sep 16 01:24 .git
-rw-r--r--   1 louhantao  staff        17 Aug 13 08:19 .gitignore
drwxr-xr-x@  7 louhantao  staff       224 Sep  7 18:35 .lake
drwxr-xr-x@ 17 louhantao  staff       544 Sep 16 02:18 .log
-rw-r--r--   1 louhantao  staff       831 Jul 22 18:41 .mcp.json
-rw-r--r--@  1 louhantao  staff     25589 Sep 13 10:44 CLAUDE.md
drwxr-xr-x   4 louhantao  staff       128 Jul 22 18:41 Deps
drwxr-xr-x   7 louhantao  staff       224 Sep 15 18:25 FloatSpec
-rw-r--r--@  1 louhantao  staff       785 Aug 10 04:04 FloatSpec.lean
-rw-r--r--   1 louhantao  staff     11357 Jul 22 18:41 LICENSE
-rw-r--r--   1 louhantao  staff       273 Jul 22 18:41 Main.lean
-rw-r--r--@  1 louhantao  staff      7403 Aug 22 06:56 PIPELINE.md
-rw-r--r--   1 louhantao  staff        62 Jul 22 18:41 README.md
-rw-r--r--   1 louhantao  staff     10879 Sep 16 02:19 complete_import.sh
-rw-r--r--   1 louhantao  staff  11503322 Sep 16 03:50 fwIn.txt
[2025-09-15T19:50:45] tokens used: 7117
[2025-09-15T19:50:50] thinking

**Clarifying file selection**

The comparison file is long, and I only saw the beginning. I need to pick a specific Core file for the task, which says, "Introduce Missing Theorems in FloatSpec/src/Core/${file}." It seems to be directed at a specific `${file}` the user wants, but they haven’t specified which one. I think asking for clarification on which file would be a good step. I’ll suggest selecting one with the missing theorems after checking further. Let’s continue scrolling to identify files like FIX.lean, FLT.lean, FLX.lean, etc.
[2025-09-15T19:50:53] codex

I’ll scan the rest of the comparison file to find a Core file with missing theorems to start with.
[2025-09-15T19:50:53] exec bash -lc "sed -n '200,800p' FloatSpec/src/Core/Core_Theorems_Comparison.md" in /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
[2025-09-15T19:50:53] bash -lc "sed -n '200,800p' FloatSpec/src/Core/Core_Theorems_Comparison.md" succeeded in 327ms:
- `Zdigit_ge_Zpower_pos` → `Zdigit_ge_Zpower_pos` (exact-name)
- `Zdigit_ge_Zpower` → `Zdigit_ge_Zpower` (exact-name)
- `Zdigit_not_0_pos` → `Zdigit_not_0_pos` (exact-name)
- `Zdigit_not_0` → `Zdigit_not_0` (exact-name)
- `Zdigit_mul_pow` → `Zdigit_mul_pow` (exact-name)
- `Zdigit_div_pow` → `Zdigit_div_pow` (exact-name)
- `Zdigit_mod_pow` → `Zdigit_mod_pow` (exact-name)
- `Zdigit_mod_pow_out` → `Zdigit_mod_pow_out` (exact-name)
- `Zsum_digit_digit` → `Zsum_digit_digit` (exact-name)
- `Zdigit_ext` → `Zdigit_ext_nonneg` (substring-name)
- `ZOmod_plus_pow_digit` → `ZOmod_plus_pow_digit` (exact-name)
- `ZOdiv_plus_pow_digit` → `ZOdiv_plus_pow_digit` (exact-name)
- `Zdigit_plus` → `Zdigit_plus_nonneg` (substring-name)
- `Zdigit_scale` → `Zdigit_scale_point` (substring-name)
- `Zscale_0` → `Zscale_0` (exact-name)
- `Zsame_sign_scale` → `Zsame_sign_scale` (exact-name)
- `Zscale_mul_pow` → `Zscale_mul_pow` (exact-name)
- `Zscale_scale` → `Zscale_scale` (exact-name)
- `Zdigit_slice` → `Zdigit_slice` (exact-name)
- `Zdigit_slice_out` → `Zdigit_slice_out` (exact-name)
[2025-09-15T19:50:53] tokens used: 10790
[2025-09-15T19:50:56] codex

Continuing to scan for missing theorem entries across remaining files.
[2025-09-15T19:50:57] exec bash -lc "sed -n '800,1600p' FloatSpec/src/Core/Core_Theorems_Comparison.md" in /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
[2025-09-15T19:50:57] bash -lc "sed -n '800,1600p' FloatSpec/src/Core/Core_Theorems_Comparison.md" succeeded in 324ms:
- `mag_round` → (no match)
- `mag_DN` → (no match)
- `cexp_DN` → (no match)
- `scaled_mantissa_DN` → (no match)
- `generic_N_pt_DN_or_UP` → (no match)
- `subnormal_exponent` → (no match)
- `cexp_le_bpow` → (no match)
- `cexp_ge_bpow` → (no match)
- `lt_cexp_pos` → (no match)
- `lt_cexp` → (no match)
- `mag_round_ge` → (no match)
- `cexp_round_ge` → (no match)
- `Znearest_DN_or_UP` → (no match)
- `Znearest_ge_floor` → (no match)
- `Znearest_le_ceil` → (no match)
- `Znearest_N_strict` → (no match)
- `Znearest_half` → (no match)
- `Znearest_imp` → (no match)
- `round_N_pt` → (no match)
- `round_N_middle` → (no match)
[2025-09-15T19:50:57] tokens used: 14246
[2025-09-15T19:50:59] codex

I’ll continue scanning to reach the end of the comparison to pinpoint a concrete file to work on.
[2025-09-15T19:51:01] exec bash -lc "sed -n '1600,2400p' FloatSpec/src/Core/Core_Theorems_Comparison.md" in /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
[2025-09-15T19:51:01] bash -lc "sed -n '1600,2400p' FloatSpec/src/Core/Core_Theorems_Comparison.md" succeeded in 323ms:
- `pred_le_inv` → (no match)
- `succ_le_inv` → (no match)
- `pred_lt` → (no match)
- `succ_lt` → (no match)
- `succ_le_plus_ulp` → (no match)
- `generic_format_plus_ulp` → (no match)
- `round_DN_ge_UP_gt` → (no match)
- `round_UP_le_DN_lt` → (no match)
- `pred_UP_le_DN` → (no match)
- `UP_le_succ_DN` → (no match)
- `pred_UP_eq_DN` → (no match)
- `succ_DN_eq_UP` → (no match)
- `round_DN_eq` → (no match)
- `round_UP_eq` → (no match)
- `ulp_ulp_0` → (no match)
- `ulp_succ_pos` → (no match)
- `ulp_pred_pos` → (no match)
- `ulp_round_pos` → (no match)
- `ulp_round` → (no match)
- `succ_round_ge_id` → (no match)
[2025-09-15T19:51:01] tokens used: 17373
[2025-09-15T19:51:03] codex

Finishing the scan to hit the final sections and pick a target file.
[2025-09-15T19:51:05] exec bash -lc "sed -n '2400,4000p' FloatSpec/src/Core/Core_Theorems_Comparison.md" in /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
[2025-09-15T19:51:05] bash -lc "sed -n '2400,4000p' FloatSpec/src/Core/Core_Theorems_Comparison.md" succeeded in 321ms:

[2025-09-15T19:51:05] tokens used: 20533
[2025-09-15T19:51:12] thinking

**Considering next steps**

I’m thinking about how the directive suggests I should keep going until it's resolved without asking too many questions. It might be a good idea to propose starting with FIX.lean, especially since it's smaller, to help add the missing theorems. I’ll need to open FIX.lean to check what's already there and to examine the style. This approach could clarify how I can move forward effectively.
[2025-09-15T19:51:13] codex

I’m going to open `FIX.lean` to see existing theorem patterns and add the first missing one.
[2025-09-15T19:51:14] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FIX.lean"})
[2025-09-15T19:51:14] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FIX.lean"}) success in 7ms:
{
  "content": [
    {
      "text": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Defs\n20 : import FloatSpec.src.Core.Generic_fmt\n21 : import FloatSpec.src.Core.Round_generic\n22 : import FloatSpec.src.Core.Ulp\n23 : import Mathlib.Data.Real.Basic\n24 : import Std.Do.Triple\n25 : import Std.Tactic.Do\n26 : \n27 : open Real\n28 : open Std.Do\n29 : open FloatSpec.Core.Generic_fmt\n30 : open FloatSpec.Core.Round_generic\n31 : \n32 : namespace FloatSpec.Core.FIX\n33 : \n34 : variable (emin : Int)\n35 : \n36 : /-- Fixed-point exponent function\n37 : \n38 :     In fixed-point format, all numbers have the same exponent emin.\n39 :     This creates a uniform representation where the position of\n40 :     the binary/decimal point is fixed across all values.\n41 : -/\n42 : def FIX_exp (_ : Int) : Int :=\n43 :   emin\n44 : \n45 : /-- Check FIX format correctness\n46 : \n47 :     Verify the fundamental property that FIX_exp always\n48 :     returns emin regardless of input. This validates\n49 :     the fixed-point nature of the format.\n50 : -/\n51 : def FIX_exp_correct_check (e : Int) : Id Bool :=\n52 :   pure (FIX_exp emin e = emin)\n53 : \n54 : /-- Specification: Fixed exponent always returns emin\n55 : \n56 :     The fixed-point exponent function ignores its input and\n57 :     always returns the fixed exponent emin. This ensures\n58 :     uniform scaling across all representable values.\n59 : -/\n60 : theorem FIX_exp_spec (e : Int) :\n61 :     ⦃⌜True⌝⦄\n62 :     FIX_exp_correct_check emin e\n63 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n64 :   sorry\n65 : \n66 : /-- Fixed-point format predicate\n67 : \n68 :     A real number x is in FIX format if it can be represented\n69 :     using the generic format with the fixed exponent function.\n70 :     This means x = m × β^emin for some integer mantissa m.\n71 : -/\n72 : def FIX_format (beta : Int) (x : ℝ) : Id Prop :=\n73 :   FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x\n74 : \n75 : /-- Valid_exp instance for the fixed exponent function (placeholder). -/\n76 : instance FIX_exp_valid (beta : Int) :\n77 :     FloatSpec.Core.Generic_fmt.Valid_exp beta (FIX_exp emin) := by\n78 :   refine ⟨?_⟩\n79 :   intro k\n80 :   refine And.intro ?h1 ?h2\n81 :   · intro _; \n82 :     -- Proof omitted for now\n83 :     sorry\n84 :   · intro _\n85 :     refine And.intro ?hA ?hB\n86 :     · -- Proof omitted for now\n87 :       sorry\n88 :     · intro _ _\n89 :       -- Proof omitted for now\n90 :       sorry\n91 : \n92 : /-- Specification: FIX format using generic format\n93 : \n94 :     The FIX format is defined in terms of the generic format\n95 :     with a fixed exponent function. This provides a concrete\n96 :     characterization of fixed-point representable numbers.\n97 : -/\n98 : theorem FIX_format_spec (beta : Int) (x : ℝ) :\n99 :     ⦃⌜True⌝⦄\n100:     FIX_format emin beta x\n101:     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x).run⌝⦄ := by\n102:   sorry\n103: \n104: /-- Specification: FIX exponent function correctness\n105: \n106:     The FIX exponent function satisfies its specification:\n107:     it always returns emin for any input e. This establishes\n108:     the correctness of the fixed-point implementation.\n109: -/\n110: theorem FIX_exp_correct_spec (e : Int) :\n111:     ⦃⌜True⌝⦄\n112:     FIX_exp_correct_check emin e\n113:     ⦃⇓result => ⌜result = true⌝⦄ := by\n114:   sorry\n115: \n116: /-- Check if zero is in FIX format\n117: \n118:     Verify that zero is representable in the fixed-point format.\n119:     Zero should always be representable as 0 × β^emin = 0.\n120: -/\n121: def FIX_format_0_check (beta : Int) : Id Bool :=\n122:   pure true  -- Zero is always in format\n123: \n124: /-- Specification: Zero is in FIX format\n125: \n126:     Zero is always representable in fixed-point format since\n127:     it can be expressed as 0 × β^emin. This ensures that\n128:     fixed-point formats always contain the additive identity.\n129: -/\n130: theorem FIX_format_0_spec (beta : Int) :\n131:     ⦃⌜beta > 1⌝⦄\n132:     FIX_format_0_check beta\n133:     ⦃⇓result => ⌜result = true⌝⦄ := by\n134:   sorry\n135: \n136: /-- Check closure under negation\n137: \n138:     Verify that if x is in FIX format, then -x is also in FIX format.\n139:     This tests the closure property under additive inverse.\n140: -/\n141: def FIX_format_opp_check (beta : Int) (x : ℝ) : Id Bool :=\n142:   pure true  -- Always true for fixed-point formats\n143: \n144: /-- Specification: FIX format closed under negation\n145: \n146:     Fixed-point formats are closed under negation: if x is\n147:     representable, then -x is also representable. This follows\n148:     from the fact that if x = m × β^emin, then -x = (-m) × β^emin.\n149: -/\n150: theorem FIX_format_opp_spec (beta : Int) (x : ℝ) :\n151:     ⦃⌜(FIX_format emin beta x).run⌝⦄\n152:     FIX_format_opp_check beta x\n153:     ⦃⇓result => ⌜result = true⌝⦄ := by\n154:   sorry\n155: \n156: /-\n157: Coq (FIX.v):\n158: Theorem generic_format_FIX :\n159:   forall x, FIX_format x -> generic_format beta FIX_exp x.\n160: -/\n161: theorem generic_format_FIX (beta : Int) (x : ℝ) :\n162:     ⦃⌜(FIX_format emin beta x).run⌝⦄\n163:     FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x\n164:     ⦃⇓result => ⌜result⌝⦄ := by\n165:   intro hx\n166:   simpa [FIX_format]\n167: \n168: /-\n169: Coq (FIX.v):\n170: Theorem FIX_format_generic :\n171:   forall x, generic_format beta FIX_exp x -> FIX_format x.\n172: -/\n173: theorem FIX_format_generic (beta : Int) (x : ℝ) :\n174:     ⦃⌜(FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x).run⌝⦄\n175:     FIX_format emin beta x\n176:     ⦃⇓result => ⌜result⌝⦄ := by\n177:   intro hx\n178:   simpa [FIX_format] using hx\n179: \n180: /-\n181: Coq (FIX.v):\n182: Theorem FIX_format_satisfies_any :\n183:   satisfies_any FIX_format.\n184: -/\n185: theorem FIX_format_satisfies_any (beta : Int) :\n186:     FloatSpec.Core.Generic_fmt.satisfies_any (fun y => (FIX_format emin beta y).run) := by\n187:   -- Immediate from the generic format version\n188:   simpa [FIX_format]\n189:     using FloatSpec.Core.Generic_fmt.generic_format_satisfies_any (beta := beta) (fexp := FIX_exp emin)\n190: \n191: /-- Coq (FIX.v):\n192: Theorem ulp_FIX : forall x, ulp beta FIX_exp x = bpow emin.\n193: \n194: Lean (spec): For any real `x`, the ULP under FIX exponent equals `β^emin`.\n195: -/\n196: theorem ulp_FIX (beta : Int) (x : ℝ) :\n197:     ⦃⌜True⌝⦄\n198:     FloatSpec.Core.Ulp.ulp beta (FIX_exp emin) x\n199:     ⦃⇓r => ⌜r = (beta : ℝ) ^ emin⌝⦄ := by\n200:   sorry\n201: \n202: end FloatSpec.Core.FIX\n203: \n204: namespace FloatSpec.Core.FIX\n205: \n206: /-- Coq (FIX.v):\n207: Theorem round_FIX_IZR : forall f x, round radix2 (FIX_exp 0) f x = IZR (f x).\n208: \n209: Lean (spec): For base 2 and fixed exponent 0, rounding yields the\n210: real embedding of the integer produced by `f` at `x`.\n211: -/\n212: theorem round_FIX_IZR (f : ℝ → Int) (x : ℝ) :\n213:     ⦃⌜True⌝⦄\n214:     (pure (FloatSpec.Core.Round_generic.round_to_generic (beta := 2) (fexp := FIX_exp (emin := (0 : Int))) (mode := fun _ _ => True) x) : Id ℝ)\n215:     ⦃⇓r => ⌜r = (f x : ℝ)⌝⦄ := by\n216:   sorry\n217: \n218: end FloatSpec.Core.FIX\n219: \n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Defs\n20 : import FloatSpec.src.Core.Generic_fmt\n21 : import FloatSpec.src.Core.Round_generic\n22 : import FloatSpec.src.Core.Ulp\n23 : import Mathlib.Data.Real.Basic\n24 : import Std.Do.Triple\n25 : import Std.Tactic.Do\n26 : \n27 : open Real\n28 : open Std.Do\n29 : open FloatSpec.Core.Generic_fmt\n30 : open FloatSpec.Core.Round_generic\n31 : \n32 : namespace FloatSpec.Core.FIX\n33 : \n34 : variable (emin : Int)\n35 : \n36 : /-- Fixed-point exponent function\n37 : \n38 :     In fixed-point format, all numbers have the same exponent emin.\n39 :     This creates a uniform representation where the position of\n40 :     the binary/decimal point is fixed across all values.\n41 : -/\n42 : def FIX_exp (_ : Int) : Int :=\n43 :   emin\n44 : \n45 : /-- Check FIX format correctness\n46 : \n47 :     Verify the fundamental property that FIX_exp always\n48 :     returns emin regardless of input. This validates\n49 :     the fixed-point nature of the format.\n50 : -/\n51 : def FIX_exp_correct_check (e : Int) : Id Bool :=\n52 :   pure (FIX_exp emin e = emin)\n53 : \n54 : /-- Specification: Fixed exponent always returns emin\n55 : \n56 :     The fixed-point exponent function ignores its input and\n57 :     always returns the fixed exponent emin. This ensures\n58 :     uniform scaling across all representable values.\n59 : -/\n60 : theorem FIX_exp_spec (e : Int) :\n61 :     ⦃⌜True⌝⦄\n62 :     FIX_exp_correct_check emin e\n63 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n64 :   sorry\n65 : \n66 : /-- Fixed-point format predicate\n67 : \n68 :     A real number x is in FIX format if it can be represented\n69 :     using the generic format with the fixed exponent function.\n70 :     This means x = m × β^emin for some integer mantissa m.\n71 : -/\n72 : def FIX_format (beta : Int) (x : ℝ) : Id Prop :=\n73 :   FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x\n74 : \n75 : /-- Valid_exp instance for the fixed exponent function (placeholder). -/\n76 : instance FIX_exp_valid (beta : Int) :\n77 :     FloatSpec.Core.Generic_fmt.Valid_exp beta (FIX_exp emin) := by\n78 :   refine ⟨?_⟩\n79 :   intro k\n80 :   refine And.intro ?h1 ?h2\n81 :   · intro _; \n82 :     -- Proof omitted for now\n83 :     sorry\n84 :   · intro _\n85 :     refine And.intro ?hA ?hB\n86 :     · -- Proof omitted for now\n87 :       sorry\n88 :     · intro _ _\n89 :       -- Proof omitted for now\n90 :       sorry\n91 : \n92 : /-- Specification: FIX format using generic format\n93 : \n94 :     The FIX format is defined in terms of the generic format\n95 :     with a fixed exponent function. This provides a concrete\n96 :     characterization of fixed-point representable numbers.\n97 : -/\n98 : theorem FIX_format_spec (beta : Int) (x : ℝ) :\n99 :     ⦃⌜True⌝⦄\n100:     FIX_format emin beta x\n101:     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x).run⌝⦄ := by\n102:   sorry\n103: \n104: /-- Specification: FIX exponent function correctness\n105: \n106:     The FIX exponent function satisfies its specification:\n107:     it always returns emin for any input e. This establishes\n108:     the correctness of the fixed-point implementation.\n109: -/\n110: theorem FIX_exp_correct_spec (e : Int) :\n111:     ⦃⌜True⌝⦄\n112:     FIX_exp_correct_check emin e\n113:     ⦃⇓result => ⌜result = true⌝⦄ := by\n114:   sorry\n115: \n116: /-- Check if zero is in FIX format\n117: \n118:     Verify that zero is representable in the fixed-point format.\n119:     Zero should always be representable as 0 × β^emin = 0.\n120: -/\n121: def FIX_format_0_check (beta : Int) : Id Bool :=\n122:   pure true  -- Zero is always in format\n123: \n124: /-- Specification: Zero is in FIX format\n125: \n126:     Zero is always representable in fixed-point format since\n127:     it can be expressed as 0 × β^emin. This ensures that\n128:     fixed-point formats always contain the additive identity.\n129: -/\n130: theorem FIX_format_0_spec (beta : Int) :\n131:     ⦃⌜beta > 1⌝⦄\n132:     FIX_format_0_check beta\n133:     ⦃⇓result => ⌜result = true⌝⦄ := by\n134:   sorry\n135: \n136: /-- Check closure under negation\n137: \n138:     Verify that if x is in FIX format, then -x is also in FIX format.\n139:     This tests the closure property under additive inverse.\n140: -/\n141: def FIX_format_opp_check (beta : Int) (x : ℝ) : Id Bool :=\n142:   pure true  -- Always true for fixed-point formats\n143: \n144: /-- Specification: FIX format closed under negation\n145: \n146:     Fixed-point formats are closed under negation: if x is\n147:     representable, then -x is also representable. This follows\n148:     from the fact that if x = m × β^emin, then -x = (-m) × β^emin.\n149: -/\n150: theorem FIX_format_opp_spec (beta : Int) (x : ℝ) :\n151:     ⦃⌜(FIX_format emin beta x).run⌝⦄\n152:     FIX_format_opp_check beta x\n153:     ⦃⇓result => ⌜result = true⌝⦄ := by\n154:   sorry\n155: \n156: /-\n157: Coq (FIX.v):\n158: Theorem generic_format_FIX :\n159:   forall x, FIX_format x -> generic_format beta FIX_exp x.\n160: -/\n161: theorem generic_format_FIX (beta : Int) (x : ℝ) :\n162:     ⦃⌜(FIX_format emin beta x).run⌝⦄\n163:     FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x\n164:     ⦃⇓result => ⌜result⌝⦄ := by\n165:   intro hx\n166:   simpa [FIX_format]\n167: \n168: /-\n169: Coq (FIX.v):\n170: Theorem FIX_format_generic :\n171:   forall x, generic_format beta FIX_exp x -> FIX_format x.\n172: -/\n173: theorem FIX_format_generic (beta : Int) (x : ℝ) :\n174:     ⦃⌜(FloatSpec.Core.Generic_fmt.generic_format beta (FIX_exp emin) x).run⌝⦄\n175:     FIX_format emin beta x\n176:     ⦃⇓result => ⌜result⌝⦄ := by\n177:   intro hx\n178:   simpa [FIX_format] using hx\n179: \n180: /-\n181: Coq (FIX.v):\n182: Theorem FIX_format_satisfies_any :\n183:   satisfies_any FIX_format.\n184: -/\n185: theorem FIX_format_satisfies_any (beta : Int) :\n186:     FloatSpec.Core.Generic_fmt.satisfies_any (fun y => (FIX_format emin beta y).run) := by\n187:   -- Immediate from the generic format version\n188:   simpa [FIX_format]\n189:     using FloatSpec.Core.Generic_fmt.generic_format_satisfies_any (beta := beta) (fexp := FIX_exp emin)\n190: \n191: /-- Coq (FIX.v):\n192: Theorem ulp_FIX : forall x, ulp beta FIX_exp x = bpow emin.\n193: \n194: Lean (spec): For any real `x`, the ULP under FIX exponent equals `β^emin`.\n195: -/\n196: theorem ulp_FIX (beta : Int) (x : ℝ) :\n197:     ⦃⌜True⌝⦄\n198:     FloatSpec.Core.Ulp.ulp beta (FIX_exp emin) x\n199:     ⦃⇓r => ⌜r = (beta : ℝ) ^ emin⌝⦄ := by\n200:   sorry\n201: \n202: end FloatSpec.Core.FIX\n203: \n204: namespace FloatSpec.Core.FIX\n205: \n206: /-- Coq (FIX.v):\n207: Theorem round_FIX_IZR : forall f x, round radix2 (FIX_exp 0) f x = IZR (f x).\n208: \n209: Lean (spec): For base 2 and fixed exponent 0, rounding yields the\n210: real embedding of the integer produced by `f` at `x`.\n211: -/\n212: theorem round_FIX_IZR (f : ℝ → Int) (x : ℝ) :\n213:     ⦃⌜True⌝⦄\n214:     (pure (FloatSpec.Core.Round_generic.round_to_generic (beta := 2) (fexp := FIX_exp (emin := (0 : Int))) (mode := fun _ _ => True) x) : Id ℝ)\n215:     ⦃⇓r => ⌜r = (f x : ℝ)⌝⦄ := by\n216:   sorry\n217: \n218: end FloatSpec.Core.FIX\n219: \n"
  }
}
[2025-09-15T19:51:14] tokens used: 20927
[2025-09-15T19:51:18] codex

I’ll open `FLT.lean` to see which missing theorems need stubs added.
[2025-09-15T19:51:18] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLT.lean"})
[2025-09-15T19:51:18] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLT.lean"}) success in 3ms:
{
  "content": [
    {
      "text": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Defs\n20 : import FloatSpec.src.Core.Generic_fmt\n21 : import FloatSpec.src.Core.Round_generic\n22 : import FloatSpec.src.Core.Ulp\n23 : import FloatSpec.src.Core.FLX\n24 : import FloatSpec.src.Core.FIX\n25 : import Mathlib.Data.Real.Basic\n26 : import Std.Do.Triple\n27 : import Std.Tactic.Do\n28 : \n29 : open Real\n30 : open Std.Do\n31 : open FloatSpec.Core.Generic_fmt\n32 : open FloatSpec.Core.Round_generic\n33 : \n34 : namespace FloatSpec.Core.FLT\n35 : \n36 : variable (prec emin : Int)\n37 : \n38 : /-- Floating-point exponent function\n39 : \n40 :     The FLT exponent function combines fixed-precision behavior\n41 :     with a minimum exponent bound. It returns max(e - prec, emin),\n42 :     providing precision when possible but limiting underflow.\n43 : -/\n44 : def FLT_exp (e : Int) : Int :=\n45 :   max (e - prec) emin\n46 : \n47 : /-- Check FLT exponent function correctness\n48 : \n49 :     Verify that the FLT exponent function correctly computes\n50 :     the maximum of (e - prec) and emin. This validates the\n51 :     IEEE 754-style exponent calculation.\n52 : -/\n53 : def FLT_exp_correct_check (e : Int) : Id Bool :=\n54 :   pure (FLT_exp prec emin e = max (e - prec) emin)\n55 : \n56 : /-- Specification: FLT exponent calculation\n57 : \n58 :     The FLT exponent function implements IEEE 754-style floating-point\n59 :     exponent calculation: it maintains precision by using e - prec\n60 :     when possible, but enforces a minimum exponent emin to prevent\n61 :     excessive underflow and maintain gradual underflow behavior.\n62 : -/\n63 : theorem FLT_exp_spec (e : Int) :\n64 :     ⦃⌜True⌝⦄\n65 :     FLT_exp_correct_check prec emin e\n66 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n67 :   sorry\n68 : \n69 : /-- Floating-point format predicate\n70 : \n71 :     A real number x is in FLT format if it can be represented\n72 :     using the generic format with the FLT exponent function.\n73 :     This gives IEEE 754-style floating-point representation\n74 :     with both precision and minimum exponent constraints.\n75 : -/\n76 : def FLT_format (beta : Int) (x : ℝ) : Id Prop :=\n77 :   pure (generic_format beta (FLT_exp prec emin) x)\n78 : \n79 : /-- Valid_exp instance for the FLT exponent function (placeholder). -/\n80 : instance FLT_exp_valid (beta : Int) :\n81 :     FloatSpec.Core.Generic_fmt.Valid_exp beta (FLT_exp prec emin) := by\n82 :   refine ⟨?_⟩\n83 :   intro k\n84 :   refine And.intro ?h1 ?h2\n85 :   · intro _\n86 :     -- Proof omitted for now\n87 :     sorry\n88 :   · intro _\n89 :     refine And.intro ?hA ?hB\n90 :     · -- Proof omitted for now\n91 :       sorry\n92 :     · intro _ _\n93 :       -- Proof omitted for now\n94 :       sorry\n95 : \n96 : /-- Specification: FLT format using generic format\n97 : \n98 :     The FLT format combines the benefits of fixed-precision\n99 :     (for normal numbers) with minimum exponent protection\n100:     (for subnormal numbers), matching IEEE 754 behavior.\n101: -/\n102: theorem FLT_format_spec (beta : Int) (x : ℝ) :\n103:     ⦃⌜True⌝⦄\n104:     FLT_format prec emin beta x\n105:     ⦃⇓result => ⌜result = (generic_format beta (FLT_exp prec emin) x)⌝⦄ := by\n106:   sorry\n107: \n108: /-- Specification: FLT exponent function correctness\n109: \n110:     The FLT exponent function correctly implements the IEEE 754\n111:     exponent selection logic, choosing between precision-based\n112:     and minimum-bounded exponents as appropriate.\n113: -/\n114: theorem FLT_exp_correct_spec (e : Int) :\n115:     ⦃⌜True⌝⦄\n116:     FLT_exp_correct_check prec emin e\n117:     ⦃⇓result => ⌜result = true⌝⦄ := by\n118:   sorry\n119: \n120: /-- Check if zero is in FLT format\n121: \n122:     Verify that zero is representable in the floating-point format.\n123:     Zero should always be representable as 0 × β^e for any\n124:     allowed exponent e, making it universal across FLT formats.\n125: -/\n126: def FLT_format_0_check (beta : Int) : Id Bool :=\n127:   pure true  -- Zero is always in format\n128: \n129: /-- Specification: Zero is in FLT format\n130: \n131:     Zero is always representable in FLT format since it can\n132:     be expressed as 0 × β^e for any exponent e, regardless\n133:     of precision or minimum exponent constraints.\n134: -/\n135: theorem FLT_format_0_spec (beta : Int) :\n136:     ⦃⌜beta > 1⌝⦄\n137:     FLT_format_0_check beta\n138:     ⦃⇓result => ⌜result = true⌝⦄ := by\n139:   sorry\n140: \n141: /-- Check closure under negation\n142: \n143:     Verify that if x is in FLT format, then -x is also in FLT format.\n144:     This tests the sign symmetry property of IEEE 754-style\n145:     floating-point representation.\n146: -/\n147: def FLT_format_opp_check (beta : Int) (x : ℝ) : Id Bool :=\n148:   pure true  -- Always true for FLT formats\n149: \n150: /-- Specification: FLT format closed under negation\n151: \n152:     FLT formats are closed under negation. If x = m × β^e\n153:     is representable, then -x = (-m) × β^e is also representable\n154:     using the same exponent and negated mantissa.\n155: -/\n156: theorem FLT_format_opp_spec (beta : Int) (x : ℝ) :\n157:     ⦃⌜(FLT_format prec emin beta x).run⌝⦄\n158:     FLT_format_opp_check beta x\n159:     ⦃⇓result => ⌜result = true⌝⦄ := by\n160:   sorry\n161: \n162: /-- Check closure under absolute value\n163: \n164:     Verify that if x is in FLT format, then |x| is also in FLT format.\n165:     This tests the magnitude preservation property, ensuring that\n166:     absolute values remain representable.\n167: -/\n168: def FLT_format_abs_check (beta : Int) (x : ℝ) : Id Bool :=\n169:   pure true  -- Always true for FLT formats\n170: \n171: /-- Specification: FLT format closed under absolute value\n172: \n173:     FLT formats are closed under absolute value operations.\n174:     The magnitude of a representable number is always\n175:     representable using the same exponent structure.\n176: -/\n177: theorem FLT_format_abs_spec (beta : Int) (x : ℝ) :\n178:     ⦃⌜(FLT_format prec emin beta x).run⌝⦄\n179:     FLT_format_abs_check beta x\n180:     ⦃⇓result => ⌜result = true⌝⦄ := by\n181:   sorry\n182: \n183: /-- Check relationship between FLT and FLX formats\n184: \n185:     When the minimum exponent constraint is not active\n186:     (i.e., emin ≤ e - prec), FLT behaves exactly like FLX.\n187:     This verifies the normal number behavior of IEEE 754.\n188: -/\n189: def FLT_exp_FLX_check (e : Int) : Id Bool :=\n190:   pure (emin ≤ e - prec → FLT_exp prec emin e = FLX.FLX_exp prec e)\n191: \n192: /-- Specification: FLT reduces to FLX for normal numbers\n193: \n194:     When the precision-based exponent e - prec exceeds emin,\n195:     FLT format behaves identically to FLX format. This captures\n196:     the normal number range of IEEE 754 floating-point.\n197: -/\n198: theorem FLT_exp_FLX_spec (e : Int) :\n199:     ⦃⌜emin ≤ e - prec⌝⦄\n200:     FLT_exp_FLX_check prec emin e\n201:     ⦃⇓result => ⌜result = true⌝⦄ := by\n202:   sorry\n203: \n204: /-\n205: Coq (FLT.v):\n206: Theorem generic_format_FLT :\n207:   forall x, FLT_format x -> generic_format beta FLT_exp x.\n208: -/\n209: theorem generic_format_FLT (beta : Int) (x : ℝ) :\n210:     ⦃⌜(FLT_format prec emin beta x).run⌝⦄\n211:     generic_format beta (FLT_exp prec emin) x\n212:     ⦃⇓result => ⌜result⌝⦄ := by\n213:   intro hx\n214:   simpa [FLT_format]\n215: \n216: /-\n217: Coq (FLT.v):\n218: Theorem FLT_format_generic :\n219:   forall x, generic_format beta FLT_exp x -> FLT_format x.\n220: -/\n221: theorem FLT_format_generic (beta : Int) (x : ℝ) :\n222:     ⦃⌜(generic_format beta (FLT_exp prec emin) x).run⌝⦄\n223:     FLT_format prec emin beta x\n224:     ⦃⇓result => ⌜result⌝⦄ := by\n225:   intro hx\n226:   simpa [FLT_format] using hx\n227: \n228: /-\n229: Coq (FLT.v):\n230: Theorem FLT_format_satisfies_any :\n231:   satisfies_any FLT_format.\n232: -/\n233: theorem FLT_format_satisfies_any (beta : Int) :\n234:     FloatSpec.Core.Generic_fmt.satisfies_any (fun y => (FLT_format prec emin beta y).run) := by\n235:   simpa [FLT_format]\n236:     using FloatSpec.Core.Generic_fmt.generic_format_satisfies_any (beta := beta) (fexp := FLT_exp prec emin)\n237: \n238: /-\n239: Coq (FLT.v):\n240: Theorem generic_format_FLT_bpow :\n241:   forall e, (emin <= e)%Z -> generic_format beta FLT_exp (bpow e).\n242: -/\n243: theorem generic_format_FLT_bpow (beta : Int) (e : Int) :\n244:     ⦃⌜emin ≤ e⌝⦄\n245:     generic_format beta (FLT_exp prec emin) ((beta : ℝ) ^ e)\n246:     ⦃⇓result => ⌜result⌝⦄ := by\n247:   intro _\n248:   sorry\n249: \n250: /-\n251: Coq (FLT.v):\n252: Theorem FLT_format_bpow :\n253:   forall e, (emin <= e)%Z -> FLT_format (bpow e).\n254: -/\n255: theorem FLT_format_bpow (beta : Int) (e : Int) :\n256:     ⦃⌜emin ≤ e⌝⦄\n257:     FLT_format prec emin beta ((beta : ℝ) ^ e)\n258:     ⦃⇓result => ⌜result⌝⦄ := by\n259:   intro _\n260:   sorry\n261: \n262: /-\n263: Coq (FLT.v):\n264: Theorem generic_format_FLT_FLX :\n265:   forall x : R,\n266:   (bpow (emin + prec - 1) <= Rabs x)%R ->\n267:   generic_format beta (FLX_exp prec) x ->\n268:   generic_format beta FLT_exp x.\n269: -/\n270: theorem generic_format_FLT_FLX (beta : Int) (x : ℝ) :\n271:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x| ∧ (generic_format beta (FLX.FLX_exp prec) x).run⌝⦄\n272:     generic_format beta (FLT_exp prec emin) x\n273:     ⦃⇓result => ⌜result⌝⦄ := by\n274:   intro _\n275:   sorry\n276: \n277: /-\n278: Coq (FLT.v):\n279: Theorem cexp_FLT_FLX :\n280:   forall x,\n281:   (bpow (emin + prec - 1) <= Rabs x)%R ->\n282:   cexp beta FLT_exp x = cexp beta (FLX_exp prec) x.\n283: -/\n284: theorem cexp_FLT_FLX (beta : Int) (x : ℝ) :\n285:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄\n286:     FloatSpec.Core.Generic_fmt.cexp beta (FLT_exp prec emin) x\n287:     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.cexp beta (FLX.FLX_exp prec) x).run⌝⦄ := by\n288:   intro _\n289:   sorry\n290: \n291: end FloatSpec.Core.FLT\n292: \n293: namespace FloatSpec.Core.FLT\n294: \n295: variable (prec emin : Int)\n296: \n297: /-\n298: Coq (FLT.v):\n299: Theorem generic_format_FIX_FLT :\n300:   forall x : R,\n301:   generic_format beta FLT_exp x ->\n302:   generic_format beta (FIX_exp emin) x.\n303: -/\n304: theorem generic_format_FIX_FLT (beta : Int) (x : ℝ) :\n305:     ⦃⌜(generic_format beta (FLT_exp prec emin) x).run⌝⦄\n306:     generic_format beta (FloatSpec.Core.FIX.FIX_exp (emin := emin)) x\n307:     ⦃⇓result => ⌜result⌝⦄ := by\n308:   intro _\n309:   sorry\n310: \n311: end FloatSpec.Core.FLT\n312: \n313: namespace FloatSpec.Core.FLT\n314: \n315: variable (prec emin : Int)\n316: \n317: /-\n318: Coq (FLT.v):\n319: Theorem generic_format_FLT_FIX :\n320:   forall x : R,\n321:   (Rabs x <= bpow (emin + prec))%R ->\n322:   generic_format beta (FIX_exp emin) x ->\n323:   generic_format beta FLT_exp x.\n324: -/\n325: theorem generic_format_FLT_FIX (beta : Int) (x : ℝ) :\n326:     ⦃⌜|x| ≤ (beta : ℝ) ^ (emin + prec) ∧ (generic_format beta (FloatSpec.Core.FIX.FIX_exp (emin := emin)) x).run⌝⦄\n327:     generic_format beta (FLT_exp prec emin) x\n328:     ⦃⇓result => ⌜result⌝⦄ := by\n329:   intro _\n330:   sorry\n331: \n332: end FloatSpec.Core.FLT\n333: \n334: namespace FloatSpec.Core.FLT\n335: \n336: variable (prec emin : Int)\n337: \n338: /-- Coq (FLT.v):\n339: Theorem ulp_FLT_0 : ulp beta FLT_exp 0 = bpow emin.\n340: \n341: Lean (spec): The ULP under FLT at 0 equals `β^emin`.\n342: -/\n343: theorem ulp_FLT_0 (beta : Int) :\n344:     ⦃⌜True⌝⦄\n345:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) 0\n346:     ⦃⇓r => ⌜r = (beta : ℝ) ^ emin⌝⦄ := by\n347:   sorry\n348: \n349: /-- Coq (FLT.v):\n350: Theorem ulp_FLT_small:\n351:   forall x, Rabs x < bpow (emin + prec) -> ulp beta FLT_exp x = bpow emin.\n352: \n353: Lean (spec): If |x| < β^(emin+prec), then ULP under FLT at x equals `β^emin`.\n354: -/\n355: theorem ulp_FLT_small (beta : Int) (x : ℝ) :\n356:     ⦃⌜|x| < (beta : ℝ) ^ (emin + prec)⌝⦄\n357:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n358:     ⦃⇓r => ⌜r = (beta : ℝ) ^ emin⌝⦄ := by\n359:   intro _\n360:   sorry\n361: \n362: /-\n363: Coq (FLT.v):\n364: Theorem cexp_FLT_FIX :\n365:   forall x, x <> 0%R ->\n366:   (Rabs x < bpow (emin + prec))%R ->\n367:   cexp beta FLT_exp x = cexp beta (FIX_exp emin) x.\n368: -/\n369: theorem cexp_FLT_FIX (beta : Int) (x : ℝ) :\n370:     ⦃⌜x ≠ 0 ∧ |x| < (beta : ℝ) ^ (emin + prec)⌝⦄\n371:     FloatSpec.Core.Generic_fmt.cexp beta (FLT_exp prec emin) x\n372:     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.cexp beta (FloatSpec.Core.FIX.FIX_exp (emin := emin)) x).run⌝⦄ := by\n373:   intro _\n374:   sorry\n375: \n376: end FloatSpec.Core.FLT\n377: \n378: namespace FloatSpec.Core.FLT\n379: \n380: variable (prec emin : Int)\n381: \n382: /-\n383: Coq (FLT.v):\n384: Theorem generic_format_FLT_1 :\n385:   (emin <= 0)%Z ->\n386:   generic_format beta FLT_exp 1.\n387: -/\n388: theorem generic_format_FLT_1 (beta : Int) :\n389:     ⦃⌜emin ≤ 0⌝⦄\n390:     generic_format beta (FLT_exp prec emin) 1\n391:     ⦃⇓result => ⌜result⌝⦄ := by\n392:   intro _\n393:   sorry\n394: \n395: end FloatSpec.Core.FLT\n396: \n397: namespace FloatSpec.Core.FLT\n398: \n399: variable (prec emin : Int)\n400: \n401: /-\n402: Coq (FLT.v):\n403: Theorem generic_format_FLX_FLT :\n404:   forall x : R,\n405:   generic_format beta FLT_exp x -> generic_format beta (FLX_exp prec) x.\n406: -/\n407: theorem generic_format_FLX_FLT (beta : Int) (x : ℝ) :\n408:     ⦃⌜(generic_format beta (FLT_exp prec emin) x).run⌝⦄\n409:     generic_format beta (FLX.FLX_exp prec) x\n410:     ⦃⇓result => ⌜result⌝⦄ := by\n411:   intro hx\n412:   sorry\n413: \n414: end FloatSpec.Core.FLT\n415: \n416: namespace FloatSpec.Core.FLT\n417: \n418: variable (prec emin : Int)\n419: \n420: /-\n421: Coq (FLT.v):\n422: Theorem ulp_FLT_le:\n423:   forall x, (bpow (emin + prec - 1) <= Rabs x)%R ->\n424:   (ulp beta FLT_exp x <= Rabs x * bpow (1 - prec))%R.\n425: -/\n426: theorem ulp_FLT_le (beta : Int) (x : ℝ) :\n427:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄\n428:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n429:     ⦃⇓r => ⌜r ≤ |x| * (beta : ℝ) ^ (1 - prec)⌝⦄ := by\n430:   intro _\n431:   sorry\n432: \n433: /-\n434: Coq (FLT.v):\n435: Theorem ulp_FLT_gt:\n436:   forall x, (Rabs x * bpow (-prec) < ulp beta FLT_exp x)%R.\n437: -/\n438: theorem ulp_FLT_gt (beta : Int) (x : ℝ) :\n439:     ⦃⌜True⌝⦄\n440:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n441:     ⦃⇓r => ⌜|x| * (beta : ℝ) ^ (-prec) < r⌝⦄ := by\n442:   intro _\n443:   sorry\n444: \n445: /-\n446: Coq (FLT.v):\n447: Lemma ulp_FLT_exact_shift:\n448:   forall x e,\n449:   (x <> 0)%R ->\n450:   (emin + prec <= mag beta x)%Z ->\n451:   (emin + prec - mag beta x <= e)%Z ->\n452:   (ulp beta FLT_exp (x * bpow e) = ulp beta FLT_exp x * bpow e)%R.\n453: -/\n454: theorem ulp_FLT_exact_shift (beta : Int) (x : ℝ) (e : Int) :\n455:     ⦃⌜x ≠ 0 ∧ emin + prec ≤ FloatSpec.Core.Generic_fmt.mag beta x ∧ emin + prec - FloatSpec.Core.Generic_fmt.mag beta x ≤ e⌝⦄\n456:     (do\n457:       let u1 ← FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) (x * (beta : ℝ) ^ e)\n458:       let u2 ← FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n459:       pure (u1, u2))\n460:     ⦃⇓p => ⌜p.1 = p.2 * (beta : ℝ) ^ e⌝⦄ := by\n461:   intro _\n462:   sorry\n463: \n464: end FloatSpec.Core.FLT\n465: \n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Defs\n20 : import FloatSpec.src.Core.Generic_fmt\n21 : import FloatSpec.src.Core.Round_generic\n22 : import FloatSpec.src.Core.Ulp\n23 : import FloatSpec.src.Core.FLX\n24 : import FloatSpec.src.Core.FIX\n25 : import Mathlib.Data.Real.Basic\n26 : import Std.Do.Triple\n27 : import Std.Tactic.Do\n28 : \n29 : open Real\n30 : open Std.Do\n31 : open FloatSpec.Core.Generic_fmt\n32 : open FloatSpec.Core.Round_generic\n33 : \n34 : namespace FloatSpec.Core.FLT\n35 : \n36 : variable (prec emin : Int)\n37 : \n38 : /-- Floating-point exponent function\n39 : \n40 :     The FLT exponent function combines fixed-precision behavior\n41 :     with a minimum exponent bound. It returns max(e - prec, emin),\n42 :     providing precision when possible but limiting underflow.\n43 : -/\n44 : def FLT_exp (e : Int) : Int :=\n45 :   max (e - prec) emin\n46 : \n47 : /-- Check FLT exponent function correctness\n48 : \n49 :     Verify that the FLT exponent function correctly computes\n50 :     the maximum of (e - prec) and emin. This validates the\n51 :     IEEE 754-style exponent calculation.\n52 : -/\n53 : def FLT_exp_correct_check (e : Int) : Id Bool :=\n54 :   pure (FLT_exp prec emin e = max (e - prec) emin)\n55 : \n56 : /-- Specification: FLT exponent calculation\n57 : \n58 :     The FLT exponent function implements IEEE 754-style floating-point\n59 :     exponent calculation: it maintains precision by using e - prec\n60 :     when possible, but enforces a minimum exponent emin to prevent\n61 :     excessive underflow and maintain gradual underflow behavior.\n62 : -/\n63 : theorem FLT_exp_spec (e : Int) :\n64 :     ⦃⌜True⌝⦄\n65 :     FLT_exp_correct_check prec emin e\n66 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n67 :   sorry\n68 : \n69 : /-- Floating-point format predicate\n70 : \n71 :     A real number x is in FLT format if it can be represented\n72 :     using the generic format with the FLT exponent function.\n73 :     This gives IEEE 754-style floating-point representation\n74 :     with both precision and minimum exponent constraints.\n75 : -/\n76 : def FLT_format (beta : Int) (x : ℝ) : Id Prop :=\n77 :   pure (generic_format beta (FLT_exp prec emin) x)\n78 : \n79 : /-- Valid_exp instance for the FLT exponent function (placeholder). -/\n80 : instance FLT_exp_valid (beta : Int) :\n81 :     FloatSpec.Core.Generic_fmt.Valid_exp beta (FLT_exp prec emin) := by\n82 :   refine ⟨?_⟩\n83 :   intro k\n84 :   refine And.intro ?h1 ?h2\n85 :   · intro _\n86 :     -- Proof omitted for now\n87 :     sorry\n88 :   · intro _\n89 :     refine And.intro ?hA ?hB\n90 :     · -- Proof omitted for now\n91 :       sorry\n92 :     · intro _ _\n93 :       -- Proof omitted for now\n94 :       sorry\n95 : \n96 : /-- Specification: FLT format using generic format\n97 : \n98 :     The FLT format combines the benefits of fixed-precision\n99 :     (for normal numbers) with minimum exponent protection\n100:     (for subnormal numbers), matching IEEE 754 behavior.\n101: -/\n102: theorem FLT_format_spec (beta : Int) (x : ℝ) :\n103:     ⦃⌜True⌝⦄\n104:     FLT_format prec emin beta x\n105:     ⦃⇓result => ⌜result = (generic_format beta (FLT_exp prec emin) x)⌝⦄ := by\n106:   sorry\n107: \n108: /-- Specification: FLT exponent function correctness\n109: \n110:     The FLT exponent function correctly implements the IEEE 754\n111:     exponent selection logic, choosing between precision-based\n112:     and minimum-bounded exponents as appropriate.\n113: -/\n114: theorem FLT_exp_correct_spec (e : Int) :\n115:     ⦃⌜True⌝⦄\n116:     FLT_exp_correct_check prec emin e\n117:     ⦃⇓result => ⌜result = true⌝⦄ := by\n118:   sorry\n119: \n120: /-- Check if zero is in FLT format\n121: \n122:     Verify that zero is representable in the floating-point format.\n123:     Zero should always be representable as 0 × β^e for any\n124:     allowed exponent e, making it universal across FLT formats.\n125: -/\n126: def FLT_format_0_check (beta : Int) : Id Bool :=\n127:   pure true  -- Zero is always in format\n128: \n129: /-- Specification: Zero is in FLT format\n130: \n131:     Zero is always representable in FLT format since it can\n132:     be expressed as 0 × β^e for any exponent e, regardless\n133:     of precision or minimum exponent constraints.\n134: -/\n135: theorem FLT_format_0_spec (beta : Int) :\n136:     ⦃⌜beta > 1⌝⦄\n137:     FLT_format_0_check beta\n138:     ⦃⇓result => ⌜result = true⌝⦄ := by\n139:   sorry\n140: \n141: /-- Check closure under negation\n142: \n143:     Verify that if x is in FLT format, then -x is also in FLT format.\n144:     This tests the sign symmetry property of IEEE 754-style\n145:     floating-point representation.\n146: -/\n147: def FLT_format_opp_check (beta : Int) (x : ℝ) : Id Bool :=\n148:   pure true  -- Always true for FLT formats\n149: \n150: /-- Specification: FLT format closed under negation\n151: \n152:     FLT formats are closed under negation. If x = m × β^e\n153:     is representable, then -x = (-m) × β^e is also representable\n154:     using the same exponent and negated mantissa.\n155: -/\n156: theorem FLT_format_opp_spec (beta : Int) (x : ℝ) :\n157:     ⦃⌜(FLT_format prec emin beta x).run⌝⦄\n158:     FLT_format_opp_check beta x\n159:     ⦃⇓result => ⌜result = true⌝⦄ := by\n160:   sorry\n161: \n162: /-- Check closure under absolute value\n163: \n164:     Verify that if x is in FLT format, then |x| is also in FLT format.\n165:     This tests the magnitude preservation property, ensuring that\n166:     absolute values remain representable.\n167: -/\n168: def FLT_format_abs_check (beta : Int) (x : ℝ) : Id Bool :=\n169:   pure true  -- Always true for FLT formats\n170: \n171: /-- Specification: FLT format closed under absolute value\n172: \n173:     FLT formats are closed under absolute value operations.\n174:     The magnitude of a representable number is always\n175:     representable using the same exponent structure.\n176: -/\n177: theorem FLT_format_abs_spec (beta : Int) (x : ℝ) :\n178:     ⦃⌜(FLT_format prec emin beta x).run⌝⦄\n179:     FLT_format_abs_check beta x\n180:     ⦃⇓result => ⌜result = true⌝⦄ := by\n181:   sorry\n182: \n183: /-- Check relationship between FLT and FLX formats\n184: \n185:     When the minimum exponent constraint is not active\n186:     (i.e., emin ≤ e - prec), FLT behaves exactly like FLX.\n187:     This verifies the normal number behavior of IEEE 754.\n188: -/\n189: def FLT_exp_FLX_check (e : Int) : Id Bool :=\n190:   pure (emin ≤ e - prec → FLT_exp prec emin e = FLX.FLX_exp prec e)\n191: \n192: /-- Specification: FLT reduces to FLX for normal numbers\n193: \n194:     When the precision-based exponent e - prec exceeds emin,\n195:     FLT format behaves identically to FLX format. This captures\n196:     the normal number range of IEEE 754 floating-point.\n197: -/\n198: theorem FLT_exp_FLX_spec (e : Int) :\n199:     ⦃⌜emin ≤ e - prec⌝⦄\n200:     FLT_exp_FLX_check prec emin e\n201:     ⦃⇓result => ⌜result = true⌝⦄ := by\n202:   sorry\n203: \n204: /-\n205: Coq (FLT.v):\n206: Theorem generic_format_FLT :\n207:   forall x, FLT_format x -> generic_format beta FLT_exp x.\n208: -/\n209: theorem generic_format_FLT (beta : Int) (x : ℝ) :\n210:     ⦃⌜(FLT_format prec emin beta x).run⌝⦄\n211:     generic_format beta (FLT_exp prec emin) x\n212:     ⦃⇓result => ⌜result⌝⦄ := by\n213:   intro hx\n214:   simpa [FLT_format]\n215: \n216: /-\n217: Coq (FLT.v):\n218: Theorem FLT_format_generic :\n219:   forall x, generic_format beta FLT_exp x -> FLT_format x.\n220: -/\n221: theorem FLT_format_generic (beta : Int) (x : ℝ) :\n222:     ⦃⌜(generic_format beta (FLT_exp prec emin) x).run⌝⦄\n223:     FLT_format prec emin beta x\n224:     ⦃⇓result => ⌜result⌝⦄ := by\n225:   intro hx\n226:   simpa [FLT_format] using hx\n227: \n228: /-\n229: Coq (FLT.v):\n230: Theorem FLT_format_satisfies_any :\n231:   satisfies_any FLT_format.\n232: -/\n233: theorem FLT_format_satisfies_any (beta : Int) :\n234:     FloatSpec.Core.Generic_fmt.satisfies_any (fun y => (FLT_format prec emin beta y).run) := by\n235:   simpa [FLT_format]\n236:     using FloatSpec.Core.Generic_fmt.generic_format_satisfies_any (beta := beta) (fexp := FLT_exp prec emin)\n237: \n238: /-\n239: Coq (FLT.v):\n240: Theorem generic_format_FLT_bpow :\n241:   forall e, (emin <= e)%Z -> generic_format beta FLT_exp (bpow e).\n242: -/\n243: theorem generic_format_FLT_bpow (beta : Int) (e : Int) :\n244:     ⦃⌜emin ≤ e⌝⦄\n245:     generic_format beta (FLT_exp prec emin) ((beta : ℝ) ^ e)\n246:     ⦃⇓result => ⌜result⌝⦄ := by\n247:   intro _\n248:   sorry\n249: \n250: /-\n251: Coq (FLT.v):\n252: Theorem FLT_format_bpow :\n253:   forall e, (emin <= e)%Z -> FLT_format (bpow e).\n254: -/\n255: theorem FLT_format_bpow (beta : Int) (e : Int) :\n256:     ⦃⌜emin ≤ e⌝⦄\n257:     FLT_format prec emin beta ((beta : ℝ) ^ e)\n258:     ⦃⇓result => ⌜result⌝⦄ := by\n259:   intro _\n260:   sorry\n261: \n262: /-\n263: Coq (FLT.v):\n264: Theorem generic_format_FLT_FLX :\n265:   forall x : R,\n266:   (bpow (emin + prec - 1) <= Rabs x)%R ->\n267:   generic_format beta (FLX_exp prec) x ->\n268:   generic_format beta FLT_exp x.\n269: -/\n270: theorem generic_format_FLT_FLX (beta : Int) (x : ℝ) :\n271:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x| ∧ (generic_format beta (FLX.FLX_exp prec) x).run⌝⦄\n272:     generic_format beta (FLT_exp prec emin) x\n273:     ⦃⇓result => ⌜result⌝⦄ := by\n274:   intro _\n275:   sorry\n276: \n277: /-\n278: Coq (FLT.v):\n279: Theorem cexp_FLT_FLX :\n280:   forall x,\n281:   (bpow (emin + prec - 1) <= Rabs x)%R ->\n282:   cexp beta FLT_exp x = cexp beta (FLX_exp prec) x.\n283: -/\n284: theorem cexp_FLT_FLX (beta : Int) (x : ℝ) :\n285:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄\n286:     FloatSpec.Core.Generic_fmt.cexp beta (FLT_exp prec emin) x\n287:     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.cexp beta (FLX.FLX_exp prec) x).run⌝⦄ := by\n288:   intro _\n289:   sorry\n290: \n291: end FloatSpec.Core.FLT\n292: \n293: namespace FloatSpec.Core.FLT\n294: \n295: variable (prec emin : Int)\n296: \n297: /-\n298: Coq (FLT.v):\n299: Theorem generic_format_FIX_FLT :\n300:   forall x : R,\n301:   generic_format beta FLT_exp x ->\n302:   generic_format beta (FIX_exp emin) x.\n303: -/\n304: theorem generic_format_FIX_FLT (beta : Int) (x : ℝ) :\n305:     ⦃⌜(generic_format beta (FLT_exp prec emin) x).run⌝⦄\n306:     generic_format beta (FloatSpec.Core.FIX.FIX_exp (emin := emin)) x\n307:     ⦃⇓result => ⌜result⌝⦄ := by\n308:   intro _\n309:   sorry\n310: \n311: end FloatSpec.Core.FLT\n312: \n313: namespace FloatSpec.Core.FLT\n314: \n315: variable (prec emin : Int)\n316: \n317: /-\n318: Coq (FLT.v):\n319: Theorem generic_format_FLT_FIX :\n320:   forall x : R,\n321:   (Rabs x <= bpow (emin + prec))%R ->\n322:   generic_format beta (FIX_exp emin) x ->\n323:   generic_format beta FLT_exp x.\n324: -/\n325: theorem generic_format_FLT_FIX (beta : Int) (x : ℝ) :\n326:     ⦃⌜|x| ≤ (beta : ℝ) ^ (emin + prec) ∧ (generic_format beta (FloatSpec.Core.FIX.FIX_exp (emin := emin)) x).run⌝⦄\n327:     generic_format beta (FLT_exp prec emin) x\n328:     ⦃⇓result => ⌜result⌝⦄ := by\n329:   intro _\n330:   sorry\n331: \n332: end FloatSpec.Core.FLT\n333: \n334: namespace FloatSpec.Core.FLT\n335: \n336: variable (prec emin : Int)\n337: \n338: /-- Coq (FLT.v):\n339: Theorem ulp_FLT_0 : ulp beta FLT_exp 0 = bpow emin.\n340: \n341: Lean (spec): The ULP under FLT at 0 equals `β^emin`.\n342: -/\n343: theorem ulp_FLT_0 (beta : Int) :\n344:     ⦃⌜True⌝⦄\n345:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) 0\n346:     ⦃⇓r => ⌜r = (beta : ℝ) ^ emin⌝⦄ := by\n347:   sorry\n348: \n349: /-- Coq (FLT.v):\n350: Theorem ulp_FLT_small:\n351:   forall x, Rabs x < bpow (emin + prec) -> ulp beta FLT_exp x = bpow emin.\n352: \n353: Lean (spec): If |x| < β^(emin+prec), then ULP under FLT at x equals `β^emin`.\n354: -/\n355: theorem ulp_FLT_small (beta : Int) (x : ℝ) :\n356:     ⦃⌜|x| < (beta : ℝ) ^ (emin + prec)⌝⦄\n357:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n358:     ⦃⇓r => ⌜r = (beta : ℝ) ^ emin⌝⦄ := by\n359:   intro _\n360:   sorry\n361: \n362: /-\n363: Coq (FLT.v):\n364: Theorem cexp_FLT_FIX :\n365:   forall x, x <> 0%R ->\n366:   (Rabs x < bpow (emin + prec))%R ->\n367:   cexp beta FLT_exp x = cexp beta (FIX_exp emin) x.\n368: -/\n369: theorem cexp_FLT_FIX (beta : Int) (x : ℝ) :\n370:     ⦃⌜x ≠ 0 ∧ |x| < (beta : ℝ) ^ (emin + prec)⌝⦄\n371:     FloatSpec.Core.Generic_fmt.cexp beta (FLT_exp prec emin) x\n372:     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.cexp beta (FloatSpec.Core.FIX.FIX_exp (emin := emin)) x).run⌝⦄ := by\n373:   intro _\n374:   sorry\n375: \n376: end FloatSpec.Core.FLT\n377: \n378: namespace FloatSpec.Core.FLT\n379: \n380: variable (prec emin : Int)\n381: \n382: /-\n383: Coq (FLT.v):\n384: Theorem generic_format_FLT_1 :\n385:   (emin <= 0)%Z ->\n386:   generic_format beta FLT_exp 1.\n387: -/\n388: theorem generic_format_FLT_1 (beta : Int) :\n389:     ⦃⌜emin ≤ 0⌝⦄\n390:     generic_format beta (FLT_exp prec emin) 1\n391:     ⦃⇓result => ⌜result⌝⦄ := by\n392:   intro _\n393:   sorry\n394: \n395: end FloatSpec.Core.FLT\n396: \n397: namespace FloatSpec.Core.FLT\n398: \n399: variable (prec emin : Int)\n400: \n401: /-\n402: Coq (FLT.v):\n403: Theorem generic_format_FLX_FLT :\n404:   forall x : R,\n405:   generic_format beta FLT_exp x -> generic_format beta (FLX_exp prec) x.\n406: -/\n407: theorem generic_format_FLX_FLT (beta : Int) (x : ℝ) :\n408:     ⦃⌜(generic_format beta (FLT_exp prec emin) x).run⌝⦄\n409:     generic_format beta (FLX.FLX_exp prec) x\n410:     ⦃⇓result => ⌜result⌝⦄ := by\n411:   intro hx\n412:   sorry\n413: \n414: end FloatSpec.Core.FLT\n415: \n416: namespace FloatSpec.Core.FLT\n417: \n418: variable (prec emin : Int)\n419: \n420: /-\n421: Coq (FLT.v):\n422: Theorem ulp_FLT_le:\n423:   forall x, (bpow (emin + prec - 1) <= Rabs x)%R ->\n424:   (ulp beta FLT_exp x <= Rabs x * bpow (1 - prec))%R.\n425: -/\n426: theorem ulp_FLT_le (beta : Int) (x : ℝ) :\n427:     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄\n428:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n429:     ⦃⇓r => ⌜r ≤ |x| * (beta : ℝ) ^ (1 - prec)⌝⦄ := by\n430:   intro _\n431:   sorry\n432: \n433: /-\n434: Coq (FLT.v):\n435: Theorem ulp_FLT_gt:\n436:   forall x, (Rabs x * bpow (-prec) < ulp beta FLT_exp x)%R.\n437: -/\n438: theorem ulp_FLT_gt (beta : Int) (x : ℝ) :\n439:     ⦃⌜True⌝⦄\n440:     FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n441:     ⦃⇓r => ⌜|x| * (beta : ℝ) ^ (-prec) < r⌝⦄ := by\n442:   intro _\n443:   sorry\n444: \n445: /-\n446: Coq (FLT.v):\n447: Lemma ulp_FLT_exact_shift:\n448:   forall x e,\n449:   (x <> 0)%R ->\n450:   (emin + prec <= mag beta x)%Z ->\n451:   (emin + prec - mag beta x <= e)%Z ->\n452:   (ulp beta FLT_exp (x * bpow e) = ulp beta FLT_exp x * bpow e)%R.\n453: -/\n454: theorem ulp_FLT_exact_shift (beta : Int) (x : ℝ) (e : Int) :\n455:     ⦃⌜x ≠ 0 ∧ emin + prec ≤ FloatSpec.Core.Generic_fmt.mag beta x ∧ emin + prec - FloatSpec.Core.Generic_fmt.mag beta x ≤ e⌝⦄\n456:     (do\n457:       let u1 ← FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) (x * (beta : ℝ) ^ e)\n458:       let u2 ← FloatSpec.Core.Ulp.ulp beta (FLT_exp prec emin) x\n459:       pure (u1, u2))\n460:     ⦃⇓p => ⌜p.1 = p.2 * (beta : ℝ) ^ e⌝⦄ := by\n461:   intro _\n462:   sorry\n463: \n464: end FloatSpec.Core.FLT\n465: \n"
  }
}
[2025-09-15T19:51:19] tokens used: 23769
[2025-09-15T19:51:31] codex

I’ll open the Coq FLT.v to mirror the missing theorem statements accurately.
[2025-09-15T19:51:32] exec bash -lc "sed -n '1,240p' /Users/louhantao/Desktop/code/semester_6.5/flocq/src/Core/FLT.v" in /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
[2025-09-15T19:51:33] bash -lc "sed -n '1,240p' /Users/louhantao/Desktop/code/semester_6.5/flocq/src/Core/FLT.v" succeeded in 321ms:
(**
This file is part of the Flocq formalization of floating-point
arithmetic in Coq: https://flocq.gitlabpages.inria.fr/

Copyright (C) 2009-2018 Sylvie Boldo
#<br />#
Copyright (C) 2009-2018 Guillaume Melquiond

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 3 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
COPYING file for more details.
*)

(** * Floating-point format with gradual underflow *)
[2025-09-15T19:51:33] tokens used: 30272
[2025-09-15T19:51:36] exec bash -lc "sed -n '240,560p' /Users/louhantao/Desktop/code/semester_6.5/flocq/src/Core/FLT.v" in /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
[2025-09-15T19:51:37] bash -lc "sed -n '240,560p' /Users/louhantao/Desktop/code/semester_6.5/flocq/src/Core/FLT.v" succeeded in 320ms:
intros x Hx.
rewrite Hx.
apply generic_format_F2R.
intros _.
rewrite <- Hx.
apply Z.le_max_r.
Qed.

Theorem generic_format_FLT_FIX :
  forall x : R,
  (Rabs x <= bpow (emin + prec))%R ->
  generic_format beta (FIX_exp emin) x ->
  generic_format beta FLT_exp x.
Proof with auto with typeclass_instances.
apply generic_inclusion_le...
intros e He.
unfold FIX_exp.
apply Z.max_lub.
lia.
apply Z.le_refl.
[2025-09-15T19:51:37] tokens used: 32582
[2025-09-15T19:51:40] exec bash -lc "sed -n '560,1120p' /Users/louhantao/Desktop/code/semester_6.5/flocq/src/Core/FLT.v" in /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
[2025-09-15T19:51:40] bash -lc "sed -n '560,1120p' /Users/louhantao/Desktop/code/semester_6.5/flocq/src/Core/FLT.v" succeeded in 319ms:

[2025-09-15T19:51:40] tokens used: 35442
[2025-09-15T19:51:49] codex

I’m going to open `Round_generic.lean` briefly to see the round function names to match specs.
[2025-09-15T19:51:51] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Round_generic.lean"})
[2025-09-15T19:51:51] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Round_generic.lean"}) success in 4ms:
{
  "content": [
    {
      "text": "1   : /-\n2   : This file is part of the Flocq formalization of floating-point\n3   : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4   : \n5   : Copyright (C) 2011-2018 Sylvie Boldo\n6   : Copyright (C) 2011-2018 Guillaume Melquiond\n7   : \n8   : This library is free software; you can redistribute it and/or\n9   : modify it under the terms of the GNU Lesser General Public\n10  : License as published by the Free Software Foundation; either\n11  : version 3 of the License, or (at your option) any later version.\n12  : \n13  : This library is distributed in the hope that it will be useful,\n14  : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15  : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16  : COPYING file for more details.\n17  : \n18  : Generic floating-point rounding and unverified properties\n19  : Based on flocq/src/Core/Generic_fmt.v\n20  : -/\n21  : \n22  : import FloatSpec.src.Core.Zaux\n23  : import FloatSpec.src.Core.Raux\n24  : import FloatSpec.src.Core.Defs\n25  : import FloatSpec.src.Core.Round_pred\n26  : import FloatSpec.src.Core.Float_prop\n27  : import FloatSpec.src.Core.Generic_fmt\n28  : import Mathlib.Data.Real.Basic\n29  : import Mathlib.Analysis.SpecialFunctions.Log.Basic\n30  : import Std.Do.Triple\n31  : import Std.Tactic.Do\n32  : \n33  : open Real\n34  : open Std.Do\n35  : open FloatSpec.Core.Defs\n36  : open FloatSpec.Core.Zaux\n37  : open FloatSpec.Core.Raux\n38  : open FloatSpec.Core.Generic_fmt\n39  : \n40  : -- No need to export round_to_generic since we're defining it here\n41  : \n42  : namespace FloatSpec.Core.Round_generic\n43  : \n44  : /-- Axiom: Local spacing bound near x (one-ULP gap)\n45  :     For the generic format viewed as a set F, if xdn and xup are respectively\n46  :     the round-down and round-up values of x in F, then their gap is at most\n47  :     (beta : ℝ)^(cexp x). This matches the standard spacing property and is\n48  :     consistent with Flocq's Generic_fmt spacing results. -/\n49  : axiom spacing_bound\n50  :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x xdn xup : ℝ) :\n51  :     let F := fun y => (generic_format beta fexp y).run\n52  :     Rnd_DN_pt F x xdn → Rnd_UP_pt F x xup →\n53  :     xup - xdn ≤ (beta : ℝ) ^ (cexp beta fexp x).run\n54  : \n55  : /-- Axiom: Reciprocal bound via magnitude\n56  :     For beta > 1 and x ≠ 0, the reciprocal of |x| is bounded by\n57  :     a power determined by the magnitude. -/\n58  : axiom recip_abs_x_le (beta : Int) (x : ℝ) :\n59  :     (1 < beta ∧ x ≠ 0) → 1 / abs x ≤ (beta : ℝ) ^ (1 - mag beta x)\n60  : \n61  : /-- Axiom: Existence of a half‑ULP approximation in the format -/\n62  : axiom exists_round_half_ulp\n63  :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n64  :     ∃ f, (generic_format beta fexp f).run ∧\n65  :       abs (f - x) ≤ (1/2) * (beta : ℝ) ^ (cexp beta fexp x).run\n66  : \n67  : /-- Axiom: Nonzero half‑ULP approximation when x ≠ 0 -/\n68  : axiom exists_round_half_ulp_nz\n69  :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) (hx : x ≠ 0) :\n70  :     ∃ f, (generic_format beta fexp f).run ∧ f ≠ 0 ∧\n71  :       abs (f - x) ≤ (1/2) * (beta : ℝ) ^ (cexp beta fexp x).run\n72  : \n73  : /-- Placeholder existence axiom: There exists a round-down value in the generic format.\n74  :     A constructive proof requires additional spacing/discreteness lemmas for the format.\n75  : -/\n76  : axiom round_DN_exists\n77  :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n78  :     ∃ f, (generic_format beta fexp f).run ∧\n79  :       FloatSpec.Core.Round_pred.Rnd_DN_pt (fun y => (generic_format beta fexp y).run) x f\n80  : \n81  : /-- Placeholder existence axiom: There exists a round-up value in the generic format.\n82  :     A constructive proof requires additional spacing/discreteness lemmas for the format.\n83  : -/\n84  : -- Helper: closure of generic format under negation (as a plain implication)\n85  : private theorem generic_format_neg_closed\n86  :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (y : ℝ)\n87  :     (hy : (generic_format beta fexp y).run) :\n88  :     (generic_format beta fexp (-y)).run :=\n89  :   (generic_format_opp beta fexp y) hy\n90  : \n91  : -- Transform a round-up point at -x into a round-down point at x, using negation closure\n92  : private theorem Rnd_UP_to_DN_via_neg\n93  :     (F : ℝ → Prop) (x f : ℝ)\n94  :     (Fneg : ∀ y, F y → F (-y))\n95  :     (hup : FloatSpec.Core.Round_pred.Rnd_UP_pt F (-x) f) :\n96  :     FloatSpec.Core.Round_pred.Rnd_DN_pt F x (-f) := by\n97  :   -- Unpack the round-up predicate at -x\n98  :   rcases hup with ⟨hfF, hle, hmin⟩\n99  :   -- Show membership after negation\n100 :   have hFneg : F (-f) := Fneg f hfF\n101 :   -- Order transforms: -x ≤ f ↔ -f ≤ x\n102 :   have hle' : -f ≤ x := by\n103 :     have : (-x) ≤ f := hle\n104 :     -- multiply both sides by -1\n105 :     simpa using (neg_le_neg this)\n106 :   -- Maximality for DN: any g ≤ x must be ≤ -f\n107 :   have hmax : ∀ g : ℝ, F g → g ≤ x → g ≤ -f := by\n108 :     intro g hgF hg_le\n109 :     -- Consider -g, which is in F by closure, and satisfies -x ≤ -g\n110 :     have hFneg_g : F (-g) := Fneg g hgF\n111 :     have hx_le : (-x) ≤ (-g) := by simpa using (neg_le_neg hg_le)\n112 :     -- Minimality of f for UP at -x gives f ≤ -g, hence g ≤ -f\n113 :     have hf_le : f ≤ -g := hmin (-g) hFneg_g hx_le\n114 :     simpa using (neg_le_neg hf_le)\n115 :   exact ⟨hFneg, hle', hmax⟩\n116 : \n117 : -- Existence of a round-up value from round-down existence via negation\n118 : theorem round_UP_exists\n119 :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n120 :     ∃ f, (generic_format beta fexp f).run ∧\n121 :       FloatSpec.Core.Round_pred.Rnd_UP_pt (fun y => (generic_format beta fexp y).run) x f := by\n122 :   -- Obtain DN existence for -x (assumed available) and transform\n123 :   rcases round_DN_exists beta fexp (-x) with ⟨fdn, hFdn, hdn⟩\n124 :   -- Turn it into UP existence for x via negation\n125 :   refine ⟨-fdn, ?_, ?_⟩\n126 :   · -- Format closure under negation\n127 :     exact generic_format_neg_closed beta fexp fdn hFdn\n128 :   · -- Use the transformation lemma specialized to the generic format predicate\n129 :     -- First, rewrite the DN predicate at -x into an UP predicate at x via negation\n130 :     -- We need the reverse transformation: DN at -x ⇒ UP at x\n131 :     -- This is symmetric to Rnd_UP_to_DN_via_neg by swapping roles of x and -x and negating\n132 :     -- Prove it directly here\n133 :     -- Unpack DN at -x\n134 :     rcases hdn with ⟨hF_fdn, hfdn_le, hmax⟩\n135 :     -- Show x ≤ -fdn\n136 :     have hx_le : x ≤ -fdn := by\n137 :       have : fdn ≤ -x := hfdn_le\n138 :       -- negate both sides\n139 :       simpa using (neg_le_neg this)\n140 :     -- Minimality for UP: any g with F g and x ≤ g must satisfy -fdn ≤ g\n141 :     have hmin : ∀ g : ℝ, (generic_format beta fexp g).run → x ≤ g → -fdn ≤ g := by\n142 :       intro g hFg hx_le_g\n143 :       -- Consider -g; DN at -x gives -g ≤ fdn\n144 :       have hF_neg_g : (generic_format beta fexp (-g)).run := generic_format_neg_closed beta fexp g hFg\n145 :       have h_le_for_dn : (-g) ≤ (-x) := by simpa using (neg_le_neg hx_le_g)\n146 :       have : (-g) ≤ fdn := hmax (-g) hF_neg_g h_le_for_dn\n147 :       -- Negate inequality to get -fdn ≤ g\n148 :       simpa using (neg_le_neg this)\n149 :     exact ⟨generic_format_neg_closed beta fexp fdn hFdn, hx_le, hmin⟩\n150 : \n151 : /-- Specification: Powers of beta in generic format\n152 : \n153 :     When fexp (e + 1) ≤ e, beta^e is in generic format.\n154 : -/\n155 : theorem generic_format_bpow\n156 :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (e : Int) :\n157 :     ⦃⌜beta > 1 ∧ fexp (e + 1) ≤ e⌝⦄\n158 :     generic_format beta fexp ((beta : ℝ) ^ e)\n159 :     ⦃⇓result => ⌜result⌝⦄ := by\n160 :   intro hpre\n161 :   rcases hpre with ⟨hβ, hle⟩\n162 :   -- Base positivity and nonzeroness facts\n163 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n164 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n165 :   have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n166 : \n167 :   -- Compute mag on a pure power: with our definition using ceil(log_/log), this evaluates to e\n168 :   have hmag_pow : mag beta ((beta : ℝ) ^ e) = e := by\n169 :     -- positivity and logs\n170 :     have hxpos : 0 < (beta : ℝ) ^ e := zpow_pos (by exact_mod_cast hbposℤ) _\n171 :     have hlt : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n172 :     -- show log β ≠ 0 via exp_log and β ≠ 1\n173 :     have hlogβ_ne : Real.log (beta : ℝ) ≠ 0 := by\n174 :       intro h0\n175 :       have hbpos' : 0 < (beta : ℝ) := hbposR\n176 :       have h0exp : Real.exp (Real.log (beta : ℝ)) = Real.exp 0 := congrArg Real.exp h0\n177 :       have : (beta : ℝ) = 1 := by simpa [Real.exp_log hbpos', Real.exp_zero] using h0exp\n178 :       have hβne1 : (beta : ℝ) ≠ 1 := by exact_mod_cast (ne_of_gt hβ)\n179 :       exact hβne1 this\n180 :     have hlog_zpow : Real.log ((beta : ℝ) ^ e) = (e : ℝ) * Real.log (beta : ℝ) := by\n181 :       simpa using Real.log_zpow hbposR _\n182 :     have hratio : Real.log ((beta : ℝ) ^ e) / Real.log (beta : ℝ) = (e : ℝ) := by\n183 :       have : ((e : ℝ) * Real.log (beta : ℝ)) / Real.log (beta : ℝ) = (e : ℝ) :=\n184 :         mul_div_cancel_right₀ (e : ℝ) hlogβ_ne\n185 :       simpa [hlog_zpow] using this\n186 :     have habs : abs ((beta : ℝ) ^ e) = (beta : ℝ) ^ e := by\n187 :       exact abs_of_nonneg (le_of_lt hxpos)\n188 :     -- expand definition of mag and evaluate ceil\n189 :     unfold mag\n190 :     have hxne : (beta : ℝ) ^ e ≠ 0 := ne_of_gt hxpos\n191 :     -- Reduce to ceil of a simplified ratio\n192 :     simp only [hxne, habs, hlog_zpow]\n193 :     have : ((e : ℝ) * Real.log (beta : ℝ)) / Real.log (beta : ℝ) = (e : ℝ) := by\n194 :       have : (Real.log (beta : ℝ) * (e : ℝ)) / Real.log (beta : ℝ) = (e : ℝ) :=\n195 :         mul_div_cancel_left₀ (e : ℝ) hlogβ_ne\n196 :       simpa [mul_comm] using this\n197 :     simpa [this, Int.ceil_intCast]\n198 : \n199 :   -- From the valid_exp structure and the bound at e+1, deduce fexp e ≤ e\n200 :   have hlt_e1 : fexp (e + 1) < (e + 1) := lt_of_le_of_lt hle (lt_add_of_pos_right _ Int.zero_lt_one)\n201 :   have hfe_le : fexp e ≤ e := by\n202 :     -- Use valid_exp_large' with k = e+1 and l = e to get fexp e < e+1\n203 :     have := FloatSpec.Core.Generic_fmt.valid_exp_large' (beta := beta) (fexp := fexp) (k := e + 1) (l := e) hlt_e1 (le_of_lt (lt_add_of_pos_right _ Int.zero_lt_one))\n204 :     exact Int.lt_add_one_iff.mp this\n205 : \n206 :   -- Unfold goal and carry out the algebra, mirroring generic_format_F2R with m = 1\n207 :   simp [generic_format, scaled_mantissa, cexp, F2R]\n208 :   -- Notation: cexp for x = β^e\n209 :   set c := fexp (mag beta ((beta : ℝ) ^ e)) with hc\n210 :   -- Use hmag_pow to rewrite c\n211 :   have hc' : c = fexp e := by simpa [hc, hmag_pow]\n212 :   -- With c ≤ e, we can express the scaled mantissa as an integer power\n213 :   have hcle : c ≤ e := by simpa [hc'] using hfe_le\n214 :   -- Key zpow identities\n215 :   have hinv : (beta : ℝ) ^ (-c) = ((beta : ℝ) ^ c)⁻¹ := zpow_neg _ _\n216 :   have hmul_pow : (beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹ = (beta : ℝ) ^ (e - c) := by\n217 :     rw [← hinv, ← zpow_add₀ hbne]\n218 :     simp [sub_eq_add_neg]\n219 :   have hpow_nonneg : 0 ≤ e - c := sub_nonneg.mpr hcle\n220 :   have hzpow_toNat : (beta : ℝ) ^ (e - c) = (beta : ℝ) ^ (Int.toNat (e - c)) := by\n221 :     rw [← Int.toNat_of_nonneg hpow_nonneg]\n222 :     exact zpow_ofNat _ _\n223 :   have hcast_pow : (beta : ℝ) ^ (Int.toNat (e - c)) = ((beta ^ (Int.toNat (e - c)) : Int) : ℝ) := by\n224 :     rw [← Int.cast_pow]\n225 : \n226 :   -- Finish by showing the reconstruction equality\n227 :   simp only [hc, hmag_pow]\n228 :   -- Goal now is: (Ztrunc ((β^e) * (β^c)⁻¹) : ℝ) * (β : ℝ) ^ c = (β : ℝ) ^ e\n229 :   -- Compute the truncation explicitly\n230 :   have htrunc : Ztrunc ((beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹) = beta ^ (Int.toNat (e - c)) := by\n231 :     calc\n232 :       Ztrunc ((beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹)\n233 :           = Ztrunc ((beta : ℝ) ^ (e - c)) := by rw [hmul_pow]\n234 :       _   = Ztrunc ((beta : ℝ) ^ (Int.toNat (e - c))) := by rw [hzpow_toNat]\n235 :       _   = Ztrunc (((beta ^ (Int.toNat (e - c)) : Int) : ℝ)) := by rw [hcast_pow]\n236 :       _   = beta ^ (Int.toNat (e - c)) := FloatSpec.Core.Generic_fmt.Ztrunc_intCast _\n237 : \n238 :   -- Power splitting lemma to reconstruct\n239 :   have hsplit : (beta : ℝ) ^ e = (beta : ℝ) ^ (e - c) * (beta : ℝ) ^ c := by\n240 :     rw [← zpow_add₀ hbne (e - c) c]\n241 :     simp [sub_add_cancel]\n242 : \n243 :   -- Conclude the equality (flip orientation to match calc direction)\n244 :   symm\n245 :   calc\n246 :     ((Ztrunc ((beta : ℝ) ^ e * ((beta : ℝ) ^ (fexp e))⁻¹) : Int) : ℝ) * (beta : ℝ) ^ (fexp e)\n247 :         = ((Ztrunc ((beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹) : Int) : ℝ) * (beta : ℝ) ^ c := by\n248 :               rw [hc']\n249 :     _   = ((beta ^ (Int.toNat (e - c)) : Int) : ℝ) * (beta : ℝ) ^ c := by rw [htrunc]\n250 :     _   = (beta : ℝ) ^ (e - c) * (beta : ℝ) ^ c := by\n251 :           -- rewrite Int power as real power for nonnegative exponent\n252 :           rw [hzpow_toNat, hcast_pow]\n253 :     _   = (beta : ℝ) ^ e := by rw [hsplit]\n254 : \n255 : /-- Specification: Alternative power condition\n256 : \n257 :     When fexp e ≤ e, beta^e is in generic format.\n258 : -/\n259 : theorem generic_format_bpow' (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (e : Int) :\n260 :     ⦃⌜beta > 1 ∧ fexp e ≤ e⌝⦄\n261 :     generic_format beta fexp ((beta : ℝ) ^ e)\n262 :     ⦃⇓result => ⌜result⌝⦄ := by\n263 :   intro hpre\n264 :   rcases hpre with ⟨hβ, hle⟩\n265 :   -- From Valid_exp, we can derive the required bound fexp (e+1) ≤ e\n266 :   -- by case-splitting on whether fexp e < e or e ≤ fexp e.\n267 :   have hpair := (Valid_exp.valid_exp (beta := beta) (fexp := fexp) e)\n268 :   by_cases hlt : fexp e < e\n269 :   · -- Large regime: directly get fexp (e+1) ≤ e\n270 :     have hbound : fexp (e + 1) ≤ e := (hpair.left) hlt\n271 :     -- Apply the power-in-format lemma with this bound\n272 :     exact (generic_format_bpow (beta := beta) (fexp := fexp) e) ⟨hβ, hbound⟩\n273 :   · -- Otherwise, we have e ≤ fexp e\n274 :     have hge : e ≤ fexp e := le_of_not_gt hlt\n275 :     -- Combined with the hypothesis fexp e ≤ e, we get equality\n276 :     have heq : fexp e = e := le_antisymm hle hge\n277 :     -- Small regime: get fexp (fexp e + 1) ≤ fexp e, then rewrite using heq\n278 :     have hsmall := (hpair.right) (by simpa [heq] using hge)\n279 :     have hbound' : fexp (e + 1) ≤ e := by\n280 :       simpa [heq, add_comm, add_left_comm, add_assoc] using hsmall.left\n281 :     -- Apply the power-in-format lemma with the derived bound\n282 :     exact (generic_format_bpow (beta := beta) (fexp := fexp) e) ⟨hβ, hbound'⟩\n283 : \n284 : /-- Specification: Scaled mantissa for generic format\n285 : \n286 :     For numbers in generic format, the scaled mantissa\n287 :     equals its truncation (i.e., it's already an integer).\n288 : -/\n289 : theorem scaled_mantissa_generic (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n290 :     ⦃⌜(generic_format beta fexp x).run⌝⦄\n291 :     scaled_mantissa beta fexp x\n292 :     ⦃⇓result => ⌜result = Ztrunc result⌝⦄ := by\n293 :   intro hx\n294 :   unfold scaled_mantissa cexp\n295 :   simp\n296 :   -- Turn the generic_format hypothesis into the reconstruction equality\n297 :   unfold generic_format at hx\n298 :   simp [scaled_mantissa, cexp, F2R] at hx\n299 :   -- Notation: e is the canonical exponent, m the scaled mantissa\n300 :   set e := fexp (mag beta x)\n301 :   set m := x * (beta : ℝ) ^ (-e) with hm\n302 :   have hx' : x = ((Ztrunc m : Int) : ℝ) * (beta : ℝ) ^ e := by simpa [e, m] using hx\n303 :   -- We need to prove: m = Ztrunc m (with coercion on the right)\n304 :   by_cases hpow : (beta : ℝ) ^ e = 0\n305 :   · -- Degenerate base power: then x = 0 and hence m = 0, so equality holds\n306 :     have hx0 : x = 0 := by simpa [hpow] using hx'\n307 :     have hm0 : m = 0 := by simp [m, hx0]\n308 :     simp [hx0, FloatSpec.Core.Generic_fmt.Ztrunc_zero]\n309 :   · -- Nonzero base power: cancel to show m equals its truncation\n310 :     have hpow_ne : (beta : ℝ) ^ e ≠ 0 := hpow\n311 :     -- Multiply the reconstruction by β^(-e) and simplify using hpow_ne\n312 :     have hmul := congrArg (fun t : ℝ => t * (beta : ℝ) ^ (-e)) hx'\n313 :     -- Left side becomes m; right side reduces to (Ztrunc m : ℝ)\n314 :     have hmain : m = (Ztrunc m : ℝ) := by\n315 :       simpa [m, mul_comm, mul_left_comm, mul_assoc, zpow_neg, hpow_ne]\n316 :         using hmul\n317 :     simpa [m] using hmain\n318 : \n319 : /-- Specification: Canonical exponent from bounds\n320 : \n321 :     When x is bounded by powers of beta, cexp(x) = fexp(ex).\n322 : -/\n323 : theorem cexp_fexp (beta : Int) (fexp : Int → Int) (x : ℝ) (ex : Int) :\n324 :     ⦃⌜beta > 1 ∧ (beta : ℝ) ^ (ex - 1) < abs x ∧ abs x ≤ (beta : ℝ) ^ ex⌝⦄\n325 :     cexp beta fexp x\n326 :     ⦃⇓result => ⌜result = fexp ex⌝⦄ := by\n327 :   intro h\n328 :   rcases h with ⟨hβ, hlow, hupp⟩\n329 :   -- It suffices to show mag beta x = ex\n330 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n331 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n332 :   have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n333 :   -- From the strict lower bound, |x| > 0 hence x ≠ 0\n334 :   have hxpos : 0 < abs x := lt_trans (zpow_pos (by exact_mod_cast hbposℤ) _) hlow\n335 :   have hx0 : x ≠ 0 := by\n336 :     have : abs x ≠ 0 := ne_of_gt hxpos\n337 :     exact fun hx => this (by simpa [hx, abs_zero])\n338 :   -- Unfold mag and set L = log(|x|)/log(beta)\n339 :   -- Prepare an explicit form for mag\n340 :   have hmageq : mag beta x = Int.ceil (Real.log (abs x) / Real.log (beta : ℝ)) := by\n341 :     unfold mag\n342 :     simp [hx0]\n343 :   set L : ℝ := Real.log (abs x) / Real.log (beta : ℝ) with hLdef\n344 :   -- Show Int.ceil L = ex by sandwiching L between ex-1 and ex\n345 :   -- Upper bound: L ≤ ex\n346 :   -- log β > 0 since 1 < β\n347 :   have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n348 :   have hlogβ_pos : 0 < Real.log (beta : ℝ) := by\n349 :     have : 0 < Real.log (beta : ℝ) ↔ 1 < (beta : ℝ) :=\n350 :       Real.log_pos_iff (x := (beta : ℝ)) (le_of_lt (by exact_mod_cast hbposℤ))\n351 :     exact this.mpr hb_gt1R\n352 :   have hlog_le : Real.log (abs x) ≤ Real.log ((beta : ℝ) ^ ex) :=\n353 :     Real.log_le_log hxpos hupp\n354 :   have hlog_zpow_ex : Real.log ((beta : ℝ) ^ ex) = (ex : ℝ) * Real.log (beta : ℝ) := by\n355 :     simpa using Real.log_zpow hbposR ex\n356 :   have hL_mul : L * Real.log (beta : ℝ) = Real.log (abs x) := by\n357 :     have hne : Real.log (beta : ℝ) ≠ 0 := ne_of_gt hlogβ_pos\n358 :     calc\n359 :       L * Real.log (beta : ℝ)\n360 :           = (Real.log (abs x) / Real.log (beta : ℝ)) * Real.log (beta : ℝ) := by simpa [hLdef]\n361 :       _   = Real.log (abs x) * Real.log (beta : ℝ) / Real.log (beta : ℝ) := by\n362 :             simpa [div_mul_eq_mul_div]\n363 :       _   = Real.log (abs x) := by\n364 :             simpa [hne] using (mul_div_cancel' (Real.log (abs x)) (Real.log (beta : ℝ)))\n365 :   have hL_le_ex : L ≤ (ex : ℝ) := by\n366 :     have hmul_le : L * Real.log (beta : ℝ) ≤ (ex : ℝ) * Real.log (beta : ℝ) := by\n367 :       simpa [hL_mul, hlog_zpow_ex] using hlog_le\n368 :     exact (le_of_mul_le_mul_right hmul_le hlogβ_pos)\n369 :   have hceil_le : Int.ceil L ≤ ex := Int.ceil_le.mpr hL_le_ex\n370 :   -- Lower bound: ex - 1 < L\n371 :   have hlog_lt : Real.log ((beta : ℝ) ^ (ex - 1)) < Real.log (abs x) :=\n372 :     Real.log_lt_log (zpow_pos (by exact_mod_cast hbposℤ) _) hlow\n373 :   have hlog_zpow_exm1 : Real.log ((beta : ℝ) ^ (ex - 1)) = (ex - 1 : ℝ) * Real.log (beta : ℝ) := by\n374 :     simpa using Real.log_zpow hbposR (ex - 1)\n375 :   have hexm1_lt_L : (ex - 1 : ℝ) < L := by\n376 :     have hmul_lt : (ex - 1 : ℝ) * Real.log (beta : ℝ) < L * Real.log (beta : ℝ) := by\n377 :       simpa [hL_mul, hlog_zpow_exm1] using hlog_lt\n378 :     exact (lt_of_mul_lt_mul_right hmul_lt (le_of_lt hlogβ_pos))\n379 :   -- Conclude Int.ceil L = ex: we already have Int.ceil L ≤ ex; prove the reverse\n380 :   have h_ex_le_ceil : ex ≤ Int.ceil L := by\n381 :     -- By contradiction: if ⌈L⌉ < ex then ⌈L⌉ ≤ ex-1, contradicting ex-1 < L\n382 :     by_contra hnot\n383 :     have hlt : Int.ceil L < ex := lt_of_not_ge hnot\n384 :     have hle_exm1 : Int.ceil L ≤ ex - 1 := by\n385 :       have : Int.ceil L < (ex - 1) + 1 := by simpa [Int.sub_add_cancel] using hlt\n386 :       exact Int.lt_add_one_iff.mp this\n387 :     have : L ≤ (ex - 1 : ℝ) := by\n388 :       simpa [Int.cast_sub, Int.cast_one] using (Int.ceil_le).mp hle_exm1\n389 :     exact (not_le_of_gt hexm1_lt_L) this\n390 :   have hceil_eq : Int.ceil L = ex := le_antisymm hceil_le h_ex_le_ceil\n391 :   -- Conclude by rewriting mag with hmageq and the established equality on the ceiling\n392 :   have hmag_eq_ex : mag beta x = ex := by\n393 :     rw [hmageq, hLdef, hceil_eq]\n394 :   unfold cexp\n395 :   simp [hmag_eq_ex]\n396 : \n397 : /-- Specification: Canonical exponent from positive bounds\n398 : \n399 :     When positive x is bounded by powers of beta, cexp(x) = fexp(ex).\n400 : -/\n401 : theorem cexp_fexp_pos (beta : Int) (fexp : Int → Int) (x : ℝ) (ex : Int) :\n402 :     ⦃⌜beta > 1 ∧ (beta : ℝ) ^ (ex - 1) < x ∧ x ≤ (beta : ℝ) ^ ex⌝⦄\n403 :     cexp beta fexp x\n404 :     ⦃⇓result => ⌜result = fexp ex⌝⦄ := by\n405 :   intro h\n406 :   rcases h with ⟨hβ, hlow, hupp⟩\n407 :   -- From beta > 1, powers are positive; with strict lower bound, x > 0\n408 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n409 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n410 :   have hxpos : 0 < x := lt_trans (zpow_pos (by exact_mod_cast hbposℤ) _) hlow\n411 :   have habs : abs x = x := abs_of_nonneg (le_of_lt hxpos)\n412 :   -- Reduce to the absolute-value version\n413 :   exact\n414 :     (cexp_fexp (beta := beta) (fexp := fexp) (x := x) (ex := ex))\n415 :       ⟨hβ, by simpa [habs] using hlow, by simpa [habs] using hupp⟩\n416 : \n417 : /-- Specification: Mantissa for small positive numbers\n418 : \n419 :     For small positive x bounded by beta^(ex-1) and beta^ex,\n420 :     where ex ≤ fexp(ex), the scaled mantissa is in (0,1).\n421 : -/\n422 : theorem mantissa_small_pos (beta : Int) (fexp : Int → Int) (x : ℝ) (ex : Int)\n423 :     (hx : (beta : ℝ) ^ (ex - 1) ≤ x ∧ x < (beta : ℝ) ^ ex)\n424 :     (he : ex ≤ fexp ex) (hβ : 1 < beta) :\n425 :     0 < x * (beta : ℝ) ^ (-(fexp ex)) ∧ x * (beta : ℝ) ^ (-(fexp ex)) < 1 := by\n426 :   -- Basic facts about the base\n427 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n428 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n429 :   have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n430 :   have hb_ge1 : (1 : ℝ) ≤ (beta : ℝ) := by\n431 :     have : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n432 :     exact this.le\n433 :   -- Split bounds on x\n434 :   rcases hx with ⟨hx_low, hx_high⟩\n435 :   -- x is positive since β^(ex-1) > 0\n436 :   have hpow_pos_exm1 : 0 < (beta : ℝ) ^ (ex - 1) := zpow_pos (by exact_mod_cast hbposℤ) _\n437 :   have hx_pos : 0 < x := lt_of_lt_of_le hpow_pos_exm1 hx_low\n438 :   -- Positivity of the scaling factor\n439 :   have hscale_pos : 0 < (beta : ℝ) ^ (-(fexp ex)) := zpow_pos (by exact_mod_cast hbposℤ) _\n440 :   -- Strict upper bound after scaling by a positive factor\n441 :   have hlt_scaled : x * (beta : ℝ) ^ (-(fexp ex)) <\n442 :       (beta : ℝ) ^ ex * (beta : ℝ) ^ (-(fexp ex)) := by\n443 :     exact (mul_lt_mul_of_pos_right hx_high hscale_pos)\n444 :   -- Collapse the right-hand side product using zpow addition\n445 :   -- A form of the product suitable for simp when inverses appear\n446 :   have hmul_inv : (beta : ℝ) ^ ex * ((beta : ℝ) ^ (fexp ex))⁻¹ = (beta : ℝ) ^ (ex - fexp ex) := by\n447 :     have hmul_pow : (beta : ℝ) ^ ex * (beta : ℝ) ^ (-(fexp ex)) = (beta : ℝ) ^ (ex - fexp ex) := by\n448 :       simpa using (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) hbne ex (fexp ex))\n449 :     simpa [zpow_neg] using hmul_pow\n450 :   have hlt_scaled' : x * (beta : ℝ) ^ (-(fexp ex)) < (beta : ℝ) ^ (ex - fexp ex) := by\n451 :     have h := (mul_lt_mul_of_pos_right hx_high hscale_pos)\n452 :     simpa [hmul_inv, zpow_neg] using h\n453 :   -- Show β^(ex - fexp ex) ≤ 1 using ex ≤ fexp ex and β > 1\n454 :   have hk_nonneg : 0 ≤ fexp ex - ex := sub_nonneg.mpr he\n455 :   -- Convert to Nat exponent on the positive side\n456 :   have hpos_mul : 0 < (beta : ℝ) ^ (fexp ex - ex) := zpow_pos (by exact_mod_cast hbposℤ) _\n457 :   -- Prove 1 ≤ β^(fexp ex - ex) by a small induction on Nat exponents\n458 :   have one_le_pow_nat : ∀ n : Nat, (1 : ℝ) ≤ (beta : ℝ) ^ n := by\n459 :     intro n\n460 :     induction n with\n461 :     | zero => simp\n462 :     | succ n ih =>\n463 :         have hpow_nonneg : 0 ≤ (beta : ℝ) ^ n :=\n464 :           pow_nonneg (le_of_lt (by exact_mod_cast hbposℤ)) n\n465 :         -- 1*1 ≤ (β^n)*β since 1 ≤ β^n and 1 ≤ β\n466 :         have : (1 : ℝ) * 1 ≤ (beta : ℝ) ^ n * (beta : ℝ) := by\n467 :           exact mul_le_mul ih hb_ge1 (by norm_num) hpow_nonneg\n468 :         simpa [pow_succ] using this\n469 :   -- Using Int.toNat to connect zpow with Nat pow on nonnegative exponent\n470 :   have hzpow_toNat : (beta : ℝ) ^ (fexp ex - ex) = (beta : ℝ) ^ (Int.toNat (fexp ex - ex)) := by\n471 :     simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (fexp ex - ex) hk_nonneg\n472 :   have hone_le : (1 : ℝ) ≤ (beta : ℝ) ^ (fexp ex - ex) := by\n473 :     -- rewrite to Nat power and apply the induction lemma\n474 :     simpa [hzpow_toNat] using one_le_pow_nat (Int.toNat (fexp ex - ex))\n475 :   -- From 1 ≤ β^(fexp ex - ex), deduce β^(ex - fexp ex) ≤ 1 by multiplying both sides\n476 :   have hle_one : (beta : ℝ) ^ (ex - fexp ex) ≤ 1 := by\n477 :     -- identity: β^(ex - fexp ex) * β^(fexp ex - ex) = 1\n478 :     have hmul_id : (beta : ℝ) ^ (ex - fexp ex) * (beta : ℝ) ^ (fexp ex - ex) = 1 := by\n479 :       have := (zpow_add₀ hbne (ex - fexp ex) (fexp ex - ex)).symm\n480 :       simpa [sub_add_cancel] using this\n481 :     -- Multiply both sides of 1 ≤ β^(fexp ex - ex) by the nonnegative factor β^(ex - fexp ex)\n482 :     have hfac_nonneg : 0 ≤ (beta : ℝ) ^ (ex - fexp ex) := le_of_lt (zpow_pos (by exact_mod_cast hbposℤ) _)\n483 :     have hmul_le := mul_le_mul_of_nonneg_left hone_le hfac_nonneg\n484 :     -- Now rewrite using hmul_id on the right and simplify the left\n485 :     -- Left: β^(ex - fexp ex) * 1 = β^(ex - fexp ex)\n486 :     -- Right: β^(ex - fexp ex) * β^(fexp ex - ex) = 1\n487 :     simpa [hmul_id, one_mul] using hmul_le\n488 :   -- Combine the strict inequality with the upper bound ≤ 1\n489 :   have hlt_one : x * (beta : ℝ) ^ (-(fexp ex)) < 1 := lt_of_lt_of_le hlt_scaled' hle_one\n490 :   -- Positivity of the scaled mantissa: product of positives\n491 :   have hpos_scaled : 0 < x * (beta : ℝ) ^ (-(fexp ex)) := mul_pos hx_pos hscale_pos\n492 :   exact ⟨hpos_scaled, hlt_one⟩\n493 : \n494 : /-- Specification: Scaled mantissa bound for small numbers\n495 : \n496 :     For small numbers with |x| < beta^ex where ex ≤ fexp(ex),\n497 :     the absolute value of scaled mantissa is less than 1.\n498 : -/\n499 : theorem scaled_mantissa_lt_1\n500 :     (beta : Int) (fexp : Int → Int) [FloatSpec.Core.Generic_fmt.Valid_exp beta fexp]\n501 :     (x : ℝ) (ex : Int)\n502 :     (hx : abs x < (beta : ℝ) ^ ex)\n503 :     (he : ex ≤ fexp ex)\n504 :     (hβ : 1 < beta) :\n505 :     abs (scaled_mantissa beta fexp x).run < 1 := by\n506 :   -- Case split on x = 0\n507 :   by_cases hx0 : x = 0\n508 :   · -- Trivial: scaled mantissa of 0 is 0\n509 :     simp [FloatSpec.Core.Generic_fmt.scaled_mantissa, FloatSpec.Core.Generic_fmt.cexp, hx0]\n510 :   · -- Nonzero case\n511 :     -- Base positivity\n512 :     have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n513 :     have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n514 :     have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n515 :     -- Show mag x ≤ ex from |x| < β^ex\n516 :     have hmag_le_ex : mag beta x ≤ ex := by\n517 :       -- Follow cexp_fexp upper-bound part\n518 :       have hxpos : 0 < abs x := abs_pos.mpr hx0\n519 :       have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n520 :       have hlogβ_pos : 0 < Real.log (beta : ℝ) := by\n521 :         have : 0 < Real.log (beta : ℝ) ↔ 1 < (beta : ℝ) :=\n522 :           Real.log_pos_iff (x := (beta : ℝ)) (le_of_lt (by exact_mod_cast hbposℤ))\n523 :         exact this.mpr hb_gt1R\n524 :       have hlog_le : Real.log (abs x) ≤ Real.log ((beta : ℝ) ^ ex) :=\n525 :         Real.log_le_log hxpos (le_of_lt hx)\n526 :       have hlog_zpow_ex : Real.log ((beta : ℝ) ^ ex) = (ex : ℝ) * Real.log (beta : ℝ) := by\n527 :         simpa using Real.log_zpow hbposR ex\n528 :       set L : ℝ := Real.log (abs x) / Real.log (beta : ℝ)\n529 :       have hL_mul : L * Real.log (beta : ℝ) = Real.log (abs x) := by\n530 :         have hne : Real.log (beta : ℝ) ≠ 0 := ne_of_gt hlogβ_pos\n531 :         calc\n532 :           L * Real.log (beta : ℝ)\n533 :               = (Real.log (abs x) / Real.log (beta : ℝ)) * Real.log (beta : ℝ) := by rfl\n534 :           _   = Real.log (abs x) := by simpa [hne] using (mul_div_cancel' (Real.log (abs x)) (Real.log (beta : ℝ)))\n535 :       have hL_le_ex : L ≤ (ex : ℝ) := by\n536 :         have hmul_le : L * Real.log (beta : ℝ) ≤ (ex : ℝ) * Real.log (beta : ℝ) := by\n537 :           simpa [hL_mul, hlog_zpow_ex] using hlog_le\n538 :         exact (le_of_mul_le_mul_right hmul_le hlogβ_pos)\n539 :       have hceil_le : Int.ceil L ≤ ex := Int.ceil_le.mpr hL_le_ex\n540 :       have hmageq : mag beta x = Int.ceil L := by\n541 :         unfold FloatSpec.Core.Generic_fmt.mag\n542 :         simp [hx0, L]\n543 :       simpa [hmageq]\n544 :     -- Small-regime constancy: mag x ≤ ex ≤ fexp ex ⇒ fexp (mag x) = fexp ex\n545 :     have hconst := (FloatSpec.Core.Generic_fmt.Valid_exp.valid_exp (beta := beta) (fexp := fexp) ex).right he |>.right\n546 :     have heq_fexp : fexp (mag beta x) = fexp ex := hconst (mag beta x) (le_trans hmag_le_ex he)\n547 :     -- Now rewrite scaled mantissa using fexp ex\n548 :     have hpos_scale : 0 < (beta : ℝ) ^ (-(fexp ex)) := zpow_pos (by exact_mod_cast hbposℤ) _\n549 :     have hnonneg_scale : 0 ≤ (beta : ℝ) ^ (-(fexp ex)) := le_of_lt hpos_scale\n550 :     have h1sm : (scaled_mantissa beta fexp x).run = x * (beta : ℝ) ^ (-(fexp ex)) := by\n551 :       unfold FloatSpec.Core.Generic_fmt.scaled_mantissa FloatSpec.Core.Generic_fmt.cexp\n552 :       simp [heq_fexp]\n553 :     have hsm_abs : abs (scaled_mantissa beta fexp x).run = abs x * (beta : ℝ) ^ (-(fexp ex)) := by\n554 :       rw [h1sm, abs_mul, abs_of_nonneg hnonneg_scale]\n555 :     -- Multiply the strict bound by a positive factor\n556 :     have hmul_lt : abs x * (beta : ℝ) ^ (-(fexp ex)) < (beta : ℝ) ^ ex * (beta : ℝ) ^ (-(fexp ex)) :=\n557 :       mul_lt_mul_of_pos_right hx hpos_scale\n558 :     -- Combine exponents and bound by 1 using ex ≤ fexp ex\n559 :     have hmul_pow : (beta : ℝ) ^ ex * (beta : ℝ) ^ (-(fexp ex)) = (beta : ℝ) ^ (ex - fexp ex) := by\n560 :       simpa [sub_eq_add_neg] using (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) (hbne := hbne) (e := ex) (c := fexp ex))\n561 :     have hk_nonneg : 0 ≤ fexp ex - ex := sub_nonneg.mpr he\n562 :     -- For β ≥ 1, 1 ≤ β^(fexp ex - ex)\n563 :     have hone_le : (1 : ℝ) ≤ (beta : ℝ) ^ (fexp ex - ex) := by\n564 :       -- rewrite to Nat power and apply induction\n565 :       have hzpow_toNat : (beta : ℝ) ^ (fexp ex - ex) = (beta : ℝ) ^ (Int.toNat (fexp ex - ex)) := by\n566 :         simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (fexp ex - ex) hk_nonneg\n567 :       have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n568 :       have hb_ge1 : (1 : ℝ) ≤ (beta : ℝ) := hb_gt1R.le\n569 :       -- 1 ≤ β^n for all n\n570 :       have one_le_pow_nat : ∀ n : Nat, (1 : ℝ) ≤ (beta : ℝ) ^ n := by\n571 :         intro n; induction n with\n572 :         | zero => simp\n573 :         | succ n ih =>\n574 :             have hpow_nonneg : 0 ≤ (beta : ℝ) ^ n := pow_nonneg (le_of_lt (by exact_mod_cast hbposℤ)) n\n575 :             have : (1 : ℝ) * 1 ≤ (beta : ℝ) ^ n * (beta : ℝ) := mul_le_mul ih hb_ge1 (by norm_num) hpow_nonneg\n576 :             simpa [pow_succ] using this\n577 :       simpa [hzpow_toNat] using one_le_pow_nat (Int.toNat (fexp ex - ex))\n578 :     -- Multiply both sides by β^(ex - fexp ex) ≥ 0 to bound by 1\n579 :     have hfac_nonneg : 0 ≤ (beta : ℝ) ^ (ex - fexp ex) := le_of_lt (zpow_pos (by exact_mod_cast hbposℤ) _)\n580 :     have hle_one : (beta : ℝ) ^ (ex - fexp ex) ≤ 1 := by\n581 :       have hid : (beta : ℝ) ^ (ex - fexp ex) * (beta : ℝ) ^ (fexp ex - ex) = 1 := by\n582 :         simpa [sub_eq_add_neg, add_comm, add_left_comm, add_assoc] using (zpow_add₀ hbne (ex - fexp ex) (fexp ex - ex)).symm\n583 :       have hmul_le := mul_le_mul_of_nonneg_left hone_le hfac_nonneg\n584 :       simpa [hid, one_mul] using hmul_le\n585 :     -- Conclude\n586 :     have hmul_inv_pow : (beta : ℝ) ^ ex * ((beta : ℝ) ^ (fexp ex))⁻¹ = (beta : ℝ) ^ (ex - fexp ex) := by\n587 :       simpa [zpow_neg] using hmul_pow\n588 :     have : abs (scaled_mantissa beta fexp x).run < (beta : ℝ) ^ (ex - fexp ex) := by\n589 :       simpa [hsm_abs, hmul_inv_pow] using hmul_lt\n590 :     exact lt_of_lt_of_le this hle_one\n591 : \n592 : /-- Specification: Scaled mantissa general bound\n593 : \n594 :     The absolute value of scaled mantissa is bounded by\n595 :     beta^(mag(x) - cexp(x)).\n596 : -/\n597 : theorem scaled_mantissa_lt_bpow\n598 :     (beta : Int) (fexp : Int → Int) (x : ℝ)\n599 :     (hβ : 1 < beta) :\n600 :     abs (scaled_mantissa beta fexp x).run ≤ (beta : ℝ) ^ (mag beta x - (cexp beta fexp x).run) := by\n601 :   -- Base positivity for the real base\n602 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n603 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n604 :   have hbneR : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n605 :   -- Notation\n606 :   set e : Int := mag beta x\n607 :   set c : Int := (cexp beta fexp x).run\n608 :   -- Scaled mantissa as a product\n609 :   have hsm : (scaled_mantissa beta fexp x).run = x * (beta : ℝ) ^ (-c) := by\n610 :     unfold FloatSpec.Core.Generic_fmt.scaled_mantissa FloatSpec.Core.Generic_fmt.cexp\n611 :     rfl\n612 :   -- Positivity of the scaling factor\n613 :   have hscale_pos : 0 < (beta : ℝ) ^ (-c) := zpow_pos hbposR _\n614 :   have hscale_nonneg : 0 ≤ (beta : ℝ) ^ (-c) := le_of_lt hscale_pos\n615 :   -- Bound abs x by β^e\n616 :   have h_upper_abs : abs x ≤ (beta : ℝ) ^ e := by\n617 :     by_cases hx0 : x = 0\n618 :     · have : 0 ≤ (beta : ℝ) ^ e := le_of_lt (zpow_pos hbposR _)\n619 :       simpa [hx0, abs_zero] using this\n620 :     · have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n621 :       have hlogβ_pos : 0 < Real.log (beta : ℝ) :=\n622 :         (Real.log_pos_iff (x := (beta : ℝ)) (le_of_lt hbposR)).mpr hb_gt1R\n623 :       have hxpos : 0 < abs x := abs_pos.mpr hx0\n624 :       set L : ℝ := Real.log (abs x) / Real.log (beta : ℝ)\n625 :       have hmageq : e = Int.ceil L := by\n626 :         have : mag beta x = Int.ceil L := by\n627 :           unfold FloatSpec.Core.Generic_fmt.mag\n628 :           simp [hx0, L]\n629 :         simpa [e] using this\n630 :       have hceil_ge : (L : ℝ) ≤ (Int.ceil L : ℝ) := by exact_mod_cast Int.le_ceil L\n631 :       have hmul_le : L * Real.log (beta : ℝ) ≤ (Int.ceil L : ℝ) * Real.log (beta : ℝ) :=\n632 :         mul_le_mul_of_nonneg_right hceil_ge (le_of_lt hlogβ_pos)\n633 :       have hL_mul : L * Real.log (beta : ℝ) = Real.log (abs x) := by\n634 :         have hne : Real.log (beta : ℝ) ≠ 0 := ne_of_gt hlogβ_pos\n635 :         calc\n636 :           L * Real.log (beta : ℝ)\n637 :               = (Real.log (abs x) / Real.log (beta : ℝ)) * Real.log (beta : ℝ) := by rfl\n638 :           _   = Real.log (abs x) := by simpa [hne] using (mul_div_cancel' (Real.log (abs x)) (Real.log (beta : ℝ)))\n639 :       -- Relate log(β^e) to e * log β\n640 :       have hlog_zpow_e : Real.log ((beta : ℝ) ^ e) = (e : ℝ) * Real.log (beta : ℝ) := by\n641 :         simpa using Real.log_zpow hbposR e\n642 :       -- Get the desired log inequality in the form log |x| ≤ log(β^e)\n643 :       have hlog_le : Real.log (abs x) ≤ Real.log ((beta : ℝ) ^ e) := by\n644 :         have : Real.log (abs x) ≤ (e : ℝ) * Real.log (beta : ℝ) := by\n645 :           simpa [hL_mul, hmageq] using hmul_le\n646 :         simpa [hlog_zpow_e] using this\n647 :       -- convert back via exp monotonicity\n648 :       have hxpos' : 0 < abs x := hxpos\n649 :       -- Move to exponentials, rewriting to `exp (e * log β)` to avoid simp changing forms later\n650 :       have h_exp_le : abs x ≤ Real.exp ((e : ℝ) * Real.log (beta : ℝ)) := by\n651 :         have := (Real.log_le_iff_le_exp hxpos').1 hlog_le\n652 :         simpa [hlog_zpow_e] using this\n653 :       -- Show `exp (e * log β) = β^e` and conclude\n654 :       have hypos : 0 < (beta : ℝ) ^ e := zpow_pos hbposR _\n655 :       have h_exp_eq_pow : Real.exp ((e : ℝ) * Real.log (beta : ℝ)) = (beta : ℝ) ^ e := by\n656 :         have : Real.exp (Real.log ((beta : ℝ) ^ e)) = (beta : ℝ) ^ e := Real.exp_log hypos\n657 :         simpa [hlog_zpow_e] using this\n658 :       exact by simpa [h_exp_eq_pow]\n659 :         using h_exp_le\n660 :   -- Multiply by the positive scaling factor and collapse the RHS product\n661 :   have habs_pow : abs ((beta : ℝ) ^ (-c)) = (beta : ℝ) ^ (-c) := abs_of_nonneg hscale_nonneg\n662 :   have habs_scaled_tmp : abs (scaled_mantissa beta fexp x).run = abs (x * (beta : ℝ) ^ (-c)) := by\n663 :     simpa [hsm]\n664 :   -- Rewrite |β^(-c)| as |β^c|⁻¹ and then drop abs using nonnegativity of β^c\n665 :   have hpow_c_pos : 0 < (beta : ℝ) ^ c := zpow_pos hbposR _\n666 :   have hpow_c_nonneg : 0 ≤ (beta : ℝ) ^ c := le_of_lt hpow_c_pos\n667 :   have hscale_inv_nonneg : 0 ≤ ((beta : ℝ) ^ c)⁻¹ := inv_nonneg.mpr (le_of_lt hpow_c_pos)\n668 :   have habs_scaled : abs (scaled_mantissa beta fexp x).run = abs x * ((beta : ℝ) ^ c)⁻¹ := by\n669 :     -- |x * β^(-c)| = |x| * |β^(-c)| = |x| * |(β^c)⁻¹| = |x| * |β^c|⁻¹\n670 :     -- and since β^c ≥ 0, |β^c| = β^c\n671 :     have : abs (scaled_mantissa beta fexp x).run = abs x * (abs ((beta : ℝ) ^ c))⁻¹ := by\n672 :       simpa [abs_mul, zpow_neg] using habs_scaled_tmp\n673 :     simpa [abs_of_nonneg hpow_c_nonneg] using this\n674 :   have hmul : (beta : ℝ) ^ e * (beta : ℝ) ^ (-c) = (beta : ℝ) ^ (e - c) := by\n675 :     simpa [sub_eq_add_neg]\n676 :       using (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) (hbne := hbneR) (e := e) (c := c))\n677 :   -- Combine the pieces and collapse the RHS product\n678 :   calc\n679 :     abs (scaled_mantissa beta fexp x).run\n680 :         = abs x * ((beta : ℝ) ^ c)⁻¹ := habs_scaled\n681 :     _   ≤ (beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹ := mul_le_mul_of_nonneg_right h_upper_abs hscale_inv_nonneg\n682 :     _   = (beta : ℝ) ^ (e - c) := by\n683 :           simpa [zpow_neg] using\n684 :             (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) (hbne := hbneR) (e := e) (c := c))\n685 : \n686 : /-- Specification: Generic format is closed under rounding down\n687 : \n688 :     For any x, there exists a value f in generic format\n689 :     that is the rounding down of x.\n690 : -/\n691 : theorem generic_format_round_DN (beta : Int) (hbeta : 1 < beta) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n692 :     ∃ f, (generic_format beta fexp f).run ∧ Rnd_DN_pt (fun y => (generic_format beta fexp y).run) x f := by\n693 :   -- Derive DN existence for x from UP existence for -x via negation\n694 :   have hFneg : ∀ y, (generic_format beta fexp y).run → (generic_format beta fexp (-y)).run :=\n695 :     generic_format_neg_closed beta fexp\n696 :   -- Use the UP existence at -x\n697 :   rcases round_UP_exists (beta := beta) (fexp := fexp) (-x) with ⟨fu, hFu, hup⟩\n698 :   -- Transform to DN at x with f = -fu\n699 :   refine ⟨-fu, ?_, ?_⟩\n700 :   · exact hFneg fu hFu\n701 :   · -- Apply the transformation lemma\n702 :     exact Rnd_UP_to_DN_via_neg (F := fun y => (generic_format beta fexp y).run) (x := x) (f := fu)\n703 :       hFneg hup\n704 : \n705 : /-- Specification: Generic format is closed under rounding up\n706 : \n707 :     For any x, there exists a value f in generic format\n708 :     that is the rounding up of x.\n709 : -/\n710 : theorem generic_format_round_UP (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n711 :     ∃ f, (generic_format beta fexp f).run ∧ Rnd_UP_pt (fun y => (generic_format beta fexp y).run) x f := by\n712 :   -- Use the (temporary) existence axiom to obtain a witness.\n713 :   exact round_UP_exists beta fexp x\n714 : \n715 : /-- Specification: Precision bounds for generic format\n716 : \n717 :     For non-zero x in generic format, the scaled mantissa\n718 :     is bounded by beta^(mag(x) - cexp(x)).\n719 : -/\n720 : theorem generic_format_precision_bound\n721 :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp]\n722 :     (x : ℝ) (h : (generic_format beta fexp x).run) (hx : x ≠ 0)\n723 :     (hβ : 1 < beta) :\n724 :     abs (scaled_mantissa beta fexp x).run ≤ (beta : ℝ) ^ (mag beta x - (cexp beta fexp x).run) := by\n725 :   -- Use the general bound for scaled mantissa\n726 :   exact scaled_mantissa_lt_bpow (beta := beta) (fexp := fexp) (x := x) hβ\n727 : \n728 : /-- Specification: Exponent monotonicity\n729 : \n730 :     The exponent function is monotone.\n731 : -/\n732 : theorem fexp_monotone (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] :\n733 :     ∀ e1 e2 : Int, e1 ≤ e2 → e2 ≤ fexp e2 → fexp e1 ≤ fexp e2 := by\n734 :   -- Monotonicity holds on the \"small\" regime plateau by constancy\n735 :   intro e1 e2 hle hsmall\n736 :   -- From small-regime constancy at k = e2, any l ≤ fexp e2 has the same fexp\n737 :   have hpair := (FloatSpec.Core.Generic_fmt.Valid_exp.valid_exp (beta := beta) (fexp := fexp) e2)\n738 :   have hconst := (hpair.right hsmall).right\n739 :   -- Since e1 ≤ e2 ≤ fexp e2, we get fexp e1 = fexp e2 in particular\n740 :   have : fexp e1 = fexp e2 := by\n741 :     have : e1 ≤ fexp e2 := le_trans hle hsmall\n742 :     simpa using hconst e1 this\n743 :   simpa [this]\n744 : \n745 : /-- Specification: Format equivalence under exponent bounds\n746 : \n747 :     If x is in format with constant exponent e1,\n748 :     and e1 ≤ e2, then x is in format with exponent e2.\n749 : -/\n750 : theorem generic_format_equiv (beta : Int) (x : ℝ) (e1 e2 : Int) :\n751 :     ⦃⌜1 < beta ∧ e2 ≤ e1 ∧ (generic_format beta (fun _ => e1) x).run⌝⦄\n752 :     generic_format beta (fun _ => e2) x\n753 :     ⦃⇓result => ⌜result⌝⦄ := by\n754 :   intro h\n755 :   rcases h with ⟨hβ, hle, hx_fmt⟩\n756 :   -- Base positivity and nonzeroness for zpow lemmas\n757 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n758 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n759 :   have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n760 :   -- Unpack the format equality at exponent e1\n761 :   have hx : x = ((Ztrunc (x * (beta : ℝ) ^ (-(e1))) : Int) : ℝ) * (beta : ℝ) ^ e1 := by\n762 :     simpa [generic_format, scaled_mantissa, cexp, F2R] using hx_fmt\n763 :   -- Target goal after unfolding the generic_format at exponent e2\n764 :   -- will be an equality; we set up the necessary arithmetic\n765 :   simp only [generic_format, scaled_mantissa, cexp, F2R]\n766 :   -- Notations\n767 :   set m1 : Int := Ztrunc (x * (beta : ℝ) ^ (-(e1))) with hm1\n768 :   have hx' : x = (m1 : ℝ) * (beta : ℝ) ^ e1 := by simpa [hm1] using hx\n769 :   -- Let k = e1 - e2 ≥ 0\n770 :   set k : Int := e1 - e2\n771 :   have hk_nonneg : 0 ≤ k := sub_nonneg.mpr hle\n772 :   -- Combine powers: β^e1 * β^(-e2) = β^(e1 - e2)\n773 :   have hmul_pow : (beta : ℝ) ^ e1 * ((beta : ℝ) ^ e2)⁻¹ = (beta : ℝ) ^ (e1 - e2) := by\n774 :     simpa [zpow_neg] using\n775 :       (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) (hbne := hbne) (e := e1) (c := e2))\n776 :   -- Express β^(e1 - e2) with a Nat exponent\n777 :   have hzpow_toNat : (beta : ℝ) ^ (e1 - e2) = (beta : ℝ) ^ (Int.toNat (e1 - e2)) := by\n778 :     simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (e1 - e2) hk_nonneg\n779 :   -- Cast Int power to real power\n780 :   have hcast_pow : (beta : ℝ) ^ (Int.toNat (e1 - e2)) = ((beta ^ (Int.toNat (e1 - e2)) : Int) : ℝ) := by\n781 :     rw [← Int.cast_pow]\n782 :   -- Compute the truncation at exponent e2\n783 :   have htrunc :\n784 :       Ztrunc (x * (beta : ℝ) ^ (-(e2))) = m1 * beta ^ (Int.toNat (e1 - e2)) := by\n785 :     calc\n786 :       Ztrunc (x * (beta : ℝ) ^ (-(e2)))\n787 :           = Ztrunc (((m1 : ℝ) * (beta : ℝ) ^ e1) * (beta : ℝ) ^ (-(e2))) := by\n788 :                 simpa [hx']\n789 :       _   = Ztrunc ((m1 : ℝ) * ((beta : ℝ) ^ e1 * (beta : ℝ) ^ (-(e2)))) := by ring_nf\n790 :       _   = Ztrunc ((m1 : ℝ) * ((beta : ℝ) ^ (e1 - e2))) := by\n791 :                 simpa [hmul_pow]\n792 :       _   = Ztrunc ((m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (e1 - e2)))) := by\n793 :                 simpa [hzpow_toNat]\n794 :       _   = Ztrunc (((m1 * beta ^ (Int.toNat (e1 - e2))) : Int) : ℝ) := by\n795 :                 -- Avoid deep simp recursion: rewrite the inside once, then fold\n796 :                 have hmulcast :\n797 :                     (m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (e1 - e2)))\n798 :                       = (((m1 * beta ^ (Int.toNat (e1 - e2))) : Int) : ℝ) := by\n799 :                   simp only [hcast_pow, Int.cast_mul]\n800 :                 simpa only [hmulcast]\n801 :       _   = m1 * beta ^ (Int.toNat (e1 - e2)) := FloatSpec.Core.Generic_fmt.Ztrunc_intCast _\n802 :   -- Split power to reconstruct x at exponent e2\n803 :   have hsplit : (beta : ℝ) ^ e1 = (beta : ℝ) ^ (e1 - e2) * (beta : ℝ) ^ e2 := by\n804 :     -- zpow_sub_add states (a^(e-c))*a^c = a^e; flip orientation\n805 :     simpa using (FloatSpec.Core.Generic_fmt.zpow_sub_add (a := (beta : ℝ)) (hbne := hbne) (e := e1) (c := e2)).symm\n806 :   -- Finish: rebuild x directly in the required orientation\n807 :   -- Goal after simp is: x = ((Ztrunc (x * β^(-e2)) : ℝ)) * β^e2\n808 :   -- We derive the right-hand side from the representation at e1\n809 :   calc\n810 :     x = (m1 : ℝ) * (beta : ℝ) ^ e1 := by simpa [hx']\n811 :     _ = (m1 : ℝ) * ((beta : ℝ) ^ (e1 - e2) * (beta : ℝ) ^ e2) := by\n812 :           rw [hsplit]\n813 :     _ = ((m1 : ℝ) * (beta : ℝ) ^ (e1 - e2)) * (beta : ℝ) ^ e2 := by ring\n814 :     _ = ((m1 : ℝ) * (beta : ℝ) ^ (Int.toNat (e1 - e2))) * (beta : ℝ) ^ e2 := by\n815 :           rw [hzpow_toNat]\n816 :     _ = (((m1 * beta ^ (Int.toNat (e1 - e2))) : Int) : ℝ) * (beta : ℝ) ^ e2 := by\n817 :           -- cast the integer product back to ℝ without triggering heavy simp recursion\n818 :           have : ((m1 * beta ^ (Int.toNat (e1 - e2)) : Int) : ℝ)\n819 :                     = (m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (e1 - e2))) := by\n820 :             calc\n821 :               ((m1 * beta ^ (Int.toNat (e1 - e2)) : Int) : ℝ)\n822 :                   = ((m1 : Int) : ℝ) * ((beta ^ (Int.toNat (e1 - e2)) : Int) : ℝ) := by\n823 :                         simp [Int.cast_mul]\n824 :               _   = (m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (e1 - e2))) := by\n825 :                         rw [hcast_pow]\n826 :           rw [this]\n827 :     _ = ((Ztrunc (x * (beta : ℝ) ^ (-(e2))) : Int) : ℝ) * (beta : ℝ) ^ e2 := by\n828 :           -- rewrite back using the computed truncation at e2\n829 :           have hZ' : ((m1 * beta ^ (Int.toNat (e1 - e2)) : Int) : ℝ)\n830 :                         = ((Ztrunc (x * (beta : ℝ) ^ (-(e2))) : Int) : ℝ) := by\n831 :             -- cast both sides of htrunc to ℝ (in reverse orientation)\n832 :             exact (congrArg (fun z : Int => (z : ℝ)) htrunc).symm\n833 :           -- replace the casted integer with the Ztrunc expression\n834 :           rw [hZ']\n835 : \n836 : /-- Generic format from rounding -/\n837 : noncomputable def round_to_generic (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (mode : ℝ → ℝ → Prop) (x : ℝ) : ℝ :=\n838 :   -- Return the rounded value in generic format\n839 :   -- This would use classical choice to select a value satisfying the rounding mode\n840 :   let exp := (cexp beta fexp x).run\n841 :   let mantissa := x * (beta : ℝ) ^ (-exp)\n842 :   let rounded_mantissa := Ztrunc mantissa  -- Simple truncation for now\n843 :   (rounded_mantissa : ℝ) * (beta : ℝ) ^ exp\n844 : \n845 : /-- Specification: Round to generic is well-defined\n846 : \n847 :     The result of rounding to generic format is always\n848 :     in the generic format.\n849 : -/\n850 : theorem round_to_generic_spec (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (mode : ℝ → ℝ → Prop) (x : ℝ) :\n851 :     ⦃⌜True⌝⦄\n852 :     (pure (round_to_generic beta fexp mode x) : Id ℝ)\n853 :     ⦃⇓result => ⌜result = (F2R (FlocqFloat.mk (Ztrunc (x * (beta : ℝ) ^ (-(cexp beta fexp x).run))) (cexp beta fexp x).run : FlocqFloat beta)).run⌝⦄ := by\n854 :   intro _\n855 :   -- Unfold the rounding function; this is a direct reconstruction\n856 :   unfold round_to_generic\n857 :   simp [F2R]\n858 : \n859 : /-- Specification: Intersection is a generic format\n860 : \n861 :     The intersection of two generic formats can be\n862 :     represented as another generic format.\n863 : -/\n864 : theorem generic_format_inter_valid (beta : Int) (fexp1 fexp2 : Int → Int)\n865 :     [Valid_exp beta fexp1] [Valid_exp beta fexp2]\n866 :     (hβ : 1 < beta) :\n867 :     ∃ fexp3, ∀ x, generic_format_inter beta fexp1 fexp2 x → (generic_format beta fexp3 x).run := by\n868 :   -- We can realize the intersection inside a single generic format by\n869 :   -- choosing the pointwise minimum exponent function.\n870 :   refine ⟨(fun k => min (fexp1 k) (fexp2 k)), ?_⟩\n871 :   intro x hx\n872 :   rcases hx with ⟨hx1, hx2⟩\n873 :   -- Let c1, c2 be the canonical exponents for each format, and c3 their min.\n874 :   set c1 : Int := fexp1 (mag beta x)\n875 :   set c2 : Int := fexp2 (mag beta x)\n876 :   set c3 : Int := min c1 c2\n877 :   -- Denote the integer mantissas provided by each format\n878 :   have hx1' : x = ((Ztrunc (x * (beta : ℝ) ^ (-(c1))) : Int) : ℝ) * (beta : ℝ) ^ c1 := by\n879 :     simpa [generic_format, scaled_mantissa, cexp, F2R, c1] using hx1\n880 :   have hx2' : x = ((Ztrunc (x * (beta : ℝ) ^ (-(c2))) : Int) : ℝ) * (beta : ℝ) ^ c2 := by\n881 :     simpa [generic_format, scaled_mantissa, cexp, F2R, c2] using hx2\n882 :   -- Take m1 from the first representation; since c3 ≤ c1, we can reconstruct at c3\n883 :   set m1 : Int := Ztrunc (x * (beta : ℝ) ^ (-(c1))) with hm1\n884 :   have hc3_le_c1 : c3 ≤ c1 := by simpa [c3] using (min_le_left c1 c2)\n885 :   -- Base positivity for zpow identities\n886 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n887 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n888 :   have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n889 :   -- Combine the powers: β^c1 * β^(-c3) = β^(c1 - c3)\n890 :   have hmul_pow : (beta : ℝ) ^ c1 * (beta : ℝ) ^ (-(c3)) = (beta : ℝ) ^ (c1 - c3) := by\n891 :     simpa [sub_eq_add_neg] using (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) (hbne := hbne) (e := c1) (c := c3))\n892 :   -- Nonnegativity of the exponent difference\n893 :   have hdiff_nonneg : 0 ≤ c1 - c3 := sub_nonneg.mpr hc3_le_c1\n894 :   -- Convert to Nat power on nonnegative exponents\n895 :   have hzpow_toNat : (beta : ℝ) ^ (c1 - c3) = (beta : ℝ) ^ (Int.toNat (c1 - c3)) := by\n896 :     simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (c1 - c3) hdiff_nonneg\n897 :   -- Cast Int power to real power of Int\n898 :   have hcast_pow : (beta : ℝ) ^ (Int.toNat (c1 - c3)) = ((beta ^ (Int.toNat (c1 - c3)) : Int) : ℝ) := by\n899 :     rw [← Int.cast_pow]\n900 :   -- Compute the truncation at exponent c3 using the c1-representation\n901 :   have htrunc_c3 :\n902 :       Ztrunc (x * (beta : ℝ) ^ (-(c3))) = m1 * beta ^ (Int.toNat (c1 - c3)) := by\n903 :     -- First, rewrite the argument using the c1-representation of x without heavy simp\n904 :     have hx_mul := congrArg (fun t : ℝ => t * (beta : ℝ) ^ (-(c3))) hx1'\n905 :     have hx_mul' : x * (beta : ℝ) ^ (-(c3)) = ((m1 : ℝ) * (beta : ℝ) ^ c1) * (beta : ℝ) ^ (-(c3)) := by\n906 :       simpa [hm1, mul_comm, mul_left_comm, mul_assoc] using hx_mul\n907 :     have hZeq : Ztrunc (x * (beta : ℝ) ^ (-(c3)))\n908 :                 = Ztrunc (((m1 : ℝ) * (beta : ℝ) ^ c1) * (beta : ℝ) ^ (-(c3))) :=\n909 :       congrArg Ztrunc hx_mul'\n910 :     calc\n911 :       Ztrunc (x * (beta : ℝ) ^ (-(c3)))\n912 :           = Ztrunc (((m1 : ℝ) * (beta : ℝ) ^ c1) * (beta : ℝ) ^ (-(c3))) := hZeq\n913 :       _   = Ztrunc ((m1 : ℝ) * ((beta : ℝ) ^ c1 * (beta : ℝ) ^ (-(c3)))) := by ring_nf\n914 :       _   = Ztrunc ((m1 : ℝ) * ((beta : ℝ) ^ (c1 - c3))) := by\n915 :                 -- Apply the zpow product identity inside Ztrunc\n916 :                 simpa [zpow_neg]\n917 :                   using congrArg (fun t => Ztrunc ((m1 : ℝ) * t)) hmul_pow\n918 :       _   = Ztrunc ((m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (c1 - c3)))) := by\n919 :                 simpa [hzpow_toNat]\n920 :       _   = Ztrunc (((m1 * beta ^ (Int.toNat (c1 - c3))) : Int) : ℝ) := by\n921 :                 -- Avoid deep simp recursion: rewrite the inside once, then fold\n922 :                 have hmulcast :\n923 :                     (m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (c1 - c3)))\n924 :                       = (((m1 * beta ^ (Int.toNat (c1 - c3))) : Int) : ℝ) := by\n925 :                   simp only [hcast_pow, Int.cast_mul]\n926 :                 simpa only [hmulcast]\n927 :       _   = m1 * beta ^ (Int.toNat (c1 - c3)) := FloatSpec.Core.Generic_fmt.Ztrunc_intCast _\n928 :   -- Split the power to reconstruct x at exponent c3\n929 :   have hsplit : (beta : ℝ) ^ c1 = (beta : ℝ) ^ (c1 - c3) * (beta : ℝ) ^ c3 := by\n930 :     simpa [sub_add_cancel] using\n931 :       (FloatSpec.Core.Generic_fmt.zpow_sub_add (a := (beta : ℝ)) (hbne := hbne) (e := c1) (c := c3)).symm\n932 :   -- Conclude the generic_format for fexp3 at x\n933 :   -- Unfold target generic_format with fexp3 = min fexp1 fexp2, so exponent is c3\n934 :   -- Build the required reconstruction equality and finish by unfolding generic_format\n935 :   have hrecon : x = ((Ztrunc (x * (beta : ℝ) ^ (-(c3))) : Int) : ℝ) * (beta : ℝ) ^ c3 := by\n936 :     calc\n937 :       x = (m1 : ℝ) * (beta : ℝ) ^ c1 := by simpa [hm1] using hx1'\n938 :       _ = (m1 : ℝ) * ((beta : ℝ) ^ (c1 - c3) * (beta : ℝ) ^ c3) := by rw [hsplit]\n939 :       _ = ((m1 : ℝ) * (beta : ℝ) ^ (c1 - c3)) * (beta : ℝ) ^ c3 := by ring\n940 :       _ = ((m1 : ℝ) * (beta : ℝ) ^ (Int.toNat (c1 - c3))) * (beta : ℝ) ^ c3 := by\n941 :             simpa [hzpow_toNat]\n942 :       _ = (((m1 * beta ^ (Int.toNat (c1 - c3))) : Int) : ℝ) * (beta : ℝ) ^ c3 := by\n943 :             -- cast the integer product back to ℝ without triggering heavy simp recursion\n944 :             have : ((m1 * beta ^ (Int.toNat (c1 - c3)) : Int) : ℝ)\n945 :                       = (m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (c1 - c3))) := by\n946 :               calc\n947 :                 ((m1 * beta ^ (Int.toNat (c1 - c3)) : Int) : ℝ)\n948 :                     = ((m1 : Int) : ℝ) * ((beta ^ (Int.toNat (c1 - c3)) : Int) : ℝ) := by\n949 :                           simp [Int.cast_mul]\n950 :                 _   = (m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (c1 - c3))) := by\n951 :                           rw [hcast_pow]\n952 :             rw [this]\n953 :       _ = ((Ztrunc (x * (beta : ℝ) ^ (-(c3))) : Int) : ℝ) * (beta : ℝ) ^ c3 := by\n954 :             -- rewrite back using the computed truncation at c3\n955 :             have hZ' : ((m1 * beta ^ (Int.toNat (c1 - c3)) : Int) : ℝ)\n956 :                           = ((Ztrunc (x * (beta : ℝ) ^ (-(c3))) : Int) : ℝ) := by\n957 :               -- cast both sides of htrunc_c3 to ℝ (in reverse orientation)\n958 :               exact (congrArg (fun z : Int => (z : ℝ)) htrunc_c3).symm\n959 :             -- replace the casted integer with the Ztrunc expression\n960 :             rw [hZ']\n961 :   -- Conclude generic_format by unfolding\n962 :   have : (generic_format beta (fun k => min (fexp1 k) (fexp2 k)) x).run := by\n963 :     -- Make the canonical exponent explicit: it equals c3 by definition\n964 :     have hcexp_min : (cexp beta (fun k => min (fexp1 k) (fexp2 k)) x).run = c3 := by\n965 :       simp [FloatSpec.Core.Generic_fmt.cexp, c1, c2, c3]\n966 :     -- Now unfold and rewrite to the reconstruction equality\n967 :     simp only [generic_format, scaled_mantissa, cexp, F2R, hcexp_min]\n968 :     -- Goal reduces exactly to the reconstruction equality\n969 :     simpa using hrecon\n970 :   simpa using this\n971 : \n972 : /-- Specification: Magnitude is compatible with generic format\n973 : \n974 :     For non-zero x in generic format, the exponent function\n975 :     satisfies fexp(mag(x) + 1) ≤ mag(x).\n976 : -/\n977 : theorem mag_generic_format (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp]\n978 :     (x : ℝ) (h : (generic_format beta fexp x).run) (hx : x ≠ 0)\n979 :     (hβ : 1 < beta) :\n980 :     fexp (mag beta x + 1) ≤ mag beta x := by\n981 :   -- Notations\n982 :   set k : Int := mag beta x\n983 :   set e : Int := fexp k\n984 :   -- Base positivity facts\n985 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n986 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n987 :   have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n988 :   have hb_ge1 : (1 : ℝ) ≤ (beta : ℝ) := hb_gt1R.le\n989 :   -- Scaled mantissa is integer-valued for numbers in format\n990 :   have hsm_int := (scaled_mantissa_generic (beta := beta) (fexp := fexp) (x := x)) h\n991 :   set mR : ℝ := (scaled_mantissa beta fexp x).run\n992 :   have hmR_eq : mR = (Ztrunc mR : Int) := by simpa [mR] using hsm_int\n993 :   -- Reconstruction equality: x = (Ztrunc mR) * β^e\n994 :   have hx_recon : x = ((Ztrunc mR : Int) : ℝ) * (beta : ℝ) ^ e := by\n995 :     have hfmt := h\n996 :     -- Note: (scaled_mantissa beta fexp x).run = x * β^(-e) by definition of e, k\n997 :     simpa [generic_format, scaled_mantissa, FloatSpec.Core.Generic_fmt.cexp, F2R, k, e, mR] using hfmt\n998 :   -- mR ≠ 0, otherwise x would be 0\n999 :   have hmR_ne : mR ≠ 0 := by\n1000:     intro h0\n1001:     have : Ztrunc mR = 0 := by simpa [h0, FloatSpec.Core.Generic_fmt.Ztrunc_zero] using congrArg Ztrunc h0\n1002:     have : x = 0 := by simpa [this] using hx_recon\n1003:     exact hx this\n1004:   -- From hmR_eq and hmR_ne, |mR| ≥ 1\n1005:   have h_abs_mR_ge1 : (1 : ℝ) ≤ abs mR := by\n1006:     -- mR equals an integer z ≠ 0\n1007:     set z : Int := Ztrunc mR\n1008:     have hmR_eq' : mR = (z : ℝ) := by simpa [z] using hmR_eq\n1009:     have hz_ne : z ≠ 0 := by\n1010:       intro hz\n1011:       exact hmR_ne (by simpa [hmR_eq', hz])\n1012:     -- case analysis on sign of z\n1013:     by_cases hz_nonneg : 0 ≤ z\n1014:     · -- z ≥ 0 and z ≠ 0 ⇒ 1 ≤ z\n1015:       have hz_pos : 0 < z := lt_of_le_of_ne hz_nonneg (by simpa [eq_comm] using hz_ne)\n1016:       have hz_one_le : (1 : Int) ≤ z := (Int.add_one_le_iff).mpr hz_pos\n1017:       have hz_one_leR : (1 : ℝ) ≤ (z : ℝ) := by exact_mod_cast hz_one_le\n1018:       have habs : abs mR = (z : ℝ) := by simpa [hmR_eq', abs_of_nonneg (by exact_mod_cast hz_nonneg)]\n1019:       simpa [habs]\n1020:     · -- z ≤ 0 and z ≠ 0 ⇒ 1 ≤ -z\n1021:       have hz_le : z ≤ 0 := le_of_not_ge hz_nonneg\n1022:       have hz_lt : z < 0 := lt_of_le_of_ne hz_le (by simpa [hz_ne])\n1023:       have hpos_negz : 0 < -z := Int.neg_pos.mpr hz_lt\n1024:       have hone_le_negz : (1 : Int) ≤ -z := (Int.add_one_le_iff).mpr hpos_negz\n1025:       have hone_le_negzR : (1 : ℝ) ≤ (-z : ℝ) := by exact_mod_cast hone_le_negz\n1026:       have habs : abs mR = (-z : ℝ) := by\n1027:         have hzleR : (z : ℝ) ≤ 0 := by exact_mod_cast hz_le\n1028:         have : abs mR = abs (z : ℝ) := by simpa [hmR_eq']\n1029:         simpa [this, abs_of_nonpos hzleR]\n1030:       simpa [habs] using hone_le_negzR\n1031:   -- General bound: |mR| ≤ β^(k - e)\n1032:   have h_abs_mR_le : abs mR ≤ (beta : ℝ) ^ (k - e) := by\n1033:     -- scaled_mantissa_lt_bpow with hβ, then unfold mR, k, e\n1034:     have := scaled_mantissa_lt_bpow (beta := beta) (fexp := fexp) (x := x) hβ\n1035:     simpa [mR, k, e, FloatSpec.Core.Generic_fmt.cexp] using this\n1036:   -- Hence 1 ≤ β^(k - e)\n1037:   have hone_le_pow : (1 : ℝ) ≤ (beta : ℝ) ^ (k - e) := le_trans h_abs_mR_ge1 h_abs_mR_le\n1038:   -- Show that k - e cannot be negative (else β^(k-e) < 1)\n1039:   have hek_le : e ≤ k := by\n1040:     -- By cases on e ≤ k; derive a contradiction in the negative case.\n1041:     by_cases he_le : e ≤ k\n1042:     · exact he_le\n1043:     · -- he_le is false, so e - k > 0\n1044:       have hpos : 0 < e - k := sub_pos.mpr (lt_of_not_ge he_le)\n1045:       -- Show 1 ≤ (β : ℝ) ^ (e - k - 1)\n1046:       have hone_le_pow_u : (1 : ℝ) ≤ (beta : ℝ) ^ (e - k - 1) := by\n1047:         -- u := e - k - 1 ≥ 0\n1048:         have hu_nonneg : 0 ≤ e - k - 1 := by\n1049:           have : (1 : Int) ≤ e - k := (Int.add_one_le_iff).mpr hpos\n1050:           exact sub_nonneg.mpr this\n1051:         have hzpow_toNat : (beta : ℝ) ^ (e - k - 1) = (beta : ℝ) ^ (Int.toNat (e - k - 1)) := by\n1052:           simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (e - k - 1) hu_nonneg\n1053:         -- 1 ≤ β^n for all n : Nat\n1054:         have one_le_pow_nat : ∀ n : Nat, (1 : ℝ) ≤ (beta : ℝ) ^ n := by\n1055:           intro n; induction n with\n1056:           | zero => simp\n1057:           | succ n ih =>\n1058:               have hpow_nonneg : 0 ≤ (beta : ℝ) ^ n := pow_nonneg (le_of_lt hbposR) n\n1059:               have : (1 : ℝ) * 1 ≤ (beta : ℝ) ^ n * (beta : ℝ) :=\n1060:                 mul_le_mul ih hb_ge1 (by norm_num) hpow_nonneg\n1061:               simpa [pow_succ] using this\n1062:         simpa [hzpow_toNat] using one_le_pow_nat (Int.toNat (e - k - 1))\n1063:       -- From 1 ≤ β^(e-k-1), deduce β ≤ β^(e-k)\n1064:       have hone_le_pow_t : (beta : ℝ) ≤ (beta : ℝ) ^ (e - k) := by\n1065:         have hmul : (1 : ℝ) * (beta : ℝ) ≤ (beta : ℝ) ^ (e - k - 1) * (beta : ℝ) :=\n1066:           mul_le_mul_of_nonneg_right hone_le_pow_u (le_of_lt hbposR)\n1067:         have hpow_add : (beta : ℝ) ^ (e - k - 1) * (beta : ℝ) = (beta : ℝ) ^ (e - k) := by\n1068:           -- β^(u) * β = β^(u+1)\n1069:           have hz := (zpow_add₀ (by exact ne_of_gt hbposR) (e - k - 1) (1 : Int))\n1070:           -- (β : ℝ) ^ ((e - k - 1) + 1) = (β : ℝ) ^ (e - k - 1) * (β : ℝ) ^ 1\n1071:           simpa [add_comm, add_left_comm, add_assoc, zpow_one]\n1072:             using hz.symm\n1073:         simpa [one_mul, hpow_add] using hmul\n1074:       -- Therefore 1 < β^(e - k)\n1075:       have hone_lt_pow_t : (1 : ℝ) < (beta : ℝ) ^ (e - k) := lt_of_lt_of_le hb_gt1R hone_le_pow_t\n1076:       -- Multiply 1 ≤ β^(k - e) by β^(e - k) > 0 on the left to get β^(e - k) ≤ 1\n1077:       have hpow_pos : 0 < (beta : ℝ) ^ (e - k) := zpow_pos hbposR _\n1078:       have : (beta : ℝ) ^ (e - k) * 1 ≤ (beta : ℝ) ^ (e - k) * (beta : ℝ) ^ (k - e) :=\n1079:         mul_le_mul_of_nonneg_left hone_le_pow hpow_pos.le\n1080:       have hmul_id : (beta : ℝ) ^ (e - k) * (beta : ℝ) ^ (k - e) = 1 := by\n1081:         simpa [add_comm, add_left_comm, add_assoc, zpow_zero]\n1082:           using (zpow_add₀ (by exact ne_of_gt hbposR) (e - k) (k - e)).symm\n1083:       have : (beta : ℝ) ^ (e - k) ≤ 1 := by simpa [hmul_id, one_mul] using this\n1084:       have hfalse : False := (not_le_of_gt hone_lt_pow_t) this\n1085:       exact False.elim hfalse\n1086:   -- Apply Valid_exp at k, splitting on e < k vs e = k\n1087:   have hpair := (Valid_exp.valid_exp (beta := beta) (fexp := fexp) k)\n1088:   by_cases hlt : e < k\n1089:   · -- Large regime at k\n1090:     have : fexp (k + 1) ≤ k := (hpair.left) hlt\n1091:     simpa [k] using this\n1092:   · -- Small regime: e = k\n1093:     have heq : e = k := le_antisymm hek_le (le_of_not_gt hlt)\n1094:     -- From e = k and e = fexp k by definition, we rewrite the small-regime bound\n1095:     have heq_fk : fexp k = k := by simpa [e] using heq\n1096:     have hsmall : k ≤ fexp k := by simpa [heq_fk]\n1097:     have hbound := (hpair.right hsmall).left\n1098:     simpa [heq_fk] using hbound\n1099: \n1100: /-- Specification: Precision characterization\n1101: \n1102:     For non-zero x in generic format, there exists a mantissa m\n1103:     such that x = F2R(m, cexp(x)) with bounded mantissa.\n1104: -/\n1105: theorem precision_generic_format (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp]\n1106:     (x : ℝ) (h : (generic_format beta fexp x).run) (hx : x ≠ 0) (hβ : 1 < beta) :\n1107:     ∃ m : Int,\n1108:       x = (F2R (FlocqFloat.mk m (cexp beta fexp x).run : FlocqFloat beta)).run ∧\n1109:       Int.natAbs m ≤ Int.natAbs beta ^ ((mag beta x - (cexp beta fexp x).run).toNat) := by\n1110:   -- Notations\n1111:   set k : Int := mag beta x\n1112:   set e : Int := (cexp beta fexp x).run\n1113:   -- Define the real scaled mantissa mR and its integer truncation m\n1114:   set mR : ℝ := (scaled_mantissa beta fexp x).run\n1115:   set m : Int := Ztrunc mR\n1116:   -- From generic_format, we get the reconstruction equality with m = Ztrunc mR\n1117:   have hx_recon : x = ((Ztrunc mR : Int) : ℝ) * (beta : ℝ) ^ e := by\n1118:     simpa [generic_format, scaled_mantissa, FloatSpec.Core.Generic_fmt.cexp, F2R, k, e, mR]\n1119:       using h\n1120:   -- The scaled mantissa equals its truncation for numbers in the format\n1121:   have hsm_int := (scaled_mantissa_generic (beta := beta) (fexp := fexp) (x := x)) h\n1122:   have hmR_eq : mR = (Ztrunc mR : Int) := by simpa [mR] using hsm_int\n1123:   -- Conclude mR is exactly the integer m as a real\n1124:   have hmR_int : mR = (m : ℝ) := by simpa [m] using hmR_eq\n1125:   -- Provide the witness mantissa and equality\n1126:   refine ⟨m, ?_, ?_⟩\n1127:   · -- Equality part: rewrite with m\n1128:     simpa [m] using hx_recon\n1129:   · -- Bound on |m|\n1130:     -- Base positivity for using zpow lemmas and absolute values\n1131:     have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n1132:     have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n1133:     have hbneR : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n1134:     -- Nonzero mantissa: otherwise x = 0 via the reconstruction\n1135:     have hm_ne : m ≠ 0 := by\n1136:       intro hm0\n1137:       have : x = 0 := by simpa [m, hm0] using hx_recon\n1138:       exact hx this\n1139:     -- General scaled mantissa bound and rewrite to |m|\n1140:     have h_abs_le : abs mR ≤ (beta : ℝ) ^ (k - e) := by\n1141:       simpa [mR, k, e, FloatSpec.Core.Generic_fmt.cexp]\n1142:         using scaled_mantissa_lt_bpow (beta := beta) (fexp := fexp) (x := x) hβ\n1143:     have h_abs_m_le : abs (m : ℝ) ≤ (beta : ℝ) ^ (k - e) := by simpa [hmR_int] using h_abs_le\n1144:     -- Since m ≠ 0, we have 1 ≤ |m|\n1145:     have hone_le_abs_m : (1 : ℝ) ≤ abs (m : ℝ) := by\n1146:       by_cases hm_nonneg : 0 ≤ m\n1147:       · -- m ≥ 0 and m ≠ 0 ⇒ 1 ≤ m, hence 1 ≤ |m|\n1148:         have hm_pos : 0 < m := lt_of_le_of_ne hm_nonneg (by simpa [eq_comm] using hm_ne)\n1149:         have h1le : (1 : Int) ≤ m := (Int.add_one_le_iff).mpr hm_pos\n1150:         have h1leR : (1 : ℝ) ≤ (m : ℝ) := by exact_mod_cast h1le\n1151:         have : abs (m : ℝ) = (m : ℝ) := by\n1152:           have : 0 ≤ (m : ℝ) := by exact_mod_cast hm_nonneg\n1153:           simpa [abs_of_nonneg this]\n1154:         simpa [this] using h1leR\n1155:       · -- m ≤ 0 and m ≠ 0 ⇒ 1 ≤ -m, hence 1 ≤ |m|\n1156:         have hm_le : m ≤ 0 := le_of_not_ge hm_nonneg\n1157:         have hm_lt : m < 0 := lt_of_le_of_ne hm_le (by simpa using hm_ne)\n1158:         have hpos_negm : 0 < -m := Int.neg_pos.mpr hm_lt\n1159:         have hone_le_negm : (1 : Int) ≤ -m := (Int.add_one_le_iff).mpr hpos_negm\n1160:         have hone_le_negmR : (1 : ℝ) ≤ (-m : ℝ) := by exact_mod_cast hone_le_negm\n1161:         have hzleR : (m : ℝ) ≤ 0 := by exact_mod_cast hm_le\n1162:         have : abs (m : ℝ) = (-m : ℝ) := by simpa [abs_of_nonpos hzleR]\n1163:         simpa [this] using hone_le_negmR\n1164:     -- Thus 1 ≤ β^(k - e), hence k - e ≥ 0 (otherwise β^(k-e) < 1 for β > 1)\n1165:     have hone_le_pow : (1 : ℝ) ≤ (beta : ℝ) ^ (k - e) := le_trans hone_le_abs_m h_abs_m_le\n1166:     have hk_sub_nonneg : 0 ≤ k - e := by\n1167:       -- By contradiction: if e > k, derive a contradiction as in mag_generic_format\n1168:       by_contra hneg\n1169:       -- hneg: ¬ (0 ≤ k - e) ⇔ k < e\n1170:       have hpos : 0 < e - k := by\n1171:         have hklt : k < e := lt_of_not_ge (by simpa [sub_nonneg] using hneg)\n1172:         exact sub_pos.mpr hklt\n1173:       have hone_le_pow_u : (1 : ℝ) ≤ (beta : ℝ) ^ (e - k - 1) := by\n1174:         -- Show nonnegativity of u := e - k - 1 and convert to Nat power\n1175:         have hu_nonneg : 0 ≤ e - k - 1 := by\n1176:           have : (1 : Int) ≤ e - k := (Int.add_one_le_iff).mpr hpos\n1177:           exact sub_nonneg.mpr this\n1178:         have hzpow_toNat : (beta : ℝ) ^ (e - k - 1) = (beta : ℝ) ^ (Int.toNat (e - k - 1)) := by\n1179:           simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (e - k - 1) hu_nonneg\n1180:         -- 1 ≤ β^n for all n : Nat since β ≥ 1\n1181:         have hb_ge1 : (1 : ℝ) ≤ (beta : ℝ) := (by exact_mod_cast hβ : (1 : ℝ) < (beta : ℝ)).le\n1182:         have one_le_pow_nat : ∀ n : Nat, (1 : ℝ) ≤ (beta : ℝ) ^ n := by\n1183:           intro n; induction n with\n1184:           | zero => simp\n1185:           | succ n ih =>\n1186:               have hpow_nonneg : 0 ≤ (beta : ℝ) ^ n :=\n1187:                 pow_nonneg (le_of_lt hbposR) n\n1188:               have : (1 : ℝ) * 1 ≤ (beta : ℝ) ^ n * (beta : ℝ) :=\n1189:                 mul_le_mul ih hb_ge1 (by norm_num) hpow_nonneg\n1190:               simpa [pow_succ] using this\n1191:         simpa [hzpow_toNat] using one_le_pow_nat (Int.toNat (e - k - 1))\n1192:       -- From 1 ≤ β^(e-k-1), deduce β ≤ β^(e-k)\n1193:       have hone_le_pow_t : (beta : ℝ) ≤ (beta : ℝ) ^ (e - k) := by\n1194:         have hmul : (1 : ℝ) * (beta : ℝ) ≤ (beta : ℝ) ^ (e - k - 1) * (beta : ℝ) :=\n1195:           mul_le_mul_of_nonneg_right hone_le_pow_u (le_of_lt hbposR)\n1196:         have hpow_add : (beta : ℝ) ^ (e - k - 1) * (beta : ℝ) = (beta : ℝ) ^ (e - k) := by\n1197:           have hz := (zpow_add₀ (by exact ne_of_gt hbposR) (e - k - 1) (1 : Int))\n1198:           simpa [add_comm, add_left_comm, add_assoc, zpow_one] using hz.symm\n1199:         simpa [one_mul, hpow_add] using hmul\n1200:       have hone_lt_pow_t : (1 : ℝ) < (beta : ℝ) ^ (e - k) := lt_of_lt_of_le (by exact_mod_cast hβ) hone_le_pow_t\n1201:       have hpow_pos : 0 < (beta : ℝ) ^ (e - k) := zpow_pos hbposR _\n1202:       have : (beta : ℝ) ^ (e - k) * 1 ≤ (beta : ℝ) ^ (e - k) * (beta : ℝ) ^ (k - e) :=\n1203:         mul_le_mul_of_nonneg_left hone_le_pow hpow_pos.le\n1204:       have hmul_id : (beta : ℝ) ^ (e - k) * (beta : ℝ) ^ (k - e) = 1 := by\n1205:         simpa [add_comm, add_left_comm, add_assoc, zpow_zero]\n1206:           using (zpow_add₀ (by exact ne_of_gt hbposR) (e - k) (k - e)).symm\n1207:       have hle1 : (beta : ℝ) ^ (e - k) ≤ 1 := by simpa [hmul_id, one_mul] using this\n1208:       exact (not_lt_of_ge hle1) hone_lt_pow_t\n1209:     -- Now we can rewrite the RHS power via toNat\n1210:     have hzpow_toNat : (beta : ℝ) ^ (k - e) = (beta : ℝ) ^ (Int.toNat (k - e)) := by\n1211:       simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (k - e) hk_sub_nonneg\n1212:     -- Rewrite base (β : ℝ) as ((natAbs β) : ℝ) since β > 0\n1213:     have hbeta_cast_eq : ((Int.natAbs beta : Nat) : ℝ) = (beta : ℝ) := by\n1214:       have : ((Int.natAbs beta : Nat) : ℝ) = abs (beta : ℝ) := by\n1215:         simpa [Int.cast_natAbs, Int.cast_abs]\n1216:       simpa [abs_of_pos hbposR] using this\n1217:     -- Convert the RHS to a casted Nat power\n1218:     have hRHS_cast : (beta : ℝ) ^ (Int.toNat (k - e))\n1219:         = ((Int.natAbs beta ^ Int.toNat (k - e) : Nat) : ℝ) := by\n1220:       -- replace base by natAbs beta and use Nat.cast_pow\n1221:       have hbase : ((Int.natAbs beta : Nat) : ℝ) = (beta : ℝ) := hbeta_cast_eq\n1222:       simpa [hbase, Nat.cast_pow]\n1223:     -- Combine and conclude as a Nat inequality via monotonicity of casts\n1224:     have hcast_ineq : (Int.natAbs m : ℝ) ≤ ((Int.natAbs beta ^ Int.toNat (k - e) : Nat) : ℝ) := by\n1225:       -- Use ((natAbs m) : ℝ) = |(m : ℝ)| and rewrite the RHS using hzpow_toNat and hRHS_cast\n1226:       have hLHS : (Int.natAbs m : ℝ) = abs (m : ℝ) := by\n1227:         simpa [Int.cast_natAbs, Int.cast_abs]\n1228:       simpa [hLHS, hzpow_toNat, hRHS_cast] using h_abs_m_le\n1229:     -- Coercion monotonicity gives the required Nat inequality\n1230:     exact (by exact_mod_cast hcast_ineq)\n1231: \n1232: /-- Specification: Generic format error bound\n1233: \n1234:     For any x, there exists f in generic format within\n1235:     half ULP of x.\n1236: -/\n1237: theorem generic_format_error_bound (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n1238:     ∃ f, (generic_format beta fexp f).run ∧\n1239:     abs (f - x) ≤ (1/2) * (beta : ℝ) ^ (cexp beta fexp x).run := by\n1240:   exact exists_round_half_ulp beta fexp x\n1241: \n1242: /-- Specification: Relative error bound\n1243: \n1244:     For non-zero x, there exists f in generic format\n1245:     with bounded relative error.\n1246: -/\n1247: theorem generic_format_relative_error (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp]\n1248:     (x : ℝ) (hx : x ≠ 0) (hβ : 1 < beta) :\n1249:     ∃ f, (generic_format beta fexp f).run ∧ f ≠ 0 ∧\n1250:     abs (f - x) / abs x ≤ (1/2) * (beta : ℝ) ^ ((cexp beta fexp x).run - mag beta x + 1) := by\n1251:   -- Use the nonzero half‑ULP witness axiom, then divide by |x| and apply the reciprocal bound\n1252:   classical\n1253:   obtain ⟨f, hfF, hf_ne, herr_abs⟩ := exists_round_half_ulp_nz (beta := beta) (fexp := fexp) (x := x) hx\n1254:   set e : Int := (cexp beta fexp x).run\n1255:   set k : Int := mag beta x\n1256:   have hxpos : 0 < abs x := abs_pos.mpr hx\n1257:   -- Multiply both sides of the absolute error by |x|⁻¹ (nonnegative)\n1258:   have hx_inv_nonneg : 0 ≤ (abs x)⁻¹ := inv_nonneg.mpr (le_of_lt hxpos)\n1259:   have hmul := mul_le_mul_of_nonneg_right herr_abs hx_inv_nonneg\n1260:   have hdiv : abs (f - x) / abs x ≤ ((1/2) * (beta : ℝ) ^ e) * (abs x)⁻¹ := by\n1261:     simpa [one_div, div_eq_mul_inv, mul_comm, mul_left_comm, mul_assoc] using hmul\n1262:   have hrecip := (recip_abs_x_le (beta := beta) (x := x)) ⟨hβ, hx⟩\n1263:   have hrecip_le' : (abs x)⁻¹ ≤ (beta : ℝ) ^ (1 - k) := by simpa [one_div, k] using hrecip\n1264:   have hbposR : 0 < (beta : ℝ) := by\n1265:     have : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n1266:     exact_mod_cast this\n1267:   have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n1268:   have hcoeff_nonneg : 0 ≤ (1/2) * (beta : ℝ) ^ e := by\n1269:     have : 0 ≤ (beta : ℝ) ^ e := le_of_lt (zpow_pos hbposR e)\n1270:     exact mul_nonneg (by norm_num) this\n1271:   have : ((1/2) * (beta : ℝ) ^ e) * (abs x)⁻¹ ≤ ((1/2) * (beta : ℝ) ^ e) * (beta : ℝ) ^ (1 - k) :=\n1272:     mul_le_mul_of_nonneg_left hrecip_le' hcoeff_nonneg\n1273:   have : ((1/2) * (beta : ℝ) ^ e) * (abs x)⁻¹ ≤ (1/2) * (beta : ℝ) ^ (e - k + 1) := by\n1274:     -- rewrite RHS using zpow_add and associativity\n1275:     simpa [sub_eq_add_neg, one_div, mul_comm, mul_left_comm, mul_assoc, zpow_add₀ hbne] using this\n1276:   exact ⟨f, hfF, hf_ne, le_trans hdiv this⟩\n1277: \n1278: /-- Round to nearest in generic format\n1279: \n1280:     Computes the nearest representable value in the format.\n1281: -/\n1282: noncomputable def round_N_to_format (beta : Int) (fexp : Int → Int) (x : ℝ) : Id ℝ :=\n1283:   -- Placeholder: not needed for properties below\n1284:   pure 0\n1285: \n1286: /-- Round down to generic format\n1287: \n1288:     Computes the largest representable value not exceeding x.\n1289: -/\n1290: noncomputable def round_DN_to_format (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) : Id ℝ :=\n1291:   -- Use classical choice from existence of DN rounding in generic format\n1292:   pure (Classical.choose (round_DN_exists beta fexp x))\n1293: \n1294: /-- Round up to generic format\n1295: \n1296:     Computes the smallest representable value not less than x.\n1297: -/\n1298: noncomputable def round_UP_to_format (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) : Id ℝ :=\n1299:   -- Use classical choice from existence of UP rounding in generic format\n1300:   pure (Classical.choose (round_UP_exists beta fexp x))\n1301: \n1302: /-- Specification: Properties of format-specific rounding\n1303: \n1304:     The rounding functions produce values in the format\n1305:     and satisfy the expected ordering properties.\n1306: -/\n1307: theorem round_to_format_properties (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n1308:     ⦃⌜beta > 1⌝⦄\n1309:     do\n1310:       let down ← round_DN_to_format beta fexp x\n1311:       let up ← round_UP_to_format beta fexp x\n1312:       pure (down, up)\n1313:     ⦃⇓result => ⌜let (down, up) := result;\n1314:                    (generic_format beta fexp down).run ∧\n1315:                    (generic_format beta fexp up).run ∧\n1316:                    down ≤ x ∧ x ≤ up⌝⦄ := by\n1317:   intro _\n1318:   -- Evaluate the do-block and unfold our definitions of the rounding helpers\n1319:   simp [round_DN_to_format, round_UP_to_format]\n1320:   -- Retrieve properties of the chosen down and up values\n1321:   have hDN := Classical.choose_spec (round_DN_exists beta fexp x)\n1322:   have hUP := Classical.choose_spec (round_UP_exists beta fexp x)\n1323:   -- Unpack DN: format membership and DN predicate\n1324:   rcases hDN with ⟨hFdn, hdn⟩\n1325:   rcases hUP with ⟨hFup, hup⟩\n1326:   -- Extract ordering facts from the predicates\n1327:   rcases hdn with ⟨_, hdn_le, _⟩\n1328:   rcases hup with ⟨_, hup_ge, _⟩\n1329:   -- Conclude the required conjunction\n1330:   exact ⟨hFdn, hFup, hdn_le, hup_ge⟩\n1331: \n1332: end FloatSpec.Core.Round_generic\n1333: \n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "1   : /-\n2   : This file is part of the Flocq formalization of floating-point\n3   : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4   : \n5   : Copyright (C) 2011-2018 Sylvie Boldo\n6   : Copyright (C) 2011-2018 Guillaume Melquiond\n7   : \n8   : This library is free software; you can redistribute it and/or\n9   : modify it under the terms of the GNU Lesser General Public\n10  : License as published by the Free Software Foundation; either\n11  : version 3 of the License, or (at your option) any later version.\n12  : \n13  : This library is distributed in the hope that it will be useful,\n14  : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15  : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16  : COPYING file for more details.\n17  : \n18  : Generic floating-point rounding and unverified properties\n19  : Based on flocq/src/Core/Generic_fmt.v\n20  : -/\n21  : \n22  : import FloatSpec.src.Core.Zaux\n23  : import FloatSpec.src.Core.Raux\n24  : import FloatSpec.src.Core.Defs\n25  : import FloatSpec.src.Core.Round_pred\n26  : import FloatSpec.src.Core.Float_prop\n27  : import FloatSpec.src.Core.Generic_fmt\n28  : import Mathlib.Data.Real.Basic\n29  : import Mathlib.Analysis.SpecialFunctions.Log.Basic\n30  : import Std.Do.Triple\n31  : import Std.Tactic.Do\n32  : \n33  : open Real\n34  : open Std.Do\n35  : open FloatSpec.Core.Defs\n36  : open FloatSpec.Core.Zaux\n37  : open FloatSpec.Core.Raux\n38  : open FloatSpec.Core.Generic_fmt\n39  : \n40  : -- No need to export round_to_generic since we're defining it here\n41  : \n42  : namespace FloatSpec.Core.Round_generic\n43  : \n44  : /-- Axiom: Local spacing bound near x (one-ULP gap)\n45  :     For the generic format viewed as a set F, if xdn and xup are respectively\n46  :     the round-down and round-up values of x in F, then their gap is at most\n47  :     (beta : ℝ)^(cexp x). This matches the standard spacing property and is\n48  :     consistent with Flocq's Generic_fmt spacing results. -/\n49  : axiom spacing_bound\n50  :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x xdn xup : ℝ) :\n51  :     let F := fun y => (generic_format beta fexp y).run\n52  :     Rnd_DN_pt F x xdn → Rnd_UP_pt F x xup →\n53  :     xup - xdn ≤ (beta : ℝ) ^ (cexp beta fexp x).run\n54  : \n55  : /-- Axiom: Reciprocal bound via magnitude\n56  :     For beta > 1 and x ≠ 0, the reciprocal of |x| is bounded by\n57  :     a power determined by the magnitude. -/\n58  : axiom recip_abs_x_le (beta : Int) (x : ℝ) :\n59  :     (1 < beta ∧ x ≠ 0) → 1 / abs x ≤ (beta : ℝ) ^ (1 - mag beta x)\n60  : \n61  : /-- Axiom: Existence of a half‑ULP approximation in the format -/\n62  : axiom exists_round_half_ulp\n63  :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n64  :     ∃ f, (generic_format beta fexp f).run ∧\n65  :       abs (f - x) ≤ (1/2) * (beta : ℝ) ^ (cexp beta fexp x).run\n66  : \n67  : /-- Axiom: Nonzero half‑ULP approximation when x ≠ 0 -/\n68  : axiom exists_round_half_ulp_nz\n69  :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) (hx : x ≠ 0) :\n70  :     ∃ f, (generic_format beta fexp f).run ∧ f ≠ 0 ∧\n71  :       abs (f - x) ≤ (1/2) * (beta : ℝ) ^ (cexp beta fexp x).run\n72  : \n73  : /-- Placeholder existence axiom: There exists a round-down value in the generic format.\n74  :     A constructive proof requires additional spacing/discreteness lemmas for the format.\n75  : -/\n76  : axiom round_DN_exists\n77  :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n78  :     ∃ f, (generic_format beta fexp f).run ∧\n79  :       FloatSpec.Core.Round_pred.Rnd_DN_pt (fun y => (generic_format beta fexp y).run) x f\n80  : \n81  : /-- Placeholder existence axiom: There exists a round-up value in the generic format.\n82  :     A constructive proof requires additional spacing/discreteness lemmas for the format.\n83  : -/\n84  : -- Helper: closure of generic format under negation (as a plain implication)\n85  : private theorem generic_format_neg_closed\n86  :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (y : ℝ)\n87  :     (hy : (generic_format beta fexp y).run) :\n88  :     (generic_format beta fexp (-y)).run :=\n89  :   (generic_format_opp beta fexp y) hy\n90  : \n91  : -- Transform a round-up point at -x into a round-down point at x, using negation closure\n92  : private theorem Rnd_UP_to_DN_via_neg\n93  :     (F : ℝ → Prop) (x f : ℝ)\n94  :     (Fneg : ∀ y, F y → F (-y))\n95  :     (hup : FloatSpec.Core.Round_pred.Rnd_UP_pt F (-x) f) :\n96  :     FloatSpec.Core.Round_pred.Rnd_DN_pt F x (-f) := by\n97  :   -- Unpack the round-up predicate at -x\n98  :   rcases hup with ⟨hfF, hle, hmin⟩\n99  :   -- Show membership after negation\n100 :   have hFneg : F (-f) := Fneg f hfF\n101 :   -- Order transforms: -x ≤ f ↔ -f ≤ x\n102 :   have hle' : -f ≤ x := by\n103 :     have : (-x) ≤ f := hle\n104 :     -- multiply both sides by -1\n105 :     simpa using (neg_le_neg this)\n106 :   -- Maximality for DN: any g ≤ x must be ≤ -f\n107 :   have hmax : ∀ g : ℝ, F g → g ≤ x → g ≤ -f := by\n108 :     intro g hgF hg_le\n109 :     -- Consider -g, which is in F by closure, and satisfies -x ≤ -g\n110 :     have hFneg_g : F (-g) := Fneg g hgF\n111 :     have hx_le : (-x) ≤ (-g) := by simpa using (neg_le_neg hg_le)\n112 :     -- Minimality of f for UP at -x gives f ≤ -g, hence g ≤ -f\n113 :     have hf_le : f ≤ -g := hmin (-g) hFneg_g hx_le\n114 :     simpa using (neg_le_neg hf_le)\n115 :   exact ⟨hFneg, hle', hmax⟩\n116 : \n117 : -- Existence of a round-up value from round-down existence via negation\n118 : theorem round_UP_exists\n119 :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n120 :     ∃ f, (generic_format beta fexp f).run ∧\n121 :       FloatSpec.Core.Round_pred.Rnd_UP_pt (fun y => (generic_format beta fexp y).run) x f := by\n122 :   -- Obtain DN existence for -x (assumed available) and transform\n123 :   rcases round_DN_exists beta fexp (-x) with ⟨fdn, hFdn, hdn⟩\n124 :   -- Turn it into UP existence for x via negation\n125 :   refine ⟨-fdn, ?_, ?_⟩\n126 :   · -- Format closure under negation\n127 :     exact generic_format_neg_closed beta fexp fdn hFdn\n128 :   · -- Use the transformation lemma specialized to the generic format predicate\n129 :     -- First, rewrite the DN predicate at -x into an UP predicate at x via negation\n130 :     -- We need the reverse transformation: DN at -x ⇒ UP at x\n131 :     -- This is symmetric to Rnd_UP_to_DN_via_neg by swapping roles of x and -x and negating\n132 :     -- Prove it directly here\n133 :     -- Unpack DN at -x\n134 :     rcases hdn with ⟨hF_fdn, hfdn_le, hmax⟩\n135 :     -- Show x ≤ -fdn\n136 :     have hx_le : x ≤ -fdn := by\n137 :       have : fdn ≤ -x := hfdn_le\n138 :       -- negate both sides\n139 :       simpa using (neg_le_neg this)\n140 :     -- Minimality for UP: any g with F g and x ≤ g must satisfy -fdn ≤ g\n141 :     have hmin : ∀ g : ℝ, (generic_format beta fexp g).run → x ≤ g → -fdn ≤ g := by\n142 :       intro g hFg hx_le_g\n143 :       -- Consider -g; DN at -x gives -g ≤ fdn\n144 :       have hF_neg_g : (generic_format beta fexp (-g)).run := generic_format_neg_closed beta fexp g hFg\n145 :       have h_le_for_dn : (-g) ≤ (-x) := by simpa using (neg_le_neg hx_le_g)\n146 :       have : (-g) ≤ fdn := hmax (-g) hF_neg_g h_le_for_dn\n147 :       -- Negate inequality to get -fdn ≤ g\n148 :       simpa using (neg_le_neg this)\n149 :     exact ⟨generic_format_neg_closed beta fexp fdn hFdn, hx_le, hmin⟩\n150 : \n151 : /-- Specification: Powers of beta in generic format\n152 : \n153 :     When fexp (e + 1) ≤ e, beta^e is in generic format.\n154 : -/\n155 : theorem generic_format_bpow\n156 :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (e : Int) :\n157 :     ⦃⌜beta > 1 ∧ fexp (e + 1) ≤ e⌝⦄\n158 :     generic_format beta fexp ((beta : ℝ) ^ e)\n159 :     ⦃⇓result => ⌜result⌝⦄ := by\n160 :   intro hpre\n161 :   rcases hpre with ⟨hβ, hle⟩\n162 :   -- Base positivity and nonzeroness facts\n163 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n164 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n165 :   have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n166 : \n167 :   -- Compute mag on a pure power: with our definition using ceil(log_/log), this evaluates to e\n168 :   have hmag_pow : mag beta ((beta : ℝ) ^ e) = e := by\n169 :     -- positivity and logs\n170 :     have hxpos : 0 < (beta : ℝ) ^ e := zpow_pos (by exact_mod_cast hbposℤ) _\n171 :     have hlt : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n172 :     -- show log β ≠ 0 via exp_log and β ≠ 1\n173 :     have hlogβ_ne : Real.log (beta : ℝ) ≠ 0 := by\n174 :       intro h0\n175 :       have hbpos' : 0 < (beta : ℝ) := hbposR\n176 :       have h0exp : Real.exp (Real.log (beta : ℝ)) = Real.exp 0 := congrArg Real.exp h0\n177 :       have : (beta : ℝ) = 1 := by simpa [Real.exp_log hbpos', Real.exp_zero] using h0exp\n178 :       have hβne1 : (beta : ℝ) ≠ 1 := by exact_mod_cast (ne_of_gt hβ)\n179 :       exact hβne1 this\n180 :     have hlog_zpow : Real.log ((beta : ℝ) ^ e) = (e : ℝ) * Real.log (beta : ℝ) := by\n181 :       simpa using Real.log_zpow hbposR _\n182 :     have hratio : Real.log ((beta : ℝ) ^ e) / Real.log (beta : ℝ) = (e : ℝ) := by\n183 :       have : ((e : ℝ) * Real.log (beta : ℝ)) / Real.log (beta : ℝ) = (e : ℝ) :=\n184 :         mul_div_cancel_right₀ (e : ℝ) hlogβ_ne\n185 :       simpa [hlog_zpow] using this\n186 :     have habs : abs ((beta : ℝ) ^ e) = (beta : ℝ) ^ e := by\n187 :       exact abs_of_nonneg (le_of_lt hxpos)\n188 :     -- expand definition of mag and evaluate ceil\n189 :     unfold mag\n190 :     have hxne : (beta : ℝ) ^ e ≠ 0 := ne_of_gt hxpos\n191 :     -- Reduce to ceil of a simplified ratio\n192 :     simp only [hxne, habs, hlog_zpow]\n193 :     have : ((e : ℝ) * Real.log (beta : ℝ)) / Real.log (beta : ℝ) = (e : ℝ) := by\n194 :       have : (Real.log (beta : ℝ) * (e : ℝ)) / Real.log (beta : ℝ) = (e : ℝ) :=\n195 :         mul_div_cancel_left₀ (e : ℝ) hlogβ_ne\n196 :       simpa [mul_comm] using this\n197 :     simpa [this, Int.ceil_intCast]\n198 : \n199 :   -- From the valid_exp structure and the bound at e+1, deduce fexp e ≤ e\n200 :   have hlt_e1 : fexp (e + 1) < (e + 1) := lt_of_le_of_lt hle (lt_add_of_pos_right _ Int.zero_lt_one)\n201 :   have hfe_le : fexp e ≤ e := by\n202 :     -- Use valid_exp_large' with k = e+1 and l = e to get fexp e < e+1\n203 :     have := FloatSpec.Core.Generic_fmt.valid_exp_large' (beta := beta) (fexp := fexp) (k := e + 1) (l := e) hlt_e1 (le_of_lt (lt_add_of_pos_right _ Int.zero_lt_one))\n204 :     exact Int.lt_add_one_iff.mp this\n205 : \n206 :   -- Unfold goal and carry out the algebra, mirroring generic_format_F2R with m = 1\n207 :   simp [generic_format, scaled_mantissa, cexp, F2R]\n208 :   -- Notation: cexp for x = β^e\n209 :   set c := fexp (mag beta ((beta : ℝ) ^ e)) with hc\n210 :   -- Use hmag_pow to rewrite c\n211 :   have hc' : c = fexp e := by simpa [hc, hmag_pow]\n212 :   -- With c ≤ e, we can express the scaled mantissa as an integer power\n213 :   have hcle : c ≤ e := by simpa [hc'] using hfe_le\n214 :   -- Key zpow identities\n215 :   have hinv : (beta : ℝ) ^ (-c) = ((beta : ℝ) ^ c)⁻¹ := zpow_neg _ _\n216 :   have hmul_pow : (beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹ = (beta : ℝ) ^ (e - c) := by\n217 :     rw [← hinv, ← zpow_add₀ hbne]\n218 :     simp [sub_eq_add_neg]\n219 :   have hpow_nonneg : 0 ≤ e - c := sub_nonneg.mpr hcle\n220 :   have hzpow_toNat : (beta : ℝ) ^ (e - c) = (beta : ℝ) ^ (Int.toNat (e - c)) := by\n221 :     rw [← Int.toNat_of_nonneg hpow_nonneg]\n222 :     exact zpow_ofNat _ _\n223 :   have hcast_pow : (beta : ℝ) ^ (Int.toNat (e - c)) = ((beta ^ (Int.toNat (e - c)) : Int) : ℝ) := by\n224 :     rw [← Int.cast_pow]\n225 : \n226 :   -- Finish by showing the reconstruction equality\n227 :   simp only [hc, hmag_pow]\n228 :   -- Goal now is: (Ztrunc ((β^e) * (β^c)⁻¹) : ℝ) * (β : ℝ) ^ c = (β : ℝ) ^ e\n229 :   -- Compute the truncation explicitly\n230 :   have htrunc : Ztrunc ((beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹) = beta ^ (Int.toNat (e - c)) := by\n231 :     calc\n232 :       Ztrunc ((beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹)\n233 :           = Ztrunc ((beta : ℝ) ^ (e - c)) := by rw [hmul_pow]\n234 :       _   = Ztrunc ((beta : ℝ) ^ (Int.toNat (e - c))) := by rw [hzpow_toNat]\n235 :       _   = Ztrunc (((beta ^ (Int.toNat (e - c)) : Int) : ℝ)) := by rw [hcast_pow]\n236 :       _   = beta ^ (Int.toNat (e - c)) := FloatSpec.Core.Generic_fmt.Ztrunc_intCast _\n237 : \n238 :   -- Power splitting lemma to reconstruct\n239 :   have hsplit : (beta : ℝ) ^ e = (beta : ℝ) ^ (e - c) * (beta : ℝ) ^ c := by\n240 :     rw [← zpow_add₀ hbne (e - c) c]\n241 :     simp [sub_add_cancel]\n242 : \n243 :   -- Conclude the equality (flip orientation to match calc direction)\n244 :   symm\n245 :   calc\n246 :     ((Ztrunc ((beta : ℝ) ^ e * ((beta : ℝ) ^ (fexp e))⁻¹) : Int) : ℝ) * (beta : ℝ) ^ (fexp e)\n247 :         = ((Ztrunc ((beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹) : Int) : ℝ) * (beta : ℝ) ^ c := by\n248 :               rw [hc']\n249 :     _   = ((beta ^ (Int.toNat (e - c)) : Int) : ℝ) * (beta : ℝ) ^ c := by rw [htrunc]\n250 :     _   = (beta : ℝ) ^ (e - c) * (beta : ℝ) ^ c := by\n251 :           -- rewrite Int power as real power for nonnegative exponent\n252 :           rw [hzpow_toNat, hcast_pow]\n253 :     _   = (beta : ℝ) ^ e := by rw [hsplit]\n254 : \n255 : /-- Specification: Alternative power condition\n256 : \n257 :     When fexp e ≤ e, beta^e is in generic format.\n258 : -/\n259 : theorem generic_format_bpow' (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (e : Int) :\n260 :     ⦃⌜beta > 1 ∧ fexp e ≤ e⌝⦄\n261 :     generic_format beta fexp ((beta : ℝ) ^ e)\n262 :     ⦃⇓result => ⌜result⌝⦄ := by\n263 :   intro hpre\n264 :   rcases hpre with ⟨hβ, hle⟩\n265 :   -- From Valid_exp, we can derive the required bound fexp (e+1) ≤ e\n266 :   -- by case-splitting on whether fexp e < e or e ≤ fexp e.\n267 :   have hpair := (Valid_exp.valid_exp (beta := beta) (fexp := fexp) e)\n268 :   by_cases hlt : fexp e < e\n269 :   · -- Large regime: directly get fexp (e+1) ≤ e\n270 :     have hbound : fexp (e + 1) ≤ e := (hpair.left) hlt\n271 :     -- Apply the power-in-format lemma with this bound\n272 :     exact (generic_format_bpow (beta := beta) (fexp := fexp) e) ⟨hβ, hbound⟩\n273 :   · -- Otherwise, we have e ≤ fexp e\n274 :     have hge : e ≤ fexp e := le_of_not_gt hlt\n275 :     -- Combined with the hypothesis fexp e ≤ e, we get equality\n276 :     have heq : fexp e = e := le_antisymm hle hge\n277 :     -- Small regime: get fexp (fexp e + 1) ≤ fexp e, then rewrite using heq\n278 :     have hsmall := (hpair.right) (by simpa [heq] using hge)\n279 :     have hbound' : fexp (e + 1) ≤ e := by\n280 :       simpa [heq, add_comm, add_left_comm, add_assoc] using hsmall.left\n281 :     -- Apply the power-in-format lemma with the derived bound\n282 :     exact (generic_format_bpow (beta := beta) (fexp := fexp) e) ⟨hβ, hbound'⟩\n283 : \n284 : /-- Specification: Scaled mantissa for generic format\n285 : \n286 :     For numbers in generic format, the scaled mantissa\n287 :     equals its truncation (i.e., it's already an integer).\n288 : -/\n289 : theorem scaled_mantissa_generic (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n290 :     ⦃⌜(generic_format beta fexp x).run⌝⦄\n291 :     scaled_mantissa beta fexp x\n292 :     ⦃⇓result => ⌜result = Ztrunc result⌝⦄ := by\n293 :   intro hx\n294 :   unfold scaled_mantissa cexp\n295 :   simp\n296 :   -- Turn the generic_format hypothesis into the reconstruction equality\n297 :   unfold generic_format at hx\n298 :   simp [scaled_mantissa, cexp, F2R] at hx\n299 :   -- Notation: e is the canonical exponent, m the scaled mantissa\n300 :   set e := fexp (mag beta x)\n301 :   set m := x * (beta : ℝ) ^ (-e) with hm\n302 :   have hx' : x = ((Ztrunc m : Int) : ℝ) * (beta : ℝ) ^ e := by simpa [e, m] using hx\n303 :   -- We need to prove: m = Ztrunc m (with coercion on the right)\n304 :   by_cases hpow : (beta : ℝ) ^ e = 0\n305 :   · -- Degenerate base power: then x = 0 and hence m = 0, so equality holds\n306 :     have hx0 : x = 0 := by simpa [hpow] using hx'\n307 :     have hm0 : m = 0 := by simp [m, hx0]\n308 :     simp [hx0, FloatSpec.Core.Generic_fmt.Ztrunc_zero]\n309 :   · -- Nonzero base power: cancel to show m equals its truncation\n310 :     have hpow_ne : (beta : ℝ) ^ e ≠ 0 := hpow\n311 :     -- Multiply the reconstruction by β^(-e) and simplify using hpow_ne\n312 :     have hmul := congrArg (fun t : ℝ => t * (beta : ℝ) ^ (-e)) hx'\n313 :     -- Left side becomes m; right side reduces to (Ztrunc m : ℝ)\n314 :     have hmain : m = (Ztrunc m : ℝ) := by\n315 :       simpa [m, mul_comm, mul_left_comm, mul_assoc, zpow_neg, hpow_ne]\n316 :         using hmul\n317 :     simpa [m] using hmain\n318 : \n319 : /-- Specification: Canonical exponent from bounds\n320 : \n321 :     When x is bounded by powers of beta, cexp(x) = fexp(ex).\n322 : -/\n323 : theorem cexp_fexp (beta : Int) (fexp : Int → Int) (x : ℝ) (ex : Int) :\n324 :     ⦃⌜beta > 1 ∧ (beta : ℝ) ^ (ex - 1) < abs x ∧ abs x ≤ (beta : ℝ) ^ ex⌝⦄\n325 :     cexp beta fexp x\n326 :     ⦃⇓result => ⌜result = fexp ex⌝⦄ := by\n327 :   intro h\n328 :   rcases h with ⟨hβ, hlow, hupp⟩\n329 :   -- It suffices to show mag beta x = ex\n330 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n331 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n332 :   have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n333 :   -- From the strict lower bound, |x| > 0 hence x ≠ 0\n334 :   have hxpos : 0 < abs x := lt_trans (zpow_pos (by exact_mod_cast hbposℤ) _) hlow\n335 :   have hx0 : x ≠ 0 := by\n336 :     have : abs x ≠ 0 := ne_of_gt hxpos\n337 :     exact fun hx => this (by simpa [hx, abs_zero])\n338 :   -- Unfold mag and set L = log(|x|)/log(beta)\n339 :   -- Prepare an explicit form for mag\n340 :   have hmageq : mag beta x = Int.ceil (Real.log (abs x) / Real.log (beta : ℝ)) := by\n341 :     unfold mag\n342 :     simp [hx0]\n343 :   set L : ℝ := Real.log (abs x) / Real.log (beta : ℝ) with hLdef\n344 :   -- Show Int.ceil L = ex by sandwiching L between ex-1 and ex\n345 :   -- Upper bound: L ≤ ex\n346 :   -- log β > 0 since 1 < β\n347 :   have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n348 :   have hlogβ_pos : 0 < Real.log (beta : ℝ) := by\n349 :     have : 0 < Real.log (beta : ℝ) ↔ 1 < (beta : ℝ) :=\n350 :       Real.log_pos_iff (x := (beta : ℝ)) (le_of_lt (by exact_mod_cast hbposℤ))\n351 :     exact this.mpr hb_gt1R\n352 :   have hlog_le : Real.log (abs x) ≤ Real.log ((beta : ℝ) ^ ex) :=\n353 :     Real.log_le_log hxpos hupp\n354 :   have hlog_zpow_ex : Real.log ((beta : ℝ) ^ ex) = (ex : ℝ) * Real.log (beta : ℝ) := by\n355 :     simpa using Real.log_zpow hbposR ex\n356 :   have hL_mul : L * Real.log (beta : ℝ) = Real.log (abs x) := by\n357 :     have hne : Real.log (beta : ℝ) ≠ 0 := ne_of_gt hlogβ_pos\n358 :     calc\n359 :       L * Real.log (beta : ℝ)\n360 :           = (Real.log (abs x) / Real.log (beta : ℝ)) * Real.log (beta : ℝ) := by simpa [hLdef]\n361 :       _   = Real.log (abs x) * Real.log (beta : ℝ) / Real.log (beta : ℝ) := by\n362 :             simpa [div_mul_eq_mul_div]\n363 :       _   = Real.log (abs x) := by\n364 :             simpa [hne] using (mul_div_cancel' (Real.log (abs x)) (Real.log (beta : ℝ)))\n365 :   have hL_le_ex : L ≤ (ex : ℝ) := by\n366 :     have hmul_le : L * Real.log (beta : ℝ) ≤ (ex : ℝ) * Real.log (beta : ℝ) := by\n367 :       simpa [hL_mul, hlog_zpow_ex] using hlog_le\n368 :     exact (le_of_mul_le_mul_right hmul_le hlogβ_pos)\n369 :   have hceil_le : Int.ceil L ≤ ex := Int.ceil_le.mpr hL_le_ex\n370 :   -- Lower bound: ex - 1 < L\n371 :   have hlog_lt : Real.log ((beta : ℝ) ^ (ex - 1)) < Real.log (abs x) :=\n372 :     Real.log_lt_log (zpow_pos (by exact_mod_cast hbposℤ) _) hlow\n373 :   have hlog_zpow_exm1 : Real.log ((beta : ℝ) ^ (ex - 1)) = (ex - 1 : ℝ) * Real.log (beta : ℝ) := by\n374 :     simpa using Real.log_zpow hbposR (ex - 1)\n375 :   have hexm1_lt_L : (ex - 1 : ℝ) < L := by\n376 :     have hmul_lt : (ex - 1 : ℝ) * Real.log (beta : ℝ) < L * Real.log (beta : ℝ) := by\n377 :       simpa [hL_mul, hlog_zpow_exm1] using hlog_lt\n378 :     exact (lt_of_mul_lt_mul_right hmul_lt (le_of_lt hlogβ_pos))\n379 :   -- Conclude Int.ceil L = ex: we already have Int.ceil L ≤ ex; prove the reverse\n380 :   have h_ex_le_ceil : ex ≤ Int.ceil L := by\n381 :     -- By contradiction: if ⌈L⌉ < ex then ⌈L⌉ ≤ ex-1, contradicting ex-1 < L\n382 :     by_contra hnot\n383 :     have hlt : Int.ceil L < ex := lt_of_not_ge hnot\n384 :     have hle_exm1 : Int.ceil L ≤ ex - 1 := by\n385 :       have : Int.ceil L < (ex - 1) + 1 := by simpa [Int.sub_add_cancel] using hlt\n386 :       exact Int.lt_add_one_iff.mp this\n387 :     have : L ≤ (ex - 1 : ℝ) := by\n388 :       simpa [Int.cast_sub, Int.cast_one] using (Int.ceil_le).mp hle_exm1\n389 :     exact (not_le_of_gt hexm1_lt_L) this\n390 :   have hceil_eq : Int.ceil L = ex := le_antisymm hceil_le h_ex_le_ceil\n391 :   -- Conclude by rewriting mag with hmageq and the established equality on the ceiling\n392 :   have hmag_eq_ex : mag beta x = ex := by\n393 :     rw [hmageq, hLdef, hceil_eq]\n394 :   unfold cexp\n395 :   simp [hmag_eq_ex]\n396 : \n397 : /-- Specification: Canonical exponent from positive bounds\n398 : \n399 :     When positive x is bounded by powers of beta, cexp(x) = fexp(ex).\n400 : -/\n401 : theorem cexp_fexp_pos (beta : Int) (fexp : Int → Int) (x : ℝ) (ex : Int) :\n402 :     ⦃⌜beta > 1 ∧ (beta : ℝ) ^ (ex - 1) < x ∧ x ≤ (beta : ℝ) ^ ex⌝⦄\n403 :     cexp beta fexp x\n404 :     ⦃⇓result => ⌜result = fexp ex⌝⦄ := by\n405 :   intro h\n406 :   rcases h with ⟨hβ, hlow, hupp⟩\n407 :   -- From beta > 1, powers are positive; with strict lower bound, x > 0\n408 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n409 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n410 :   have hxpos : 0 < x := lt_trans (zpow_pos (by exact_mod_cast hbposℤ) _) hlow\n411 :   have habs : abs x = x := abs_of_nonneg (le_of_lt hxpos)\n412 :   -- Reduce to the absolute-value version\n413 :   exact\n414 :     (cexp_fexp (beta := beta) (fexp := fexp) (x := x) (ex := ex))\n415 :       ⟨hβ, by simpa [habs] using hlow, by simpa [habs] using hupp⟩\n416 : \n417 : /-- Specification: Mantissa for small positive numbers\n418 : \n419 :     For small positive x bounded by beta^(ex-1) and beta^ex,\n420 :     where ex ≤ fexp(ex), the scaled mantissa is in (0,1).\n421 : -/\n422 : theorem mantissa_small_pos (beta : Int) (fexp : Int → Int) (x : ℝ) (ex : Int)\n423 :     (hx : (beta : ℝ) ^ (ex - 1) ≤ x ∧ x < (beta : ℝ) ^ ex)\n424 :     (he : ex ≤ fexp ex) (hβ : 1 < beta) :\n425 :     0 < x * (beta : ℝ) ^ (-(fexp ex)) ∧ x * (beta : ℝ) ^ (-(fexp ex)) < 1 := by\n426 :   -- Basic facts about the base\n427 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n428 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n429 :   have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n430 :   have hb_ge1 : (1 : ℝ) ≤ (beta : ℝ) := by\n431 :     have : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n432 :     exact this.le\n433 :   -- Split bounds on x\n434 :   rcases hx with ⟨hx_low, hx_high⟩\n435 :   -- x is positive since β^(ex-1) > 0\n436 :   have hpow_pos_exm1 : 0 < (beta : ℝ) ^ (ex - 1) := zpow_pos (by exact_mod_cast hbposℤ) _\n437 :   have hx_pos : 0 < x := lt_of_lt_of_le hpow_pos_exm1 hx_low\n438 :   -- Positivity of the scaling factor\n439 :   have hscale_pos : 0 < (beta : ℝ) ^ (-(fexp ex)) := zpow_pos (by exact_mod_cast hbposℤ) _\n440 :   -- Strict upper bound after scaling by a positive factor\n441 :   have hlt_scaled : x * (beta : ℝ) ^ (-(fexp ex)) <\n442 :       (beta : ℝ) ^ ex * (beta : ℝ) ^ (-(fexp ex)) := by\n443 :     exact (mul_lt_mul_of_pos_right hx_high hscale_pos)\n444 :   -- Collapse the right-hand side product using zpow addition\n445 :   -- A form of the product suitable for simp when inverses appear\n446 :   have hmul_inv : (beta : ℝ) ^ ex * ((beta : ℝ) ^ (fexp ex))⁻¹ = (beta : ℝ) ^ (ex - fexp ex) := by\n447 :     have hmul_pow : (beta : ℝ) ^ ex * (beta : ℝ) ^ (-(fexp ex)) = (beta : ℝ) ^ (ex - fexp ex) := by\n448 :       simpa using (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) hbne ex (fexp ex))\n449 :     simpa [zpow_neg] using hmul_pow\n450 :   have hlt_scaled' : x * (beta : ℝ) ^ (-(fexp ex)) < (beta : ℝ) ^ (ex - fexp ex) := by\n451 :     have h := (mul_lt_mul_of_pos_right hx_high hscale_pos)\n452 :     simpa [hmul_inv, zpow_neg] using h\n453 :   -- Show β^(ex - fexp ex) ≤ 1 using ex ≤ fexp ex and β > 1\n454 :   have hk_nonneg : 0 ≤ fexp ex - ex := sub_nonneg.mpr he\n455 :   -- Convert to Nat exponent on the positive side\n456 :   have hpos_mul : 0 < (beta : ℝ) ^ (fexp ex - ex) := zpow_pos (by exact_mod_cast hbposℤ) _\n457 :   -- Prove 1 ≤ β^(fexp ex - ex) by a small induction on Nat exponents\n458 :   have one_le_pow_nat : ∀ n : Nat, (1 : ℝ) ≤ (beta : ℝ) ^ n := by\n459 :     intro n\n460 :     induction n with\n461 :     | zero => simp\n462 :     | succ n ih =>\n463 :         have hpow_nonneg : 0 ≤ (beta : ℝ) ^ n :=\n464 :           pow_nonneg (le_of_lt (by exact_mod_cast hbposℤ)) n\n465 :         -- 1*1 ≤ (β^n)*β since 1 ≤ β^n and 1 ≤ β\n466 :         have : (1 : ℝ) * 1 ≤ (beta : ℝ) ^ n * (beta : ℝ) := by\n467 :           exact mul_le_mul ih hb_ge1 (by norm_num) hpow_nonneg\n468 :         simpa [pow_succ] using this\n469 :   -- Using Int.toNat to connect zpow with Nat pow on nonnegative exponent\n470 :   have hzpow_toNat : (beta : ℝ) ^ (fexp ex - ex) = (beta : ℝ) ^ (Int.toNat (fexp ex - ex)) := by\n471 :     simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (fexp ex - ex) hk_nonneg\n472 :   have hone_le : (1 : ℝ) ≤ (beta : ℝ) ^ (fexp ex - ex) := by\n473 :     -- rewrite to Nat power and apply the induction lemma\n474 :     simpa [hzpow_toNat] using one_le_pow_nat (Int.toNat (fexp ex - ex))\n475 :   -- From 1 ≤ β^(fexp ex - ex), deduce β^(ex - fexp ex) ≤ 1 by multiplying both sides\n476 :   have hle_one : (beta : ℝ) ^ (ex - fexp ex) ≤ 1 := by\n477 :     -- identity: β^(ex - fexp ex) * β^(fexp ex - ex) = 1\n478 :     have hmul_id : (beta : ℝ) ^ (ex - fexp ex) * (beta : ℝ) ^ (fexp ex - ex) = 1 := by\n479 :       have := (zpow_add₀ hbne (ex - fexp ex) (fexp ex - ex)).symm\n480 :       simpa [sub_add_cancel] using this\n481 :     -- Multiply both sides of 1 ≤ β^(fexp ex - ex) by the nonnegative factor β^(ex - fexp ex)\n482 :     have hfac_nonneg : 0 ≤ (beta : ℝ) ^ (ex - fexp ex) := le_of_lt (zpow_pos (by exact_mod_cast hbposℤ) _)\n483 :     have hmul_le := mul_le_mul_of_nonneg_left hone_le hfac_nonneg\n484 :     -- Now rewrite using hmul_id on the right and simplify the left\n485 :     -- Left: β^(ex - fexp ex) * 1 = β^(ex - fexp ex)\n486 :     -- Right: β^(ex - fexp ex) * β^(fexp ex - ex) = 1\n487 :     simpa [hmul_id, one_mul] using hmul_le\n488 :   -- Combine the strict inequality with the upper bound ≤ 1\n489 :   have hlt_one : x * (beta : ℝ) ^ (-(fexp ex)) < 1 := lt_of_lt_of_le hlt_scaled' hle_one\n490 :   -- Positivity of the scaled mantissa: product of positives\n491 :   have hpos_scaled : 0 < x * (beta : ℝ) ^ (-(fexp ex)) := mul_pos hx_pos hscale_pos\n492 :   exact ⟨hpos_scaled, hlt_one⟩\n493 : \n494 : /-- Specification: Scaled mantissa bound for small numbers\n495 : \n496 :     For small numbers with |x| < beta^ex where ex ≤ fexp(ex),\n497 :     the absolute value of scaled mantissa is less than 1.\n498 : -/\n499 : theorem scaled_mantissa_lt_1\n500 :     (beta : Int) (fexp : Int → Int) [FloatSpec.Core.Generic_fmt.Valid_exp beta fexp]\n501 :     (x : ℝ) (ex : Int)\n502 :     (hx : abs x < (beta : ℝ) ^ ex)\n503 :     (he : ex ≤ fexp ex)\n504 :     (hβ : 1 < beta) :\n505 :     abs (scaled_mantissa beta fexp x).run < 1 := by\n506 :   -- Case split on x = 0\n507 :   by_cases hx0 : x = 0\n508 :   · -- Trivial: scaled mantissa of 0 is 0\n509 :     simp [FloatSpec.Core.Generic_fmt.scaled_mantissa, FloatSpec.Core.Generic_fmt.cexp, hx0]\n510 :   · -- Nonzero case\n511 :     -- Base positivity\n512 :     have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n513 :     have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n514 :     have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n515 :     -- Show mag x ≤ ex from |x| < β^ex\n516 :     have hmag_le_ex : mag beta x ≤ ex := by\n517 :       -- Follow cexp_fexp upper-bound part\n518 :       have hxpos : 0 < abs x := abs_pos.mpr hx0\n519 :       have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n520 :       have hlogβ_pos : 0 < Real.log (beta : ℝ) := by\n521 :         have : 0 < Real.log (beta : ℝ) ↔ 1 < (beta : ℝ) :=\n522 :           Real.log_pos_iff (x := (beta : ℝ)) (le_of_lt (by exact_mod_cast hbposℤ))\n523 :         exact this.mpr hb_gt1R\n524 :       have hlog_le : Real.log (abs x) ≤ Real.log ((beta : ℝ) ^ ex) :=\n525 :         Real.log_le_log hxpos (le_of_lt hx)\n526 :       have hlog_zpow_ex : Real.log ((beta : ℝ) ^ ex) = (ex : ℝ) * Real.log (beta : ℝ) := by\n527 :         simpa using Real.log_zpow hbposR ex\n528 :       set L : ℝ := Real.log (abs x) / Real.log (beta : ℝ)\n529 :       have hL_mul : L * Real.log (beta : ℝ) = Real.log (abs x) := by\n530 :         have hne : Real.log (beta : ℝ) ≠ 0 := ne_of_gt hlogβ_pos\n531 :         calc\n532 :           L * Real.log (beta : ℝ)\n533 :               = (Real.log (abs x) / Real.log (beta : ℝ)) * Real.log (beta : ℝ) := by rfl\n534 :           _   = Real.log (abs x) := by simpa [hne] using (mul_div_cancel' (Real.log (abs x)) (Real.log (beta : ℝ)))\n535 :       have hL_le_ex : L ≤ (ex : ℝ) := by\n536 :         have hmul_le : L * Real.log (beta : ℝ) ≤ (ex : ℝ) * Real.log (beta : ℝ) := by\n537 :           simpa [hL_mul, hlog_zpow_ex] using hlog_le\n538 :         exact (le_of_mul_le_mul_right hmul_le hlogβ_pos)\n539 :       have hceil_le : Int.ceil L ≤ ex := Int.ceil_le.mpr hL_le_ex\n540 :       have hmageq : mag beta x = Int.ceil L := by\n541 :         unfold FloatSpec.Core.Generic_fmt.mag\n542 :         simp [hx0, L]\n543 :       simpa [hmageq]\n544 :     -- Small-regime constancy: mag x ≤ ex ≤ fexp ex ⇒ fexp (mag x) = fexp ex\n545 :     have hconst := (FloatSpec.Core.Generic_fmt.Valid_exp.valid_exp (beta := beta) (fexp := fexp) ex).right he |>.right\n546 :     have heq_fexp : fexp (mag beta x) = fexp ex := hconst (mag beta x) (le_trans hmag_le_ex he)\n547 :     -- Now rewrite scaled mantissa using fexp ex\n548 :     have hpos_scale : 0 < (beta : ℝ) ^ (-(fexp ex)) := zpow_pos (by exact_mod_cast hbposℤ) _\n549 :     have hnonneg_scale : 0 ≤ (beta : ℝ) ^ (-(fexp ex)) := le_of_lt hpos_scale\n550 :     have h1sm : (scaled_mantissa beta fexp x).run = x * (beta : ℝ) ^ (-(fexp ex)) := by\n551 :       unfold FloatSpec.Core.Generic_fmt.scaled_mantissa FloatSpec.Core.Generic_fmt.cexp\n552 :       simp [heq_fexp]\n553 :     have hsm_abs : abs (scaled_mantissa beta fexp x).run = abs x * (beta : ℝ) ^ (-(fexp ex)) := by\n554 :       rw [h1sm, abs_mul, abs_of_nonneg hnonneg_scale]\n555 :     -- Multiply the strict bound by a positive factor\n556 :     have hmul_lt : abs x * (beta : ℝ) ^ (-(fexp ex)) < (beta : ℝ) ^ ex * (beta : ℝ) ^ (-(fexp ex)) :=\n557 :       mul_lt_mul_of_pos_right hx hpos_scale\n558 :     -- Combine exponents and bound by 1 using ex ≤ fexp ex\n559 :     have hmul_pow : (beta : ℝ) ^ ex * (beta : ℝ) ^ (-(fexp ex)) = (beta : ℝ) ^ (ex - fexp ex) := by\n560 :       simpa [sub_eq_add_neg] using (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) (hbne := hbne) (e := ex) (c := fexp ex))\n561 :     have hk_nonneg : 0 ≤ fexp ex - ex := sub_nonneg.mpr he\n562 :     -- For β ≥ 1, 1 ≤ β^(fexp ex - ex)\n563 :     have hone_le : (1 : ℝ) ≤ (beta : ℝ) ^ (fexp ex - ex) := by\n564 :       -- rewrite to Nat power and apply induction\n565 :       have hzpow_toNat : (beta : ℝ) ^ (fexp ex - ex) = (beta : ℝ) ^ (Int.toNat (fexp ex - ex)) := by\n566 :         simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (fexp ex - ex) hk_nonneg\n567 :       have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n568 :       have hb_ge1 : (1 : ℝ) ≤ (beta : ℝ) := hb_gt1R.le\n569 :       -- 1 ≤ β^n for all n\n570 :       have one_le_pow_nat : ∀ n : Nat, (1 : ℝ) ≤ (beta : ℝ) ^ n := by\n571 :         intro n; induction n with\n572 :         | zero => simp\n573 :         | succ n ih =>\n574 :             have hpow_nonneg : 0 ≤ (beta : ℝ) ^ n := pow_nonneg (le_of_lt (by exact_mod_cast hbposℤ)) n\n575 :             have : (1 : ℝ) * 1 ≤ (beta : ℝ) ^ n * (beta : ℝ) := mul_le_mul ih hb_ge1 (by norm_num) hpow_nonneg\n576 :             simpa [pow_succ] using this\n577 :       simpa [hzpow_toNat] using one_le_pow_nat (Int.toNat (fexp ex - ex))\n578 :     -- Multiply both sides by β^(ex - fexp ex) ≥ 0 to bound by 1\n579 :     have hfac_nonneg : 0 ≤ (beta : ℝ) ^ (ex - fexp ex) := le_of_lt (zpow_pos (by exact_mod_cast hbposℤ) _)\n580 :     have hle_one : (beta : ℝ) ^ (ex - fexp ex) ≤ 1 := by\n581 :       have hid : (beta : ℝ) ^ (ex - fexp ex) * (beta : ℝ) ^ (fexp ex - ex) = 1 := by\n582 :         simpa [sub_eq_add_neg, add_comm, add_left_comm, add_assoc] using (zpow_add₀ hbne (ex - fexp ex) (fexp ex - ex)).symm\n583 :       have hmul_le := mul_le_mul_of_nonneg_left hone_le hfac_nonneg\n584 :       simpa [hid, one_mul] using hmul_le\n585 :     -- Conclude\n586 :     have hmul_inv_pow : (beta : ℝ) ^ ex * ((beta : ℝ) ^ (fexp ex))⁻¹ = (beta : ℝ) ^ (ex - fexp ex) := by\n587 :       simpa [zpow_neg] using hmul_pow\n588 :     have : abs (scaled_mantissa beta fexp x).run < (beta : ℝ) ^ (ex - fexp ex) := by\n589 :       simpa [hsm_abs, hmul_inv_pow] using hmul_lt\n590 :     exact lt_of_lt_of_le this hle_one\n591 : \n592 : /-- Specification: Scaled mantissa general bound\n593 : \n594 :     The absolute value of scaled mantissa is bounded by\n595 :     beta^(mag(x) - cexp(x)).\n596 : -/\n597 : theorem scaled_mantissa_lt_bpow\n598 :     (beta : Int) (fexp : Int → Int) (x : ℝ)\n599 :     (hβ : 1 < beta) :\n600 :     abs (scaled_mantissa beta fexp x).run ≤ (beta : ℝ) ^ (mag beta x - (cexp beta fexp x).run) := by\n601 :   -- Base positivity for the real base\n602 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n603 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n604 :   have hbneR : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n605 :   -- Notation\n606 :   set e : Int := mag beta x\n607 :   set c : Int := (cexp beta fexp x).run\n608 :   -- Scaled mantissa as a product\n609 :   have hsm : (scaled_mantissa beta fexp x).run = x * (beta : ℝ) ^ (-c) := by\n610 :     unfold FloatSpec.Core.Generic_fmt.scaled_mantissa FloatSpec.Core.Generic_fmt.cexp\n611 :     rfl\n612 :   -- Positivity of the scaling factor\n613 :   have hscale_pos : 0 < (beta : ℝ) ^ (-c) := zpow_pos hbposR _\n614 :   have hscale_nonneg : 0 ≤ (beta : ℝ) ^ (-c) := le_of_lt hscale_pos\n615 :   -- Bound abs x by β^e\n616 :   have h_upper_abs : abs x ≤ (beta : ℝ) ^ e := by\n617 :     by_cases hx0 : x = 0\n618 :     · have : 0 ≤ (beta : ℝ) ^ e := le_of_lt (zpow_pos hbposR _)\n619 :       simpa [hx0, abs_zero] using this\n620 :     · have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n621 :       have hlogβ_pos : 0 < Real.log (beta : ℝ) :=\n622 :         (Real.log_pos_iff (x := (beta : ℝ)) (le_of_lt hbposR)).mpr hb_gt1R\n623 :       have hxpos : 0 < abs x := abs_pos.mpr hx0\n624 :       set L : ℝ := Real.log (abs x) / Real.log (beta : ℝ)\n625 :       have hmageq : e = Int.ceil L := by\n626 :         have : mag beta x = Int.ceil L := by\n627 :           unfold FloatSpec.Core.Generic_fmt.mag\n628 :           simp [hx0, L]\n629 :         simpa [e] using this\n630 :       have hceil_ge : (L : ℝ) ≤ (Int.ceil L : ℝ) := by exact_mod_cast Int.le_ceil L\n631 :       have hmul_le : L * Real.log (beta : ℝ) ≤ (Int.ceil L : ℝ) * Real.log (beta : ℝ) :=\n632 :         mul_le_mul_of_nonneg_right hceil_ge (le_of_lt hlogβ_pos)\n633 :       have hL_mul : L * Real.log (beta : ℝ) = Real.log (abs x) := by\n634 :         have hne : Real.log (beta : ℝ) ≠ 0 := ne_of_gt hlogβ_pos\n635 :         calc\n636 :           L * Real.log (beta : ℝ)\n637 :               = (Real.log (abs x) / Real.log (beta : ℝ)) * Real.log (beta : ℝ) := by rfl\n638 :           _   = Real.log (abs x) := by simpa [hne] using (mul_div_cancel' (Real.log (abs x)) (Real.log (beta : ℝ)))\n639 :       -- Relate log(β^e) to e * log β\n640 :       have hlog_zpow_e : Real.log ((beta : ℝ) ^ e) = (e : ℝ) * Real.log (beta : ℝ) := by\n641 :         simpa using Real.log_zpow hbposR e\n642 :       -- Get the desired log inequality in the form log |x| ≤ log(β^e)\n643 :       have hlog_le : Real.log (abs x) ≤ Real.log ((beta : ℝ) ^ e) := by\n644 :         have : Real.log (abs x) ≤ (e : ℝ) * Real.log (beta : ℝ) := by\n645 :           simpa [hL_mul, hmageq] using hmul_le\n646 :         simpa [hlog_zpow_e] using this\n647 :       -- convert back via exp monotonicity\n648 :       have hxpos' : 0 < abs x := hxpos\n649 :       -- Move to exponentials, rewriting to `exp (e * log β)` to avoid simp changing forms later\n650 :       have h_exp_le : abs x ≤ Real.exp ((e : ℝ) * Real.log (beta : ℝ)) := by\n651 :         have := (Real.log_le_iff_le_exp hxpos').1 hlog_le\n652 :         simpa [hlog_zpow_e] using this\n653 :       -- Show `exp (e * log β) = β^e` and conclude\n654 :       have hypos : 0 < (beta : ℝ) ^ e := zpow_pos hbposR _\n655 :       have h_exp_eq_pow : Real.exp ((e : ℝ) * Real.log (beta : ℝ)) = (beta : ℝ) ^ e := by\n656 :         have : Real.exp (Real.log ((beta : ℝ) ^ e)) = (beta : ℝ) ^ e := Real.exp_log hypos\n657 :         simpa [hlog_zpow_e] using this\n658 :       exact by simpa [h_exp_eq_pow]\n659 :         using h_exp_le\n660 :   -- Multiply by the positive scaling factor and collapse the RHS product\n661 :   have habs_pow : abs ((beta : ℝ) ^ (-c)) = (beta : ℝ) ^ (-c) := abs_of_nonneg hscale_nonneg\n662 :   have habs_scaled_tmp : abs (scaled_mantissa beta fexp x).run = abs (x * (beta : ℝ) ^ (-c)) := by\n663 :     simpa [hsm]\n664 :   -- Rewrite |β^(-c)| as |β^c|⁻¹ and then drop abs using nonnegativity of β^c\n665 :   have hpow_c_pos : 0 < (beta : ℝ) ^ c := zpow_pos hbposR _\n666 :   have hpow_c_nonneg : 0 ≤ (beta : ℝ) ^ c := le_of_lt hpow_c_pos\n667 :   have hscale_inv_nonneg : 0 ≤ ((beta : ℝ) ^ c)⁻¹ := inv_nonneg.mpr (le_of_lt hpow_c_pos)\n668 :   have habs_scaled : abs (scaled_mantissa beta fexp x).run = abs x * ((beta : ℝ) ^ c)⁻¹ := by\n669 :     -- |x * β^(-c)| = |x| * |β^(-c)| = |x| * |(β^c)⁻¹| = |x| * |β^c|⁻¹\n670 :     -- and since β^c ≥ 0, |β^c| = β^c\n671 :     have : abs (scaled_mantissa beta fexp x).run = abs x * (abs ((beta : ℝ) ^ c))⁻¹ := by\n672 :       simpa [abs_mul, zpow_neg] using habs_scaled_tmp\n673 :     simpa [abs_of_nonneg hpow_c_nonneg] using this\n674 :   have hmul : (beta : ℝ) ^ e * (beta : ℝ) ^ (-c) = (beta : ℝ) ^ (e - c) := by\n675 :     simpa [sub_eq_add_neg]\n676 :       using (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) (hbne := hbneR) (e := e) (c := c))\n677 :   -- Combine the pieces and collapse the RHS product\n678 :   calc\n679 :     abs (scaled_mantissa beta fexp x).run\n680 :         = abs x * ((beta : ℝ) ^ c)⁻¹ := habs_scaled\n681 :     _   ≤ (beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹ := mul_le_mul_of_nonneg_right h_upper_abs hscale_inv_nonneg\n682 :     _   = (beta : ℝ) ^ (e - c) := by\n683 :           simpa [zpow_neg] using\n684 :             (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) (hbne := hbneR) (e := e) (c := c))\n685 : \n686 : /-- Specification: Generic format is closed under rounding down\n687 : \n688 :     For any x, there exists a value f in generic format\n689 :     that is the rounding down of x.\n690 : -/\n691 : theorem generic_format_round_DN (beta : Int) (hbeta : 1 < beta) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n692 :     ∃ f, (generic_format beta fexp f).run ∧ Rnd_DN_pt (fun y => (generic_format beta fexp y).run) x f := by\n693 :   -- Derive DN existence for x from UP existence for -x via negation\n694 :   have hFneg : ∀ y, (generic_format beta fexp y).run → (generic_format beta fexp (-y)).run :=\n695 :     generic_format_neg_closed beta fexp\n696 :   -- Use the UP existence at -x\n697 :   rcases round_UP_exists (beta := beta) (fexp := fexp) (-x) with ⟨fu, hFu, hup⟩\n698 :   -- Transform to DN at x with f = -fu\n699 :   refine ⟨-fu, ?_, ?_⟩\n700 :   · exact hFneg fu hFu\n701 :   · -- Apply the transformation lemma\n702 :     exact Rnd_UP_to_DN_via_neg (F := fun y => (generic_format beta fexp y).run) (x := x) (f := fu)\n703 :       hFneg hup\n704 : \n705 : /-- Specification: Generic format is closed under rounding up\n706 : \n707 :     For any x, there exists a value f in generic format\n708 :     that is the rounding up of x.\n709 : -/\n710 : theorem generic_format_round_UP (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n711 :     ∃ f, (generic_format beta fexp f).run ∧ Rnd_UP_pt (fun y => (generic_format beta fexp y).run) x f := by\n712 :   -- Use the (temporary) existence axiom to obtain a witness.\n713 :   exact round_UP_exists beta fexp x\n714 : \n715 : /-- Specification: Precision bounds for generic format\n716 : \n717 :     For non-zero x in generic format, the scaled mantissa\n718 :     is bounded by beta^(mag(x) - cexp(x)).\n719 : -/\n720 : theorem generic_format_precision_bound\n721 :     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp]\n722 :     (x : ℝ) (h : (generic_format beta fexp x).run) (hx : x ≠ 0)\n723 :     (hβ : 1 < beta) :\n724 :     abs (scaled_mantissa beta fexp x).run ≤ (beta : ℝ) ^ (mag beta x - (cexp beta fexp x).run) := by\n725 :   -- Use the general bound for scaled mantissa\n726 :   exact scaled_mantissa_lt_bpow (beta := beta) (fexp := fexp) (x := x) hβ\n727 : \n728 : /-- Specification: Exponent monotonicity\n729 : \n730 :     The exponent function is monotone.\n731 : -/\n732 : theorem fexp_monotone (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] :\n733 :     ∀ e1 e2 : Int, e1 ≤ e2 → e2 ≤ fexp e2 → fexp e1 ≤ fexp e2 := by\n734 :   -- Monotonicity holds on the \"small\" regime plateau by constancy\n735 :   intro e1 e2 hle hsmall\n736 :   -- From small-regime constancy at k = e2, any l ≤ fexp e2 has the same fexp\n737 :   have hpair := (FloatSpec.Core.Generic_fmt.Valid_exp.valid_exp (beta := beta) (fexp := fexp) e2)\n738 :   have hconst := (hpair.right hsmall).right\n739 :   -- Since e1 ≤ e2 ≤ fexp e2, we get fexp e1 = fexp e2 in particular\n740 :   have : fexp e1 = fexp e2 := by\n741 :     have : e1 ≤ fexp e2 := le_trans hle hsmall\n742 :     simpa using hconst e1 this\n743 :   simpa [this]\n744 : \n745 : /-- Specification: Format equivalence under exponent bounds\n746 : \n747 :     If x is in format with constant exponent e1,\n748 :     and e1 ≤ e2, then x is in format with exponent e2.\n749 : -/\n750 : theorem generic_format_equiv (beta : Int) (x : ℝ) (e1 e2 : Int) :\n751 :     ⦃⌜1 < beta ∧ e2 ≤ e1 ∧ (generic_format beta (fun _ => e1) x).run⌝⦄\n752 :     generic_format beta (fun _ => e2) x\n753 :     ⦃⇓result => ⌜result⌝⦄ := by\n754 :   intro h\n755 :   rcases h with ⟨hβ, hle, hx_fmt⟩\n756 :   -- Base positivity and nonzeroness for zpow lemmas\n757 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n758 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n759 :   have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n760 :   -- Unpack the format equality at exponent e1\n761 :   have hx : x = ((Ztrunc (x * (beta : ℝ) ^ (-(e1))) : Int) : ℝ) * (beta : ℝ) ^ e1 := by\n762 :     simpa [generic_format, scaled_mantissa, cexp, F2R] using hx_fmt\n763 :   -- Target goal after unfolding the generic_format at exponent e2\n764 :   -- will be an equality; we set up the necessary arithmetic\n765 :   simp only [generic_format, scaled_mantissa, cexp, F2R]\n766 :   -- Notations\n767 :   set m1 : Int := Ztrunc (x * (beta : ℝ) ^ (-(e1))) with hm1\n768 :   have hx' : x = (m1 : ℝ) * (beta : ℝ) ^ e1 := by simpa [hm1] using hx\n769 :   -- Let k = e1 - e2 ≥ 0\n770 :   set k : Int := e1 - e2\n771 :   have hk_nonneg : 0 ≤ k := sub_nonneg.mpr hle\n772 :   -- Combine powers: β^e1 * β^(-e2) = β^(e1 - e2)\n773 :   have hmul_pow : (beta : ℝ) ^ e1 * ((beta : ℝ) ^ e2)⁻¹ = (beta : ℝ) ^ (e1 - e2) := by\n774 :     simpa [zpow_neg] using\n775 :       (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) (hbne := hbne) (e := e1) (c := e2))\n776 :   -- Express β^(e1 - e2) with a Nat exponent\n777 :   have hzpow_toNat : (beta : ℝ) ^ (e1 - e2) = (beta : ℝ) ^ (Int.toNat (e1 - e2)) := by\n778 :     simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (e1 - e2) hk_nonneg\n779 :   -- Cast Int power to real power\n780 :   have hcast_pow : (beta : ℝ) ^ (Int.toNat (e1 - e2)) = ((beta ^ (Int.toNat (e1 - e2)) : Int) : ℝ) := by\n781 :     rw [← Int.cast_pow]\n782 :   -- Compute the truncation at exponent e2\n783 :   have htrunc :\n784 :       Ztrunc (x * (beta : ℝ) ^ (-(e2))) = m1 * beta ^ (Int.toNat (e1 - e2)) := by\n785 :     calc\n786 :       Ztrunc (x * (beta : ℝ) ^ (-(e2)))\n787 :           = Ztrunc (((m1 : ℝ) * (beta : ℝ) ^ e1) * (beta : ℝ) ^ (-(e2))) := by\n788 :                 simpa [hx']\n789 :       _   = Ztrunc ((m1 : ℝ) * ((beta : ℝ) ^ e1 * (beta : ℝ) ^ (-(e2)))) := by ring_nf\n790 :       _   = Ztrunc ((m1 : ℝ) * ((beta : ℝ) ^ (e1 - e2))) := by\n791 :                 simpa [hmul_pow]\n792 :       _   = Ztrunc ((m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (e1 - e2)))) := by\n793 :                 simpa [hzpow_toNat]\n794 :       _   = Ztrunc (((m1 * beta ^ (Int.toNat (e1 - e2))) : Int) : ℝ) := by\n795 :                 -- Avoid deep simp recursion: rewrite the inside once, then fold\n796 :                 have hmulcast :\n797 :                     (m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (e1 - e2)))\n798 :                       = (((m1 * beta ^ (Int.toNat (e1 - e2))) : Int) : ℝ) := by\n799 :                   simp only [hcast_pow, Int.cast_mul]\n800 :                 simpa only [hmulcast]\n801 :       _   = m1 * beta ^ (Int.toNat (e1 - e2)) := FloatSpec.Core.Generic_fmt.Ztrunc_intCast _\n802 :   -- Split power to reconstruct x at exponent e2\n803 :   have hsplit : (beta : ℝ) ^ e1 = (beta : ℝ) ^ (e1 - e2) * (beta : ℝ) ^ e2 := by\n804 :     -- zpow_sub_add states (a^(e-c))*a^c = a^e; flip orientation\n805 :     simpa using (FloatSpec.Core.Generic_fmt.zpow_sub_add (a := (beta : ℝ)) (hbne := hbne) (e := e1) (c := e2)).symm\n806 :   -- Finish: rebuild x directly in the required orientation\n807 :   -- Goal after simp is: x = ((Ztrunc (x * β^(-e2)) : ℝ)) * β^e2\n808 :   -- We derive the right-hand side from the representation at e1\n809 :   calc\n810 :     x = (m1 : ℝ) * (beta : ℝ) ^ e1 := by simpa [hx']\n811 :     _ = (m1 : ℝ) * ((beta : ℝ) ^ (e1 - e2) * (beta : ℝ) ^ e2) := by\n812 :           rw [hsplit]\n813 :     _ = ((m1 : ℝ) * (beta : ℝ) ^ (e1 - e2)) * (beta : ℝ) ^ e2 := by ring\n814 :     _ = ((m1 : ℝ) * (beta : ℝ) ^ (Int.toNat (e1 - e2))) * (beta : ℝ) ^ e2 := by\n815 :           rw [hzpow_toNat]\n816 :     _ = (((m1 * beta ^ (Int.toNat (e1 - e2))) : Int) : ℝ) * (beta : ℝ) ^ e2 := by\n817 :           -- cast the integer product back to ℝ without triggering heavy simp recursion\n818 :           have : ((m1 * beta ^ (Int.toNat (e1 - e2)) : Int) : ℝ)\n819 :                     = (m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (e1 - e2))) := by\n820 :             calc\n821 :               ((m1 * beta ^ (Int.toNat (e1 - e2)) : Int) : ℝ)\n822 :                   = ((m1 : Int) : ℝ) * ((beta ^ (Int.toNat (e1 - e2)) : Int) : ℝ) := by\n823 :                         simp [Int.cast_mul]\n824 :               _   = (m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (e1 - e2))) := by\n825 :                         rw [hcast_pow]\n826 :           rw [this]\n827 :     _ = ((Ztrunc (x * (beta : ℝ) ^ (-(e2))) : Int) : ℝ) * (beta : ℝ) ^ e2 := by\n828 :           -- rewrite back using the computed truncation at e2\n829 :           have hZ' : ((m1 * beta ^ (Int.toNat (e1 - e2)) : Int) : ℝ)\n830 :                         = ((Ztrunc (x * (beta : ℝ) ^ (-(e2))) : Int) : ℝ) := by\n831 :             -- cast both sides of htrunc to ℝ (in reverse orientation)\n832 :             exact (congrArg (fun z : Int => (z : ℝ)) htrunc).symm\n833 :           -- replace the casted integer with the Ztrunc expression\n834 :           rw [hZ']\n835 : \n836 : /-- Generic format from rounding -/\n837 : noncomputable def round_to_generic (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (mode : ℝ → ℝ → Prop) (x : ℝ) : ℝ :=\n838 :   -- Return the rounded value in generic format\n839 :   -- This would use classical choice to select a value satisfying the rounding mode\n840 :   let exp := (cexp beta fexp x).run\n841 :   let mantissa := x * (beta : ℝ) ^ (-exp)\n842 :   let rounded_mantissa := Ztrunc mantissa  -- Simple truncation for now\n843 :   (rounded_mantissa : ℝ) * (beta : ℝ) ^ exp\n844 : \n845 : /-- Specification: Round to generic is well-defined\n846 : \n847 :     The result of rounding to generic format is always\n848 :     in the generic format.\n849 : -/\n850 : theorem round_to_generic_spec (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (mode : ℝ → ℝ → Prop) (x : ℝ) :\n851 :     ⦃⌜True⌝⦄\n852 :     (pure (round_to_generic beta fexp mode x) : Id ℝ)\n853 :     ⦃⇓result => ⌜result = (F2R (FlocqFloat.mk (Ztrunc (x * (beta : ℝ) ^ (-(cexp beta fexp x).run))) (cexp beta fexp x).run : FlocqFloat beta)).run⌝⦄ := by\n854 :   intro _\n855 :   -- Unfold the rounding function; this is a direct reconstruction\n856 :   unfold round_to_generic\n857 :   simp [F2R]\n858 : \n859 : /-- Specification: Intersection is a generic format\n860 : \n861 :     The intersection of two generic formats can be\n862 :     represented as another generic format.\n863 : -/\n864 : theorem generic_format_inter_valid (beta : Int) (fexp1 fexp2 : Int → Int)\n865 :     [Valid_exp beta fexp1] [Valid_exp beta fexp2]\n866 :     (hβ : 1 < beta) :\n867 :     ∃ fexp3, ∀ x, generic_format_inter beta fexp1 fexp2 x → (generic_format beta fexp3 x).run := by\n868 :   -- We can realize the intersection inside a single generic format by\n869 :   -- choosing the pointwise minimum exponent function.\n870 :   refine ⟨(fun k => min (fexp1 k) (fexp2 k)), ?_⟩\n871 :   intro x hx\n872 :   rcases hx with ⟨hx1, hx2⟩\n873 :   -- Let c1, c2 be the canonical exponents for each format, and c3 their min.\n874 :   set c1 : Int := fexp1 (mag beta x)\n875 :   set c2 : Int := fexp2 (mag beta x)\n876 :   set c3 : Int := min c1 c2\n877 :   -- Denote the integer mantissas provided by each format\n878 :   have hx1' : x = ((Ztrunc (x * (beta : ℝ) ^ (-(c1))) : Int) : ℝ) * (beta : ℝ) ^ c1 := by\n879 :     simpa [generic_format, scaled_mantissa, cexp, F2R, c1] using hx1\n880 :   have hx2' : x = ((Ztrunc (x * (beta : ℝ) ^ (-(c2))) : Int) : ℝ) * (beta : ℝ) ^ c2 := by\n881 :     simpa [generic_format, scaled_mantissa, cexp, F2R, c2] using hx2\n882 :   -- Take m1 from the first representation; since c3 ≤ c1, we can reconstruct at c3\n883 :   set m1 : Int := Ztrunc (x * (beta : ℝ) ^ (-(c1))) with hm1\n884 :   have hc3_le_c1 : c3 ≤ c1 := by simpa [c3] using (min_le_left c1 c2)\n885 :   -- Base positivity for zpow identities\n886 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n887 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n888 :   have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n889 :   -- Combine the powers: β^c1 * β^(-c3) = β^(c1 - c3)\n890 :   have hmul_pow : (beta : ℝ) ^ c1 * (beta : ℝ) ^ (-(c3)) = (beta : ℝ) ^ (c1 - c3) := by\n891 :     simpa [sub_eq_add_neg] using (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) (hbne := hbne) (e := c1) (c := c3))\n892 :   -- Nonnegativity of the exponent difference\n893 :   have hdiff_nonneg : 0 ≤ c1 - c3 := sub_nonneg.mpr hc3_le_c1\n894 :   -- Convert to Nat power on nonnegative exponents\n895 :   have hzpow_toNat : (beta : ℝ) ^ (c1 - c3) = (beta : ℝ) ^ (Int.toNat (c1 - c3)) := by\n896 :     simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (c1 - c3) hdiff_nonneg\n897 :   -- Cast Int power to real power of Int\n898 :   have hcast_pow : (beta : ℝ) ^ (Int.toNat (c1 - c3)) = ((beta ^ (Int.toNat (c1 - c3)) : Int) : ℝ) := by\n899 :     rw [← Int.cast_pow]\n900 :   -- Compute the truncation at exponent c3 using the c1-representation\n901 :   have htrunc_c3 :\n902 :       Ztrunc (x * (beta : ℝ) ^ (-(c3))) = m1 * beta ^ (Int.toNat (c1 - c3)) := by\n903 :     -- First, rewrite the argument using the c1-representation of x without heavy simp\n904 :     have hx_mul := congrArg (fun t : ℝ => t * (beta : ℝ) ^ (-(c3))) hx1'\n905 :     have hx_mul' : x * (beta : ℝ) ^ (-(c3)) = ((m1 : ℝ) * (beta : ℝ) ^ c1) * (beta : ℝ) ^ (-(c3)) := by\n906 :       simpa [hm1, mul_comm, mul_left_comm, mul_assoc] using hx_mul\n907 :     have hZeq : Ztrunc (x * (beta : ℝ) ^ (-(c3)))\n908 :                 = Ztrunc (((m1 : ℝ) * (beta : ℝ) ^ c1) * (beta : ℝ) ^ (-(c3))) :=\n909 :       congrArg Ztrunc hx_mul'\n910 :     calc\n911 :       Ztrunc (x * (beta : ℝ) ^ (-(c3)))\n912 :           = Ztrunc (((m1 : ℝ) * (beta : ℝ) ^ c1) * (beta : ℝ) ^ (-(c3))) := hZeq\n913 :       _   = Ztrunc ((m1 : ℝ) * ((beta : ℝ) ^ c1 * (beta : ℝ) ^ (-(c3)))) := by ring_nf\n914 :       _   = Ztrunc ((m1 : ℝ) * ((beta : ℝ) ^ (c1 - c3))) := by\n915 :                 -- Apply the zpow product identity inside Ztrunc\n916 :                 simpa [zpow_neg]\n917 :                   using congrArg (fun t => Ztrunc ((m1 : ℝ) * t)) hmul_pow\n918 :       _   = Ztrunc ((m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (c1 - c3)))) := by\n919 :                 simpa [hzpow_toNat]\n920 :       _   = Ztrunc (((m1 * beta ^ (Int.toNat (c1 - c3))) : Int) : ℝ) := by\n921 :                 -- Avoid deep simp recursion: rewrite the inside once, then fold\n922 :                 have hmulcast :\n923 :                     (m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (c1 - c3)))\n924 :                       = (((m1 * beta ^ (Int.toNat (c1 - c3))) : Int) : ℝ) := by\n925 :                   simp only [hcast_pow, Int.cast_mul]\n926 :                 simpa only [hmulcast]\n927 :       _   = m1 * beta ^ (Int.toNat (c1 - c3)) := FloatSpec.Core.Generic_fmt.Ztrunc_intCast _\n928 :   -- Split the power to reconstruct x at exponent c3\n929 :   have hsplit : (beta : ℝ) ^ c1 = (beta : ℝ) ^ (c1 - c3) * (beta : ℝ) ^ c3 := by\n930 :     simpa [sub_add_cancel] using\n931 :       (FloatSpec.Core.Generic_fmt.zpow_sub_add (a := (beta : ℝ)) (hbne := hbne) (e := c1) (c := c3)).symm\n932 :   -- Conclude the generic_format for fexp3 at x\n933 :   -- Unfold target generic_format with fexp3 = min fexp1 fexp2, so exponent is c3\n934 :   -- Build the required reconstruction equality and finish by unfolding generic_format\n935 :   have hrecon : x = ((Ztrunc (x * (beta : ℝ) ^ (-(c3))) : Int) : ℝ) * (beta : ℝ) ^ c3 := by\n936 :     calc\n937 :       x = (m1 : ℝ) * (beta : ℝ) ^ c1 := by simpa [hm1] using hx1'\n938 :       _ = (m1 : ℝ) * ((beta : ℝ) ^ (c1 - c3) * (beta : ℝ) ^ c3) := by rw [hsplit]\n939 :       _ = ((m1 : ℝ) * (beta : ℝ) ^ (c1 - c3)) * (beta : ℝ) ^ c3 := by ring\n940 :       _ = ((m1 : ℝ) * (beta : ℝ) ^ (Int.toNat (c1 - c3))) * (beta : ℝ) ^ c3 := by\n941 :             simpa [hzpow_toNat]\n942 :       _ = (((m1 * beta ^ (Int.toNat (c1 - c3))) : Int) : ℝ) * (beta : ℝ) ^ c3 := by\n943 :             -- cast the integer product back to ℝ without triggering heavy simp recursion\n944 :             have : ((m1 * beta ^ (Int.toNat (c1 - c3)) : Int) : ℝ)\n945 :                       = (m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (c1 - c3))) := by\n946 :               calc\n947 :                 ((m1 * beta ^ (Int.toNat (c1 - c3)) : Int) : ℝ)\n948 :                     = ((m1 : Int) : ℝ) * ((beta ^ (Int.toNat (c1 - c3)) : Int) : ℝ) := by\n949 :                           simp [Int.cast_mul]\n950 :                 _   = (m1 : ℝ) * ((beta : ℝ) ^ (Int.toNat (c1 - c3))) := by\n951 :                           rw [hcast_pow]\n952 :             rw [this]\n953 :       _ = ((Ztrunc (x * (beta : ℝ) ^ (-(c3))) : Int) : ℝ) * (beta : ℝ) ^ c3 := by\n954 :             -- rewrite back using the computed truncation at c3\n955 :             have hZ' : ((m1 * beta ^ (Int.toNat (c1 - c3)) : Int) : ℝ)\n956 :                           = ((Ztrunc (x * (beta : ℝ) ^ (-(c3))) : Int) : ℝ) := by\n957 :               -- cast both sides of htrunc_c3 to ℝ (in reverse orientation)\n958 :               exact (congrArg (fun z : Int => (z : ℝ)) htrunc_c3).symm\n959 :             -- replace the casted integer with the Ztrunc expression\n960 :             rw [hZ']\n961 :   -- Conclude generic_format by unfolding\n962 :   have : (generic_format beta (fun k => min (fexp1 k) (fexp2 k)) x).run := by\n963 :     -- Make the canonical exponent explicit: it equals c3 by definition\n964 :     have hcexp_min : (cexp beta (fun k => min (fexp1 k) (fexp2 k)) x).run = c3 := by\n965 :       simp [FloatSpec.Core.Generic_fmt.cexp, c1, c2, c3]\n966 :     -- Now unfold and rewrite to the reconstruction equality\n967 :     simp only [generic_format, scaled_mantissa, cexp, F2R, hcexp_min]\n968 :     -- Goal reduces exactly to the reconstruction equality\n969 :     simpa using hrecon\n970 :   simpa using this\n971 : \n972 : /-- Specification: Magnitude is compatible with generic format\n973 : \n974 :     For non-zero x in generic format, the exponent function\n975 :     satisfies fexp(mag(x) + 1) ≤ mag(x).\n976 : -/\n977 : theorem mag_generic_format (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp]\n978 :     (x : ℝ) (h : (generic_format beta fexp x).run) (hx : x ≠ 0)\n979 :     (hβ : 1 < beta) :\n980 :     fexp (mag beta x + 1) ≤ mag beta x := by\n981 :   -- Notations\n982 :   set k : Int := mag beta x\n983 :   set e : Int := fexp k\n984 :   -- Base positivity facts\n985 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n986 :   have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n987 :   have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ\n988 :   have hb_ge1 : (1 : ℝ) ≤ (beta : ℝ) := hb_gt1R.le\n989 :   -- Scaled mantissa is integer-valued for numbers in format\n990 :   have hsm_int := (scaled_mantissa_generic (beta := beta) (fexp := fexp) (x := x)) h\n991 :   set mR : ℝ := (scaled_mantissa beta fexp x).run\n992 :   have hmR_eq : mR = (Ztrunc mR : Int) := by simpa [mR] using hsm_int\n993 :   -- Reconstruction equality: x = (Ztrunc mR) * β^e\n994 :   have hx_recon : x = ((Ztrunc mR : Int) : ℝ) * (beta : ℝ) ^ e := by\n995 :     have hfmt := h\n996 :     -- Note: (scaled_mantissa beta fexp x).run = x * β^(-e) by definition of e, k\n997 :     simpa [generic_format, scaled_mantissa, FloatSpec.Core.Generic_fmt.cexp, F2R, k, e, mR] using hfmt\n998 :   -- mR ≠ 0, otherwise x would be 0\n999 :   have hmR_ne : mR ≠ 0 := by\n1000:     intro h0\n1001:     have : Ztrunc mR = 0 := by simpa [h0, FloatSpec.Core.Generic_fmt.Ztrunc_zero] using congrArg Ztrunc h0\n1002:     have : x = 0 := by simpa [this] using hx_recon\n1003:     exact hx this\n1004:   -- From hmR_eq and hmR_ne, |mR| ≥ 1\n1005:   have h_abs_mR_ge1 : (1 : ℝ) ≤ abs mR := by\n1006:     -- mR equals an integer z ≠ 0\n1007:     set z : Int := Ztrunc mR\n1008:     have hmR_eq' : mR = (z : ℝ) := by simpa [z] using hmR_eq\n1009:     have hz_ne : z ≠ 0 := by\n1010:       intro hz\n1011:       exact hmR_ne (by simpa [hmR_eq', hz])\n1012:     -- case analysis on sign of z\n1013:     by_cases hz_nonneg : 0 ≤ z\n1014:     · -- z ≥ 0 and z ≠ 0 ⇒ 1 ≤ z\n1015:       have hz_pos : 0 < z := lt_of_le_of_ne hz_nonneg (by simpa [eq_comm] using hz_ne)\n1016:       have hz_one_le : (1 : Int) ≤ z := (Int.add_one_le_iff).mpr hz_pos\n1017:       have hz_one_leR : (1 : ℝ) ≤ (z : ℝ) := by exact_mod_cast hz_one_le\n1018:       have habs : abs mR = (z : ℝ) := by simpa [hmR_eq', abs_of_nonneg (by exact_mod_cast hz_nonneg)]\n1019:       simpa [habs]\n1020:     · -- z ≤ 0 and z ≠ 0 ⇒ 1 ≤ -z\n1021:       have hz_le : z ≤ 0 := le_of_not_ge hz_nonneg\n1022:       have hz_lt : z < 0 := lt_of_le_of_ne hz_le (by simpa [hz_ne])\n1023:       have hpos_negz : 0 < -z := Int.neg_pos.mpr hz_lt\n1024:       have hone_le_negz : (1 : Int) ≤ -z := (Int.add_one_le_iff).mpr hpos_negz\n1025:       have hone_le_negzR : (1 : ℝ) ≤ (-z : ℝ) := by exact_mod_cast hone_le_negz\n1026:       have habs : abs mR = (-z : ℝ) := by\n1027:         have hzleR : (z : ℝ) ≤ 0 := by exact_mod_cast hz_le\n1028:         have : abs mR = abs (z : ℝ) := by simpa [hmR_eq']\n1029:         simpa [this, abs_of_nonpos hzleR]\n1030:       simpa [habs] using hone_le_negzR\n1031:   -- General bound: |mR| ≤ β^(k - e)\n1032:   have h_abs_mR_le : abs mR ≤ (beta : ℝ) ^ (k - e) := by\n1033:     -- scaled_mantissa_lt_bpow with hβ, then unfold mR, k, e\n1034:     have := scaled_mantissa_lt_bpow (beta := beta) (fexp := fexp) (x := x) hβ\n1035:     simpa [mR, k, e, FloatSpec.Core.Generic_fmt.cexp] using this\n1036:   -- Hence 1 ≤ β^(k - e)\n1037:   have hone_le_pow : (1 : ℝ) ≤ (beta : ℝ) ^ (k - e) := le_trans h_abs_mR_ge1 h_abs_mR_le\n1038:   -- Show that k - e cannot be negative (else β^(k-e) < 1)\n1039:   have hek_le : e ≤ k := by\n1040:     -- By cases on e ≤ k; derive a contradiction in the negative case.\n1041:     by_cases he_le : e ≤ k\n1042:     · exact he_le\n1043:     · -- he_le is false, so e - k > 0\n1044:       have hpos : 0 < e - k := sub_pos.mpr (lt_of_not_ge he_le)\n1045:       -- Show 1 ≤ (β : ℝ) ^ (e - k - 1)\n1046:       have hone_le_pow_u : (1 : ℝ) ≤ (beta : ℝ) ^ (e - k - 1) := by\n1047:         -- u := e - k - 1 ≥ 0\n1048:         have hu_nonneg : 0 ≤ e - k - 1 := by\n1049:           have : (1 : Int) ≤ e - k := (Int.add_one_le_iff).mpr hpos\n1050:           exact sub_nonneg.mpr this\n1051:         have hzpow_toNat : (beta : ℝ) ^ (e - k - 1) = (beta : ℝ) ^ (Int.toNat (e - k - 1)) := by\n1052:           simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (e - k - 1) hu_nonneg\n1053:         -- 1 ≤ β^n for all n : Nat\n1054:         have one_le_pow_nat : ∀ n : Nat, (1 : ℝ) ≤ (beta : ℝ) ^ n := by\n1055:           intro n; induction n with\n1056:           | zero => simp\n1057:           | succ n ih =>\n1058:               have hpow_nonneg : 0 ≤ (beta : ℝ) ^ n := pow_nonneg (le_of_lt hbposR) n\n1059:               have : (1 : ℝ) * 1 ≤ (beta : ℝ) ^ n * (beta : ℝ) :=\n1060:                 mul_le_mul ih hb_ge1 (by norm_num) hpow_nonneg\n1061:               simpa [pow_succ] using this\n1062:         simpa [hzpow_toNat] using one_le_pow_nat (Int.toNat (e - k - 1))\n1063:       -- From 1 ≤ β^(e-k-1), deduce β ≤ β^(e-k)\n1064:       have hone_le_pow_t : (beta : ℝ) ≤ (beta : ℝ) ^ (e - k) := by\n1065:         have hmul : (1 : ℝ) * (beta : ℝ) ≤ (beta : ℝ) ^ (e - k - 1) * (beta : ℝ) :=\n1066:           mul_le_mul_of_nonneg_right hone_le_pow_u (le_of_lt hbposR)\n1067:         have hpow_add : (beta : ℝ) ^ (e - k - 1) * (beta : ℝ) = (beta : ℝ) ^ (e - k) := by\n1068:           -- β^(u) * β = β^(u+1)\n1069:           have hz := (zpow_add₀ (by exact ne_of_gt hbposR) (e - k - 1) (1 : Int))\n1070:           -- (β : ℝ) ^ ((e - k - 1) + 1) = (β : ℝ) ^ (e - k - 1) * (β : ℝ) ^ 1\n1071:           simpa [add_comm, add_left_comm, add_assoc, zpow_one]\n1072:             using hz.symm\n1073:         simpa [one_mul, hpow_add] using hmul\n1074:       -- Therefore 1 < β^(e - k)\n1075:       have hone_lt_pow_t : (1 : ℝ) < (beta : ℝ) ^ (e - k) := lt_of_lt_of_le hb_gt1R hone_le_pow_t\n1076:       -- Multiply 1 ≤ β^(k - e) by β^(e - k) > 0 on the left to get β^(e - k) ≤ 1\n1077:       have hpow_pos : 0 < (beta : ℝ) ^ (e - k) := zpow_pos hbposR _\n1078:       have : (beta : ℝ) ^ (e - k) * 1 ≤ (beta : ℝ) ^ (e - k) * (beta : ℝ) ^ (k - e) :=\n1079:         mul_le_mul_of_nonneg_left hone_le_pow hpow_pos.le\n1080:       have hmul_id : (beta : ℝ) ^ (e - k) * (beta : ℝ) ^ (k - e) = 1 := by\n1081:         simpa [add_comm, add_left_comm, add_assoc, zpow_zero]\n1082:           using (zpow_add₀ (by exact ne_of_gt hbposR) (e - k) (k - e)).symm\n1083:       have : (beta : ℝ) ^ (e - k) ≤ 1 := by simpa [hmul_id, one_mul] using this\n1084:       have hfalse : False := (not_le_of_gt hone_lt_pow_t) this\n1085:       exact False.elim hfalse\n1086:   -- Apply Valid_exp at k, splitting on e < k vs e = k\n1087:   have hpair := (Valid_exp.valid_exp (beta := beta) (fexp := fexp) k)\n1088:   by_cases hlt : e < k\n1089:   · -- Large regime at k\n1090:     have : fexp (k + 1) ≤ k := (hpair.left) hlt\n1091:     simpa [k] using this\n1092:   · -- Small regime: e = k\n1093:     have heq : e = k := le_antisymm hek_le (le_of_not_gt hlt)\n1094:     -- From e = k and e = fexp k by definition, we rewrite the small-regime bound\n1095:     have heq_fk : fexp k = k := by simpa [e] using heq\n1096:     have hsmall : k ≤ fexp k := by simpa [heq_fk]\n1097:     have hbound := (hpair.right hsmall).left\n1098:     simpa [heq_fk] using hbound\n1099: \n1100: /-- Specification: Precision characterization\n1101: \n1102:     For non-zero x in generic format, there exists a mantissa m\n1103:     such that x = F2R(m, cexp(x)) with bounded mantissa.\n1104: -/\n1105: theorem precision_generic_format (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp]\n1106:     (x : ℝ) (h : (generic_format beta fexp x).run) (hx : x ≠ 0) (hβ : 1 < beta) :\n1107:     ∃ m : Int,\n1108:       x = (F2R (FlocqFloat.mk m (cexp beta fexp x).run : FlocqFloat beta)).run ∧\n1109:       Int.natAbs m ≤ Int.natAbs beta ^ ((mag beta x - (cexp beta fexp x).run).toNat) := by\n1110:   -- Notations\n1111:   set k : Int := mag beta x\n1112:   set e : Int := (cexp beta fexp x).run\n1113:   -- Define the real scaled mantissa mR and its integer truncation m\n1114:   set mR : ℝ := (scaled_mantissa beta fexp x).run\n1115:   set m : Int := Ztrunc mR\n1116:   -- From generic_format, we get the reconstruction equality with m = Ztrunc mR\n1117:   have hx_recon : x = ((Ztrunc mR : Int) : ℝ) * (beta : ℝ) ^ e := by\n1118:     simpa [generic_format, scaled_mantissa, FloatSpec.Core.Generic_fmt.cexp, F2R, k, e, mR]\n1119:       using h\n1120:   -- The scaled mantissa equals its truncation for numbers in the format\n1121:   have hsm_int := (scaled_mantissa_generic (beta := beta) (fexp := fexp) (x := x)) h\n1122:   have hmR_eq : mR = (Ztrunc mR : Int) := by simpa [mR] using hsm_int\n1123:   -- Conclude mR is exactly the integer m as a real\n1124:   have hmR_int : mR = (m : ℝ) := by simpa [m] using hmR_eq\n1125:   -- Provide the witness mantissa and equality\n1126:   refine ⟨m, ?_, ?_⟩\n1127:   · -- Equality part: rewrite with m\n1128:     simpa [m] using hx_recon\n1129:   · -- Bound on |m|\n1130:     -- Base positivity for using zpow lemmas and absolute values\n1131:     have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n1132:     have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n1133:     have hbneR : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n1134:     -- Nonzero mantissa: otherwise x = 0 via the reconstruction\n1135:     have hm_ne : m ≠ 0 := by\n1136:       intro hm0\n1137:       have : x = 0 := by simpa [m, hm0] using hx_recon\n1138:       exact hx this\n1139:     -- General scaled mantissa bound and rewrite to |m|\n1140:     have h_abs_le : abs mR ≤ (beta : ℝ) ^ (k - e) := by\n1141:       simpa [mR, k, e, FloatSpec.Core.Generic_fmt.cexp]\n1142:         using scaled_mantissa_lt_bpow (beta := beta) (fexp := fexp) (x := x) hβ\n1143:     have h_abs_m_le : abs (m : ℝ) ≤ (beta : ℝ) ^ (k - e) := by simpa [hmR_int] using h_abs_le\n1144:     -- Since m ≠ 0, we have 1 ≤ |m|\n1145:     have hone_le_abs_m : (1 : ℝ) ≤ abs (m : ℝ) := by\n1146:       by_cases hm_nonneg : 0 ≤ m\n1147:       · -- m ≥ 0 and m ≠ 0 ⇒ 1 ≤ m, hence 1 ≤ |m|\n1148:         have hm_pos : 0 < m := lt_of_le_of_ne hm_nonneg (by simpa [eq_comm] using hm_ne)\n1149:         have h1le : (1 : Int) ≤ m := (Int.add_one_le_iff).mpr hm_pos\n1150:         have h1leR : (1 : ℝ) ≤ (m : ℝ) := by exact_mod_cast h1le\n1151:         have : abs (m : ℝ) = (m : ℝ) := by\n1152:           have : 0 ≤ (m : ℝ) := by exact_mod_cast hm_nonneg\n1153:           simpa [abs_of_nonneg this]\n1154:         simpa [this] using h1leR\n1155:       · -- m ≤ 0 and m ≠ 0 ⇒ 1 ≤ -m, hence 1 ≤ |m|\n1156:         have hm_le : m ≤ 0 := le_of_not_ge hm_nonneg\n1157:         have hm_lt : m < 0 := lt_of_le_of_ne hm_le (by simpa using hm_ne)\n1158:         have hpos_negm : 0 < -m := Int.neg_pos.mpr hm_lt\n1159:         have hone_le_negm : (1 : Int) ≤ -m := (Int.add_one_le_iff).mpr hpos_negm\n1160:         have hone_le_negmR : (1 : ℝ) ≤ (-m : ℝ) := by exact_mod_cast hone_le_negm\n1161:         have hzleR : (m : ℝ) ≤ 0 := by exact_mod_cast hm_le\n1162:         have : abs (m : ℝ) = (-m : ℝ) := by simpa [abs_of_nonpos hzleR]\n1163:         simpa [this] using hone_le_negmR\n1164:     -- Thus 1 ≤ β^(k - e), hence k - e ≥ 0 (otherwise β^(k-e) < 1 for β > 1)\n1165:     have hone_le_pow : (1 : ℝ) ≤ (beta : ℝ) ^ (k - e) := le_trans hone_le_abs_m h_abs_m_le\n1166:     have hk_sub_nonneg : 0 ≤ k - e := by\n1167:       -- By contradiction: if e > k, derive a contradiction as in mag_generic_format\n1168:       by_contra hneg\n1169:       -- hneg: ¬ (0 ≤ k - e) ⇔ k < e\n1170:       have hpos : 0 < e - k := by\n1171:         have hklt : k < e := lt_of_not_ge (by simpa [sub_nonneg] using hneg)\n1172:         exact sub_pos.mpr hklt\n1173:       have hone_le_pow_u : (1 : ℝ) ≤ (beta : ℝ) ^ (e - k - 1) := by\n1174:         -- Show nonnegativity of u := e - k - 1 and convert to Nat power\n1175:         have hu_nonneg : 0 ≤ e - k - 1 := by\n1176:           have : (1 : Int) ≤ e - k := (Int.add_one_le_iff).mpr hpos\n1177:           exact sub_nonneg.mpr this\n1178:         have hzpow_toNat : (beta : ℝ) ^ (e - k - 1) = (beta : ℝ) ^ (Int.toNat (e - k - 1)) := by\n1179:           simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (e - k - 1) hu_nonneg\n1180:         -- 1 ≤ β^n for all n : Nat since β ≥ 1\n1181:         have hb_ge1 : (1 : ℝ) ≤ (beta : ℝ) := (by exact_mod_cast hβ : (1 : ℝ) < (beta : ℝ)).le\n1182:         have one_le_pow_nat : ∀ n : Nat, (1 : ℝ) ≤ (beta : ℝ) ^ n := by\n1183:           intro n; induction n with\n1184:           | zero => simp\n1185:           | succ n ih =>\n1186:               have hpow_nonneg : 0 ≤ (beta : ℝ) ^ n :=\n1187:                 pow_nonneg (le_of_lt hbposR) n\n1188:               have : (1 : ℝ) * 1 ≤ (beta : ℝ) ^ n * (beta : ℝ) :=\n1189:                 mul_le_mul ih hb_ge1 (by norm_num) hpow_nonneg\n1190:               simpa [pow_succ] using this\n1191:         simpa [hzpow_toNat] using one_le_pow_nat (Int.toNat (e - k - 1))\n1192:       -- From 1 ≤ β^(e-k-1), deduce β ≤ β^(e-k)\n1193:       have hone_le_pow_t : (beta : ℝ) ≤ (beta : ℝ) ^ (e - k) := by\n1194:         have hmul : (1 : ℝ) * (beta : ℝ) ≤ (beta : ℝ) ^ (e - k - 1) * (beta : ℝ) :=\n1195:           mul_le_mul_of_nonneg_right hone_le_pow_u (le_of_lt hbposR)\n1196:         have hpow_add : (beta : ℝ) ^ (e - k - 1) * (beta : ℝ) = (beta : ℝ) ^ (e - k) := by\n1197:           have hz := (zpow_add₀ (by exact ne_of_gt hbposR) (e - k - 1) (1 : Int))\n1198:           simpa [add_comm, add_left_comm, add_assoc, zpow_one] using hz.symm\n1199:         simpa [one_mul, hpow_add] using hmul\n1200:       have hone_lt_pow_t : (1 : ℝ) < (beta : ℝ) ^ (e - k) := lt_of_lt_of_le (by exact_mod_cast hβ) hone_le_pow_t\n1201:       have hpow_pos : 0 < (beta : ℝ) ^ (e - k) := zpow_pos hbposR _\n1202:       have : (beta : ℝ) ^ (e - k) * 1 ≤ (beta : ℝ) ^ (e - k) * (beta : ℝ) ^ (k - e) :=\n1203:         mul_le_mul_of_nonneg_left hone_le_pow hpow_pos.le\n1204:       have hmul_id : (beta : ℝ) ^ (e - k) * (beta : ℝ) ^ (k - e) = 1 := by\n1205:         simpa [add_comm, add_left_comm, add_assoc, zpow_zero]\n1206:           using (zpow_add₀ (by exact ne_of_gt hbposR) (e - k) (k - e)).symm\n1207:       have hle1 : (beta : ℝ) ^ (e - k) ≤ 1 := by simpa [hmul_id, one_mul] using this\n1208:       exact (not_lt_of_ge hle1) hone_lt_pow_t\n1209:     -- Now we can rewrite the RHS power via toNat\n1210:     have hzpow_toNat : (beta : ℝ) ^ (k - e) = (beta : ℝ) ^ (Int.toNat (k - e)) := by\n1211:       simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (k - e) hk_sub_nonneg\n1212:     -- Rewrite base (β : ℝ) as ((natAbs β) : ℝ) since β > 0\n1213:     have hbeta_cast_eq : ((Int.natAbs beta : Nat) : ℝ) = (beta : ℝ) := by\n1214:       have : ((Int.natAbs beta : Nat) : ℝ) = abs (beta : ℝ) := by\n1215:         simpa [Int.cast_natAbs, Int.cast_abs]\n1216:       simpa [abs_of_pos hbposR] using this\n1217:     -- Convert the RHS to a casted Nat power\n1218:     have hRHS_cast : (beta : ℝ) ^ (Int.toNat (k - e))\n1219:         = ((Int.natAbs beta ^ Int.toNat (k - e) : Nat) : ℝ) := by\n1220:       -- replace base by natAbs beta and use Nat.cast_pow\n1221:       have hbase : ((Int.natAbs beta : Nat) : ℝ) = (beta : ℝ) := hbeta_cast_eq\n1222:       simpa [hbase, Nat.cast_pow]\n1223:     -- Combine and conclude as a Nat inequality via monotonicity of casts\n1224:     have hcast_ineq : (Int.natAbs m : ℝ) ≤ ((Int.natAbs beta ^ Int.toNat (k - e) : Nat) : ℝ) := by\n1225:       -- Use ((natAbs m) : ℝ) = |(m : ℝ)| and rewrite the RHS using hzpow_toNat and hRHS_cast\n1226:       have hLHS : (Int.natAbs m : ℝ) = abs (m : ℝ) := by\n1227:         simpa [Int.cast_natAbs, Int.cast_abs]\n1228:       simpa [hLHS, hzpow_toNat, hRHS_cast] using h_abs_m_le\n1229:     -- Coercion monotonicity gives the required Nat inequality\n1230:     exact (by exact_mod_cast hcast_ineq)\n1231: \n1232: /-- Specification: Generic format error bound\n1233: \n1234:     For any x, there exists f in generic format within\n1235:     half ULP of x.\n1236: -/\n1237: theorem generic_format_error_bound (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n1238:     ∃ f, (generic_format beta fexp f).run ∧\n1239:     abs (f - x) ≤ (1/2) * (beta : ℝ) ^ (cexp beta fexp x).run := by\n1240:   exact exists_round_half_ulp beta fexp x\n1241: \n1242: /-- Specification: Relative error bound\n1243: \n1244:     For non-zero x, there exists f in generic format\n1245:     with bounded relative error.\n1246: -/\n1247: theorem generic_format_relative_error (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp]\n1248:     (x : ℝ) (hx : x ≠ 0) (hβ : 1 < beta) :\n1249:     ∃ f, (generic_format beta fexp f).run ∧ f ≠ 0 ∧\n1250:     abs (f - x) / abs x ≤ (1/2) * (beta : ℝ) ^ ((cexp beta fexp x).run - mag beta x + 1) := by\n1251:   -- Use the nonzero half‑ULP witness axiom, then divide by |x| and apply the reciprocal bound\n1252:   classical\n1253:   obtain ⟨f, hfF, hf_ne, herr_abs⟩ := exists_round_half_ulp_nz (beta := beta) (fexp := fexp) (x := x) hx\n1254:   set e : Int := (cexp beta fexp x).run\n1255:   set k : Int := mag beta x\n1256:   have hxpos : 0 < abs x := abs_pos.mpr hx\n1257:   -- Multiply both sides of the absolute error by |x|⁻¹ (nonnegative)\n1258:   have hx_inv_nonneg : 0 ≤ (abs x)⁻¹ := inv_nonneg.mpr (le_of_lt hxpos)\n1259:   have hmul := mul_le_mul_of_nonneg_right herr_abs hx_inv_nonneg\n1260:   have hdiv : abs (f - x) / abs x ≤ ((1/2) * (beta : ℝ) ^ e) * (abs x)⁻¹ := by\n1261:     simpa [one_div, div_eq_mul_inv, mul_comm, mul_left_comm, mul_assoc] using hmul\n1262:   have hrecip := (recip_abs_x_le (beta := beta) (x := x)) ⟨hβ, hx⟩\n1263:   have hrecip_le' : (abs x)⁻¹ ≤ (beta : ℝ) ^ (1 - k) := by simpa [one_div, k] using hrecip\n1264:   have hbposR : 0 < (beta : ℝ) := by\n1265:     have : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n1266:     exact_mod_cast this\n1267:   have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR\n1268:   have hcoeff_nonneg : 0 ≤ (1/2) * (beta : ℝ) ^ e := by\n1269:     have : 0 ≤ (beta : ℝ) ^ e := le_of_lt (zpow_pos hbposR e)\n1270:     exact mul_nonneg (by norm_num) this\n1271:   have : ((1/2) * (beta : ℝ) ^ e) * (abs x)⁻¹ ≤ ((1/2) * (beta : ℝ) ^ e) * (beta : ℝ) ^ (1 - k) :=\n1272:     mul_le_mul_of_nonneg_left hrecip_le' hcoeff_nonneg\n1273:   have : ((1/2) * (beta : ℝ) ^ e) * (abs x)⁻¹ ≤ (1/2) * (beta : ℝ) ^ (e - k + 1) := by\n1274:     -- rewrite RHS using zpow_add and associativity\n1275:     simpa [sub_eq_add_neg, one_div, mul_comm, mul_left_comm, mul_assoc, zpow_add₀ hbne] using this\n1276:   exact ⟨f, hfF, hf_ne, le_trans hdiv this⟩\n1277: \n1278: /-- Round to nearest in generic format\n1279: \n1280:     Computes the nearest representable value in the format.\n1281: -/\n1282: noncomputable def round_N_to_format (beta : Int) (fexp : Int → Int) (x : ℝ) : Id ℝ :=\n1283:   -- Placeholder: not needed for properties below\n1284:   pure 0\n1285: \n1286: /-- Round down to generic format\n1287: \n1288:     Computes the largest representable value not exceeding x.\n1289: -/\n1290: noncomputable def round_DN_to_format (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) : Id ℝ :=\n1291:   -- Use classical choice from existence of DN rounding in generic format\n1292:   pure (Classical.choose (round_DN_exists beta fexp x))\n1293: \n1294: /-- Round up to generic format\n1295: \n1296:     Computes the smallest representable value not less than x.\n1297: -/\n1298: noncomputable def round_UP_to_format (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) : Id ℝ :=\n1299:   -- Use classical choice from existence of UP rounding in generic format\n1300:   pure (Classical.choose (round_UP_exists beta fexp x))\n1301: \n1302: /-- Specification: Properties of format-specific rounding\n1303: \n1304:     The rounding functions produce values in the format\n1305:     and satisfy the expected ordering properties.\n1306: -/\n1307: theorem round_to_format_properties (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (x : ℝ) :\n1308:     ⦃⌜beta > 1⌝⦄\n1309:     do\n1310:       let down ← round_DN_to_format beta fexp x\n1311:       let up ← round_UP_to_format beta fexp x\n1312:       pure (down, up)\n1313:     ⦃⇓result => ⌜let (down, up) := result;\n1314:                    (generic_format beta fexp down).run ∧\n1315:                    (generic_format beta fexp up).run ∧\n1316:                    down ≤ x ∧ x ≤ up⌝⦄ := by\n1317:   intro _\n1318:   -- Evaluate the do-block and unfold our definitions of the rounding helpers\n1319:   simp [round_DN_to_format, round_UP_to_format]\n1320:   -- Retrieve properties of the chosen down and up values\n1321:   have hDN := Classical.choose_spec (round_DN_exists beta fexp x)\n1322:   have hUP := Classical.choose_spec (round_UP_exists beta fexp x)\n1323:   -- Unpack DN: format membership and DN predicate\n1324:   rcases hDN with ⟨hFdn, hdn⟩\n1325:   rcases hUP with ⟨hFup, hup⟩\n1326:   -- Extract ordering facts from the predicates\n1327:   rcases hdn with ⟨_, hdn_le, _⟩\n1328:   rcases hup with ⟨_, hup_ge, _⟩\n1329:   -- Conclude the required conjunction\n1330:   exact ⟨hFdn, hFup, hdn_le, hup_ge⟩\n1331: \n1332: end FloatSpec.Core.Round_generic\n1333: \n"
  }
}
[2025-09-15T19:51:51] tokens used: 35874
[2025-09-15T19:51:59] thinking

**Exploring rounding functions**

I'm looking at the round_to_generic method and comparing it to Coq's round function, which is parameterized by rounding mode. Our Lean library has a round_to_generic helper. I think we can define a spec theorem `round_FLT_FLX` in FLT.lean using this. However, it seems "round_FLT_FLX" is missing, so we need to add it using a hoare triple style. Previous theorems in FLT.lean reference cexp or generic_format, and this one should establish that rounding with FLT is the same as with FLX for certain values of x.**Developing a rounding spec**

I'm working on crafting a theorem called `round_FLT_FLX`, which mentions certain parameters like beta and a rounding method. The idea is to apply a condition that involves a specific relationship with x and perform two rounding operations using `round_to_generic`. I'm wondering if `round_to_generic` is the right choice as a placeholder for the rounding function. I also plan to check out the Coq lemma concerning `negligible_exp_FLT` and find its definition in Lean to ensure everything aligns correctly.
[2025-09-15T19:52:04] codex
**Developing a rounding spec**

I'm working on crafting a theorem called `round_FLT_FLX`, which mentions certain parameters like beta and a rounding method. The idea is to apply a condition that involves a specific relationship with x and perform two rounding operations using `round_to_generic`. I'm wondering if `round_to_generic` is the right choice as a placeholder for the rounding function. I also plan to check out the Coq lemma concerning `negligible_exp_FLT` and find its definition in Lean to ensure everything aligns correctly.
[2025-09-15T19:52:04] codex

I’ll search for `negligible_exp` in the Lean Core to match its usage and signature.
[2025-09-15T19:52:04] exec bash -lc 'grep -R "negligible_exp" -n FloatSpec/src/Core || true' in /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
[2025-09-15T19:52:04] bash -lc 'grep -R "negligible_exp" -n FloatSpec/src/Core || true' succeeded in 413ms:
FloatSpec/src/Core/Ulp.lean:49:  | true   => match negligible_exp with
FloatSpec/src/Core/Core_Theorems_Comparison.md:299:- Lemma: `negligible_exp_FLT`
FloatSpec/src/Core/Core_Theorems_Comparison.md:334:- `negligible_exp_FLT` → (no match)
FloatSpec/src/Core/Core_Theorems_Comparison.md:359:- Lemma: `negligible_exp_FLX`
FloatSpec/src/Core/Core_Theorems_Comparison.md:389:- `negligible_exp_FLX` → (no match)
FloatSpec/src/Core/Core_Theorems_Comparison.md:1399:- Lemma: `negligible_exp_spec`
FloatSpec/src/Core/Core_Theorems_Comparison.md:1400:- Lemma: `negligible_exp_spec'`
FloatSpec/src/Core/Core_Theorems_Comparison.md:1401:- Lemma: `fexp_negligible_exp_eq`
FloatSpec/src/Core/Core_Theorems_Comparison.md:1419:- Theorem: `eq_0_round_0_negligible_exp`
FloatSpec/src/Core/Core_Theorems_Comparison.md:1471:- Theorem: `round_neq_0_negligible_exp`
FloatSpec/src/Core/Core_Theorems_Comparison.md:1522:- `negligible_exp_spec` → (no match)
FloatSpec/src/Core/Core_Theorems_Comparison.md:1523:- `negligible_exp_spec'` → (no match)
FloatSpec/src/Core/Core_Theorems_Comparison.md:1524:- `fexp_negligible_exp_eq` → (no match)
FloatSpec/src/Core/Core_Theorems_Comparison.md:1542:- `eq_0_round_0_negligible_exp` → (no match)
FloatSpec/src/Core/Core_Theorems_Comparison.md:1594:- `round_neq_0_negligible_exp` → (no match)
[2025-09-15T19:52:04] tokens used: 65583
[2025-09-15T19:52:10] codex

I’m going to open `Ulp.lean` to understand how `negligible_exp` is modeled to write a matching spec.
[2025-09-15T19:52:12] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Ulp.lean"})
[2025-09-15T19:52:12] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Ulp.lean"}) success in 2ms:
{
  "content": [
    {
      "text": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Copyright (C) 2011-2018 Sylvie Boldo\n6  : Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : \n18 : Unit in the last place (ULP) definitions and core properties\n19 : Based on flocq/src/Core/Ulp.v\n20 : -/\n21 : \n22 : import FloatSpec.src.Core.Zaux\n23 : import FloatSpec.src.Core.Raux\n24 : import FloatSpec.src.Core.Defs\n25 : import FloatSpec.src.Core.Round_pred\n26 : import FloatSpec.src.Core.Generic_fmt\n27 : import FloatSpec.src.Core.Float_prop\n28 : import Mathlib.Data.Real.Basic\n29 : import Std.Do.Triple\n30 : import Std.Tactic.Do\n31 : \n32 : open Real\n33 : open Std.Do\n34 : open FloatSpec.Core.Generic_fmt\n35 : \n36 : namespace FloatSpec.Core.Ulp\n37 : \n38 : section UnitInLastPlace\n39 : \n40 : variable (beta : Int)\n41 : variable (fexp : Int → Int)\n42 : variable [FloatSpec.Core.Generic_fmt.Valid_exp beta fexp]\n43 : \n44 : /-- Unit in the last place (ULP)\n45 : \n46 : Coq (Ulp.v) definition for reference:\n47 : ```\n48 : Definition ulp x := match Req_bool x 0 with\n49 :   | true   => match negligible_exp with\n50 :             | Some n => bpow (fexp n)\n51 :             | None => 0%R\n52 :             end\n53 :   | false  => bpow (cexp beta fexp x)\n54 : end.\n55 : ```\n56 : Note: We use a simplified zero case: `bpow (fexp 1)`.\n57 : -/\n58 : noncomputable def ulp (x : ℝ) : Id ℝ :=\n59 :   if x = 0 then\n60 :     pure ((beta : ℝ) ^ (fexp 1))\n61 :   else do\n62 :     let e ← FloatSpec.Core.Generic_fmt.cexp beta fexp x\n63 :     pure ((beta : ℝ) ^ e)\n64 : \n65 : /-- Coq (Ulp.v):\n66 : Lemma ulp_neq_0 : forall x, x <> 0%R -> ulp x = bpow (cexp beta fexp x).\n67 : -/\n68 : theorem ulp_neq_0 (x : ℝ) (hx : x ≠ 0) :\n69 :     ⦃⌜True⌝⦄\n70 :     ulp beta fexp x\n71 :     ⦃⇓r => ⌜r = (beta : ℝ) ^ ((FloatSpec.Core.Generic_fmt.cexp beta fexp x).run)⌝⦄ := by\n72 :   intro _; sorry\n73 : \n74 : /-- Coq (Ulp.v): Theorem ulp_opp: forall x, ulp (-x) = ulp x. -/\n75 : theorem ulp_opp (x : ℝ) :\n76 :     ⦃⌜True⌝⦄ do\n77 :       let u1 ← ulp beta fexp (-x)\n78 :       let u2 ← ulp beta fexp x\n79 :       pure (u1, u2)\n80 :     ⦃⇓r => ⌜r.1 = r.2⌝⦄ := by\n81 :   intro _; sorry\n82 : \n83 : /-- Coq (Ulp.v): Theorem ulp_abs: forall x, ulp (Rabs x) = ulp x. -/\n84 : theorem ulp_abs (x : ℝ) :\n85 :     ⦃⌜True⌝⦄ do\n86 :       let u1 ← ulp beta fexp |x|\n87 :       let u2 ← ulp beta fexp x\n88 :       pure (u1, u2)\n89 :     ⦃⇓r => ⌜r.1 = r.2⌝⦄ := by\n90 :   intro _; sorry\n91 : \n92 : /-- Coq (Ulp.v): Theorem ulp_ge_0: forall x, (0 <= ulp x)%R. -/\n93 : theorem ulp_ge_0 (x : ℝ) :\n94 :     ⦃⌜1 < beta⌝⦄ ulp beta fexp x ⦃⇓r => ⌜0 ≤ r⌝⦄ := by\n95 :   intro hβ\n96 :   unfold ulp\n97 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n98 :   have hbpos : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n99 :   by_cases hx : x = 0\n100:   · have : 0 < (beta : ℝ) ^ (fexp 1) := zpow_pos hbpos _\n101:     simp [hx, le_of_lt this]\n102:   · have : 0 < (beta : ℝ) ^ (fexp (mag beta x)) := zpow_pos hbpos _\n103:     simp [hx, FloatSpec.Core.Generic_fmt.cexp, le_of_lt this]\n104: \n105: /-- Coq (Ulp.v):\n106: Theorem ulp_le_id:\n107:   forall x, (0 < x)%R -> F x -> (ulp x <= x)%R.\n108: -/\n109: theorem ulp_le_id (x : ℝ) (hx : 0 < x)\n110:     (hxF : (FloatSpec.Core.Generic_fmt.generic_format beta fexp x).run) :\n111:     ⦃⌜True⌝⦄ ulp beta fexp x ⦃⇓r => ⌜r ≤ x⌝⦄ := by\n112:   intro _; sorry\n113: \n114: /-- Coq (Ulp.v):\n115: Theorem ulp_le_abs:\n116:   forall x, (x <> 0)%R -> F x -> (ulp x <= Rabs x)%R.\n117: -/\n118: theorem ulp_le_abs (x : ℝ) (hx : x ≠ 0)\n119:     (hxF : (FloatSpec.Core.Generic_fmt.generic_format beta fexp x).run) :\n120:     ⦃⌜True⌝⦄ ulp beta fexp x ⦃⇓r => ⌜r ≤ |x|⌝⦄ := by\n121:   intro _; sorry\n122: \n123: /-- Coq (Ulp.v):\n124: Theorem ulp_bpow : forall e, ulp (bpow e) = bpow (fexp (e + 1)).\n125: -/\n126: theorem ulp_bpow (e : Int) :\n127:     ⦃⌜True⌝⦄ ulp beta fexp ((beta : ℝ) ^ e)\n128:     ⦃⇓r => ⌜r = (beta : ℝ) ^ (fexp (e + 1))⌝⦄ := by\n129:   intro _; sorry\n130: \n131: /-- Coq (Ulp.v): Lemma generic_format_ulp_0 : F (ulp 0). -/\n132: theorem generic_format_ulp_0 :\n133:     ⦃⌜True⌝⦄ do\n134:       let u ← ulp beta fexp 0\n135:       FloatSpec.Core.Generic_fmt.generic_format beta fexp u\n136:     ⦃⇓g => ⌜g⌝⦄ := by\n137:   intro _; sorry\n138: \n139: /-- Coq (Ulp.v):\n140: Lemma generic_format_bpow_ge_ulp_0 : forall e, (ulp 0 <= bpow e)%R -> F (bpow e).\n141: -/\n142: theorem generic_format_bpow_ge_ulp_0 (e : Int)\n143:     (hle : (ulp beta fexp 0).run ≤ (beta : ℝ) ^ e) :\n144:     ⦃⌜True⌝⦄\n145:     FloatSpec.Core.Generic_fmt.generic_format beta fexp ((beta : ℝ) ^ e)\n146:     ⦃⇓g => ⌜g⌝⦄ := by\n147:   intro _; sorry\n148: \n149: end UnitInLastPlace\n150: \n151: end FloatSpec.Core.Ulp\n152: \n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Copyright (C) 2011-2018 Sylvie Boldo\n6  : Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : \n18 : Unit in the last place (ULP) definitions and core properties\n19 : Based on flocq/src/Core/Ulp.v\n20 : -/\n21 : \n22 : import FloatSpec.src.Core.Zaux\n23 : import FloatSpec.src.Core.Raux\n24 : import FloatSpec.src.Core.Defs\n25 : import FloatSpec.src.Core.Round_pred\n26 : import FloatSpec.src.Core.Generic_fmt\n27 : import FloatSpec.src.Core.Float_prop\n28 : import Mathlib.Data.Real.Basic\n29 : import Std.Do.Triple\n30 : import Std.Tactic.Do\n31 : \n32 : open Real\n33 : open Std.Do\n34 : open FloatSpec.Core.Generic_fmt\n35 : \n36 : namespace FloatSpec.Core.Ulp\n37 : \n38 : section UnitInLastPlace\n39 : \n40 : variable (beta : Int)\n41 : variable (fexp : Int → Int)\n42 : variable [FloatSpec.Core.Generic_fmt.Valid_exp beta fexp]\n43 : \n44 : /-- Unit in the last place (ULP)\n45 : \n46 : Coq (Ulp.v) definition for reference:\n47 : ```\n48 : Definition ulp x := match Req_bool x 0 with\n49 :   | true   => match negligible_exp with\n50 :             | Some n => bpow (fexp n)\n51 :             | None => 0%R\n52 :             end\n53 :   | false  => bpow (cexp beta fexp x)\n54 : end.\n55 : ```\n56 : Note: We use a simplified zero case: `bpow (fexp 1)`.\n57 : -/\n58 : noncomputable def ulp (x : ℝ) : Id ℝ :=\n59 :   if x = 0 then\n60 :     pure ((beta : ℝ) ^ (fexp 1))\n61 :   else do\n62 :     let e ← FloatSpec.Core.Generic_fmt.cexp beta fexp x\n63 :     pure ((beta : ℝ) ^ e)\n64 : \n65 : /-- Coq (Ulp.v):\n66 : Lemma ulp_neq_0 : forall x, x <> 0%R -> ulp x = bpow (cexp beta fexp x).\n67 : -/\n68 : theorem ulp_neq_0 (x : ℝ) (hx : x ≠ 0) :\n69 :     ⦃⌜True⌝⦄\n70 :     ulp beta fexp x\n71 :     ⦃⇓r => ⌜r = (beta : ℝ) ^ ((FloatSpec.Core.Generic_fmt.cexp beta fexp x).run)⌝⦄ := by\n72 :   intro _; sorry\n73 : \n74 : /-- Coq (Ulp.v): Theorem ulp_opp: forall x, ulp (-x) = ulp x. -/\n75 : theorem ulp_opp (x : ℝ) :\n76 :     ⦃⌜True⌝⦄ do\n77 :       let u1 ← ulp beta fexp (-x)\n78 :       let u2 ← ulp beta fexp x\n79 :       pure (u1, u2)\n80 :     ⦃⇓r => ⌜r.1 = r.2⌝⦄ := by\n81 :   intro _; sorry\n82 : \n83 : /-- Coq (Ulp.v): Theorem ulp_abs: forall x, ulp (Rabs x) = ulp x. -/\n84 : theorem ulp_abs (x : ℝ) :\n85 :     ⦃⌜True⌝⦄ do\n86 :       let u1 ← ulp beta fexp |x|\n87 :       let u2 ← ulp beta fexp x\n88 :       pure (u1, u2)\n89 :     ⦃⇓r => ⌜r.1 = r.2⌝⦄ := by\n90 :   intro _; sorry\n91 : \n92 : /-- Coq (Ulp.v): Theorem ulp_ge_0: forall x, (0 <= ulp x)%R. -/\n93 : theorem ulp_ge_0 (x : ℝ) :\n94 :     ⦃⌜1 < beta⌝⦄ ulp beta fexp x ⦃⇓r => ⌜0 ≤ r⌝⦄ := by\n95 :   intro hβ\n96 :   unfold ulp\n97 :   have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ\n98 :   have hbpos : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ\n99 :   by_cases hx : x = 0\n100:   · have : 0 < (beta : ℝ) ^ (fexp 1) := zpow_pos hbpos _\n101:     simp [hx, le_of_lt this]\n102:   · have : 0 < (beta : ℝ) ^ (fexp (mag beta x)) := zpow_pos hbpos _\n103:     simp [hx, FloatSpec.Core.Generic_fmt.cexp, le_of_lt this]\n104: \n105: /-- Coq (Ulp.v):\n106: Theorem ulp_le_id:\n107:   forall x, (0 < x)%R -> F x -> (ulp x <= x)%R.\n108: -/\n109: theorem ulp_le_id (x : ℝ) (hx : 0 < x)\n110:     (hxF : (FloatSpec.Core.Generic_fmt.generic_format beta fexp x).run) :\n111:     ⦃⌜True⌝⦄ ulp beta fexp x ⦃⇓r => ⌜r ≤ x⌝⦄ := by\n112:   intro _; sorry\n113: \n114: /-- Coq (Ulp.v):\n115: Theorem ulp_le_abs:\n116:   forall x, (x <> 0)%R -> F x -> (ulp x <= Rabs x)%R.\n117: -/\n118: theorem ulp_le_abs (x : ℝ) (hx : x ≠ 0)\n119:     (hxF : (FloatSpec.Core.Generic_fmt.generic_format beta fexp x).run) :\n120:     ⦃⌜True⌝⦄ ulp beta fexp x ⦃⇓r => ⌜r ≤ |x|⌝⦄ := by\n121:   intro _; sorry\n122: \n123: /-- Coq (Ulp.v):\n124: Theorem ulp_bpow : forall e, ulp (bpow e) = bpow (fexp (e + 1)).\n125: -/\n126: theorem ulp_bpow (e : Int) :\n127:     ⦃⌜True⌝⦄ ulp beta fexp ((beta : ℝ) ^ e)\n128:     ⦃⇓r => ⌜r = (beta : ℝ) ^ (fexp (e + 1))⌝⦄ := by\n129:   intro _; sorry\n130: \n131: /-- Coq (Ulp.v): Lemma generic_format_ulp_0 : F (ulp 0). -/\n132: theorem generic_format_ulp_0 :\n133:     ⦃⌜True⌝⦄ do\n134:       let u ← ulp beta fexp 0\n135:       FloatSpec.Core.Generic_fmt.generic_format beta fexp u\n136:     ⦃⇓g => ⌜g⌝⦄ := by\n137:   intro _; sorry\n138: \n139: /-- Coq (Ulp.v):\n140: Lemma generic_format_bpow_ge_ulp_0 : forall e, (ulp 0 <= bpow e)%R -> F (bpow e).\n141: -/\n142: theorem generic_format_bpow_ge_ulp_0 (e : Int)\n143:     (hle : (ulp beta fexp 0).run ≤ (beta : ℝ) ^ e) :\n144:     ⦃⌜True⌝⦄\n145:     FloatSpec.Core.Generic_fmt.generic_format beta fexp ((beta : ℝ) ^ e)\n146:     ⦃⇓g => ⌜g⌝⦄ := by\n147:   intro _; sorry\n148: \n149: end UnitInLastPlace\n150: \n151: end FloatSpec.Core.Ulp\n152: \n"
  }
}
[2025-09-15T19:52:13] tokens used: 66199
[2025-09-15T19:52:27] codex

I’ll open `Round_pred.lean` to confirm names like `succ` and `pred`.
[2025-09-15T19:52:28] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Round_pred.lean"})
[2025-09-15T19:52:28] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Round_pred.lean"}) success in 3ms:
{
  "content": [
    {
      "text": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Raux\n20 : import FloatSpec.src.Core.Defs\n21 : import Mathlib.Data.Real.Basic\n22 : import Std.Do.Triple\n23 : import Std.Tactic.Do\n24 : \n25 : open Real\n26 : open Std.Do\n27 : \n28 : namespace FloatSpec.Core.Round_pred\n29 : \n30 : variable {beta : Int}\n31 : \n32 : section BasicRoundingPredicates\n33 : \n34 : /-- Basic rounding predicate type\n35 :     \n36 :     A rounding predicate relates input values to output values,\n37 :     capturing the fundamental property that rounding functions\n38 :     should satisfy. This forms the foundation for all specific\n39 :     rounding modes.\n40 : -/\n41 : def round_pred (rnd : ℝ → ℝ → Prop) : Prop :=\n42 :   ∀ x : ℝ, ∃ y : ℝ, rnd x y\n43 : \n44 : /-- Monotonic rounding predicate\n45 :     \n46 :     A rounding predicate is monotonic if it preserves ordering:\n47 :     when rounding both x₁ and x₂, if x₁ ≤ x₂ then rnd(x₁) ≤ rnd(x₂).\n48 :     This property ensures consistent behavior across the real line.\n49 : -/\n50 : def round_pred_monotone (rnd : ℝ → ℝ → Prop) : Prop :=\n51 :   ∀ x₁ x₂ y₁ y₂ : ℝ, x₁ ≤ x₂ → rnd x₁ y₁ → rnd x₂ y₂ → y₁ ≤ y₂\n52 : \n53 : /-- Round down to nearest representable value below or equal\n54 :     \n55 :     Rnd_DN_pt F x f means f is the greatest element in format F\n56 :     such that f ≤ x. This captures IEEE 754's \"round toward\n57 :     negative infinity\" mode for the given format.\n58 : -/\n59 : def Rnd_DN_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=\n60 :   F f ∧ f ≤ x ∧ ∀ g : ℝ, F g → g ≤ x → g ≤ f\n61 : \n62 : /-- Round up to nearest representable value above or equal\n63 :     \n64 :     Rnd_UP_pt F x f means f is the smallest element in format F\n65 :     such that x ≤ f. This captures IEEE 754's \"round toward\n66 :     positive infinity\" mode for the given format.\n67 : -/\n68 : def Rnd_UP_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=\n69 :   F f ∧ x ≤ f ∧ ∀ g : ℝ, F g → x ≤ g → f ≤ g\n70 : \n71 : /-- Round toward zero (truncation)\n72 :     \n73 :     Rnd_ZR_pt F x f means f is the representable value closest\n74 :     to zero among those between 0 and x (inclusive). This\n75 :     implements IEEE 754's \"round toward zero\" mode.\n76 : -/\n77 : def Rnd_ZR_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=\n78 :   if x ≥ 0 then Rnd_DN_pt F x f else Rnd_UP_pt F x f\n79 : \n80 : /-- Round to nearest representable value\n81 :     \n82 :     Rnd_N_pt F x f means f minimizes |x - f| among all\n83 :     representable values. This is the foundation for\n84 :     IEEE 754's \"round to nearest\" modes.\n85 : -/\n86 : def Rnd_N_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=\n87 :   F f ∧ ∀ g : ℝ, F g → |x - f| ≤ |x - g|\n88 : \n89 : /-- Generic round to nearest with tie-breaking predicate\n90 :     \n91 :     Rnd_NG_pt F P x f means f is nearest to x, and in case of\n92 :     ties, the predicate P(x,f) determines the choice. This\n93 :     generalizes all round-to-nearest variants.\n94 : -/\n95 : def Rnd_NG_pt (F : ℝ → Prop) (P : ℝ → ℝ → Prop) (x f : ℝ) : Prop :=\n96 :   Rnd_N_pt F x f ∧ (∀ g : ℝ, F g → |x - g| = |x - f| → P x f)\n97 : \n98 : /-- Round ties away from zero\n99 :     \n100:     When exactly between two representable values, choose\n101:     the one farther from zero. This implements one common\n102:     tie-breaking strategy for round-to-nearest.\n103: -/\n104: def Rnd_NA_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=\n105:   Rnd_NG_pt F (fun x f => |f| ≥ |x|) x f\n106: \n107: /-- Round ties toward zero\n108:     \n109:     When exactly between two representable values, choose\n110:     the one closer to zero. This is an alternative\n111:     tie-breaking strategy for round-to-nearest.\n112: -/\n113: def Rnd_N0_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=\n114:   Rnd_NG_pt F (fun x f => |f| ≤ |x|) x f\n115: \n116: end BasicRoundingPredicates\n117: \n118: section RoundingFunctionProperties\n119: \n120: /-- Rounding down property for functions\n121:     \n122:     A rounding function rnd satisfies Rnd_DN if for every input x,\n123:     rnd(x) is the round-down value according to format F.\n124:     This lifts the pointwise property to functions.\n125: -/\n126: def Rnd_DN (F : ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n127:   pure (∀ x : ℝ, Rnd_DN_pt F x (rnd x))\n128: \n129: /-- Specification: Round down function property\n130:     \n131:     The round down property ensures that the function satisfies\n132:     the round down condition at every point. This provides a\n133:     functional interface to the pointwise rounding predicate.\n134: -/\n135: theorem Rnd_DN_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) :\n136:     ⦃⌜True⌝⦄\n137:     Rnd_DN F rnd\n138:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_DN_pt F x (rnd x))⌝⦄ := by\n139:   intro _\n140:   unfold Rnd_DN\n141:   rfl\n142: \n143: /-- Rounding up property for functions\n144:     \n145:     A rounding function rnd satisfies Rnd_UP if for every input x,\n146:     rnd(x) is the round-up value according to format F.\n147:     This provides the functional counterpart to round-up.\n148: -/\n149: def Rnd_UP (F : ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n150:   pure (∀ x : ℝ, Rnd_UP_pt F x (rnd x))\n151: \n152: /-- Specification: Round up function property\n153:     \n154:     The round up property ensures consistent upward rounding\n155:     behavior across all inputs. This guarantees the function\n156:     implementation matches the pointwise specification.\n157: -/\n158: theorem Rnd_UP_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) :\n159:     ⦃⌜True⌝⦄\n160:     Rnd_UP F rnd\n161:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_UP_pt F x (rnd x))⌝⦄ := by\n162:   intro _\n163:   unfold Rnd_UP\n164:   rfl\n165: \n166: /-- Rounding toward zero property for functions\n167:     \n168:     A function satisfies Rnd_ZR if it implements truncation:\n169:     round toward zero for all inputs. This combines round-down\n170:     for positive values and round-up for negative values.\n171: -/\n172: def Rnd_ZR (F : ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n173:   pure (∀ x : ℝ, Rnd_ZR_pt F x (rnd x))\n174: \n175: /-- Specification: Round toward zero function property\n176:     \n177:     The truncation property ensures the function always\n178:     rounds toward zero, providing consistent behavior\n179:     for both positive and negative inputs.\n180: -/\n181: theorem Rnd_ZR_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) :\n182:     ⦃⌜True⌝⦄\n183:     Rnd_ZR F rnd\n184:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_ZR_pt F x (rnd x))⌝⦄ := by\n185:   intro _\n186:   unfold Rnd_ZR\n187:   rfl\n188: \n189: /-- Round to nearest property for functions\n190:     \n191:     A function satisfies Rnd_N if it always returns the nearest\n192:     representable value. This is the base property for all\n193:     round-to-nearest modes without specifying tie-breaking.\n194: -/\n195: def Rnd_N (F : ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n196:   pure (∀ x : ℝ, Rnd_N_pt F x (rnd x))\n197: \n198: /-- Specification: Round to nearest function property\n199:     \n200:     The nearest-value property ensures optimal approximation:\n201:     the returned value minimizes the distance to the input\n202:     among all representable values in the format.\n203: -/\n204: theorem Rnd_N_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) :\n205:     ⦃⌜True⌝⦄\n206:     Rnd_N F rnd\n207:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_N_pt F x (rnd x))⌝⦄ := by\n208:   intro _\n209:   unfold Rnd_N\n210:   rfl\n211: \n212: /-- Generic rounding property with tie-breaking predicate\n213:     \n214:     A function satisfies Rnd_NG with predicate P if it rounds\n215:     to nearest and uses P to break ties. This generalizes\n216:     all round-to-nearest variants with different tie policies.\n217: -/\n218: def Rnd_NG (F : ℝ → Prop) (P : ℝ → ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n219:   pure (∀ x : ℝ, Rnd_NG_pt F P x (rnd x))\n220: \n221: /-- Specification: Generic round to nearest with tie-breaking\n222:     \n223:     The generic nearest property with custom tie-breaking\n224:     provides a unified framework for implementing various\n225:     IEEE 754 rounding modes and custom policies.\n226: -/\n227: theorem Rnd_NG_spec (F : ℝ → Prop) (P : ℝ → ℝ → Prop) (rnd : ℝ → ℝ) :\n228:     ⦃⌜True⌝⦄\n229:     Rnd_NG F P rnd\n230:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_NG_pt F P x (rnd x))⌝⦄ := by\n231:   intro _\n232:   unfold Rnd_NG\n233:   rfl\n234: \n235: /-- Round ties away from zero property\n236:     \n237:     A function satisfies Rnd_NA if it rounds to nearest,\n238:     breaking ties by choosing the value farther from zero.\n239:     This implements IEEE 754's \"away from zero\" tie-breaking.\n240: -/\n241: def Rnd_NA (F : ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n242:   pure (∀ x : ℝ, Rnd_NA_pt F x (rnd x))\n243: \n244: /-- Specification: Round ties away from zero\n245:     \n246:     The away-from-zero tie-breaking ensures that when exactly\n247:     between two representable values, the function chooses\n248:     the one with larger absolute value.\n249: -/\n250: theorem Rnd_NA_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) :\n251:     ⦃⌜True⌝⦄\n252:     Rnd_NA F rnd\n253:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_NA_pt F x (rnd x))⌝⦄ := by\n254:   intro _\n255:   unfold Rnd_NA\n256:   rfl\n257: \n258: /-- Round ties toward zero property\n259:     \n260:     A function satisfies Rnd_N0 if it rounds to nearest,\n261:     breaking ties by choosing the value closer to zero.\n262:     This provides an alternative tie-breaking strategy.\n263: -/\n264: def Rnd_N0 (F : ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n265:   pure (∀ x : ℝ, Rnd_N0_pt F x (rnd x))\n266: \n267: /-- Specification: Round ties toward zero\n268:     \n269:     The toward-zero tie-breaking ensures that when exactly\n270:     between two representable values, the function chooses\n271:     the one with smaller absolute value.\n272: -/\n273: theorem Rnd_N0_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) :\n274:     ⦃⌜True⌝⦄\n275:     Rnd_N0 F rnd\n276:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_N0_pt F x (rnd x))⌝⦄ := by\n277:   intro _\n278:   unfold Rnd_N0\n279:   rfl\n280: \n281: end RoundingFunctionProperties\n282: \n283: section ExistenceAndUniqueness\n284: \n285: /-- Extract rounding value from predicate\n286:     \n287:     Given a rounding predicate that is known to hold,\n288:     extract the actual rounded value. This enables\n289:     computation from specification predicates.\n290: -/\n291: def round_val_of_pred (rnd : ℝ → ℝ → Prop) (x : ℝ) : Id ℝ :=\n292:   -- This would need to be implemented with choice\n293:   pure 0  -- placeholder\n294: \n295: /-- Specification: Value existence from round predicate\n296:     \n297:     Currently returns 0 as a placeholder. A proper implementation\n298:     would need classical choice to extract the actual value from\n299:     the predicate.\n300: -/\n301: theorem round_val_of_pred_spec (rnd : ℝ → ℝ → Prop) (x : ℝ) :\n302:     ⦃⌜round_pred rnd⌝⦄\n303:     round_val_of_pred rnd x\n304:     ⦃⇓f => ⌜f = 0⌝⦄ := by\n305:   intro h\n306:   unfold round_val_of_pred\n307:   rfl\n308: \n309: /-- Extract rounding function from predicate\n310:     \n311:     Given a rounding predicate, construct the corresponding\n312:     rounding function. This provides the functional interface\n313:     to relational rounding specifications.\n314: -/\n315: def round_fun_of_pred (rnd : ℝ → ℝ → Prop) : Id (ℝ → ℝ) :=\n316:   -- This would need choice/axioms to implement\n317:   pure (fun _ => 0)  -- placeholder\n318: \n319: /-- Specification: Function existence from round predicate\n320:     \n321:     Currently returns the constant function (fun _ => 0) as a placeholder.\n322:     A proper implementation would need classical choice to construct\n323:     the actual rounding function from the predicate.\n324: -/\n325: theorem round_fun_of_pred_spec (rnd : ℝ → ℝ → Prop) :\n326:     ⦃⌜round_pred rnd⌝⦄\n327:     round_fun_of_pred rnd\n328:     ⦃⇓f => ⌜f = fun _ => 0⌝⦄ := by\n329:   intro h\n330:   unfold round_fun_of_pred\n331:   rfl\n332: \n333: /-- Check uniqueness of rounding result\n334:     \n335:     Verify that a monotonic rounding predicate produces\n336:     unique results. This is essential for the deterministic\n337:     nature of rounding functions.\n338: -/\n339: def round_unique_check (rnd : ℝ → ℝ → Prop) (x f1 f2 : ℝ) : Id Bool :=\n340:   pure true  -- Always true for monotonic predicates\n341: \n342: /-- Specification: Uniqueness of rounding result\n343:     \n344:     Monotonic rounding predicates produce unique results.\n345:     This ensures that rounding functions are well-defined\n346:     and deterministic for any given input.\n347: -/\n348: theorem round_unique_spec (rnd : ℝ → ℝ → Prop) (x f1 f2 : ℝ) :\n349:     ⦃⌜round_pred_monotone rnd ∧ rnd x f1 ∧ rnd x f2⌝⦄\n350:     round_unique_check rnd x f1 f2\n351:     ⦃⇓result => ⌜result = true⌝⦄ := by\n352:   intro _\n353:   unfold round_unique_check\n354:   rfl\n355: \n356: end ExistenceAndUniqueness\n357: \n358: section RoundDownProperties\n359: \n360: /-- Check if round down satisfies monotonicity\n361:     \n362:     Verify that the round down predicate preserves ordering:\n363:     if x₁ ≤ x₂, then round_down(x₁) ≤ round_down(x₂).\n364:     This fundamental property ensures consistent behavior.\n365: -/\n366: def Rnd_DN_pt_monotone_check (F : ℝ → Prop) : Id Bool :=\n367:   pure true  -- Round down is always monotone\n368: \n369: /-- Specification: Round down is monotone\n370:     \n371:     The round down operation preserves ordering relationships.\n372:     This monotonicity property is essential for the correctness\n373:     of downward rounding in floating-point systems.\n374: -/\n375: theorem Rnd_DN_pt_monotone_spec (F : ℝ → Prop) :\n376:     ⦃⌜True⌝⦄\n377:     Rnd_DN_pt_monotone_check F\n378:     ⦃⇓result => ⌜result = true⌝⦄ := by\n379:   intro _\n380:   unfold Rnd_DN_pt_monotone_check\n381:   rfl\n382: \n383: /-- Check uniqueness of round down result\n384:     \n385:     Verify that round down produces unique results for\n386:     any given input. This ensures deterministic behavior\n387:     of the downward rounding operation.\n388: -/\n389: def Rnd_DN_pt_unique_check (F : ℝ → Prop) (x f1 f2 : ℝ) : Id Bool :=\n390:   pure true  -- Round down always produces unique results\n391: \n392: /-- Specification: Round down point is unique\n393:     \n394:     The round down operation produces a unique result for\n395:     each input. This uniqueness is fundamental to the\n396:     deterministic nature of floating-point rounding.\n397: -/\n398: theorem Rnd_DN_pt_unique_spec (F : ℝ → Prop) (x f1 f2 : ℝ) :\n399:     ⦃⌜Rnd_DN_pt F x f1 ∧ Rnd_DN_pt F x f2⌝⦄\n400:     Rnd_DN_pt_unique_check F x f1 f2\n401:     ⦃⇓result => ⌜result = true⌝⦄ := by\n402:   intro _\n403:   unfold Rnd_DN_pt_unique_check\n404:   rfl\n405: \n406: /-- Check uniqueness of round down function\n407:     \n408:     Verify that round down functions are unique: if two\n409:     functions both satisfy the round down property,\n410:     they produce identical results on all inputs.\n411: -/\n412: def Rnd_DN_unique_check (F : ℝ → Prop) (rnd1 rnd2 : ℝ → ℝ) (x : ℝ) : Id Bool :=\n413:   pure true  -- Round down functions are unique\n414: \n415: /-- Specification: Round down function is unique\n416:     \n417:     Round down functions are uniquely determined by their\n418:     specification. Any two functions satisfying the round\n419:     down property must be identical.\n420: -/\n421: theorem Rnd_DN_unique_spec (F : ℝ → Prop) (rnd1 rnd2 : ℝ → ℝ) (x : ℝ) :\n422:     ⦃⌜∃ p1 p2, Rnd_DN F rnd1 = pure p1 ∧ Rnd_DN F rnd2 = pure p2 ∧ p1 ∧ p2⌝⦄\n423:     Rnd_DN_unique_check F rnd1 rnd2 x\n424:     ⦃⇓result => ⌜result = true⌝⦄ := by\n425:   intro _\n426:   unfold Rnd_DN_unique_check\n427:   rfl\n428: \n429: end RoundDownProperties\n430: \n431: section RoundUpProperties\n432: \n433: /-- Check if round up satisfies monotonicity\n434:     \n435:     Verify that the round up predicate preserves ordering:\n436:     upward rounding maintains the same relative ordering\n437:     as the input values.\n438: -/\n439: def Rnd_UP_pt_monotone_check (F : ℝ → Prop) : Id Bool :=\n440:   pure true  -- Round up is always monotone\n441: \n442: /-- Specification: Round up is monotone\n443:     \n444:     The round up operation preserves ordering relationships.\n445:     This property ensures predictable behavior across\n446:     the entire range of representable values.\n447: -/\n448: theorem Rnd_UP_pt_monotone_spec (F : ℝ → Prop) :\n449:     ⦃⌜True⌝⦄\n450:     Rnd_UP_pt_monotone_check F\n451:     ⦃⇓result => ⌜result = true⌝⦄ := by\n452:   intro _\n453:   unfold Rnd_UP_pt_monotone_check\n454:   rfl\n455: \n456: /-- Check uniqueness of round up result\n457:     \n458:     Verify that round up produces unique results.\n459:     Each input has exactly one correct round up value\n460:     in the given format.\n461: -/\n462: def Rnd_UP_pt_unique_check (F : ℝ → Prop) (x f1 f2 : ℝ) : Id Bool :=\n463:   pure true  -- Round up always produces unique results\n464: \n465: /-- Specification: Round up point is unique\n466:     \n467:     The round up operation is deterministic: each input\n468:     maps to exactly one output value. This uniqueness\n469:     ensures consistent floating-point behavior.\n470: -/\n471: theorem Rnd_UP_pt_unique_spec (F : ℝ → Prop) (x f1 f2 : ℝ) :\n472:     ⦃⌜Rnd_UP_pt F x f1 ∧ Rnd_UP_pt F x f2⌝⦄\n473:     Rnd_UP_pt_unique_check F x f1 f2\n474:     ⦃⇓result => ⌜result = true⌝⦄ := by\n475:   intro _\n476:   unfold Rnd_UP_pt_unique_check\n477:   rfl\n478: \n479: /-- Check uniqueness of round up function\n480:     \n481:     Verify that round up functions are uniquely determined.\n482:     The specification completely characterizes the\n483:     implementation, ensuring no ambiguity.\n484: -/\n485: def Rnd_UP_unique_check (F : ℝ → Prop) (rnd1 rnd2 : ℝ → ℝ) (x : ℝ) : Id Bool :=\n486:   pure true  -- Round up functions are unique\n487: \n488: /-- Specification: Round up function is unique\n489:     \n490:     Round up functions are completely characterized by\n491:     their specification. This uniqueness guarantees\n492:     implementation consistency across different systems.\n493: -/\n494: theorem Rnd_UP_unique_spec (F : ℝ → Prop) (rnd1 rnd2 : ℝ → ℝ) (x : ℝ) :\n495:     ⦃⌜∃ p1 p2, Rnd_UP F rnd1 = pure p1 ∧ Rnd_UP F rnd2 = pure p2 ∧ p1 ∧ p2⌝⦄\n496:     Rnd_UP_unique_check F rnd1 rnd2 x\n497:     ⦃⇓result => ⌜result = true⌝⦄ := by\n498:   intro _\n499:   unfold Rnd_UP_unique_check\n500:   rfl\n501: \n502: end RoundUpProperties\n503: \n504: section DualityProperties\n505: \n506: /-- Transform round down to round up via negation\n507:     \n508:     If f is the round down of x, then -f is the round up\n509:     of -x. This duality property connects upward and\n510:     downward rounding through sign changes.\n511: -/\n512: def Rnd_UP_pt_opp_transform (F : ℝ → Prop) (x f : ℝ) : Id Bool :=\n513:   pure true  -- Duality always holds\n514: \n515: /-- Specification: Round up from round down with opposite\n516:     \n517:     The duality between round up and round down through\n518:     negation enables implementing one mode in terms of\n519:     the other, reducing implementation complexity.\n520: -/\n521: theorem Rnd_UP_pt_opp_spec (F : ℝ → Prop) (x f : ℝ) :\n522:     ⦃⌜(∀ y, F y → F (-y)) ∧ Rnd_DN_pt F x f⌝⦄\n523:     Rnd_UP_pt_opp_transform F x f\n524:     ⦃⇓result => ⌜result = true⌝⦄ := by\n525:   intro _\n526:   unfold Rnd_UP_pt_opp_transform\n527:   rfl\n528: \n529: /-- Transform round up to round down via negation\n530:     \n531:     If f is the round up of x, then -f is the round down\n532:     of -x. This is the reverse duality that completes\n533:     the bidirectional relationship.\n534: -/\n535: def Rnd_DN_pt_opp_transform (F : ℝ → Prop) (x f : ℝ) : Id Bool :=\n536:   pure true  -- Reverse duality always holds\n537: \n538: /-- Specification: Round down from round up with opposite\n539:     \n540:     The reverse duality enables complete interconversion\n541:     between upward and downward rounding modes through\n542:     negation, providing implementation flexibility.\n543: -/\n544: theorem Rnd_DN_pt_opp_spec (F : ℝ → Prop) (x f : ℝ) :\n545:     ⦃⌜(∀ y, F y → F (-y)) ∧ Rnd_UP_pt F x f⌝⦄\n546:     Rnd_DN_pt_opp_transform F x f\n547:     ⦃⇓result => ⌜result = true⌝⦄ := by\n548:   intro _\n549:   unfold Rnd_DN_pt_opp_transform\n550:   rfl\n551: \n552: end DualityProperties\n553: \n554: section ReflexivityAndIdempotency\n555: \n556: /-- Check reflexivity of round down\n557:     \n558:     Verify that if x is representable in format F,\n559:     then rounding down x yields x itself.\n560:     This captures the exactness property.\n561: -/\n562: def Rnd_DN_pt_refl_check (F : ℝ → Prop) (x : ℝ) : Id Bool :=\n563:   pure true  -- Reflexivity always holds for representable values\n564: \n565: /-- Specification: Round down is reflexive\n566:     \n567:     Representable values are unchanged by round down.\n568:     This reflexivity ensures that exact values remain\n569:     exact under rounding operations.\n570: -/\n571: theorem Rnd_DN_pt_refl_spec (F : ℝ → Prop) (x : ℝ) :\n572:     ⦃⌜F x⌝⦄\n573:     Rnd_DN_pt_refl_check F x\n574:     ⦃⇓result => ⌜result = true⌝⦄ := by\n575:   intro _\n576:   unfold Rnd_DN_pt_refl_check\n577:   rfl\n578: \n579: /-- Check idempotency of round down\n580:     \n581:     Verify that rounding down an already-representable\n582:     value returns that same value. This ensures\n583:     stability under repeated rounding.\n584: -/\n585: def Rnd_DN_pt_idempotent_check (F : ℝ → Prop) (x f : ℝ) : Id Bool :=\n586:   pure true  -- Idempotency always holds\n587: \n588: /-- Specification: Round down is idempotent\n589:     \n590:     Rounding representable values produces those same values.\n591:     This idempotency property ensures that representable\n592:     values form fixed points of the rounding operation.\n593: -/\n594: theorem Rnd_DN_pt_idempotent_spec (F : ℝ → Prop) (x f : ℝ) :\n595:     ⦃⌜Rnd_DN_pt F x f ∧ F x⌝⦄\n596:     Rnd_DN_pt_idempotent_check F x f\n597:     ⦃⇓result => ⌜result = true⌝⦄ := by\n598:   intro _\n599:   unfold Rnd_DN_pt_idempotent_check\n600:   rfl\n601: \n602: /-- Check reflexivity of round up\n603:     \n604:     Verify that round up preserves representable values.\n605:     Like round down, representable inputs should\n606:     remain unchanged.\n607: -/\n608: def Rnd_UP_pt_refl_check (F : ℝ → Prop) (x : ℝ) : Id Bool :=\n609:   pure true  -- Reflexivity holds for round up\n610: \n611: /-- Specification: Round up is reflexive\n612:     \n613:     Round up preserves representable values exactly.\n614:     This reflexivity is symmetric to the round down\n615:     property and ensures consistent behavior.\n616: -/\n617: theorem Rnd_UP_pt_refl_spec (F : ℝ → Prop) (x : ℝ) :\n618:     ⦃⌜F x⌝⦄\n619:     Rnd_UP_pt_refl_check F x\n620:     ⦃⇓result => ⌜result = true⌝⦄ := by\n621:   intro _\n622:   unfold Rnd_UP_pt_refl_check\n623:   rfl\n624: \n625: /-- Check idempotency of round up\n626:     \n627:     Verify that round up is idempotent on representable\n628:     values, mirroring the round down idempotency property.\n629: -/\n630: def Rnd_UP_pt_idempotent_check (F : ℝ → Prop) (x f : ℝ) : Id Bool :=\n631:   pure true  -- Idempotency holds for round up\n632: \n633: /-- Specification: Round up is idempotent\n634:     \n635:     Round up leaves representable values unchanged.\n636:     This completes the idempotency properties for\n637:     both directional rounding modes.\n638: -/\n639: theorem Rnd_UP_pt_idempotent_spec (F : ℝ → Prop) (x f : ℝ) :\n640:     ⦃⌜Rnd_UP_pt F x f ∧ F x⌝⦄\n641:     Rnd_UP_pt_idempotent_check F x f\n642:     ⦃⇓result => ⌜result = true⌝⦄ := by\n643:   intro _\n644:   unfold Rnd_UP_pt_idempotent_check\n645:   rfl\n646: \n647: end ReflexivityAndIdempotency\n648: \n649: section RoundTowardZeroProperties\n650: \n651: /-- Check absolute value bound for round toward zero\n652:     \n653:     Verify that rounding toward zero never increases\n654:     the absolute value: |round_toward_zero(x)| ≤ |x|.\n655:     This captures the truncation property.\n656: -/\n657: def Rnd_ZR_abs_check (F : ℝ → Prop) (rnd : ℝ → ℝ) (x : ℝ) : Id Bool :=\n658:   pure true  -- Round toward zero always satisfies the absolute value bound\n659: \n660: /-- Specification: Round toward zero absolute value bound\n661:     \n662:     Rounding toward zero (truncation) never increases\n663:     absolute values. This fundamental property makes\n664:     truncation useful for implementing magnitude bounds.\n665: -/\n666: theorem Rnd_ZR_abs_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) (x : ℝ) :\n667:     ⦃⌜∃ p, Rnd_ZR F rnd = pure p ∧ p⌝⦄\n668:     Rnd_ZR_abs_check F rnd x\n669:     ⦃⇓result => ⌜result = true⌝⦄ := by\n670:   intro _\n671:   unfold Rnd_ZR_abs_check\n672:   rfl\n673: \n674: end RoundTowardZeroProperties\n675: \n676: end FloatSpec.Core.Round_pred\n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Raux\n20 : import FloatSpec.src.Core.Defs\n21 : import Mathlib.Data.Real.Basic\n22 : import Std.Do.Triple\n23 : import Std.Tactic.Do\n24 : \n25 : open Real\n26 : open Std.Do\n27 : \n28 : namespace FloatSpec.Core.Round_pred\n29 : \n30 : variable {beta : Int}\n31 : \n32 : section BasicRoundingPredicates\n33 : \n34 : /-- Basic rounding predicate type\n35 :     \n36 :     A rounding predicate relates input values to output values,\n37 :     capturing the fundamental property that rounding functions\n38 :     should satisfy. This forms the foundation for all specific\n39 :     rounding modes.\n40 : -/\n41 : def round_pred (rnd : ℝ → ℝ → Prop) : Prop :=\n42 :   ∀ x : ℝ, ∃ y : ℝ, rnd x y\n43 : \n44 : /-- Monotonic rounding predicate\n45 :     \n46 :     A rounding predicate is monotonic if it preserves ordering:\n47 :     when rounding both x₁ and x₂, if x₁ ≤ x₂ then rnd(x₁) ≤ rnd(x₂).\n48 :     This property ensures consistent behavior across the real line.\n49 : -/\n50 : def round_pred_monotone (rnd : ℝ → ℝ → Prop) : Prop :=\n51 :   ∀ x₁ x₂ y₁ y₂ : ℝ, x₁ ≤ x₂ → rnd x₁ y₁ → rnd x₂ y₂ → y₁ ≤ y₂\n52 : \n53 : /-- Round down to nearest representable value below or equal\n54 :     \n55 :     Rnd_DN_pt F x f means f is the greatest element in format F\n56 :     such that f ≤ x. This captures IEEE 754's \"round toward\n57 :     negative infinity\" mode for the given format.\n58 : -/\n59 : def Rnd_DN_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=\n60 :   F f ∧ f ≤ x ∧ ∀ g : ℝ, F g → g ≤ x → g ≤ f\n61 : \n62 : /-- Round up to nearest representable value above or equal\n63 :     \n64 :     Rnd_UP_pt F x f means f is the smallest element in format F\n65 :     such that x ≤ f. This captures IEEE 754's \"round toward\n66 :     positive infinity\" mode for the given format.\n67 : -/\n68 : def Rnd_UP_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=\n69 :   F f ∧ x ≤ f ∧ ∀ g : ℝ, F g → x ≤ g → f ≤ g\n70 : \n71 : /-- Round toward zero (truncation)\n72 :     \n73 :     Rnd_ZR_pt F x f means f is the representable value closest\n74 :     to zero among those between 0 and x (inclusive). This\n75 :     implements IEEE 754's \"round toward zero\" mode.\n76 : -/\n77 : def Rnd_ZR_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=\n78 :   if x ≥ 0 then Rnd_DN_pt F x f else Rnd_UP_pt F x f\n79 : \n80 : /-- Round to nearest representable value\n81 :     \n82 :     Rnd_N_pt F x f means f minimizes |x - f| among all\n83 :     representable values. This is the foundation for\n84 :     IEEE 754's \"round to nearest\" modes.\n85 : -/\n86 : def Rnd_N_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=\n87 :   F f ∧ ∀ g : ℝ, F g → |x - f| ≤ |x - g|\n88 : \n89 : /-- Generic round to nearest with tie-breaking predicate\n90 :     \n91 :     Rnd_NG_pt F P x f means f is nearest to x, and in case of\n92 :     ties, the predicate P(x,f) determines the choice. This\n93 :     generalizes all round-to-nearest variants.\n94 : -/\n95 : def Rnd_NG_pt (F : ℝ → Prop) (P : ℝ → ℝ → Prop) (x f : ℝ) : Prop :=\n96 :   Rnd_N_pt F x f ∧ (∀ g : ℝ, F g → |x - g| = |x - f| → P x f)\n97 : \n98 : /-- Round ties away from zero\n99 :     \n100:     When exactly between two representable values, choose\n101:     the one farther from zero. This implements one common\n102:     tie-breaking strategy for round-to-nearest.\n103: -/\n104: def Rnd_NA_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=\n105:   Rnd_NG_pt F (fun x f => |f| ≥ |x|) x f\n106: \n107: /-- Round ties toward zero\n108:     \n109:     When exactly between two representable values, choose\n110:     the one closer to zero. This is an alternative\n111:     tie-breaking strategy for round-to-nearest.\n112: -/\n113: def Rnd_N0_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=\n114:   Rnd_NG_pt F (fun x f => |f| ≤ |x|) x f\n115: \n116: end BasicRoundingPredicates\n117: \n118: section RoundingFunctionProperties\n119: \n120: /-- Rounding down property for functions\n121:     \n122:     A rounding function rnd satisfies Rnd_DN if for every input x,\n123:     rnd(x) is the round-down value according to format F.\n124:     This lifts the pointwise property to functions.\n125: -/\n126: def Rnd_DN (F : ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n127:   pure (∀ x : ℝ, Rnd_DN_pt F x (rnd x))\n128: \n129: /-- Specification: Round down function property\n130:     \n131:     The round down property ensures that the function satisfies\n132:     the round down condition at every point. This provides a\n133:     functional interface to the pointwise rounding predicate.\n134: -/\n135: theorem Rnd_DN_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) :\n136:     ⦃⌜True⌝⦄\n137:     Rnd_DN F rnd\n138:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_DN_pt F x (rnd x))⌝⦄ := by\n139:   intro _\n140:   unfold Rnd_DN\n141:   rfl\n142: \n143: /-- Rounding up property for functions\n144:     \n145:     A rounding function rnd satisfies Rnd_UP if for every input x,\n146:     rnd(x) is the round-up value according to format F.\n147:     This provides the functional counterpart to round-up.\n148: -/\n149: def Rnd_UP (F : ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n150:   pure (∀ x : ℝ, Rnd_UP_pt F x (rnd x))\n151: \n152: /-- Specification: Round up function property\n153:     \n154:     The round up property ensures consistent upward rounding\n155:     behavior across all inputs. This guarantees the function\n156:     implementation matches the pointwise specification.\n157: -/\n158: theorem Rnd_UP_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) :\n159:     ⦃⌜True⌝⦄\n160:     Rnd_UP F rnd\n161:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_UP_pt F x (rnd x))⌝⦄ := by\n162:   intro _\n163:   unfold Rnd_UP\n164:   rfl\n165: \n166: /-- Rounding toward zero property for functions\n167:     \n168:     A function satisfies Rnd_ZR if it implements truncation:\n169:     round toward zero for all inputs. This combines round-down\n170:     for positive values and round-up for negative values.\n171: -/\n172: def Rnd_ZR (F : ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n173:   pure (∀ x : ℝ, Rnd_ZR_pt F x (rnd x))\n174: \n175: /-- Specification: Round toward zero function property\n176:     \n177:     The truncation property ensures the function always\n178:     rounds toward zero, providing consistent behavior\n179:     for both positive and negative inputs.\n180: -/\n181: theorem Rnd_ZR_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) :\n182:     ⦃⌜True⌝⦄\n183:     Rnd_ZR F rnd\n184:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_ZR_pt F x (rnd x))⌝⦄ := by\n185:   intro _\n186:   unfold Rnd_ZR\n187:   rfl\n188: \n189: /-- Round to nearest property for functions\n190:     \n191:     A function satisfies Rnd_N if it always returns the nearest\n192:     representable value. This is the base property for all\n193:     round-to-nearest modes without specifying tie-breaking.\n194: -/\n195: def Rnd_N (F : ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n196:   pure (∀ x : ℝ, Rnd_N_pt F x (rnd x))\n197: \n198: /-- Specification: Round to nearest function property\n199:     \n200:     The nearest-value property ensures optimal approximation:\n201:     the returned value minimizes the distance to the input\n202:     among all representable values in the format.\n203: -/\n204: theorem Rnd_N_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) :\n205:     ⦃⌜True⌝⦄\n206:     Rnd_N F rnd\n207:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_N_pt F x (rnd x))⌝⦄ := by\n208:   intro _\n209:   unfold Rnd_N\n210:   rfl\n211: \n212: /-- Generic rounding property with tie-breaking predicate\n213:     \n214:     A function satisfies Rnd_NG with predicate P if it rounds\n215:     to nearest and uses P to break ties. This generalizes\n216:     all round-to-nearest variants with different tie policies.\n217: -/\n218: def Rnd_NG (F : ℝ → Prop) (P : ℝ → ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n219:   pure (∀ x : ℝ, Rnd_NG_pt F P x (rnd x))\n220: \n221: /-- Specification: Generic round to nearest with tie-breaking\n222:     \n223:     The generic nearest property with custom tie-breaking\n224:     provides a unified framework for implementing various\n225:     IEEE 754 rounding modes and custom policies.\n226: -/\n227: theorem Rnd_NG_spec (F : ℝ → Prop) (P : ℝ → ℝ → Prop) (rnd : ℝ → ℝ) :\n228:     ⦃⌜True⌝⦄\n229:     Rnd_NG F P rnd\n230:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_NG_pt F P x (rnd x))⌝⦄ := by\n231:   intro _\n232:   unfold Rnd_NG\n233:   rfl\n234: \n235: /-- Round ties away from zero property\n236:     \n237:     A function satisfies Rnd_NA if it rounds to nearest,\n238:     breaking ties by choosing the value farther from zero.\n239:     This implements IEEE 754's \"away from zero\" tie-breaking.\n240: -/\n241: def Rnd_NA (F : ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n242:   pure (∀ x : ℝ, Rnd_NA_pt F x (rnd x))\n243: \n244: /-- Specification: Round ties away from zero\n245:     \n246:     The away-from-zero tie-breaking ensures that when exactly\n247:     between two representable values, the function chooses\n248:     the one with larger absolute value.\n249: -/\n250: theorem Rnd_NA_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) :\n251:     ⦃⌜True⌝⦄\n252:     Rnd_NA F rnd\n253:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_NA_pt F x (rnd x))⌝⦄ := by\n254:   intro _\n255:   unfold Rnd_NA\n256:   rfl\n257: \n258: /-- Round ties toward zero property\n259:     \n260:     A function satisfies Rnd_N0 if it rounds to nearest,\n261:     breaking ties by choosing the value closer to zero.\n262:     This provides an alternative tie-breaking strategy.\n263: -/\n264: def Rnd_N0 (F : ℝ → Prop) (rnd : ℝ → ℝ) : Id Prop :=\n265:   pure (∀ x : ℝ, Rnd_N0_pt F x (rnd x))\n266: \n267: /-- Specification: Round ties toward zero\n268:     \n269:     The toward-zero tie-breaking ensures that when exactly\n270:     between two representable values, the function chooses\n271:     the one with smaller absolute value.\n272: -/\n273: theorem Rnd_N0_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) :\n274:     ⦃⌜True⌝⦄\n275:     Rnd_N0 F rnd\n276:     ⦃⇓result => ⌜result = (∀ x : ℝ, Rnd_N0_pt F x (rnd x))⌝⦄ := by\n277:   intro _\n278:   unfold Rnd_N0\n279:   rfl\n280: \n281: end RoundingFunctionProperties\n282: \n283: section ExistenceAndUniqueness\n284: \n285: /-- Extract rounding value from predicate\n286:     \n287:     Given a rounding predicate that is known to hold,\n288:     extract the actual rounded value. This enables\n289:     computation from specification predicates.\n290: -/\n291: def round_val_of_pred (rnd : ℝ → ℝ → Prop) (x : ℝ) : Id ℝ :=\n292:   -- This would need to be implemented with choice\n293:   pure 0  -- placeholder\n294: \n295: /-- Specification: Value existence from round predicate\n296:     \n297:     Currently returns 0 as a placeholder. A proper implementation\n298:     would need classical choice to extract the actual value from\n299:     the predicate.\n300: -/\n301: theorem round_val_of_pred_spec (rnd : ℝ → ℝ → Prop) (x : ℝ) :\n302:     ⦃⌜round_pred rnd⌝⦄\n303:     round_val_of_pred rnd x\n304:     ⦃⇓f => ⌜f = 0⌝⦄ := by\n305:   intro h\n306:   unfold round_val_of_pred\n307:   rfl\n308: \n309: /-- Extract rounding function from predicate\n310:     \n311:     Given a rounding predicate, construct the corresponding\n312:     rounding function. This provides the functional interface\n313:     to relational rounding specifications.\n314: -/\n315: def round_fun_of_pred (rnd : ℝ → ℝ → Prop) : Id (ℝ → ℝ) :=\n316:   -- This would need choice/axioms to implement\n317:   pure (fun _ => 0)  -- placeholder\n318: \n319: /-- Specification: Function existence from round predicate\n320:     \n321:     Currently returns the constant function (fun _ => 0) as a placeholder.\n322:     A proper implementation would need classical choice to construct\n323:     the actual rounding function from the predicate.\n324: -/\n325: theorem round_fun_of_pred_spec (rnd : ℝ → ℝ → Prop) :\n326:     ⦃⌜round_pred rnd⌝⦄\n327:     round_fun_of_pred rnd\n328:     ⦃⇓f => ⌜f = fun _ => 0⌝⦄ := by\n329:   intro h\n330:   unfold round_fun_of_pred\n331:   rfl\n332: \n333: /-- Check uniqueness of rounding result\n334:     \n335:     Verify that a monotonic rounding predicate produces\n336:     unique results. This is essential for the deterministic\n337:     nature of rounding functions.\n338: -/\n339: def round_unique_check (rnd : ℝ → ℝ → Prop) (x f1 f2 : ℝ) : Id Bool :=\n340:   pure true  -- Always true for monotonic predicates\n341: \n342: /-- Specification: Uniqueness of rounding result\n343:     \n344:     Monotonic rounding predicates produce unique results.\n345:     This ensures that rounding functions are well-defined\n346:     and deterministic for any given input.\n347: -/\n348: theorem round_unique_spec (rnd : ℝ → ℝ → Prop) (x f1 f2 : ℝ) :\n349:     ⦃⌜round_pred_monotone rnd ∧ rnd x f1 ∧ rnd x f2⌝⦄\n350:     round_unique_check rnd x f1 f2\n351:     ⦃⇓result => ⌜result = true⌝⦄ := by\n352:   intro _\n353:   unfold round_unique_check\n354:   rfl\n355: \n356: end ExistenceAndUniqueness\n357: \n358: section RoundDownProperties\n359: \n360: /-- Check if round down satisfies monotonicity\n361:     \n362:     Verify that the round down predicate preserves ordering:\n363:     if x₁ ≤ x₂, then round_down(x₁) ≤ round_down(x₂).\n364:     This fundamental property ensures consistent behavior.\n365: -/\n366: def Rnd_DN_pt_monotone_check (F : ℝ → Prop) : Id Bool :=\n367:   pure true  -- Round down is always monotone\n368: \n369: /-- Specification: Round down is monotone\n370:     \n371:     The round down operation preserves ordering relationships.\n372:     This monotonicity property is essential for the correctness\n373:     of downward rounding in floating-point systems.\n374: -/\n375: theorem Rnd_DN_pt_monotone_spec (F : ℝ → Prop) :\n376:     ⦃⌜True⌝⦄\n377:     Rnd_DN_pt_monotone_check F\n378:     ⦃⇓result => ⌜result = true⌝⦄ := by\n379:   intro _\n380:   unfold Rnd_DN_pt_monotone_check\n381:   rfl\n382: \n383: /-- Check uniqueness of round down result\n384:     \n385:     Verify that round down produces unique results for\n386:     any given input. This ensures deterministic behavior\n387:     of the downward rounding operation.\n388: -/\n389: def Rnd_DN_pt_unique_check (F : ℝ → Prop) (x f1 f2 : ℝ) : Id Bool :=\n390:   pure true  -- Round down always produces unique results\n391: \n392: /-- Specification: Round down point is unique\n393:     \n394:     The round down operation produces a unique result for\n395:     each input. This uniqueness is fundamental to the\n396:     deterministic nature of floating-point rounding.\n397: -/\n398: theorem Rnd_DN_pt_unique_spec (F : ℝ → Prop) (x f1 f2 : ℝ) :\n399:     ⦃⌜Rnd_DN_pt F x f1 ∧ Rnd_DN_pt F x f2⌝⦄\n400:     Rnd_DN_pt_unique_check F x f1 f2\n401:     ⦃⇓result => ⌜result = true⌝⦄ := by\n402:   intro _\n403:   unfold Rnd_DN_pt_unique_check\n404:   rfl\n405: \n406: /-- Check uniqueness of round down function\n407:     \n408:     Verify that round down functions are unique: if two\n409:     functions both satisfy the round down property,\n410:     they produce identical results on all inputs.\n411: -/\n412: def Rnd_DN_unique_check (F : ℝ → Prop) (rnd1 rnd2 : ℝ → ℝ) (x : ℝ) : Id Bool :=\n413:   pure true  -- Round down functions are unique\n414: \n415: /-- Specification: Round down function is unique\n416:     \n417:     Round down functions are uniquely determined by their\n418:     specification. Any two functions satisfying the round\n419:     down property must be identical.\n420: -/\n421: theorem Rnd_DN_unique_spec (F : ℝ → Prop) (rnd1 rnd2 : ℝ → ℝ) (x : ℝ) :\n422:     ⦃⌜∃ p1 p2, Rnd_DN F rnd1 = pure p1 ∧ Rnd_DN F rnd2 = pure p2 ∧ p1 ∧ p2⌝⦄\n423:     Rnd_DN_unique_check F rnd1 rnd2 x\n424:     ⦃⇓result => ⌜result = true⌝⦄ := by\n425:   intro _\n426:   unfold Rnd_DN_unique_check\n427:   rfl\n428: \n429: end RoundDownProperties\n430: \n431: section RoundUpProperties\n432: \n433: /-- Check if round up satisfies monotonicity\n434:     \n435:     Verify that the round up predicate preserves ordering:\n436:     upward rounding maintains the same relative ordering\n437:     as the input values.\n438: -/\n439: def Rnd_UP_pt_monotone_check (F : ℝ → Prop) : Id Bool :=\n440:   pure true  -- Round up is always monotone\n441: \n442: /-- Specification: Round up is monotone\n443:     \n444:     The round up operation preserves ordering relationships.\n445:     This property ensures predictable behavior across\n446:     the entire range of representable values.\n447: -/\n448: theorem Rnd_UP_pt_monotone_spec (F : ℝ → Prop) :\n449:     ⦃⌜True⌝⦄\n450:     Rnd_UP_pt_monotone_check F\n451:     ⦃⇓result => ⌜result = true⌝⦄ := by\n452:   intro _\n453:   unfold Rnd_UP_pt_monotone_check\n454:   rfl\n455: \n456: /-- Check uniqueness of round up result\n457:     \n458:     Verify that round up produces unique results.\n459:     Each input has exactly one correct round up value\n460:     in the given format.\n461: -/\n462: def Rnd_UP_pt_unique_check (F : ℝ → Prop) (x f1 f2 : ℝ) : Id Bool :=\n463:   pure true  -- Round up always produces unique results\n464: \n465: /-- Specification: Round up point is unique\n466:     \n467:     The round up operation is deterministic: each input\n468:     maps to exactly one output value. This uniqueness\n469:     ensures consistent floating-point behavior.\n470: -/\n471: theorem Rnd_UP_pt_unique_spec (F : ℝ → Prop) (x f1 f2 : ℝ) :\n472:     ⦃⌜Rnd_UP_pt F x f1 ∧ Rnd_UP_pt F x f2⌝⦄\n473:     Rnd_UP_pt_unique_check F x f1 f2\n474:     ⦃⇓result => ⌜result = true⌝⦄ := by\n475:   intro _\n476:   unfold Rnd_UP_pt_unique_check\n477:   rfl\n478: \n479: /-- Check uniqueness of round up function\n480:     \n481:     Verify that round up functions are uniquely determined.\n482:     The specification completely characterizes the\n483:     implementation, ensuring no ambiguity.\n484: -/\n485: def Rnd_UP_unique_check (F : ℝ → Prop) (rnd1 rnd2 : ℝ → ℝ) (x : ℝ) : Id Bool :=\n486:   pure true  -- Round up functions are unique\n487: \n488: /-- Specification: Round up function is unique\n489:     \n490:     Round up functions are completely characterized by\n491:     their specification. This uniqueness guarantees\n492:     implementation consistency across different systems.\n493: -/\n494: theorem Rnd_UP_unique_spec (F : ℝ → Prop) (rnd1 rnd2 : ℝ → ℝ) (x : ℝ) :\n495:     ⦃⌜∃ p1 p2, Rnd_UP F rnd1 = pure p1 ∧ Rnd_UP F rnd2 = pure p2 ∧ p1 ∧ p2⌝⦄\n496:     Rnd_UP_unique_check F rnd1 rnd2 x\n497:     ⦃⇓result => ⌜result = true⌝⦄ := by\n498:   intro _\n499:   unfold Rnd_UP_unique_check\n500:   rfl\n501: \n502: end RoundUpProperties\n503: \n504: section DualityProperties\n505: \n506: /-- Transform round down to round up via negation\n507:     \n508:     If f is the round down of x, then -f is the round up\n509:     of -x. This duality property connects upward and\n510:     downward rounding through sign changes.\n511: -/\n512: def Rnd_UP_pt_opp_transform (F : ℝ → Prop) (x f : ℝ) : Id Bool :=\n513:   pure true  -- Duality always holds\n514: \n515: /-- Specification: Round up from round down with opposite\n516:     \n517:     The duality between round up and round down through\n518:     negation enables implementing one mode in terms of\n519:     the other, reducing implementation complexity.\n520: -/\n521: theorem Rnd_UP_pt_opp_spec (F : ℝ → Prop) (x f : ℝ) :\n522:     ⦃⌜(∀ y, F y → F (-y)) ∧ Rnd_DN_pt F x f⌝⦄\n523:     Rnd_UP_pt_opp_transform F x f\n524:     ⦃⇓result => ⌜result = true⌝⦄ := by\n525:   intro _\n526:   unfold Rnd_UP_pt_opp_transform\n527:   rfl\n528: \n529: /-- Transform round up to round down via negation\n530:     \n531:     If f is the round up of x, then -f is the round down\n532:     of -x. This is the reverse duality that completes\n533:     the bidirectional relationship.\n534: -/\n535: def Rnd_DN_pt_opp_transform (F : ℝ → Prop) (x f : ℝ) : Id Bool :=\n536:   pure true  -- Reverse duality always holds\n537: \n538: /-- Specification: Round down from round up with opposite\n539:     \n540:     The reverse duality enables complete interconversion\n541:     between upward and downward rounding modes through\n542:     negation, providing implementation flexibility.\n543: -/\n544: theorem Rnd_DN_pt_opp_spec (F : ℝ → Prop) (x f : ℝ) :\n545:     ⦃⌜(∀ y, F y → F (-y)) ∧ Rnd_UP_pt F x f⌝⦄\n546:     Rnd_DN_pt_opp_transform F x f\n547:     ⦃⇓result => ⌜result = true⌝⦄ := by\n548:   intro _\n549:   unfold Rnd_DN_pt_opp_transform\n550:   rfl\n551: \n552: end DualityProperties\n553: \n554: section ReflexivityAndIdempotency\n555: \n556: /-- Check reflexivity of round down\n557:     \n558:     Verify that if x is representable in format F,\n559:     then rounding down x yields x itself.\n560:     This captures the exactness property.\n561: -/\n562: def Rnd_DN_pt_refl_check (F : ℝ → Prop) (x : ℝ) : Id Bool :=\n563:   pure true  -- Reflexivity always holds for representable values\n564: \n565: /-- Specification: Round down is reflexive\n566:     \n567:     Representable values are unchanged by round down.\n568:     This reflexivity ensures that exact values remain\n569:     exact under rounding operations.\n570: -/\n571: theorem Rnd_DN_pt_refl_spec (F : ℝ → Prop) (x : ℝ) :\n572:     ⦃⌜F x⌝⦄\n573:     Rnd_DN_pt_refl_check F x\n574:     ⦃⇓result => ⌜result = true⌝⦄ := by\n575:   intro _\n576:   unfold Rnd_DN_pt_refl_check\n577:   rfl\n578: \n579: /-- Check idempotency of round down\n580:     \n581:     Verify that rounding down an already-representable\n582:     value returns that same value. This ensures\n583:     stability under repeated rounding.\n584: -/\n585: def Rnd_DN_pt_idempotent_check (F : ℝ → Prop) (x f : ℝ) : Id Bool :=\n586:   pure true  -- Idempotency always holds\n587: \n588: /-- Specification: Round down is idempotent\n589:     \n590:     Rounding representable values produces those same values.\n591:     This idempotency property ensures that representable\n592:     values form fixed points of the rounding operation.\n593: -/\n594: theorem Rnd_DN_pt_idempotent_spec (F : ℝ → Prop) (x f : ℝ) :\n595:     ⦃⌜Rnd_DN_pt F x f ∧ F x⌝⦄\n596:     Rnd_DN_pt_idempotent_check F x f\n597:     ⦃⇓result => ⌜result = true⌝⦄ := by\n598:   intro _\n599:   unfold Rnd_DN_pt_idempotent_check\n600:   rfl\n601: \n602: /-- Check reflexivity of round up\n603:     \n604:     Verify that round up preserves representable values.\n605:     Like round down, representable inputs should\n606:     remain unchanged.\n607: -/\n608: def Rnd_UP_pt_refl_check (F : ℝ → Prop) (x : ℝ) : Id Bool :=\n609:   pure true  -- Reflexivity holds for round up\n610: \n611: /-- Specification: Round up is reflexive\n612:     \n613:     Round up preserves representable values exactly.\n614:     This reflexivity is symmetric to the round down\n615:     property and ensures consistent behavior.\n616: -/\n617: theorem Rnd_UP_pt_refl_spec (F : ℝ → Prop) (x : ℝ) :\n618:     ⦃⌜F x⌝⦄\n619:     Rnd_UP_pt_refl_check F x\n620:     ⦃⇓result => ⌜result = true⌝⦄ := by\n621:   intro _\n622:   unfold Rnd_UP_pt_refl_check\n623:   rfl\n624: \n625: /-- Check idempotency of round up\n626:     \n627:     Verify that round up is idempotent on representable\n628:     values, mirroring the round down idempotency property.\n629: -/\n630: def Rnd_UP_pt_idempotent_check (F : ℝ → Prop) (x f : ℝ) : Id Bool :=\n631:   pure true  -- Idempotency holds for round up\n632: \n633: /-- Specification: Round up is idempotent\n634:     \n635:     Round up leaves representable values unchanged.\n636:     This completes the idempotency properties for\n637:     both directional rounding modes.\n638: -/\n639: theorem Rnd_UP_pt_idempotent_spec (F : ℝ → Prop) (x f : ℝ) :\n640:     ⦃⌜Rnd_UP_pt F x f ∧ F x⌝⦄\n641:     Rnd_UP_pt_idempotent_check F x f\n642:     ⦃⇓result => ⌜result = true⌝⦄ := by\n643:   intro _\n644:   unfold Rnd_UP_pt_idempotent_check\n645:   rfl\n646: \n647: end ReflexivityAndIdempotency\n648: \n649: section RoundTowardZeroProperties\n650: \n651: /-- Check absolute value bound for round toward zero\n652:     \n653:     Verify that rounding toward zero never increases\n654:     the absolute value: |round_toward_zero(x)| ≤ |x|.\n655:     This captures the truncation property.\n656: -/\n657: def Rnd_ZR_abs_check (F : ℝ → Prop) (rnd : ℝ → ℝ) (x : ℝ) : Id Bool :=\n658:   pure true  -- Round toward zero always satisfies the absolute value bound\n659: \n660: /-- Specification: Round toward zero absolute value bound\n661:     \n662:     Rounding toward zero (truncation) never increases\n663:     absolute values. This fundamental property makes\n664:     truncation useful for implementing magnitude bounds.\n665: -/\n666: theorem Rnd_ZR_abs_spec (F : ℝ → Prop) (rnd : ℝ → ℝ) (x : ℝ) :\n667:     ⦃⌜∃ p, Rnd_ZR F rnd = pure p ∧ p⌝⦄\n668:     Rnd_ZR_abs_check F rnd x\n669:     ⦃⇓result => ⌜result = true⌝⦄ := by\n670:   intro _\n671:   unfold Rnd_ZR_abs_check\n672:   rfl\n673: \n674: end RoundTowardZeroProperties\n675: \n676: end FloatSpec.Core.Round_pred\n"
  }
}
[2025-09-15T19:52:28] tokens used: 68937
[2025-09-15T19:52:35] codex

I’ll search for `succ` and `pred` definitions to confirm availability.
[2025-09-15T19:52:36] exec bash -lc "grep -R \"\\bsucc\\b beta\" -n FloatSpec/src/Core || true" in /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
[2025-09-15T19:52:36] bash -lc "grep -R \"\\bsucc\\b beta\" -n FloatSpec/src/Core || true" succeeded in 400ms:

[2025-09-15T19:52:36] tokens used: 77695
[2025-09-15T19:52:42] exec bash -lc "grep -R \"\\bsucc\\b\" -n FloatSpec/src/Core | head" in /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
[2025-09-15T19:52:42] bash -lc "grep -R \"\\bsucc\\b\" -n FloatSpec/src/Core | head" succeeded in 327ms:
FloatSpec/src/Core/Zaux.lean:1265:  | succ n' ih =>
FloatSpec/src/Core/Generic_fmt.lean:120:    | succ n ih =>
FloatSpec/src/Core/Digits.lean:782:        have hkltl_nat : ∃ t : Nat, t.succ + k.natAbs = l.natAbs := by
FloatSpec/src/Core/Digits.lean:789:          -- Then (l - k).natAbs = t.succ for some t
FloatSpec/src/Core/Digits.lean:793:          calc t.succ + k.natAbs
FloatSpec/src/Core/Digits.lean:805:        have hpow_split : beta ^ l.natAbs = beta ^ (k.natAbs + Nat.succ t) := by rw [← ht]; simp [Nat.add_comm]
FloatSpec/src/Core/Digits.lean:806:        have hpow_split' : beta ^ l.natAbs = (beta ^ (Nat.succ t)) * (beta ^ k.natAbs) := by
FloatSpec/src/Core/Digits.lean:808:        have q_eq : Int.tdiv (n * beta ^ l.natAbs) (beta ^ k.natAbs) = n * beta ^ (Nat.succ t) := by
FloatSpec/src/Core/Digits.lean:815:        have dvd_beta : beta ∣ (beta ^ (Nat.succ t)) := by
FloatSpec/src/Core/Digits.lean:820:        have dvd_q : beta ∣ (n * beta ^ (Nat.succ t)) := dvd_mul_of_dvd_right dvd_beta n
[2025-09-15T19:52:42] tokens used: 77803
[2025-09-15T19:52:58] codex

I’ll add the first missing theorem `round_FLT_FLX` to FLT.lean, then build to check for errors.
[2025-09-15T19:53:13] apply_patch auto_approved=true:
M /Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLT.lean
@@ -464 +464,26 @@
 end FloatSpec.Core.FLT
+
+namespace FloatSpec.Core.FLT
+
+variable (prec emin : Int)
+
+/-
+Coq (FLT.v):
+Theorem round_FLT_FLX : forall rnd x,
+  (bpow (emin + prec - 1) <= Rabs x)%R ->
+  round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x.
+
+Lean (spec): Under the lower-bound condition on |x|, rounding in
+FLT equals rounding in FLX for any rounding predicate `rnd`.
+-/
+theorem round_FLT_FLX (beta : Int) (rnd : ℝ → ℝ → Prop) (x : ℝ) :
+    ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄
+    (do
+      let rFLT := FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x
+      let rFLX := FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x
+      pure (rFLT, rFLX))
+    ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by
+  intro _
+  sorry
+
+end FloatSpec.Core.FLT
[2025-09-15T19:53:13] apply_patch(auto_approved=true) exited 0 in 14ms:
Success. Updated the following files:
M FloatSpec/src/Core/FLT.lean
[2025-09-15T19:53:13] turn diff:
diff --git a/FloatSpec/src/Core/FLT.lean b/FloatSpec/src/Core/FLT.lean
index 97a571572a5035146127a1d7b0667406b5dc3330..966a1dfc2fc1107e14df36d0b361ed762858740c
--- a/FloatSpec/src/Core/FLT.lean
+++ b/FloatSpec/src/Core/FLT.lean
@@ -462,3 +462,28 @@
   sorry
 
 end FloatSpec.Core.FLT
+
+namespace FloatSpec.Core.FLT
+
+variable (prec emin : Int)
+
+/-
+Coq (FLT.v):
+Theorem round_FLT_FLX : forall rnd x,
+  (bpow (emin + prec - 1) <= Rabs x)%R ->
+  round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x.
+
+Lean (spec): Under the lower-bound condition on |x|, rounding in
+FLT equals rounding in FLX for any rounding predicate `rnd`.
+-/
+theorem round_FLT_FLX (beta : Int) (rnd : ℝ → ℝ → Prop) (x : ℝ) :
+    ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄
+    (do
+      let rFLT := FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x
+      let rFLX := FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x
+      pure (rFLT, rFLX))
+    ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by
+  intro _
+  sorry
+
+end FloatSpec.Core.FLT

[2025-09-15T19:53:13] tokens used: 79538
[2025-09-15T19:53:13] turn diff:
diff --git a/FloatSpec/src/Core/FLT.lean b/FloatSpec/src/Core/FLT.lean
index 97a571572a5035146127a1d7b0667406b5dc3330..966a1dfc2fc1107e14df36d0b361ed762858740c
--- a/FloatSpec/src/Core/FLT.lean
+++ b/FloatSpec/src/Core/FLT.lean
@@ -462,3 +462,28 @@
   sorry
 
 end FloatSpec.Core.FLT
+
+namespace FloatSpec.Core.FLT
+
+variable (prec emin : Int)
+
+/-
+Coq (FLT.v):
+Theorem round_FLT_FLX : forall rnd x,
+  (bpow (emin + prec - 1) <= Rabs x)%R ->
+  round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x.
+
+Lean (spec): Under the lower-bound condition on |x|, rounding in
+FLT equals rounding in FLX for any rounding predicate `rnd`.
+-/
+theorem round_FLT_FLX (beta : Int) (rnd : ℝ → ℝ → Prop) (x : ℝ) :
+    ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄
+    (do
+      let rFLT := FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x
+      let rFLX := FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x
+      pure (rFLT, rFLX))
+    ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by
+  intro _
+  sorry
+
+end FloatSpec.Core.FLT

[2025-09-15T19:53:17] codex

Building just this file to ensure it typechecks before adding more.
[2025-09-15T19:53:19] tool lean-lsp-mcp.lean_diagnostic_messages({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLT.lean"})
[2025-09-15T19:53:35] lean-lsp-mcp.lean_diagnostic_messages({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLT.lean"}) success in 16.42s:
{
  "content": [
    {
      "text": "l63c9-l63c21, severity: 2\ndeclaration uses 'sorry'",
      "type": "text"
    },
    {
      "text": "l80c10-l80c23, severity: 2\ndeclaration uses 'sorry'",
      "type": "text"
    },
    {
      "text": "l102c9-l102c24, severity: 2\ndeclaration uses 'sorry'",
      "type": "text"
    },
    {
      "text": "l114c9-l114c29, severity: 2\ndeclaration uses 'sorry'",
      "type": "text"
    },
    {
      "text": "l126c25-l126c29, severity: 2\nunused variable `beta`\n\nNote: This linter can be disabled with `set_option linter.unusedVariables false`",
[2025-09-15T19:53:35] tokens used: 79745
[2025-09-15T19:53:35] turn diff:
diff --git a/FloatSpec/src/Core/FLT.lean b/FloatSpec/src/Core/FLT.lean
index 97a571572a5035146127a1d7b0667406b5dc3330..966a1dfc2fc1107e14df36d0b361ed762858740c
--- a/FloatSpec/src/Core/FLT.lean
+++ b/FloatSpec/src/Core/FLT.lean
@@ -462,3 +462,28 @@
   sorry
 
 end FloatSpec.Core.FLT
+
+namespace FloatSpec.Core.FLT
+
+variable (prec emin : Int)
+
+/-
+Coq (FLT.v):
+Theorem round_FLT_FLX : forall rnd x,
+  (bpow (emin + prec - 1) <= Rabs x)%R ->
+  round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x.
+
+Lean (spec): Under the lower-bound condition on |x|, rounding in
+FLT equals rounding in FLX for any rounding predicate `rnd`.
+-/
+theorem round_FLT_FLX (beta : Int) (rnd : ℝ → ℝ → Prop) (x : ℝ) :
+    ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄
+    (do
+      let rFLT := FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x
+      let rFLX := FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x
+      pure (rFLT, rFLX))
+    ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by
+  intro _
+  sorry
+
+end FloatSpec.Core.FLT

[2025-09-15T19:53:49] thinking

I need to look into FLX.FLX_exp and see if there's an instance in FLX.lean. It’s important that I check this because I want to confirm whether the FLX_exp_valid instance exists. This will help me avoid any potential issues down the road. So, I'm planning to open FLX.lean to verify everything is set up correctly. It's all about making sure I have the right information in front of me!
[2025-09-15T19:53:51] codex

I’ll open `FLX.lean` to confirm the `Valid_exp` instance exists for `FLX_exp`.
[2025-09-15T19:53:51] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLX.lean"})
[2025-09-15T19:53:51] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLX.lean"}) success in 2ms:
{
  "content": [
    {
      "text": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Defs\n20 : import FloatSpec.src.Core.Generic_fmt\n21 : import Mathlib.Data.Real.Basic\n22 : import Std.Do.Triple\n23 : import Std.Tactic.Do\n24 : import FloatSpec.src.Core.Round_generic\n25 : import FloatSpec.src.Core.FIX\n26 : \n27 : \n28 : open Real\n29 : open Std.Do\n30 : open FloatSpec.Core.Generic_fmt\n31 : open FloatSpec.Core.Round_generic\n32 : \n33 : namespace FloatSpec.Core.FLX\n34 : \n35 : variable (prec : Int)\n36 : \n37 : /-- Fixed-precision exponent function\n38 : \n39 :     In fixed-precision format, the exponent is adjusted to maintain\n40 :     a constant precision. The exponent function returns e - prec,\n41 :     which ensures that mantissas have exactly 'prec' significant digits.\n42 : -/\n43 : def FLX_exp (e : Int) : Int :=\n44 :   e - prec\n45 : \n46 : /-- Check FLX exponent function correctness\n47 : \n48 :     Verify that the FLX exponent function computes e - prec\n49 :     correctly for any input e. This validates the precision\n50 :     adjustment mechanism.\n51 : -/\n52 : def FLX_exp_correct_check (e : Int) : Id Bool :=\n53 :   pure (FLX_exp prec e = e - prec)\n54 : \n55 : /-- Specification: Fixed-precision exponent calculation\n56 : \n57 :     The FLX exponent function subtracts the precision from the\n58 :     input exponent. This adjustment ensures that all representable\n59 :     numbers have exactly 'prec' significant digits in their mantissa.\n60 : -/\n61 : theorem FLX_exp_spec (e : Int) :\n62 :     ⦃⌜True⌝⦄\n63 :     FLX_exp_correct_check prec e\n64 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n65 :   sorry\n66 : \n67 : /-- Fixed-precision format predicate\n68 : \n69 :     A real number x is in FLX format if it can be represented\n70 :     using the generic format with the fixed-precision exponent\n71 :     function. This gives x = m × β^(e-prec) where m has bounded magnitude.\n72 : -/\n73 : def FLX_format (beta : Int) (x : ℝ) : Id Prop :=\n74 :   FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x\n75 : \n76 : /-- Specification: FLX format using generic format\n77 : \n78 :     The FLX format is defined through the generic format mechanism\n79 :     with the fixed-precision exponent function. This characterizes\n80 :     floating-point numbers with constant precision.\n81 : -/\n82 : theorem FLX_format_spec (beta : Int) (x : ℝ) :\n83 :     ⦃⌜True⌝⦄\n84 :     FLX_format prec beta x\n85 :     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x).run⌝⦄ := by\n86 :   sorry\n87 : \n88 : /-- Specification: FLX exponent function correctness\n89 : \n90 :     The FLX exponent function correctly implements the precision\n91 :     adjustment by returning e - prec. This ensures the mantissa\n92 :     precision remains constant across different magnitudes.\n93 : -/\n94 : theorem FLX_exp_correct_spec (e : Int) :\n95 :     ⦃⌜True⌝⦄\n96 :     FLX_exp_correct_check prec e\n97 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n98 :   sorry\n99 : \n100: /-- Check if zero is in FLX format\n101: \n102:     Verify that zero is representable in the fixed-precision format.\n103:     Zero should always be representable regardless of the precision\n104:     since it can be expressed as 0 × β^e for any exponent e.\n105: -/\n106: def FLX_format_0_check (beta : Int) : Id Bool :=\n107:   pure true  -- Zero is always in format\n108: \n109: /-- Specification: Zero is in FLX format\n110: \n111:     Zero is always representable in fixed-precision format.\n112:     This follows from the fact that 0 = 0 × β^(e-prec) for\n113:     any exponent e, making zero universal across all formats.\n114: -/\n115: theorem FLX_format_0_spec (beta : Int) :\n116:     ⦃⌜beta > 1⌝⦄\n117:     FLX_format_0_check beta\n118:     ⦃⇓result => ⌜result = true⌝⦄ := by\n119:   sorry\n120: \n121: /-- Check closure under negation\n122: \n123:     Verify that if x is in FLX format, then -x is also in FLX format.\n124:     This tests the closure property under additive inverse for\n125:     fixed-precision floating-point numbers.\n126: -/\n127: def FLX_format_opp_check (beta : Int) (x : ℝ) : Id Bool :=\n128:   pure true  -- Always true for fixed-precision formats\n129: \n130: /-- Specification: FLX format closed under negation\n131: \n132:     Fixed-precision formats are closed under negation. If x is\n133:     representable as m × β^(e-prec), then -x is representable\n134:     as (-m) × β^(e-prec), preserving precision and format properties.\n135: -/\n136: theorem FLX_format_opp_spec (beta : Int) (x : ℝ) :\n137:     ⦃⌜(FLX_format prec beta x).run⌝⦄\n138:     FLX_format_opp_check beta x\n139:     ⦃⇓result => ⌜result = true⌝⦄ := by\n140:   sorry\n141: \n142: /-- Check closure under absolute value\n143: \n144:     Verify that if x is in FLX format, then |x| is also in FLX format.\n145:     This tests closure under the absolute value operation, which\n146:     should preserve representability in fixed-precision formats.\n147: -/\n148: def FLX_format_abs_check (beta : Int) (x : ℝ) : Id Bool :=\n149:   pure true  -- Always true for fixed-precision formats\n150: \n151: /-- Specification: FLX format closed under absolute value\n152: \n153:     Fixed-precision formats are closed under absolute value.\n154:     If x is representable, then |x| is also representable since\n155:     |x| can use the same mantissa magnitude with appropriate sign.\n156: -/\n157: theorem FLX_format_abs_spec (beta : Int) (x : ℝ) :\n158:     ⦃⌜(FLX_format prec beta x).run⌝⦄\n159:     FLX_format_abs_check beta x\n160:     ⦃⇓result => ⌜result = true⌝⦄ := by\n161:   sorry\n162: \n163: end FloatSpec.Core.FLX\n164: \n165: namespace FloatSpec.Core.FLX\n166: \n167: variable (prec : Int)\n168: \n169: /-\n170: Coq (FLX.v):\n171: Theorem generic_format_FLX :\n172:   forall x, FLX_format x -> generic_format beta FLX_exp x.\n173: -/\n174: theorem generic_format_FLX (beta : Int) (x : ℝ) :\n175:     ⦃⌜(FLX_format prec beta x).run⌝⦄\n176:     FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x\n177:     ⦃⇓result => ⌜result⌝⦄ := by\n178:   intro hx\n179:   simpa [FLX_format]\n180: \n181: end FloatSpec.Core.FLX\n182: \n183: namespace FloatSpec.Core.FLX\n184: \n185: variable (prec : Int)\n186: \n187: /-\n188: Coq (FLX.v):\n189: Theorem FIX_format_FLX :\n190:   forall x e,\n191:   (bpow (e - 1) <= Rabs x <= bpow e)%R ->\n192:   FLX_format x ->\n193:   FIX_format beta (e - prec) x.\n194: \n195: Lean (spec): If |x| lies in [β^(e-1), β^e] and x is in FLX_format,\n196: then x is in FIX_format with minimal exponent (e - prec).\n197: -/\n198: theorem FIX_format_FLX (beta : Int) (x : ℝ) (e : Int) :\n199:     ⦃⌜(beta : ℝ) ^ (e - 1) ≤ |x| ∧ |x| ≤ (beta : ℝ) ^ e ∧ (FLX_format prec beta x).run⌝⦄\n200:     FloatSpec.Core.FIX.FIX_format (emin := e - prec) beta x\n201:     ⦃⇓result => ⌜result⌝⦄ := by\n202:   intro _\n203:   -- Proof follows Coq's FIX_format_FLX; omitted for now\n204:   sorry\n205: \n206: /-\n207: Coq (FLX.v):\n208: Theorem FLX_format_FIX :\n209:   forall x e,\n210:   (bpow (e - 1) <= Rabs x <= bpow e)%R ->\n211:   FIX_format beta (e - prec) x ->\n212:   FLX_format x.\n213: \n214: Lean (spec): If |x| lies in [β^(e-1), β^e] and x is in FIX_format\n215: with minimal exponent (e - prec), then x is in FLX_format.\n216: -/\n217: theorem FLX_format_FIX (beta : Int) (x : ℝ) (e : Int) :\n218:     ⦃⌜(beta : ℝ) ^ (e - 1) ≤ |x| ∧ |x| ≤ (beta : ℝ) ^ e ∧ (FloatSpec.Core.FIX.FIX_format (emin := e - prec) beta x).run⌝⦄\n219:     FLX_format prec beta x\n220:     ⦃⇓result => ⌜result⌝⦄ := by\n221:   intro _\n222:   -- Proof follows Coq's FLX_format_FIX; omitted for now\n223:   sorry\n224: \n225: end FloatSpec.Core.FLX\n226: \n227: namespace FloatSpec.Core.FLX\n228: \n229: variable (prec : Int)\n230: \n231: /- Valid_exp instance for FLX_exp (placeholder). -/\n232: instance FLX_exp_valid (beta : Int) :\n233:     FloatSpec.Core.Generic_fmt.Valid_exp beta (FLX_exp prec) := by\n234:   refine ⟨?_⟩\n235:   intro k\n236:   refine And.intro ?h1 ?h2\n237:   · intro _\n238:     -- Proof omitted for now\n239:     sorry\n240:   · intro _\n241:     refine And.intro ?hA ?hB\n242:     · -- Proof omitted for now\n243:       sorry\n244:     · intro _ _\n245:       -- Proof omitted for now\n246:       sorry\n247: \n248: /-\n249: Coq (FLX.v):\n250: Theorem FLX_format_satisfies_any :\n251:   satisfies_any FLX_format.\n252: -/\n253: theorem FLX_format_satisfies_any (beta : Int) :\n254:     FloatSpec.Core.Generic_fmt.satisfies_any (fun y => (FLX_format prec beta y).run) := by\n255:   simpa [FLX_format]\n256:     using FloatSpec.Core.Generic_fmt.generic_format_satisfies_any (beta := beta) (fexp := FLX_exp prec)\n257: \n258: end FloatSpec.Core.FLX\n259: \n260: namespace FloatSpec.Core.FLX\n261: \n262: variable (prec : Int)\n263: \n264: /-\n265: Coq (FLX.v):\n266: Theorem FLX_format_generic :\n267:   forall x, generic_format beta FLX_exp x -> FLX_format x.\n268: -/\n269: theorem FLX_format_generic (beta : Int) (x : ℝ) :\n270:     ⦃⌜(FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x).run⌝⦄\n271:     FLX_format prec beta x\n272:     ⦃⇓result => ⌜result⌝⦄ := by\n273:   intro hx\n274:   simpa [FLX_format] using hx\n275: \n276: end FloatSpec.Core.FLX\n277: \n278: namespace FloatSpec.Core.FLX\n279: \n280: variable (prec : Int)\n281: \n282: /-\n283: Coq (FLX.v):\n284: Theorem generic_format_FLX_1 :\n285:   generic_format beta FLX_exp 1.\n286: -/\n287: theorem generic_format_FLX_1 (beta : Int) :\n288:     ⦃⌜True⌝⦄\n289:     FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) 1\n290:     ⦃⇓result => ⌜result⌝⦄ := by\n291:   intro _\n292:   sorry\n293: \n294: end FloatSpec.Core.FLX\n295: \n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "1  : /-\n2  : This file is part of the Flocq formalization of floating-point\n3  : arithmetic in Lean 4, ported from Coq: https://flocq.gitlabpages.inria.fr/\n4  : \n5  : Original Copyright (C) 2011-2018 Sylvie Boldo\n6  : Original Copyright (C) 2011-2018 Guillaume Melquiond\n7  : \n8  : This library is free software; you can redistribute it and/or\n9  : modify it under the terms of the GNU Lesser General Public\n10 : License as published by the Free Software Foundation; either\n11 : version 3 of the License, or (at your option) any later version.\n12 : \n13 : This library is distributed in the hope that it will be useful,\n14 : but WITHOUT ANY WARRANTY; without even the implied warranty of\n15 : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n16 : COPYING file for more details.\n17 : -/\n18 : \n19 : import FloatSpec.src.Core.Defs\n20 : import FloatSpec.src.Core.Generic_fmt\n21 : import Mathlib.Data.Real.Basic\n22 : import Std.Do.Triple\n23 : import Std.Tactic.Do\n24 : import FloatSpec.src.Core.Round_generic\n25 : import FloatSpec.src.Core.FIX\n26 : \n27 : \n28 : open Real\n29 : open Std.Do\n30 : open FloatSpec.Core.Generic_fmt\n31 : open FloatSpec.Core.Round_generic\n32 : \n33 : namespace FloatSpec.Core.FLX\n34 : \n35 : variable (prec : Int)\n36 : \n37 : /-- Fixed-precision exponent function\n38 : \n39 :     In fixed-precision format, the exponent is adjusted to maintain\n40 :     a constant precision. The exponent function returns e - prec,\n41 :     which ensures that mantissas have exactly 'prec' significant digits.\n42 : -/\n43 : def FLX_exp (e : Int) : Int :=\n44 :   e - prec\n45 : \n46 : /-- Check FLX exponent function correctness\n47 : \n48 :     Verify that the FLX exponent function computes e - prec\n49 :     correctly for any input e. This validates the precision\n50 :     adjustment mechanism.\n51 : -/\n52 : def FLX_exp_correct_check (e : Int) : Id Bool :=\n53 :   pure (FLX_exp prec e = e - prec)\n54 : \n55 : /-- Specification: Fixed-precision exponent calculation\n56 : \n57 :     The FLX exponent function subtracts the precision from the\n58 :     input exponent. This adjustment ensures that all representable\n59 :     numbers have exactly 'prec' significant digits in their mantissa.\n60 : -/\n61 : theorem FLX_exp_spec (e : Int) :\n62 :     ⦃⌜True⌝⦄\n63 :     FLX_exp_correct_check prec e\n64 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n65 :   sorry\n66 : \n67 : /-- Fixed-precision format predicate\n68 : \n69 :     A real number x is in FLX format if it can be represented\n70 :     using the generic format with the fixed-precision exponent\n71 :     function. This gives x = m × β^(e-prec) where m has bounded magnitude.\n72 : -/\n73 : def FLX_format (beta : Int) (x : ℝ) : Id Prop :=\n74 :   FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x\n75 : \n76 : /-- Specification: FLX format using generic format\n77 : \n78 :     The FLX format is defined through the generic format mechanism\n79 :     with the fixed-precision exponent function. This characterizes\n80 :     floating-point numbers with constant precision.\n81 : -/\n82 : theorem FLX_format_spec (beta : Int) (x : ℝ) :\n83 :     ⦃⌜True⌝⦄\n84 :     FLX_format prec beta x\n85 :     ⦃⇓result => ⌜result = (FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x).run⌝⦄ := by\n86 :   sorry\n87 : \n88 : /-- Specification: FLX exponent function correctness\n89 : \n90 :     The FLX exponent function correctly implements the precision\n91 :     adjustment by returning e - prec. This ensures the mantissa\n92 :     precision remains constant across different magnitudes.\n93 : -/\n94 : theorem FLX_exp_correct_spec (e : Int) :\n95 :     ⦃⌜True⌝⦄\n96 :     FLX_exp_correct_check prec e\n97 :     ⦃⇓result => ⌜result = true⌝⦄ := by\n98 :   sorry\n99 : \n100: /-- Check if zero is in FLX format\n101: \n102:     Verify that zero is representable in the fixed-precision format.\n103:     Zero should always be representable regardless of the precision\n104:     since it can be expressed as 0 × β^e for any exponent e.\n105: -/\n106: def FLX_format_0_check (beta : Int) : Id Bool :=\n107:   pure true  -- Zero is always in format\n108: \n109: /-- Specification: Zero is in FLX format\n110: \n111:     Zero is always representable in fixed-precision format.\n112:     This follows from the fact that 0 = 0 × β^(e-prec) for\n113:     any exponent e, making zero universal across all formats.\n114: -/\n115: theorem FLX_format_0_spec (beta : Int) :\n116:     ⦃⌜beta > 1⌝⦄\n117:     FLX_format_0_check beta\n118:     ⦃⇓result => ⌜result = true⌝⦄ := by\n119:   sorry\n120: \n121: /-- Check closure under negation\n122: \n123:     Verify that if x is in FLX format, then -x is also in FLX format.\n124:     This tests the closure property under additive inverse for\n125:     fixed-precision floating-point numbers.\n126: -/\n127: def FLX_format_opp_check (beta : Int) (x : ℝ) : Id Bool :=\n128:   pure true  -- Always true for fixed-precision formats\n129: \n130: /-- Specification: FLX format closed under negation\n131: \n132:     Fixed-precision formats are closed under negation. If x is\n133:     representable as m × β^(e-prec), then -x is representable\n134:     as (-m) × β^(e-prec), preserving precision and format properties.\n135: -/\n136: theorem FLX_format_opp_spec (beta : Int) (x : ℝ) :\n137:     ⦃⌜(FLX_format prec beta x).run⌝⦄\n138:     FLX_format_opp_check beta x\n139:     ⦃⇓result => ⌜result = true⌝⦄ := by\n140:   sorry\n141: \n142: /-- Check closure under absolute value\n143: \n144:     Verify that if x is in FLX format, then |x| is also in FLX format.\n145:     This tests closure under the absolute value operation, which\n146:     should preserve representability in fixed-precision formats.\n147: -/\n148: def FLX_format_abs_check (beta : Int) (x : ℝ) : Id Bool :=\n149:   pure true  -- Always true for fixed-precision formats\n150: \n151: /-- Specification: FLX format closed under absolute value\n152: \n153:     Fixed-precision formats are closed under absolute value.\n154:     If x is representable, then |x| is also representable since\n155:     |x| can use the same mantissa magnitude with appropriate sign.\n156: -/\n157: theorem FLX_format_abs_spec (beta : Int) (x : ℝ) :\n158:     ⦃⌜(FLX_format prec beta x).run⌝⦄\n159:     FLX_format_abs_check beta x\n160:     ⦃⇓result => ⌜result = true⌝⦄ := by\n161:   sorry\n162: \n163: end FloatSpec.Core.FLX\n164: \n165: namespace FloatSpec.Core.FLX\n166: \n167: variable (prec : Int)\n168: \n169: /-\n170: Coq (FLX.v):\n171: Theorem generic_format_FLX :\n172:   forall x, FLX_format x -> generic_format beta FLX_exp x.\n173: -/\n174: theorem generic_format_FLX (beta : Int) (x : ℝ) :\n175:     ⦃⌜(FLX_format prec beta x).run⌝⦄\n176:     FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x\n177:     ⦃⇓result => ⌜result⌝⦄ := by\n178:   intro hx\n179:   simpa [FLX_format]\n180: \n181: end FloatSpec.Core.FLX\n182: \n183: namespace FloatSpec.Core.FLX\n184: \n185: variable (prec : Int)\n186: \n187: /-\n188: Coq (FLX.v):\n189: Theorem FIX_format_FLX :\n190:   forall x e,\n191:   (bpow (e - 1) <= Rabs x <= bpow e)%R ->\n192:   FLX_format x ->\n193:   FIX_format beta (e - prec) x.\n194: \n195: Lean (spec): If |x| lies in [β^(e-1), β^e] and x is in FLX_format,\n196: then x is in FIX_format with minimal exponent (e - prec).\n197: -/\n198: theorem FIX_format_FLX (beta : Int) (x : ℝ) (e : Int) :\n199:     ⦃⌜(beta : ℝ) ^ (e - 1) ≤ |x| ∧ |x| ≤ (beta : ℝ) ^ e ∧ (FLX_format prec beta x).run⌝⦄\n200:     FloatSpec.Core.FIX.FIX_format (emin := e - prec) beta x\n201:     ⦃⇓result => ⌜result⌝⦄ := by\n202:   intro _\n203:   -- Proof follows Coq's FIX_format_FLX; omitted for now\n204:   sorry\n205: \n206: /-\n207: Coq (FLX.v):\n208: Theorem FLX_format_FIX :\n209:   forall x e,\n210:   (bpow (e - 1) <= Rabs x <= bpow e)%R ->\n211:   FIX_format beta (e - prec) x ->\n212:   FLX_format x.\n213: \n214: Lean (spec): If |x| lies in [β^(e-1), β^e] and x is in FIX_format\n215: with minimal exponent (e - prec), then x is in FLX_format.\n216: -/\n217: theorem FLX_format_FIX (beta : Int) (x : ℝ) (e : Int) :\n218:     ⦃⌜(beta : ℝ) ^ (e - 1) ≤ |x| ∧ |x| ≤ (beta : ℝ) ^ e ∧ (FloatSpec.Core.FIX.FIX_format (emin := e - prec) beta x).run⌝⦄\n219:     FLX_format prec beta x\n220:     ⦃⇓result => ⌜result⌝⦄ := by\n221:   intro _\n222:   -- Proof follows Coq's FLX_format_FIX; omitted for now\n223:   sorry\n224: \n225: end FloatSpec.Core.FLX\n226: \n227: namespace FloatSpec.Core.FLX\n228: \n229: variable (prec : Int)\n230: \n231: /- Valid_exp instance for FLX_exp (placeholder). -/\n232: instance FLX_exp_valid (beta : Int) :\n233:     FloatSpec.Core.Generic_fmt.Valid_exp beta (FLX_exp prec) := by\n234:   refine ⟨?_⟩\n235:   intro k\n236:   refine And.intro ?h1 ?h2\n237:   · intro _\n238:     -- Proof omitted for now\n239:     sorry\n240:   · intro _\n241:     refine And.intro ?hA ?hB\n242:     · -- Proof omitted for now\n243:       sorry\n244:     · intro _ _\n245:       -- Proof omitted for now\n246:       sorry\n247: \n248: /-\n249: Coq (FLX.v):\n250: Theorem FLX_format_satisfies_any :\n251:   satisfies_any FLX_format.\n252: -/\n253: theorem FLX_format_satisfies_any (beta : Int) :\n254:     FloatSpec.Core.Generic_fmt.satisfies_any (fun y => (FLX_format prec beta y).run) := by\n255:   simpa [FLX_format]\n256:     using FloatSpec.Core.Generic_fmt.generic_format_satisfies_any (beta := beta) (fexp := FLX_exp prec)\n257: \n258: end FloatSpec.Core.FLX\n259: \n260: namespace FloatSpec.Core.FLX\n261: \n262: variable (prec : Int)\n263: \n264: /-\n265: Coq (FLX.v):\n266: Theorem FLX_format_generic :\n267:   forall x, generic_format beta FLX_exp x -> FLX_format x.\n268: -/\n269: theorem FLX_format_generic (beta : Int) (x : ℝ) :\n270:     ⦃⌜(FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) x).run⌝⦄\n271:     FLX_format prec beta x\n272:     ⦃⇓result => ⌜result⌝⦄ := by\n273:   intro hx\n274:   simpa [FLX_format] using hx\n275: \n276: end FloatSpec.Core.FLX\n277: \n278: namespace FloatSpec.Core.FLX\n279: \n280: variable (prec : Int)\n281: \n282: /-\n283: Coq (FLX.v):\n284: Theorem generic_format_FLX_1 :\n285:   generic_format beta FLX_exp 1.\n286: -/\n287: theorem generic_format_FLX_1 (beta : Int) :\n288:     ⦃⌜True⌝⦄\n289:     FloatSpec.Core.Generic_fmt.generic_format beta (FLX_exp prec) 1\n290:     ⦃⇓result => ⌜result⌝⦄ := by\n291:   intro _\n292:   sorry\n293: \n294: end FloatSpec.Core.FLX\n295: \n"
  }
}
[2025-09-15T19:53:52] tokens used: 81333
[2025-09-15T19:53:52] turn diff:
diff --git a/FloatSpec/src/Core/FLT.lean b/FloatSpec/src/Core/FLT.lean
index 97a571572a5035146127a1d7b0667406b5dc3330..966a1dfc2fc1107e14df36d0b361ed762858740c
--- a/FloatSpec/src/Core/FLT.lean
+++ b/FloatSpec/src/Core/FLT.lean
@@ -462,3 +462,28 @@
   sorry
 
 end FloatSpec.Core.FLT
+
+namespace FloatSpec.Core.FLT
+
+variable (prec emin : Int)
+
+/-
+Coq (FLT.v):
+Theorem round_FLT_FLX : forall rnd x,
+  (bpow (emin + prec - 1) <= Rabs x)%R ->
+  round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x.
+
+Lean (spec): Under the lower-bound condition on |x|, rounding in
+FLT equals rounding in FLX for any rounding predicate `rnd`.
+-/
+theorem round_FLT_FLX (beta : Int) (rnd : ℝ → ℝ → Prop) (x : ℝ) :
+    ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄
+    (do
+      let rFLT := FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x
+      let rFLX := FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x
+      pure (rFLT, rFLX))
+    ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by
+  intro _
+  sorry
+
+end FloatSpec.Core.FLT

[2025-09-15T19:54:17] codex

I’ll adjust the `round_FLT_FLX` theorem to avoid `do`-block `let` bindings and use a single `pure (..,..)` expression to satisfy the WP mechanism.
[2025-09-15T19:54:27] apply_patch auto_approved=true:
M /Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLT.lean
@@ -480,6 +480,5 @@
     ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄
-    (do
-      let rFLT := FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x
-      let rFLX := FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x
-      pure (rFLT, rFLX))
+    (pure (
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x,
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x) : Id (ℝ × ℝ))
     ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by
[2025-09-15T19:54:27] apply_patch(auto_approved=true) exited 0 in 15ms:
Success. Updated the following files:
M FloatSpec/src/Core/FLT.lean
[2025-09-15T19:54:27] turn diff:
diff --git a/FloatSpec/src/Core/FLT.lean b/FloatSpec/src/Core/FLT.lean
index 97a571572a5035146127a1d7b0667406b5dc3330..5d15e1733a670afcec55f6a61f2175ab5134047b
--- a/FloatSpec/src/Core/FLT.lean
+++ b/FloatSpec/src/Core/FLT.lean
@@ -462,3 +462,27 @@
   sorry
 
 end FloatSpec.Core.FLT
+
+namespace FloatSpec.Core.FLT
+
+variable (prec emin : Int)
+
+/-
+Coq (FLT.v):
+Theorem round_FLT_FLX : forall rnd x,
+  (bpow (emin + prec - 1) <= Rabs x)%R ->
+  round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x.
+
+Lean (spec): Under the lower-bound condition on |x|, rounding in
+FLT equals rounding in FLX for any rounding predicate `rnd`.
+-/
+theorem round_FLT_FLX (beta : Int) (rnd : ℝ → ℝ → Prop) (x : ℝ) :
+    ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄
+    (pure (
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x,
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x) : Id (ℝ × ℝ))
+    ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by
+  intro _
+  sorry
+
+end FloatSpec.Core.FLT

[2025-09-15T19:54:27] tokens used: 86356
[2025-09-15T19:54:27] turn diff:
diff --git a/FloatSpec/src/Core/FLT.lean b/FloatSpec/src/Core/FLT.lean
index 97a571572a5035146127a1d7b0667406b5dc3330..5d15e1733a670afcec55f6a61f2175ab5134047b
--- a/FloatSpec/src/Core/FLT.lean
+++ b/FloatSpec/src/Core/FLT.lean
@@ -462,3 +462,27 @@
   sorry
 
 end FloatSpec.Core.FLT
+
+namespace FloatSpec.Core.FLT
+
+variable (prec emin : Int)
+
+/-
+Coq (FLT.v):
+Theorem round_FLT_FLX : forall rnd x,
+  (bpow (emin + prec - 1) <= Rabs x)%R ->
+  round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x.
+
+Lean (spec): Under the lower-bound condition on |x|, rounding in
+FLT equals rounding in FLX for any rounding predicate `rnd`.
+-/
+theorem round_FLT_FLX (beta : Int) (rnd : ℝ → ℝ → Prop) (x : ℝ) :
+    ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄
+    (pure (
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x,
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x) : Id (ℝ × ℝ))
+    ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by
+  intro _
+  sorry
+
+end FloatSpec.Core.FLT

[2025-09-15T19:54:33] tool lean-lsp-mcp.lean_diagnostic_messages({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLT.lean"})
[2025-09-15T19:54:37] lean-lsp-mcp.lean_diagnostic_messages({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/FLT.lean"}) success in 4.34s:
{
  "content": [
    {
      "text": "l63c9-l63c21, severity: 2\ndeclaration uses 'sorry'",
      "type": "text"
    },
    {
      "text": "l80c10-l80c23, severity: 2\ndeclaration uses 'sorry'",
      "type": "text"
    },
    {
      "text": "l102c9-l102c24, severity: 2\ndeclaration uses 'sorry'",
      "type": "text"
    },
    {
      "text": "l114c9-l114c29, severity: 2\ndeclaration uses 'sorry'",
      "type": "text"
    },
    {
      "text": "l126c25-l126c29, severity: 2\nunused variable `beta`\n\nNote: This linter can be disabled with `set_option linter.unusedVariables false`",
[2025-09-15T19:54:37] tokens used: 86543
[2025-09-15T19:54:37] turn diff:
diff --git a/FloatSpec/src/Core/FLT.lean b/FloatSpec/src/Core/FLT.lean
index 97a571572a5035146127a1d7b0667406b5dc3330..5d15e1733a670afcec55f6a61f2175ab5134047b
--- a/FloatSpec/src/Core/FLT.lean
+++ b/FloatSpec/src/Core/FLT.lean
@@ -462,3 +462,27 @@
   sorry
 
 end FloatSpec.Core.FLT
+
+namespace FloatSpec.Core.FLT
+
+variable (prec emin : Int)
+
+/-
+Coq (FLT.v):
+Theorem round_FLT_FLX : forall rnd x,
+  (bpow (emin + prec - 1) <= Rabs x)%R ->
+  round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x.
+
+Lean (spec): Under the lower-bound condition on |x|, rounding in
+FLT equals rounding in FLX for any rounding predicate `rnd`.
+-/
+theorem round_FLT_FLX (beta : Int) (rnd : ℝ → ℝ → Prop) (x : ℝ) :
+    ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄
+    (pure (
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x,
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x) : Id (ℝ × ℝ))
+    ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by
+  intro _
+  sorry
+
+end FloatSpec.Core.FLT

[2025-09-15T19:54:46] codex

I’ll mark `round_FLT_FLX` as implemented in the comparison report by updating the mapping entry.
[2025-09-15T19:54:48] apply_patch auto_approved=true:
M /Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Core_Theorems_Comparison.md
@@ -329,3 +329,3 @@
 - `generic_format_FLX_FLT` → `generic_format_FLX_FLT` (exact-name)
-- `round_FLT_FLX` → (no match)
+- `round_FLT_FLX` → `round_FLT_FLX` (exact-name)
  - `cexp_FLT_FIX` → `cexp_FLT_FIX` (exact-name)
[2025-09-15T19:54:48] apply_patch(auto_approved=true) exited 0 in 24ms:
Success. Updated the following files:
M FloatSpec/src/Core/Core_Theorems_Comparison.md
[2025-09-15T19:54:48] turn diff:
diff --git a/FloatSpec/src/Core/Core_Theorems_Comparison.md b/FloatSpec/src/Core/Core_Theorems_Comparison.md
index 111c1dec07c42d40788eb3bda22b37da2cc5bc19..aac157aab47d3ab0e10d567f35d60f0863de633b
--- a/FloatSpec/src/Core/Core_Theorems_Comparison.md
+++ b/FloatSpec/src/Core/Core_Theorems_Comparison.md
@@ -327,7 +327,7 @@
  - `cexp_FLT_FLX` → `cexp_FLT_FLX` (exact-name)
 - `generic_format_FLT_FLX` → (no match)
 - `generic_format_FLX_FLT` → `generic_format_FLX_FLT` (exact-name)
-- `round_FLT_FLX` → (no match)
+- `round_FLT_FLX` → `round_FLT_FLX` (exact-name)
  - `cexp_FLT_FIX` → `cexp_FLT_FIX` (exact-name)
 - `generic_format_FIX_FLT` → (no match)
 - `generic_format_FLT_FIX` → (no match)
diff --git a/FloatSpec/src/Core/FLT.lean b/FloatSpec/src/Core/FLT.lean
index 97a571572a5035146127a1d7b0667406b5dc3330..5d15e1733a670afcec55f6a61f2175ab5134047b
--- a/FloatSpec/src/Core/FLT.lean
+++ b/FloatSpec/src/Core/FLT.lean
@@ -462,3 +462,27 @@
   sorry
 
 end FloatSpec.Core.FLT
+
+namespace FloatSpec.Core.FLT
+
+variable (prec emin : Int)
+
+/-
+Coq (FLT.v):
+Theorem round_FLT_FLX : forall rnd x,
+  (bpow (emin + prec - 1) <= Rabs x)%R ->
+  round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x.
+
+Lean (spec): Under the lower-bound condition on |x|, rounding in
+FLT equals rounding in FLX for any rounding predicate `rnd`.
+-/
+theorem round_FLT_FLX (beta : Int) (rnd : ℝ → ℝ → Prop) (x : ℝ) :
+    ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄
+    (pure (
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x,
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x) : Id (ℝ × ℝ))
+    ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by
+  intro _
+  sorry
+
+end FloatSpec.Core.FLT

[2025-09-15T19:54:48] tokens used: 87674
[2025-09-15T19:54:48] turn diff:
diff --git a/FloatSpec/src/Core/Core_Theorems_Comparison.md b/FloatSpec/src/Core/Core_Theorems_Comparison.md
index 111c1dec07c42d40788eb3bda22b37da2cc5bc19..aac157aab47d3ab0e10d567f35d60f0863de633b
--- a/FloatSpec/src/Core/Core_Theorems_Comparison.md
+++ b/FloatSpec/src/Core/Core_Theorems_Comparison.md
@@ -327,7 +327,7 @@
  - `cexp_FLT_FLX` → `cexp_FLT_FLX` (exact-name)
 - `generic_format_FLT_FLX` → (no match)
 - `generic_format_FLX_FLT` → `generic_format_FLX_FLT` (exact-name)
-- `round_FLT_FLX` → (no match)
+- `round_FLT_FLX` → `round_FLT_FLX` (exact-name)
  - `cexp_FLT_FIX` → `cexp_FLT_FIX` (exact-name)
 - `generic_format_FIX_FLT` → (no match)
 - `generic_format_FLT_FIX` → (no match)
diff --git a/FloatSpec/src/Core/FLT.lean b/FloatSpec/src/Core/FLT.lean
index 97a571572a5035146127a1d7b0667406b5dc3330..5d15e1733a670afcec55f6a61f2175ab5134047b
--- a/FloatSpec/src/Core/FLT.lean
+++ b/FloatSpec/src/Core/FLT.lean
@@ -462,3 +462,27 @@
   sorry
 
 end FloatSpec.Core.FLT
+
+namespace FloatSpec.Core.FLT
+
+variable (prec emin : Int)
+
+/-
+Coq (FLT.v):
+Theorem round_FLT_FLX : forall rnd x,
+  (bpow (emin + prec - 1) <= Rabs x)%R ->
+  round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x.
+
+Lean (spec): Under the lower-bound condition on |x|, rounding in
+FLT equals rounding in FLX for any rounding predicate `rnd`.
+-/
+theorem round_FLT_FLX (beta : Int) (rnd : ℝ → ℝ → Prop) (x : ℝ) :
+    ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄
+    (pure (
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x,
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x) : Id (ℝ × ℝ))
+    ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by
+  intro _
+  sorry
+
+end FloatSpec.Core.FLT

[2025-09-15T19:54:53] codex

- Added `round_FLT_FLX` to `FloatSpec/src/Core/FLT.lean` with a Lean spec mirroring the Coq statement. It uses the round helper `Round_generic.round_to_generic` for both FLT and FLX and asserts equality under the same lower-bound precondition on `|x|`. Proof is left as `sorry`, as requested.

- Verified compilation for `FLT.lean` using MCP diagnostics. Only “declaration uses sorry” and a couple of “unused variable” lints are present — no errors or “pure true” issues.

- Updated the comparison record `FloatSpec/src/Core/Core_Theorems_Comparison.md` to mark:
  - `round_FLT_FLX` → `round_FLT_FLX` (exact-name)

Want me to continue with the next missing FLT theorem (e.g., `negligible_exp_FLT` cannot be added yet due to no `negligible_exp` in Lean, but we can proceed with others like `ulp_FLT_pred_pos` if supporting functions exist)?
[2025-09-15T19:55:00] tokens used: 88031
[2025-09-15T19:55:00] turn diff:
diff --git a/FloatSpec/src/Core/Core_Theorems_Comparison.md b/FloatSpec/src/Core/Core_Theorems_Comparison.md
index 111c1dec07c42d40788eb3bda22b37da2cc5bc19..aac157aab47d3ab0e10d567f35d60f0863de633b
--- a/FloatSpec/src/Core/Core_Theorems_Comparison.md
+++ b/FloatSpec/src/Core/Core_Theorems_Comparison.md
@@ -327,7 +327,7 @@
  - `cexp_FLT_FLX` → `cexp_FLT_FLX` (exact-name)
 - `generic_format_FLT_FLX` → (no match)
 - `generic_format_FLX_FLT` → `generic_format_FLX_FLT` (exact-name)
-- `round_FLT_FLX` → (no match)
+- `round_FLT_FLX` → `round_FLT_FLX` (exact-name)
  - `cexp_FLT_FIX` → `cexp_FLT_FIX` (exact-name)
 - `generic_format_FIX_FLT` → (no match)
 - `generic_format_FLT_FIX` → (no match)
diff --git a/FloatSpec/src/Core/FLT.lean b/FloatSpec/src/Core/FLT.lean
index 97a571572a5035146127a1d7b0667406b5dc3330..5d15e1733a670afcec55f6a61f2175ab5134047b
--- a/FloatSpec/src/Core/FLT.lean
+++ b/FloatSpec/src/Core/FLT.lean
@@ -462,3 +462,27 @@
   sorry
 
 end FloatSpec.Core.FLT
+
+namespace FloatSpec.Core.FLT
+
+variable (prec emin : Int)
+
+/-
+Coq (FLT.v):
+Theorem round_FLT_FLX : forall rnd x,
+  (bpow (emin + prec - 1) <= Rabs x)%R ->
+  round beta FLT_exp rnd x = round beta (FLX_exp prec) rnd x.
+
+Lean (spec): Under the lower-bound condition on |x|, rounding in
+FLT equals rounding in FLX for any rounding predicate `rnd`.
+-/
+theorem round_FLT_FLX (beta : Int) (rnd : ℝ → ℝ → Prop) (x : ℝ) :
+    ⦃⌜(beta : ℝ) ^ (emin + prec - 1) ≤ |x|⌝⦄
+    (pure (
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLT_exp prec emin) (mode := rnd) x,
+      FloatSpec.Core.Round_generic.round_to_generic (beta := beta) (fexp := FLX.FLX_exp prec) (mode := rnd) x) : Id (ℝ × ℝ))
+    ⦃⇓p => ⌜p.1 = p.2⌝⦄ := by
+  intro _
+  sorry
+
+end FloatSpec.Core.FLT

