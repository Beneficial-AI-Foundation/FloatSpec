[2025-09-16T03:10:35] OpenAI Codex v0.20.0 (research preview)
--------
workdir: /Users/louhantao/Desktop/code/semester_6.5/FloatSpec
model: gpt-5
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: medium
reasoning summaries: auto
--------
[2025-09-16T03:10:35] User instructions:
Please ensure your implementation Always Works™ for:

## Task: Introduce Missing Theorems in FloatSpec/src/Core/${file}

## Scope

Introduce missing theorems in the file. You can find the record of missing theorems in file /Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Core_Theorems_Comparison.md, which is generated by comparing the Coq and Lean versions of the file. For all the missing theorems in the file, find their corresponding Coq implementation in /Users/louhantao/Desktop/code/semester_6.5/flocq/src/Core and implement them in Lean, using the same name and similar syntax with existing theorems. Leave the proofs empty for now.

### Prerequisites

1. **Read documentation first:**
    - FloatSpec/PIPELINE.md - understand the overall pipeline
    - ./CLAUDE.md - focus on proof writing instructions and mvcgen info

### Core Requirements

### Theorem Importing Process

1. **Follow the Zfast_div_eucl_spec example** in Zaux.lean and other theorems in current file as your template
2. **ONE-BY-ONE approach is mandatory:**
    - Write ONE theorem
    - Use the hoare triple syntax (introduced in FloatSpec/PIPELINE.md and CLAUDE.md) to write the theorem
    - Check immediately with mcp tool or `lake build`
    - Fix any errors before proceeding to next theorem
    - Never batch multiple theorems without checking
3. After writing each theorem, check whether they are aligned with the Coq implementation. If so, mark them as complete in the record file.

### Before Writing Each Theorem

1. **Verify function implementation** - ensure the function body is correct
2. **Preserve syntax** - do NOT change hoare triple syntax unless absolutely necessary
    - Think multiple times before modifying specs or code body
    - If changes are needed, decompose complex specs rather than rewriting

### Compilation Verification

- **After EVERY theorem:** Run `mcp` (preferred) or `lake build xxx`
- **Definition of complete:** NO errors or 'pure true' statements
- **Never mark as complete if:**
    - Any errors or 'pure true' statements remain
    - Compilation returns errors
    - Sorry is allowed, but only as a placeholder for the proof


### Important Notes

- Use MCP tool instead of bash command to get diagnostic messages!
- Skip already-imported theorems!! There might be warnings be just leave them there!
- You can use exisiting (and proved) theorem to assist your spec writing. If a theorem is necessary but not introduced, you can turn to work on that first. The useful theorems might not be in the same file, but in the import list
- When you are trying to use a certain lemma, check through mcp tools (or https://github.com/leanprover-community/mathlib4) to make sure the lemma exists. Else, write your own implementation of the lemma.

### Success Criteria

✅ All error and 'pure true' statements eliminated
✅ Clean compilation for entire file
✅ Each theorem verified individually before moving on

[2025-09-16T03:10:45] ERROR: MCP client for `leanexploreLocal` failed to start: request timed out
[2025-09-16T03:10:45] ERROR: MCP client for `LeanTool` failed to start: No such file or directory (os error 2)
[2025-09-16T03:10:45] ERROR: MCP client for `leanexploreRemote` failed to start: request timed out
[2025-09-16T03:10:58] thinking

**Implementing missing theorems**

The instructions say to introduce missing theorems in a specific file, though it's not clear which one. I can select a file and add the necessary theorems, but they want it to be reliable, so I’ll follow a one-by-one approach and check the build after each addition. I’ll ensure to edit using apply_patch and run the lean build tool. Next, I’ll open the comparison markdown file for reference.
[2025-09-16T03:11:00] codex

I’m going to open the comparison record and the pipeline docs to identify missing theorems and the hoare triple syntax used here.
[2025-09-16T03:11:00] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Core_Theorems_Comparison.md","annotate_lines":false})
[2025-09-16T03:11:00] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/FloatSpec/src/Core/Core_Theorems_Comparison.md","annotate_lines":false}) success in 6ms:
{
  "content": [
    {
      "text": "# Core Theorems Comparison: Coq vs Lean (FloatSpec)\n\nThis document lists all theorem-like declarations in flocq/src/Core (*.v) and FloatSpec/src/Core (*.lean), grouped by file, and indicates for each Coq declaration whether a corresponding Lean theorem/lemma exists. Matching is based on exact/normalized/substr name matches and, when available, explicit Coq references in Lean comments.\n\n## File: Core.v\n- Coq file: Core.v\n- Lean file(s): (none)\n\n### Coq Declarations\n\n### Lean Declarations\n\n### Mapping (Coq → Lean)\n\n## File: Defs.v\n- Coq file: Defs.v\n- Lean file(s): Defs.lean\n\n### Coq Declarations\n\n### Lean Declarations\n- theorem: `F2R_spec`\n- theorem: `Fnum_extract_spec`\n- theorem: `Fexp_extract_spec`\n- theorem: `make_float_spec`\n- theorem: `FlocqFloat_eq_spec`\n- theorem: `F2R_zero_spec`\n- theorem: `F2R_add_same_exp_spec`\n\n### Mapping (Coq → Lean)\n\n## File: Digits.v\n- Coq file: Digits.v\n- Lean file(s): Digits.lean\n\n### Coq Declarations\n- Theorem: `digits2_Pnat_correct`\n- Theorem: `Zdigit_lt`\n- Theorem: `Zdigit_0`\n- Theorem: `Zdigit_opp`\n- Theorem: `Zdigit_ge_Zpower_pos`\n- Theorem: `Zdigit_ge_Zpower`\n- Theorem: `Zdigit_not_0_pos`\n- Theorem: `Zdigit_not_0`\n- Theorem: `Zdigit_mul_pow`\n- Theorem: `Zdigit_div_pow`\n- Theorem: `Zdigit_mod_pow`\n- Theorem: `Zdigit_mod_pow_out`\n- Theorem: `Zsum_digit_digit`\n- Theorem: `Zdigit_ext`\n- Theorem: `ZOmod_plus_pow_digit`\n- Theorem: `ZOdiv_plus_pow_digit`\n- Theorem: `Zdigit_plus`\n- Theorem: `Zdigit_scale`\n- Theorem: `Zscale_0`\n- Theorem: `Zsame_sign_scale`\n- Theorem: `Zscale_mul_pow`\n- Theorem: `Zscale_scale`\n- Theorem: `Zdigit_slice`\n- Theorem: `Zdigit_slice_out`\n- Theorem: `Zslice_0`\n- Theorem: `Zsame_sign_slice`\n- Theorem: `Zslice_slice`\n- Theorem: `Zslice_mul_pow`\n- Theorem: `Zslice_div_pow`\n- Theorem: `Zslice_scale`\n- Theorem: `Zslice_div_pow_scale`\n- Theorem: `Zplus_slice`\n- Theorem: `Zdigits_correct`\n- Theorem: `Zdigits_unique`\n- Theorem: `Zdigits_abs`\n- Theorem: `Zdigits_opp`\n- Theorem: `Zdigits_cond_Zopp`\n- Theorem: `Zdigits_gt_0`\n- Theorem: `Zdigits_ge_0`\n- Theorem: `Zdigit_out`\n- Theorem: `Zdigit_digits`\n- Theorem: `Zdigits_slice`\n- Theorem: `Zdigits_mult_Zpower`\n- Theorem: `Zdigits_Zpower`\n- Theorem: `Zdigits_le`\n- Theorem: `lt_Zdigits`\n- Theorem: `Zpower_le_Zdigits`\n- Theorem: `Zdigits_le_Zpower`\n- Theorem: `Zpower_gt_Zdigits`\n- Theorem: `Zdigits_gt_Zpower`\n- Theorem: `Zdigits_mult_strong`\n- Theorem: `Zdigits_mult`\n- Theorem: `Zdigits_mult_ge`\n- Theorem: `Zdigits_div_Zpower`\n- Theorem: `Zdigits_succ_le`\n- Theorem: `Z_of_nat_S_digits2_Pnat`\n- Theorem: `Zpos_digits2_pos`\n- Lemma: `Zdigits2_Zdigits`\n\n### Lean Declarations\n- lemma: `bits_pos`\n- lemma: `split2`\n- lemma: `bits_succ`\n- lemma: `digits2_eq_bits`\n- lemma: `bits_bounds`\n- theorem: `digits2_Pnat_correct`\n- theorem: `Zdigit_lt`\n- theorem: `Zdigit_0`\n- theorem: `Zdigit_opp`\n- theorem: `Zdigit_ge_Zpower_pos`\n- theorem: `Zdigit_ge_Zpower`\n- theorem: `Zdigit_not_0_pos`\n- theorem: `Zdigit_not_0`\n- theorem: `Zdigit_mul_pow`\n- theorem: `Zdigit_div_pow`\n- theorem: `Zdigit_mod_pow`\n- theorem: `Zdigit_mod_pow_out`\n- theorem: `Zsum_digit_digit`\n- theorem: `ZOmod_plus_pow_digit`\n- theorem: `Zdigit_ext_nonneg`\n- theorem: `ZOdiv_plus_pow_digit`\n- theorem: `Zdigit_plus_nonneg`\n- theorem: `Zdigit_scale_point`\n- theorem: `Zscale_0`\n- theorem: `Zsame_sign_scale`\n- theorem: `Zscale_mul_pow`\n- theorem: `Zscale_scale`\n- theorem: `Zdigit_slice`\n- theorem: `Zdigit_slice_out`\n- theorem: `Zslice_0`\n- theorem: `Zsame_sign_slice`\n- theorem: `Zslice_slice`\n- theorem: `Zslice_mul_pow`\n- theorem: `Zslice_div_pow`\n- theorem: `Zslice_scale`\n- theorem: `Zslice_div_pow_scale_nonnegKp`\n- theorem: `Zplus_slice`\n- theorem: `Zdigits_correct`\n- theorem: `Zdigits_unique`\n- theorem: `Zdigits_abs`\n- theorem: `Zdigits_opp`\n- theorem: `Zdigits_cond_Zopp`\n- theorem: `Zdigits_ge_0`\n- theorem: `Zdigits_gt_0`\n- theorem: `Zdigit_out`\n- theorem: `Zdigit_digits`\n- theorem: `lt_Zdigits`\n- theorem: `Zdigits_le_Zpower`\n- theorem: `Zdigits_slice`\n- theorem: `Zdigits_mult_Zpower`\n- theorem: `Zdigits_Zpower`\n- theorem: `Zdigits_le`\n- theorem: `Zpower_le_Zdigits`\n- theorem: `Zdigits_le_Zdigits`\n- theorem: `Zpower_gt_Zdigits`\n- theorem: `Zdigits_gt_Zpower`\n- theorem: `Zdigits_mult_strong`\n- theorem: `Zdigits_mult`\n- theorem: `Zdigits_mult_ge`\n- theorem: `Zdigits_div_Zpower`\n- theorem: `Zdigits_succ_le`\n- theorem: `Z_of_nat_S_digits2_Pnat`\n- theorem: `Zpos_digits2_pos`\n- theorem: `Zdigits2_Zdigits`\n- lemma: `beta_pos`\n- lemma: `pow_pos_int`\n- lemma: `Zdigit_at_zero`\n- lemma: `Zdigit_eval_nonneg`\n- lemma: `tdiv_zero_iff_lt_of_nonneg_pos`\n- lemma: `tdiv_pow_succ_assoc`\n- lemma: `exists_nonzero_digit`\n- lemma: `tdiv_mod_pow_eq`\n- lemma: `pow_mono_int`\n- lemma: `pow_strict_mono_int`\n- lemma: `wp_mono_pure`\n- lemma: `zscale_div_exact`\n- lemma: `div_mul_pow_eq_div_sub`\n- lemma: `pow_base_mono`\n- lemma: `abs_lt_beta_pow_succ_natAbs`\n- theorem: `Zdigits_aux_bounds`\n- lemma: `natAbs_sub_one_gt_of_nonpos`\n- lemma: `pow_succ_ge`\n- lemma: `pow_le_pow_exponent`\n- lemma: `natAbs_sub_one_eq_add_one_of_nonpos`\n- lemma: `Zdigits_aux_abs_eq`\n- lemma: `Zdigits_pos_aux`\n- lemma: `tdiv_lower_bound`\n- lemma: `tdiv_upper_bound`\n- lemma: `digit_nonzero_at_boundary`\n- lemma: `Zdigits_implies_nonzero_digit`\n- lemma: `digit_sum_bound`\n- lemma: `highest_nonzero_digit_bound`\n- lemma: `Zdigits_nonneg`\n- lemma: `product_upper_bound`\n- lemma: `pow_add_split`\n- lemma: `Zdigits_run_eq`\n- lemma: `Zdigits_sum_product_bound`\n\n### Mapping (Coq → Lean)\n- `digits2_Pnat_correct` → `digits2_Pnat_correct` (exact-name)\n- `Zdigit_lt` → `Zdigit_lt` (exact-name)\n- `Zdigit_0` → `Zdigit_0` (exact-name)\n- `Zdigit_opp` → `Zdigit_opp` (exact-name)\n- `Zdigit_ge_Zpower_pos` → `Zdigit_ge_Zpower_pos` (exact-name)\n- `Zdigit_ge_Zpower` → `Zdigit_ge_Zpower` (exact-name)\n- `Zdigit_not_0_pos` → `Zdigit_not_0_pos` (exact-name)\n- `Zdigit_not_0` → `Zdigit_not_0` (exact-name)\n- `Zdigit_mul_pow` → `Zdigit_mul_pow` (exact-name)\n- `Zdigit_div_pow` → `Zdigit_div_pow` (exact-name)\n- `Zdigit_mod_pow` → `Zdigit_mod_pow` (exact-name)\n- `Zdigit_mod_pow_out` → `Zdigit_mod_pow_out` (exact-name)\n- `Zsum_digit_digit` → `Zsum_digit_digit` (exact-name)\n- `Zdigit_ext` → `Zdigit_ext_nonneg` (substring-name)\n- `ZOmod_plus_pow_digit` → `ZOmod_plus_pow_digit` (exact-name)\n- `ZOdiv_plus_pow_digit` → `ZOdiv_plus_pow_digit` (exact-name)\n- `Zdigit_plus` → `Zdigit_plus_nonneg` (substring-name)\n- `Zdigit_scale` → `Zdigit_scale_point` (substring-name)\n- `Zscale_0` → `Zscale_0` (exact-name)\n- `Zsame_sign_scale` → `Zsame_sign_scale` (exact-name)\n- `Zscale_mul_pow` → `Zscale_mul_pow` (exact-name)\n- `Zscale_scale` → `Zscale_scale` (exact-name)\n- `Zdigit_slice` → `Zdigit_slice` (exact-name)\n- `Zdigit_slice_out` → `Zdigit_slice_out` (exact-name)\n- `Zslice_0` → `Zslice_0` (exact-name)\n- `Zsame_sign_slice` → `Zsame_sign_slice` (exact-name)\n- `Zslice_slice` → `Zslice_slice` (exact-name)\n- `Zslice_mul_pow` → `Zslice_mul_pow` (exact-name)\n- `Zslice_div_pow` → `Zslice_div_pow` (exact-name)\n- `Zslice_scale` → `Zslice_scale` (exact-name)\n- `Zslice_div_pow_scale` → `Zslice_div_pow` (substring-name)\n- `Zplus_slice` → `Zplus_slice` (exact-name)\n- `Zdigits_correct` → `Zdigits_correct` (exact-name)\n- `Zdigits_unique` → `Zdigits_unique` (exact-name)\n- `Zdigits_abs` → `Zdigits_abs` (exact-name)\n- `Zdigits_opp` → `Zdigits_opp` (exact-name)\n- `Zdigits_cond_Zopp` → `Zdigits_cond_Zopp` (exact-name)\n- `Zdigits_gt_0` → `Zdigits_gt_0` (exact-name)\n- `Zdigits_ge_0` → `Zdigits_ge_0` (exact-name)\n- `Zdigit_out` → `Zdigit_out` (exact-name)\n- `Zdigit_digits` → `Zdigit_digits` (exact-name)\n- `Zdigits_slice` → `Zdigits_slice` (exact-name)\n- `Zdigits_mult_Zpower` → `Zdigits_mult_Zpower` (exact-name)\n- `Zdigits_Zpower` → `Zdigits_Zpower` (exact-name)\n- `Zdigits_le` → `Zdigits_le` (exact-name)\n- `lt_Zdigits` → `lt_Zdigits` (exact-name)\n- `Zpower_le_Zdigits` → `Zpower_le_Zdigits` (exact-name)\n- `Zdigits_le_Zpower` → `Zdigits_le_Zpower` (exact-name)\n- `Zpower_gt_Zdigits` → `Zpower_gt_Zdigits` (exact-name)\n- `Zdigits_gt_Zpower` → `Zdigits_gt_Zpower` (exact-name)\n- `Zdigits_mult_strong` → `Zdigits_mult_strong` (exact-name)\n- `Zdigits_mult` → `Zdigits_mult` (exact-name)\n- `Zdigits_mult_ge` → `Zdigits_mult_ge` (exact-name)\n- `Zdigits_div_Zpower` → `Zdigits_div_Zpower` (exact-name)\n- `Zdigits_succ_le` → `Zdigits_succ_le` (exact-name)\n- `Z_of_nat_S_digits2_Pnat` → `Z_of_nat_S_digits2_Pnat` (exact-name)\n- `Zpos_digits2_pos` → `Zpos_digits2_pos` (exact-name)\n- `Zdigits2_Zdigits` → `Zdigits2_Zdigits` (exact-name)\n\n## File: FIX.v\n- Coq file: FIX.v\n- Lean file(s): FIX.lean\n\n### Coq Declarations\n- Theorem: `generic_format_FIX`\n- Theorem: `FIX_format_generic`\n- Theorem: `FIX_format_satisfies_any`\n- Theorem: `ulp_FIX`\n- Theorem: `round_FIX_IZR`\n\n### Lean Declarations\n- theorem: `FIX_exp_spec`\n- theorem: `FIX_format_spec`\n- theorem: `FIX_exp_correct_spec`\n- theorem: `FIX_format_0_spec`\n- theorem: `FIX_format_opp_spec`\n\n### Mapping (Coq → Lean)\n- `generic_format_FIX` → (no match)\n- `FIX_format_generic` → (no match)\n- `FIX_format_satisfies_any` → (no match)\n- `ulp_FIX` → (no match)\n- `ulp_FIX` → `ulp_FIX` (exact-name)\n- `round_FIX_IZR` → (no match)\n - `round_FIX_IZR` → `round_FIX_IZR` (exact-name)\n\n## File: FLT.v\n- Coq file: FLT.v\n- Lean file(s): FLT.lean\n\n### Coq Declarations\n- Theorem: `generic_format_FLT`\n- Theorem: `FLT_format_generic`\n- Theorem: `generic_format_FLT_bpow`\n- Theorem: `FLT_format_bpow`\n- Theorem: `FLT_format_satisfies_any`\n- Theorem: `cexp_FLT_FLX`\n- Theorem: `generic_format_FLT_FLX`\n- Theorem: `generic_format_FLX_FLT`\n- Theorem: `round_FLT_FLX`\n- Theorem: `cexp_FLT_FIX`\n- Theorem: `generic_format_FIX_FLT`\n- Theorem: `generic_format_FLT_FIX`\n- Lemma: `negligible_exp_FLT`\n- Theorem: `generic_format_FLT_1`\n- Theorem: `ulp_FLT_0`\n- Theorem: `ulp_FLT_small`\n- Theorem: `ulp_FLT_le`\n- Theorem: `ulp_FLT_gt`\n- Lemma: `ulp_FLT_exact_shift`\n- Lemma: `succ_FLT_exact_shift_pos`\n- Lemma: `succ_FLT_exact_shift`\n- Lemma: `pred_FLT_exact_shift`\n- Theorem: `ulp_FLT_pred_pos`\n\n### Lean Declarations\n- theorem: `FLT_exp_spec`\n- theorem: `FLT_format_spec`\n- theorem: `FLT_exp_correct_spec`\n- theorem: `FLT_format_0_spec`\n- theorem: `FLT_format_opp_spec`\n- theorem: `FLT_format_abs_spec`\n- theorem: `FLT_exp_FLX_spec`\n\n### Mapping (Coq → Lean)\n - `generic_format_FLT` → `generic_format_FLT` (exact-name)\n - `FLT_format_generic` → `FLT_format_generic` (exact-name)\n- `generic_format_FLT_bpow` → (no match)\n- `FLT_format_bpow` → (no match)\n - `FLT_format_satisfies_any` → `FLT_format_satisfies_any` (exact-name)\n- `cexp_FLT_FLX` → (no match)\n - `cexp_FLT_FLX` → `cexp_FLT_FLX` (exact-name)\n- `generic_format_FLT_FLX` → (no match)\n- `generic_format_FLX_FLT` → `generic_format_FLX_FLT` (exact-name)\n- `round_FLT_FLX` → `round_FLT_FLX` (exact-name)\n - `cexp_FLT_FIX` → `cexp_FLT_FIX` (exact-name)\n- `generic_format_FIX_FLT` → (no match)\n- `generic_format_FLT_FIX` → (no match)\n- `negligible_exp_FLT` → (no match)\n- `generic_format_FLT_1` → `generic_format_FLT_1` (exact-name)\n - `ulp_FLT_0` → `ulp_FLT_0` (exact-name)\n - `ulp_FLT_small` → `ulp_FLT_small` (exact-name)\n- `ulp_FLT_le` → (no match)\n- `ulp_FLT_gt` → (no match)\n- `ulp_FLT_exact_shift` → (no match)\n- `succ_FLT_exact_shift_pos` → (no match)\n- `succ_FLT_exact_shift` → (no match)\n- `pred_FLT_exact_shift` → (no match)\n- `ulp_FLT_pred_pos` → (no match)\n\n## File: FLX.v\n- Coq file: FLX.v\n- Lean file(s): FLX.lean\n\n### Coq Declarations\n- Theorem: `FIX_format_FLX`\n- Theorem: `FLX_format_generic`\n- Theorem: `generic_format_FLX`\n- Theorem: `FLX_format_satisfies_any`\n- Theorem: `FLX_format_FIX`\n- Theorem: `generic_format_FLXN`\n- Theorem: `FLXN_format_generic`\n- Theorem: `FLXN_format_satisfies_any`\n- Lemma: `negligible_exp_FLX`\n- Theorem: `generic_format_FLX_1`\n- Theorem: `ulp_FLX_0`\n- Lemma: `ulp_FLX_1`\n- Lemma: `succ_FLX_1`\n- Theorem: `eq_0_round_0_FLX`\n- Theorem: `gt_0_round_gt_0_FLX`\n- Theorem: `ulp_FLX_le`\n- Theorem: `ulp_FLX_ge`\n- Lemma: `ulp_FLX_exact_shift`\n- Lemma: `succ_FLX_exact_shift`\n- Lemma: `pred_FLX_exact_shift`\n\n### Lean Declarations\n- theorem: `FLX_exp_spec`\n- theorem: `FLX_format_spec`\n- theorem: `FLX_exp_correct_spec`\n- theorem: `FLX_format_0_spec`\n- theorem: `FLX_format_opp_spec`\n- theorem: `FLX_format_abs_spec`\n- theorem: `ulp_FLX_1`\n\n### Mapping (Coq → Lean)\n- `FIX_format_FLX` → (no match)\n - `FLX_format_generic` → `FLX_format_generic` (exact-name)\n- `generic_format_FLX` → (no match)\n- `FLX_format_satisfies_any` → `FLX_format_satisfies_any` (exact-name)\n- `FLX_format_FIX` → (no match)\n- `generic_format_FLXN` → (no match)\n- `FLXN_format_generic` → (no match)\n- `FLXN_format_satisfies_any` → (no match)\n- `negligible_exp_FLX` → (no match)\n- `generic_format_FLX_1` → `generic_format_FLX_1` (exact-name)\n- `ulp_FLX_0` → `ulp_FLX_0` (exact-name)\n- `ulp_FLX_1` → `ulp_FLX_1` (exact-name)\n- `succ_FLX_1` → (no match)\n- `eq_0_round_0_FLX` → (no match)\n- `gt_0_round_gt_0_FLX` → (no match)\n- `ulp_FLX_le` → `ulp_FLX_le` (exact-name)\n- `ulp_FLX_ge` → (no match)\n - `ulp_FLX_ge` → `ulp_FLX_ge` (exact-name)\n- `ulp_FLX_exact_shift` → (no match)\n - `ulp_FLX_exact_shift` → `ulp_FLX_exact_shift` (exact-name)\n- `succ_FLX_exact_shift` → (no match)\n- `pred_FLX_exact_shift` → (no match)\n\n## File: FTZ.v\n- Coq file: FTZ.v\n- Lean file(s): FTZ.lean\n\n### Coq Declarations\n- Theorem: `FLXN_format_FTZ`\n- Theorem: `generic_format_FTZ`\n- Theorem: `FTZ_format_generic`\n- Theorem: `FTZ_format_satisfies_any`\n- Theorem: `FTZ_format_FLXN`\n- Theorem: `ulp_FTZ_0`\n- Theorem: `round_FTZ_FLX`\n- Theorem: `round_FTZ_small`\n\n### Lean Declarations\n- theorem: `FTZ_exp_spec`\n- theorem: `FTZ_format_spec`\n- theorem: `FTZ_exp_correct_spec`\n- theorem: `FTZ_format_0_spec`\n- theorem: `FTZ_format_opp_spec`\n- theorem: `FTZ_format_abs_spec`\n\n### Mapping (Coq → Lean)\n- `FLXN_format_FTZ` → (no match)\n- `generic_format_FTZ` → `generic_format_FTZ` (exact-name)\n- `FTZ_format_generic` → `FTZ_format_generic` (exact-name)\n- `FTZ_format_satisfies_any` → `FTZ_format_satisfies_any` (exact-name)\n- `FTZ_format_FLXN` → (no match)\n- `ulp_FTZ_0` → `ulp_FTZ_0` (exact-name)\n- `round_FTZ_FLX` → `round_FTZ_FLX` (exact-name)\n- `round_FTZ_small` → `round_FTZ_small` (exact-name)\n\n## File: Float_prop.v\n- Coq file: Float_prop.v\n- Lean file(s): Float_prop.lean\n\n### Coq Declarations\n- Theorem: `Rcompare_F2R`\n- Theorem: `le_F2R`\n- Theorem: `F2R_le`\n- Theorem: `lt_F2R`\n- Theorem: `F2R_lt`\n- Theorem: `F2R_eq`\n- Theorem: `eq_F2R`\n- Theorem: `F2R_Zabs`\n- Theorem: `F2R_Zopp`\n- Theorem: `F2R_cond_Zopp`\n- Theorem: `F2R_0`\n- Theorem: `eq_0_F2R`\n- Theorem: `ge_0_F2R`\n- Theorem: `le_0_F2R`\n- Theorem: `gt_0_F2R`\n- Theorem: `lt_0_F2R`\n- Theorem: `F2R_ge_0`\n- Theorem: `F2R_le_0`\n- Theorem: `F2R_gt_0`\n- Theorem: `F2R_lt_0`\n- Theorem: `F2R_neq_0`\n- Lemma: `Fnum_ge_0`\n- Lemma: `Fnum_le_0`\n- Theorem: `F2R_bpow`\n- Theorem: `bpow_le_F2R`\n- Theorem: `F2R_p1_le_bpow`\n- Theorem: `bpow_le_F2R_m1`\n- Theorem: `F2R_lt_bpow`\n- Theorem: `F2R_change_exp`\n- Theorem: `F2R_prec_normalize`\n- Theorem: `mag_F2R_bounds`\n- Theorem: `mag_F2R`\n- Theorem: `Zdigits_mag`\n- Theorem: `mag_F2R_Zdigits`\n- Theorem: `mag_F2R_bounds_Zdigits`\n- Theorem: `float_distribution_pos`\n\n### Lean Declarations\n- theorem: `Rcompare_F2R`\n- theorem: `le_F2R`\n- theorem: `F2R_le`\n- theorem: `lt_F2R`\n- theorem: `F2R_lt`\n- theorem: `F2R_eq`\n- theorem: `eq_F2R`\n- theorem: `F2R_Zabs`\n- theorem: `F2R_Zopp`\n- theorem: `F2R_cond_Zopp`\n- theorem: `F2R_0`\n- theorem: `eq_0_F2R`\n- theorem: `ge_0_F2R`\n- theorem: `le_0_F2R`\n- theorem: `gt_0_F2R`\n- theorem: `lt_0_F2R`\n- theorem: `F2R_ge_0`\n- theorem: `F2R_le_0`\n- theorem: `F2R_gt_0`\n- theorem: `F2R_lt_0`\n- theorem: `F2R_neq_0`\n- theorem: `F2R_bpow`\n- theorem: `bpow_le_F2R`\n- theorem: `F2R_p1_le_bpow`\n- theorem: `bpow_le_F2R_m1`\n- theorem: `F2R_lt_bpow`\n- theorem: `F2R_change_exp`\n- theorem: `F2R_prec_normalize`\n- theorem: `mag_F2R_bounds`\n- theorem: `mag_F2R`\n- theorem: `Zdigits_mag`\n- theorem: `mag_F2R_Zdigits`\n- theorem: `mag_F2R_bounds_Zdigits`\n- theorem: `float_distribution_pos`\n\n### Mapping (Coq → Lean)\n- `Rcompare_F2R` → `Rcompare_F2R` (exact-name)\n- `le_F2R` → `le_F2R` (exact-name)\n- `F2R_le` → `F2R_le` (exact-name)\n- `lt_F2R` → `lt_F2R` (exact-name)\n- `F2R_lt` → `F2R_lt` (exact-name)\n- `F2R_eq` → `F2R_eq` (exact-name)\n- `eq_F2R` → `eq_F2R` (exact-name)\n- `F2R_Zabs` → `F2R_Zabs` (exact-name)\n- `F2R_Zopp` → `F2R_Zopp` (exact-name)\n- `F2R_cond_Zopp` → `F2R_cond_Zopp` (exact-name)\n- `F2R_0` → `F2R_0` (exact-name)\n- `eq_0_F2R` → `eq_0_F2R` (exact-name)\n- `ge_0_F2R` → `ge_0_F2R` (exact-name)\n- `le_0_F2R` → `le_0_F2R` (exact-name)\n- `gt_0_F2R` → `gt_0_F2R` (exact-name)\n- `lt_0_F2R` → `lt_0_F2R` (exact-name)\n- `F2R_ge_0` → `F2R_ge_0` (exact-name)\n- `F2R_le_0` → `F2R_le_0` (exact-name)\n- `F2R_gt_0` → `F2R_gt_0` (exact-name)\n- `F2R_lt_0` → `F2R_lt_0` (exact-name)\n- `F2R_neq_0` → `F2R_neq_0` (exact-name)\n- `Fnum_ge_0` → `Fnum_ge_0` (exact-name)\n- `Fnum_le_0` → `Fnum_le_0` (exact-name)\n- `F2R_bpow` → `F2R_bpow` (exact-name)\n- `bpow_le_F2R` → `bpow_le_F2R` (exact-name)\n- `F2R_p1_le_bpow` → `F2R_p1_le_bpow` (exact-name)\n- `bpow_le_F2R_m1` → `bpow_le_F2R_m1` (exact-name)\n- `F2R_lt_bpow` → `F2R_lt_bpow` (exact-name)\n- `F2R_change_exp` → `F2R_change_exp` (exact-name)\n- `F2R_prec_normalize` → `F2R_prec_normalize` (exact-name)\n- `mag_F2R_bounds` → `mag_F2R_bounds` (exact-name)\n- `mag_F2R` → `mag_F2R` (exact-name)\n- `Zdigits_mag` → `Zdigits_mag` (exact-name)\n- `mag_F2R_Zdigits` → `mag_F2R_Zdigits` (exact-name)\n- `mag_F2R_bounds_Zdigits` → `mag_F2R_bounds_Zdigits` (exact-name)\n- `float_distribution_pos` → `float_distribution_pos` (exact-name)\n\n## File: Generic_fmt.v\n- Coq file: Generic_fmt.v\n- Lean file(s): Generic_fmt.lean, Round_generic.lean\n\n### Coq Declarations\n- Theorem: `valid_exp_large`\n- Theorem: `valid_exp_large'`\n- Theorem: `generic_format_0`\n- Theorem: `cexp_opp`\n- Theorem: `cexp_abs`\n- Theorem: `canonical_generic_format`\n- Theorem: `generic_format_bpow`\n- Theorem: `generic_format_bpow'`\n- Theorem: `generic_format_F2R`\n- Lemma: `generic_format_F2R'`\n- Theorem: `canonical_opp`\n- Theorem: `canonical_abs`\n- Theorem: `canonical_0`\n- Theorem: `canonical_unique`\n- Theorem: `scaled_mantissa_generic`\n- Theorem: `scaled_mantissa_mult_bpow`\n- Theorem: `scaled_mantissa_0`\n- Theorem: `scaled_mantissa_opp`\n- Theorem: `scaled_mantissa_abs`\n- Theorem: `generic_format_opp`\n- Theorem: `generic_format_abs`\n- Theorem: `generic_format_abs_inv`\n- Theorem: `cexp_fexp`\n- Theorem: `cexp_fexp_pos`\n- Theorem: `mantissa_small_pos`\n- Theorem: `scaled_mantissa_lt_1`\n- Theorem: `scaled_mantissa_lt_bpow`\n- Theorem: `mag_generic_gt`\n- Lemma: `mantissa_DN_small_pos`\n- Lemma: `mantissa_UP_small_pos`\n- Theorem: `generic_format_discrete`\n- Theorem: `generic_format_canonical`\n- Theorem: `generic_format_ge_bpow`\n- Theorem: `abs_lt_bpow_prec`\n- Theorem: `generic_format_bpow_inv'`\n- Theorem: `generic_format_bpow_inv`\n- Theorem: `Zrnd_DN_or_UP`\n- Theorem: `Zrnd_ZR_or_AW`\n- Theorem: `round_bounded_large_pos`\n- Theorem: `round_bounded_small_pos`\n- Lemma: `round_le_pos`\n- Theorem: `round_generic`\n- Theorem: `round_0`\n- Theorem: `exp_small_round_0_pos`\n- Lemma: `generic_format_round_pos`\n- Theorem: `round_ext`\n- Theorem: `round_opp`\n- Theorem: `round_DN_or_UP`\n- Theorem: `round_ZR_or_AW`\n- Theorem: `round_le`\n- Theorem: `round_ge_generic`\n- Theorem: `round_le_generic`\n- Theorem: `round_abs_abs`\n- Theorem: `round_bounded_large`\n- Theorem: `exp_small_round_0`\n- Theorem: `abs_round_ge_generic`\n- Theorem: `abs_round_le_generic`\n- Theorem: `round_DN_opp`\n- Theorem: `round_UP_opp`\n- Theorem: `round_ZR_opp`\n- Theorem: `round_ZR_abs`\n- Theorem: `round_AW_opp`\n- Theorem: `round_AW_abs`\n- Theorem: `round_ZR_DN`\n- Theorem: `round_ZR_UP`\n- Theorem: `round_AW_UP`\n- Theorem: `round_AW_DN`\n- Theorem: `generic_format_round`\n- Theorem: `round_DN_pt`\n- Theorem: `generic_format_satisfies_any`\n- Theorem: `round_UP_pt`\n- Theorem: `round_ZR_pt`\n- Lemma: `round_DN_small_pos`\n- Theorem: `round_DN_UP_lt`\n- Lemma: `round_UP_small_pos`\n- Theorem: `generic_format_EM`\n- Lemma: `round_large_pos_ge_bpow`\n- Theorem: `mag_round_ZR`\n- Theorem: `mag_round`\n- Theorem: `mag_DN`\n- Theorem: `cexp_DN`\n- Theorem: `scaled_mantissa_DN`\n- Theorem: `generic_N_pt_DN_or_UP`\n- Theorem: `subnormal_exponent`\n- Lemma: `cexp_le_bpow`\n- Lemma: `cexp_ge_bpow`\n- Lemma: `lt_cexp_pos`\n- Theorem: `lt_cexp`\n- Theorem: `mag_round_ge`\n- Theorem: `cexp_round_ge`\n- Theorem: `Znearest_DN_or_UP`\n- Theorem: `Znearest_ge_floor`\n- Theorem: `Znearest_le_ceil`\n- Theorem: `Znearest_N_strict`\n- Theorem: `Znearest_half`\n- Theorem: `Znearest_imp`\n- Theorem: `round_N_pt`\n- Theorem: `round_N_middle`\n- Lemma: `round_N_small_pos`\n- Theorem: `round_NA_pt`\n- Theorem: `round_N0_pt`\n- Theorem: `Znearest_opp`\n- Theorem: `round_N_opp`\n- Lemma: `round_N0_opp`\n- Lemma: `round_N_small`\n- Theorem: `generic_inclusion_mag`\n- Theorem: `generic_inclusion_lt_ge`\n- Theorem: `generic_inclusion`\n- Theorem: `generic_inclusion_le_ge`\n- Theorem: `generic_inclusion_le`\n- Theorem: `generic_inclusion_ge`\n- Theorem: `generic_round_generic`\n- Lemma: `round_NA_opp`\n\n### Lean Declarations\n- lemma: `Ztrunc_int`\n- lemma: `zpow_ne_zero_of_pos`\n- theorem: `valid_exp_large`\n- theorem: `cexp_spec`\n- theorem: `scaled_mantissa_spec`\n- theorem: `generic_format_spec`\n- theorem: `Ztrunc_neg`\n- theorem: `Ztrunc_intCast`\n- theorem: `zpow_mul_sub`\n- theorem: `zpow_sub_add`\n- theorem: `zpow_nonneg_toNat`\n- theorem: `generic_format_0`\n- theorem: `cexp_opp`\n- theorem: `cexp_abs`\n- theorem: `canonical_generic_format`\n- theorem: `scaled_mantissa_mult_bpow`\n- lemma: `Ztrunc_zero`\n- theorem: `generic_format_F2R`\n- theorem: `canonical_opp`\n- theorem: `canonical_abs`\n- theorem: `canonical_0`\n- theorem: `canonical_unique`\n- theorem: `scaled_mantissa_0`\n- theorem: `scaled_mantissa_opp`\n- theorem: `scaled_mantissa_abs`\n- theorem: `generic_format_opp`\n- theorem: `generic_format_abs`\n- theorem: `generic_format_abs_inv`\n- theorem: `generic_format_satisfies_any`\n- theorem: `round_UP_exists`\n- theorem: `generic_format_bpow`\n- theorem: `scaled_mantissa_generic`\n- theorem: `cexp_fexp`\n- theorem: `cexp_fexp_pos`\n- theorem: `mantissa_small_pos`\n- theorem: `scaled_mantissa_lt_1`\n- theorem: `scaled_mantissa_lt_bpow`\n- theorem: `generic_format_round_DN`\n- theorem: `generic_format_round_UP`\n- theorem: `generic_format_precision_bound`\n- theorem: `fexp_monotone`\n- theorem: `generic_format_equiv`\n- theorem: `round_to_generic_spec`\n- theorem: `generic_format_inter_valid`\n- theorem: `mag_generic_format`\n- theorem: `precision_generic_format`\n- theorem: `generic_format_error_bound`\n- theorem: `generic_format_relative_error`\n- theorem: `round_to_format_properties`\n- theorem: `generic_format_neg_closed`\n- theorem: `Rnd_UP_to_DN_via_neg`\n\n### Mapping (Coq → Lean)\n- `valid_exp_large` → `valid_exp_large` (exact-name)\n- `valid_exp_large'` → `valid_exp_large` (normalized-name)\n- `generic_format_0` → `generic_format_0` (exact-name)\n- `cexp_opp` → `cexp_opp` (exact-name)\n- `cexp_abs` → `cexp_abs` (exact-name)\n- `canonical_generic_format` → `canonical_generic_format` (exact-name)\n- `generic_format_bpow` → `generic_format_bpow` (exact-name)\n- `generic_format_bpow'` → `generic_format_bpow` (normalized-name)\n- `generic_format_F2R` → `generic_format_F2R` (exact-name)\n- `generic_format_F2R'` → `generic_format_F2R` (normalized-name)\n- `canonical_opp` → `canonical_opp` (exact-name)\n- `canonical_abs` → `canonical_abs` (exact-name)\n- `canonical_0` → `canonical_0` (exact-name)\n- `canonical_unique` → `canonical_unique` (exact-name)\n- `scaled_mantissa_generic` → `scaled_mantissa_generic` (exact-name)\n- `scaled_mantissa_mult_bpow` → `scaled_mantissa_mult_bpow` (exact-name)\n- `scaled_mantissa_0` → `scaled_mantissa_0` (exact-name)\n- `scaled_mantissa_opp` → `scaled_mantissa_opp` (exact-name)\n- `scaled_mantissa_abs` → `scaled_mantissa_abs` (exact-name)\n- `generic_format_opp` → `generic_format_opp` (exact-name)\n- `generic_format_abs` → `generic_format_abs` (exact-name)\n- `generic_format_abs_inv` → `generic_format_abs_inv` (exact-name)\n- `cexp_fexp` → `cexp_fexp` (exact-name)\n- `cexp_fexp_pos` → `cexp_fexp_pos` (exact-name)\n- `mantissa_small_pos` → `mantissa_small_pos` (exact-name)\n- `scaled_mantissa_lt_1` → `scaled_mantissa_lt_1` (exact-name)\n- `mag_generic_gt` → `mag_generic_gt` (exact-name)\n- `mantissa_DN_small_pos` → (no match)\n- `mantissa_UP_small_pos` → (no match)\n- `generic_format_discrete` → (no match)\n- `generic_format_canonical` → (no match)\n- `generic_format_ge_bpow` → (no match)\n- `abs_lt_bpow_prec` → (no match)\n- `generic_format_bpow_inv'` → `generic_format_bpow` (substring-name)\n- `generic_format_bpow_inv` → `generic_format_bpow` (substring-name)\n- `Zrnd_DN_or_UP` → (no match)\n- `Zrnd_ZR_or_AW` → (no match)\n- `round_bounded_large_pos` → (no match)\n- `round_bounded_small_pos` → (no match)\n- `round_le_pos` → (no match)\n- `round_generic` → (no match)\n- `round_0` → `round_0` (exact-name)\n- `exp_small_round_0_pos` → (no match)\n- `generic_format_round_pos` → (no match)\n- `round_ext` → (no match)\n- `round_opp` → (no match)\n- `round_DN_or_UP` → (no match)\n- `round_ZR_or_AW` → (no match)\n- `round_le` → (no match)\n- `round_ge_generic` → (no match)\n- `round_le_generic` → (no match)\n- `round_abs_abs` → (no match)\n- `round_bounded_large` → (no match)\n- `exp_small_round_0` → (no match)\n- `abs_round_ge_generic` → (no match)\n- `abs_round_le_generic` → (no match)\n- `round_DN_opp` → (no match)\n- `round_UP_opp` → (no match)\n- `round_ZR_opp` → (no match)\n- `round_ZR_abs` → (no match)\n- `round_AW_opp` → (no match)\n- `round_AW_abs` → (no match)\n- `round_ZR_DN` → (no match)\n- `round_ZR_UP` → (no match)\n- `round_AW_UP` → (no match)\n- `round_AW_DN` → (no match)\n- `generic_format_round` → `generic_format_round_DN` (substring-name)\n- `round_DN_pt` → (no match)\n- `generic_format_satisfies_any` → `generic_format_satisfies_any` (exact-name)\n- `round_UP_pt` → (no match)\n- `round_ZR_pt` → (no match)\n- `round_DN_small_pos` → (no match)\n- `round_DN_UP_lt` → (no match)\n- `round_UP_small_pos` → (no match)\n- `generic_format_EM` → (no match)\n- `round_large_pos_ge_bpow` → (no match)\n- `mag_round_ZR` → (no match)\n- `mag_round` → (no match)\n- `mag_DN` → (no match)\n- `cexp_DN` → (no match)\n- `scaled_mantissa_DN` → (no match)\n- `generic_N_pt_DN_or_UP` → (no match)\n- `subnormal_exponent` → (no match)\n- `cexp_le_bpow` → (no match)\n- `cexp_ge_bpow` → (no match)\n- `lt_cexp_pos` → (no match)\n- `lt_cexp` → (no match)\n- `mag_round_ge` → (no match)\n- `cexp_round_ge` → (no match)\n- `Znearest_DN_or_UP` → (no match)\n- `Znearest_ge_floor` → (no match)\n- `Znearest_le_ceil` → (no match)\n- `Znearest_N_strict` → (no match)\n- `Znearest_half` → (no match)\n- `Znearest_imp` → (no match)\n- `round_N_pt` → (no match)\n- `round_N_middle` → (no match)\n- `round_N_small_pos` → (no match)\n- `round_NA_pt` → (no match)\n- `round_N0_pt` → (no match)\n- `Znearest_opp` → (no match)\n- `round_N_opp` → (no match)\n- `round_N0_opp` → (no match)\n- `round_N_small` → (no match)\n- `generic_inclusion_mag` → (no match)\n- `generic_inclusion_lt_ge` → (no match)\n- `generic_inclusion` → (no match)\n- `generic_inclusion_le_ge` → (no match)\n- `generic_inclusion_le` → (no match)\n- `generic_inclusion_ge` → (no match)\n- `generic_round_generic` → (no match)\n- `round_NA_opp` → (no match)\n\n## File: Raux.v\n- Coq file: Raux.v\n- Lean file(s): Raux.lean\n\n### Coq Declarations\n- Theorem: `Rle_0_minus`\n- Theorem: `Rabs_eq_Rabs`\n- Theorem: `Rabs_minus_le`\n- Theorem: `Rabs_eq_R0`\n- Theorem: `Rmult_lt_compat`\n- Lemma: `Rmult_neq_reg_r`\n- Lemma: `Rmult_neq_compat_r`\n- Theorem: `Rmult_min_distr_r`\n- Theorem: `Rmult_min_distr_l`\n- Lemma: `Rmin_opp`\n- Lemma: `Rmax_opp`\n- Theorem: `exp_le`\n- Theorem: `Rinv_lt`\n- Theorem: `Rinv_le`\n- Theorem: `sqrt_ge_0`\n- Lemma: `sqrt_neg`\n- Lemma: `Rsqr_le_abs_0_alt`\n- Theorem: `Rabs_le_inv`\n- Theorem: `Rabs_ge`\n- Theorem: `Rabs_ge_inv`\n- Theorem: `Rabs_lt`\n- Theorem: `Rabs_lt_inv`\n- Theorem: `Rabs_gt`\n- Theorem: `Rabs_gt_inv`\n- Theorem: `IZR_le_lt`\n- Theorem: `le_lt_IZR`\n- Theorem: `neq_IZR`\n- Theorem: `Rcompare_spec`\n- Theorem: `Rcompare_Lt`\n- Theorem: `Rcompare_Lt_inv`\n- Theorem: `Rcompare_not_Lt`\n- Theorem: `Rcompare_not_Lt_inv`\n- Theorem: `Rcompare_Eq`\n- Theorem: `Rcompare_Eq_inv`\n- Theorem: `Rcompare_Gt`\n- Theorem: `Rcompare_Gt_inv`\n- Theorem: `Rcompare_not_Gt`\n- Theorem: `Rcompare_not_Gt_inv`\n- Theorem: `Rcompare_IZR`\n- Theorem: `Rcompare_sym`\n- Lemma: `Rcompare_opp`\n- Theorem: `Rcompare_plus_r`\n- Theorem: `Rcompare_plus_l`\n- Theorem: `Rcompare_mult_r`\n- Theorem: `Rcompare_mult_l`\n- Theorem: `Rcompare_middle`\n- Theorem: `Rcompare_half_l`\n- Theorem: `Rcompare_half_r`\n- Theorem: `Rcompare_sqr`\n- Theorem: `Rmin_compare`\n- Theorem: `Rle_bool_spec`\n- Theorem: `Rle_bool_true`\n- Theorem: `Rle_bool_false`\n- Theorem: `Rlt_bool_spec`\n- Theorem: `negb_Rlt_bool`\n- Theorem: `negb_Rle_bool`\n- Theorem: `Rlt_bool_true`\n- Theorem: `Rlt_bool_false`\n- Lemma: `Rlt_bool_opp`\n- Theorem: `Req_bool_spec`\n- Theorem: `Req_bool_true`\n- Theorem: `Req_bool_false`\n- Theorem: `Zfloor_lb`\n- Theorem: `Zfloor_ub`\n- Theorem: `Zfloor_lub`\n- Theorem: `Zfloor_imp`\n- Theorem: `Zfloor_IZR`\n- Theorem: `Zfloor_le`\n- Theorem: `Zceil_ub`\n- Theorem: `Zceil_lb`\n- Theorem: `Zceil_glb`\n- Theorem: `Zceil_imp`\n- Theorem: `Zceil_IZR`\n- Theorem: `Zceil_le`\n- Theorem: `Zceil_floor_neq`\n- Theorem: `Ztrunc_IZR`\n- Theorem: `Ztrunc_floor`\n- Theorem: `Ztrunc_ceil`\n- Theorem: `Ztrunc_le`\n- Theorem: `Ztrunc_opp`\n- Theorem: `Ztrunc_abs`\n- Theorem: `Ztrunc_lub`\n- Theorem: `Zaway_IZR`\n- Theorem: `Zaway_ceil`\n- Theorem: `Zaway_floor`\n- Theorem: `Zaway_le`\n- Theorem: `Zaway_opp`\n- Theorem: `Zaway_abs`\n- Theorem: `Rcompare_floor_ceil_middle`\n- Theorem: `Rcompare_ceil_floor_middle`\n- Theorem: `Zfloor_div`\n- Theorem: `Ztrunc_div`\n- Theorem: `radix_pos`\n- Theorem: `IZR_Zpower_pos`\n- Theorem: `bpow_powerRZ`\n- Theorem: `bpow_ge_0`\n- Theorem: `bpow_gt_0`\n- Theorem: `bpow_plus`\n- Theorem: `bpow_1`\n- Theorem: `bpow_plus_1`\n- Theorem: `bpow_opp`\n- Theorem: `IZR_Zpower_nat`\n- Theorem: `IZR_Zpower`\n- Theorem: `bpow_lt`\n- Theorem: `lt_bpow`\n- Theorem: `bpow_le`\n- Theorem: `le_bpow`\n- Theorem: `bpow_inj`\n- Theorem: `bpow_exp`\n- Lemma: `sqrt_bpow`\n- Lemma: `sqrt_bpow_ge`\n- Theorem: `bpow_lt_bpow`\n- Theorem: `bpow_unique`\n- Theorem: `mag_unique`\n- Theorem: `mag_opp`\n- Theorem: `mag_abs`\n- Theorem: `mag_unique_pos`\n- Theorem: `mag_le_abs`\n- Theorem: `mag_le`\n- Lemma: `lt_mag`\n- Theorem: `mag_bpow`\n- Theorem: `mag_mult_bpow`\n- Theorem: `mag_le_bpow`\n- Theorem: `mag_gt_bpow`\n- Theorem: `mag_ge_bpow`\n- Theorem: `bpow_mag_gt`\n- Theorem: `bpow_mag_le`\n- Theorem: `mag_le_Zpower`\n- Theorem: `mag_gt_Zpower`\n- Lemma: `mag_mult`\n- Lemma: `mag_plus`\n- Lemma: `mag_minus`\n- Lemma: `mag_minus_lb`\n- Theorem: `mag_plus_ge`\n- Lemma: `mag_div`\n- Lemma: `mag_sqrt`\n- Lemma: `mag_1`\n- Theorem: `eqb_sym`\n- Theorem: `eqb_false`\n- Theorem: `eqb_true`\n- Theorem: `IZR_cond_Zopp`\n- Theorem: `abs_cond_Ropp`\n- Theorem: `cond_Ropp_Rlt_bool`\n- Theorem: `Rlt_bool_cond_Ropp`\n- Theorem: `cond_Ropp_involutive`\n- Theorem: `cond_Ropp_inj`\n- Theorem: `cond_Ropp_mult_l`\n- Theorem: `cond_Ropp_mult_r`\n- Theorem: `cond_Ropp_plus`\n- Theorem: `LPO_min`\n- Theorem: `LPO`\n- Lemma: `LPO_Z`\n\n### Lean Declarations\n- theorem: `Rle_0_minus_spec`\n- theorem: `Rmult_lt_compat_spec`\n- theorem: `Rmult_neq_reg_r_spec`\n- theorem: `Rmult_neq_compat_r_spec`\n- theorem: `Rmult_min_distr_r_spec`\n- theorem: `Rmult_min_distr_l_spec`\n- theorem: `Rmin_opp_spec`\n- theorem: `Rmax_opp_spec`\n- theorem: `Rabs_eq_Rabs_spec`\n- theorem: `Rabs_minus_le_spec`\n - theorem: `Rabs_ge_spec`\n - theorem: `Rabs_ge_inv_spec`\n- theorem: `Rcompare_spec`\n- theorem: `Rcompare_sym_spec`\n- theorem: `Rcompare_opp_spec`\n- theorem: `Rcompare_plus_r_spec`\n- theorem: `Rcompare_plus_l_spec`\n- theorem: `Rcompare_mult_r_spec`\n- theorem: `Rcompare_mult_l_spec`\n- theorem: `Rle_bool_spec`\n- theorem: `Rlt_bool_spec`\n- theorem: `negb_Rlt_bool_spec`\n- theorem: `negb_Rle_bool_spec`\n- theorem: `Req_bool_spec`\n- theorem: `eqb_sym_spec`\n- theorem: `cond_Ropp_spec`\n- theorem: `cond_Ropp_involutive_spec`\n- theorem: `cond_Ropp_inj_spec`\n\n### Mapping (Coq → Lean)\n- `Rle_0_minus` → `Rle_0_minus_spec` (substring-name)\n- `Rabs_eq_Rabs` → (no match)\n- `Rabs_eq_Rabs` → `Rabs_eq_Rabs_spec` (substring-name)\n- `Rabs_minus_le` → `Rabs_minus_le_spec` (substring-name)\n- `Rabs_eq_R0` → `Rabs_eq_R0_spec` (substring-name)\n- `Rmult_lt_compat` → `Rmult_lt_compat_spec` (substring-name)\n- `Rmult_neq_reg_r` → `Rmult_neq_reg_r_spec` (substring-name)\n- `Rmult_neq_compat_r` → `Rmult_neq_compat_r_spec` (substring-name)\n- `Rmult_min_distr_r` → `Rmult_min_distr_r_spec` (substring-name)\n- `Rmult_min_distr_l` → `Rmult_min_distr_l_spec` (substring-name)\n- `Rmin_opp` → `Rmin_opp_spec` (substring-name)\n- `Rmax_opp` → `Rmax_opp_spec` (substring-name)\n- `exp_le` → `exp_le_spec` (substring-name)\n- `Rinv_lt` → `Rinv_lt_spec` (substring-name)\n- `Rinv_le` → `Rinv_le_spec` (substring-name)\n- `sqrt_ge_0` → `sqrt_ge_0_spec` (substring-name)\n- `sqrt_neg` → (no match)\n- `Rsqr_le_abs_0_alt` → (no match)\n- `Rabs_le_inv` → (no match)\n- `Rabs_ge` → `Rabs_ge_spec` (substring-name)\n- `Rabs_ge_inv` → `Rabs_ge_inv_spec` (substring-name)\n- `Rabs_lt` → (no match)\n- `Rabs_lt_inv` → (no match)\n- `Rabs_gt` → (no match)\n- `Rabs_gt_inv` → (no match)\n- `IZR_le_lt` → (no match)\n- `le_lt_IZR` → (no match)\n- `neq_IZR` → (no match)\n- `Rcompare_spec` → `Rcompare_spec` (exact-name)\n- `Rcompare_Lt` → (no match)\n- `Rcompare_Lt_inv` → (no match)\n- `Rcompare_not_Lt` → (no match)\n- `Rcompare_not_Lt_inv` → (no match)\n- `Rcompare_Eq` → (no match)\n- `Rcompare_Eq_inv` → (no match)\n- `Rcompare_Gt` → (no match)\n- `Rcompare_Gt_inv` → (no match)\n- `Rcompare_not_Gt` → (no match)\n- `Rcompare_not_Gt_inv` → (no match)\n- `Rcompare_IZR` → (no match)\n- `Rcompare_sym` → `Rcompare_sym_spec` (substring-name)\n- `Rcompare_opp` → `Rcompare_opp_spec` (substring-name)\n- `Rcompare_plus_r` → `Rcompare_plus_r_spec` (substring-name)\n- `Rcompare_plus_l` → `Rcompare_plus_l_spec` (substring-name)\n- `Rcompare_mult_r` → `Rcompare_mult_r_spec` (substring-name)\n- `Rcompare_mult_l` → `Rcompare_mult_l_spec` (substring-name)\n- `Rcompare_middle` → (no match)\n- `Rcompare_half_l` → (no match)\n- `Rcompare_half_r` → (no match)\n- `Rcompare_sqr` → (no match)\n- `Rmin_compare` → (no match)\n- `Rle_bool_spec` → `Rle_bool_spec` (exact-name)\n- `Rle_bool_true` → (no match)\n- `Rle_bool_false` → (no match)\n- `Rlt_bool_spec` → `Rlt_bool_spec` (exact-name)\n- `negb_Rlt_bool` → `negb_Rlt_bool_spec` (substring-name)\n- `negb_Rle_bool` → `negb_Rle_bool_spec` (substring-name)\n- `Rlt_bool_true` → (no match)\n- `Rlt_bool_false` → (no match)\n- `Rlt_bool_opp` → (no match)\n- `Req_bool_spec` → `Req_bool_spec` (exact-name)\n- `Req_bool_true` → (no match)\n- `Req_bool_false` → (no match)\n- `Zfloor_lb` → (no match)\n- `Zfloor_ub` → (no match)\n- `Zfloor_lub` → (no match)\n- `Zfloor_imp` → (no match)\n- `Zfloor_IZR` → (no match)\n- `Zfloor_le` → (no match)\n- `Zceil_ub` → (no match)\n- `Zceil_lb` → (no match)\n- `Zceil_glb` → (no match)\n- `Zceil_imp` → (no match)\n- `Zceil_IZR` → (no match)\n- `Zceil_le` → (no match)\n- `Zceil_floor_neq` → (no match)\n- `Ztrunc_IZR` → (no match)\n- `Ztrunc_floor` → (no match)\n- `Ztrunc_ceil` → (no match)\n- `Ztrunc_le` → (no match)\n- `Ztrunc_opp` → (no match)\n- `Ztrunc_abs` → (no match)\n- `Ztrunc_lub` → (no match)\n- `Zaway_IZR` → (no match)\n- `Zaway_ceil` → (no match)\n- `Zaway_floor` → (no match)\n- `Zaway_le` → (no match)\n- `Zaway_opp` → (no match)\n- `Zaway_abs` → (no match)\n- `Rcompare_floor_ceil_middle` → (no match)\n- `Rcompare_ceil_floor_middle` → (no match)\n- `Zfloor_div` → (no match)\n- `Ztrunc_div` → (no match)\n- `radix_pos` → (no match)\n- `IZR_Zpower_pos` → (no match)\n- `bpow_powerRZ` → (no match)\n- `bpow_ge_0` → (no match)\n- `bpow_gt_0` → (no match)\n- `bpow_plus` → (no match)\n- `bpow_1` → (no match)\n- `bpow_plus_1` → (no match)\n- `bpow_opp` → (no match)\n- `IZR_Zpower_nat` → (no match)\n- `IZR_Zpower` → (no match)\n- `bpow_lt` → (no match)\n- `lt_bpow` → (no match)\n- `bpow_le` → (no match)\n- `le_bpow` → (no match)\n- `bpow_inj` → (no match)\n- `bpow_exp` → (no match)\n- `sqrt_bpow` → (no match)\n- `sqrt_bpow_ge` → (no match)\n- `bpow_lt_bpow` → (no match)\n- `bpow_unique` → (no match)\n- `mag_unique` → (no match)\n- `mag_opp` → (no match)\n- `mag_abs` → (no match)\n- `mag_unique_pos` → (no match)\n- `mag_le_abs` → (no match)\n- `mag_le` → (no match)\n- `lt_mag` → (no match)\n- `mag_bpow` → (no match)\n- `mag_mult_bpow` → (no match)\n- `mag_le_bpow` → (no match)\n- `mag_gt_bpow` → (no match)\n- `mag_ge_bpow` → (no match)\n- `bpow_mag_gt` → (no match)\n- `bpow_mag_le` → (no match)\n- `mag_le_Zpower` → (no match)\n- `mag_gt_Zpower` → (no match)\n- `mag_mult` → (no match)\n- `mag_plus` → (no match)\n- `mag_minus` → (no match)\n- `mag_minus_lb` → (no match)\n- `mag_plus_ge` → (no match)\n- `mag_div` → (no match)\n- `mag_sqrt` → (no match)\n- `mag_1` → (no match)\n- `eqb_sym` → `eqb_sym_spec` (substring-name)\n- `eqb_false` → (no match)\n- `eqb_true` → (no match)\n- `IZR_cond_Zopp` → (no match)\n- `abs_cond_Ropp` → (no match)\n- `cond_Ropp_Rlt_bool` → (no match)\n- `Rlt_bool_cond_Ropp` → (no match)\n- `cond_Ropp_involutive` → `cond_Ropp_involutive_spec` (substring-name)\n- `cond_Ropp_inj` → `cond_Ropp_inj_spec` (substring-name)\n- `cond_Ropp_mult_l` → (no match)\n- `cond_Ropp_mult_r` → (no match)\n- `cond_Ropp_plus` → (no match)\n- `LPO_min` → (no match)\n- `LPO` → (no match)\n- `LPO_Z` → (no match)\n\n## File: Round_NE.v\n- Coq file: Round_NE.v\n- Lean file(s): Round_NE.lean\n\n### Coq Declarations\n- Lemma: `DN_UP_parity_aux`\n- Theorem: `DN_UP_parity_generic_pos`\n- Theorem: `DN_UP_parity_generic`\n- Theorem: `Rnd_NE_pt_total`\n- Theorem: `Rnd_NE_pt_monotone`\n- Theorem: `Rnd_NE_pt_round`\n- Lemma: `round_NE_pt_pos`\n- Theorem: `round_NE_opp`\n- Lemma: `round_NE_abs`\n- Theorem: `round_NE_pt`\n\n### Lean Declarations\n- theorem: `DN_UP_parity_aux`\n- theorem: `DN_UP_parity_generic_pos`\n- theorem: `DN_UP_parity_generic`\n- theorem: `Rnd_NE_pt_unique_prop`\n- theorem: `Rnd_NE_pt_unique`\n- theorem: `Rnd_NE_pt_monotone`\n- theorem: `Rnd_NE_pt_total`\n- theorem: `Rnd_NE_pt_round`\n- theorem: `satisfies_any_imp_NE`\n- theorem: `Rnd_NE_pt_refl`\n- theorem: `Rnd_NE_pt_idempotent`\n- theorem: `DN_UP_parity_pos_holds`\n- theorem: `Rnd_NE_pt_sign`\n- theorem: `Rnd_NE_pt_abs`\n- theorem: `round_NE_pt_pos`\n- theorem: `round_NE_opp`\n- theorem: `round_NE_abs`\n- theorem: `round_NE_pt`\n- theorem: `Rnd_NE_pt_error_bound`\n- theorem: `Rnd_NE_pt_minimal_error`\n\n### Mapping (Coq → Lean)\n- `DN_UP_parity_aux` → `DN_UP_parity_aux` (exact-name)\n- `DN_UP_parity_generic_pos` → `DN_UP_parity_generic_pos` (exact-name)\n- `DN_UP_parity_generic` → `DN_UP_parity_generic` (exact-name)\n- `Rnd_NE_pt_total` → `Rnd_NE_pt_total` (exact-name)\n- `Rnd_NE_pt_monotone` → `Rnd_NE_pt_monotone` (exact-name)\n- `Rnd_NE_pt_round` → `Rnd_NE_pt_round` (exact-name)\n- `round_NE_pt_pos` → `round_NE_pt_pos` (exact-name)\n- `round_NE_opp` → `round_NE_opp` (exact-name)\n- `round_NE_abs` → `round_NE_abs` (exact-name)\n- `round_NE_pt` → `round_NE_pt` (exact-name)\n\n## File: Round_pred.v\n- Coq file: Round_pred.v\n- Lean file(s): Round_pred.lean\n\n### Coq Declarations\n- Theorem: `round_val_of_pred`\n- Theorem: `round_fun_of_pred`\n- Theorem: `round_unique`\n- Theorem: `Rnd_DN_pt_monotone`\n- Theorem: `Rnd_DN_pt_unique`\n- Theorem: `Rnd_DN_unique`\n- Theorem: `Rnd_UP_pt_monotone`\n- Theorem: `Rnd_UP_pt_unique`\n- Theorem: `Rnd_UP_unique`\n- Theorem: `Rnd_UP_pt_opp`\n- Theorem: `Rnd_DN_pt_opp`\n- Theorem: `Rnd_DN_opp`\n- Theorem: `Rnd_DN_UP_pt_split`\n- Theorem: `Rnd_DN_pt_refl`\n- Theorem: `Rnd_DN_pt_idempotent`\n- Theorem: `Rnd_UP_pt_refl`\n- Theorem: `Rnd_UP_pt_idempotent`\n- Theorem: `Only_DN_or_UP`\n- Theorem: `Rnd_ZR_abs`\n- Theorem: `Rnd_ZR_pt_monotone`\n- Theorem: `Rnd_N_pt_DN_or_UP`\n- Theorem: `Rnd_N_pt_DN_or_UP_eq`\n- Theorem: `Rnd_N_pt_opp_inv`\n- Theorem: `Rnd_N_pt_monotone`\n- Theorem: `Rnd_N_pt_unique`\n- Theorem: `Rnd_N_pt_refl`\n- Theorem: `Rnd_N_pt_idempotent`\n- Theorem: `Rnd_N_pt_0`\n- Theorem: `Rnd_N_pt_ge_0`\n- Theorem: `Rnd_N_pt_le_0`\n- Theorem: `Rnd_N_pt_abs`\n- Theorem: `Rnd_N_pt_DN_UP`\n- Theorem: `Rnd_N_pt_DN`\n- Theorem: `Rnd_N_pt_UP`\n- Theorem: `Rnd_NG_pt_unique`\n- Theorem: `Rnd_NG_pt_monotone`\n- Theorem: `Rnd_NG_pt_refl`\n- Theorem: `Rnd_NG_pt_opp_inv`\n- Theorem: `Rnd_NG_unique`\n- Theorem: `Rnd_NA_NG_pt`\n- Lemma: `Rnd_NA_pt_unique_prop`\n- Theorem: `Rnd_NA_pt_unique`\n- Theorem: `Rnd_NA_pt_N`\n- Theorem: `Rnd_NA_unique`\n- Theorem: `Rnd_NA_pt_monotone`\n- Theorem: `Rnd_NA_pt_refl`\n- Theorem: `Rnd_NA_pt_idempotent`\n- Theorem: `Rnd_N0_NG_pt`\n- Lemma: `Rnd_N0_pt_unique_prop`\n- Theorem: `Rnd_N0_pt_unique`\n- Theorem: `Rnd_N0_pt_N`\n- Theorem: `Rnd_N0_unique`\n- Theorem: `Rnd_N0_pt_monotone`\n- Theorem: `Rnd_N0_pt_refl`\n- Theorem: `Rnd_N0_pt_idempotent`\n- Theorem: `round_pred_ge_0`\n- Theorem: `round_pred_gt_0`\n- Theorem: `round_pred_le_0`\n- Theorem: `round_pred_lt_0`\n- Theorem: `Rnd_DN_pt_equiv_format`\n- Theorem: `Rnd_UP_pt_equiv_format`\n- Theorem: `satisfies_any_eq`\n- Theorem: `satisfies_any_imp_DN`\n- Theorem: `satisfies_any_imp_UP`\n- Theorem: `satisfies_any_imp_ZR`\n- Theorem: `satisfies_any_imp_NG`\n- Theorem: `satisfies_any_imp_NA`\n- Theorem: `satisfies_any_imp_N0`\n\n### Lean Declarations\n- theorem: `Rnd_DN_spec`\n- theorem: `Rnd_UP_spec`\n- theorem: `Rnd_ZR_spec`\n- theorem: `Rnd_N_spec`\n- theorem: `Rnd_NG_spec`\n- theorem: `Rnd_NA_spec`\n- theorem: `Rnd_N0_spec`\n- theorem: `round_val_of_pred_spec`\n- theorem: `round_fun_of_pred_spec`\n- theorem: `round_unique_spec`\n- theorem: `Rnd_DN_pt_monotone_spec`\n- theorem: `Rnd_DN_pt_unique_spec`\n- theorem: `Rnd_DN_unique_spec`\n- theorem: `Rnd_UP_pt_monotone_spec`\n- theorem: `Rnd_UP_pt_unique_spec`\n- theorem: `Rnd_UP_unique_spec`\n- theorem: `Rnd_UP_pt_opp_spec`\n- theorem: `Rnd_DN_pt_opp_spec`\n- theorem: `Rnd_DN_pt_refl_spec`\n- theorem: `Rnd_DN_pt_idempotent_spec`\n- theorem: `Rnd_UP_pt_refl_spec`\n- theorem: `Rnd_UP_pt_idempotent_spec`\n- theorem: `Rnd_ZR_abs_spec`\n\n### Mapping (Coq → Lean)\n- `round_val_of_pred` → `round_val_of_pred_spec` (substring-name)\n- `round_fun_of_pred` → `round_fun_of_pred_spec` (substring-name)\n- `round_unique` → `round_unique_spec` (substring-name)\n- `Rnd_DN_pt_monotone` → `Rnd_DN_pt_monotone_spec` (substring-name)\n- `Rnd_DN_pt_unique` → `Rnd_DN_pt_unique_spec` (substring-name)\n- `Rnd_DN_unique` → `Rnd_DN_unique_spec` (substring-name)\n- `Rnd_UP_pt_monotone` → `Rnd_UP_pt_monotone_spec` (substring-name)\n- `Rnd_UP_pt_unique` → `Rnd_UP_pt_unique_spec` (substring-name)\n- `Rnd_UP_unique` → `Rnd_UP_unique_spec` (substring-name)\n- `Rnd_UP_pt_opp` → `Rnd_UP_pt_opp_spec` (substring-name)\n- `Rnd_DN_pt_opp` → `Rnd_DN_pt_opp_spec` (substring-name)\n- `Rnd_DN_opp` → (no match)\n- `Rnd_DN_UP_pt_split` → (no match)\n- `Rnd_DN_pt_refl` → `Rnd_DN_pt_refl_spec` (substring-name)\n- `Rnd_DN_pt_idempotent` → `Rnd_DN_pt_idempotent_spec` (substring-name)\n- `Rnd_UP_pt_refl` → `Rnd_UP_pt_refl_spec` (substring-name)\n- `Rnd_UP_pt_idempotent` → `Rnd_UP_pt_idempotent_spec` (substring-name)\n- `Only_DN_or_UP` → (no match)\n- `Rnd_ZR_abs` → `Rnd_ZR_abs_spec` (substring-name)\n- `Rnd_ZR_pt_monotone` → (no match)\n- `Rnd_N_pt_DN_or_UP` → (no match)\n- `Rnd_N_pt_DN_or_UP_eq` → (no match)\n- `Rnd_N_pt_opp_inv` → (no match)\n- `Rnd_N_pt_monotone` → (no match)\n- `Rnd_N_pt_unique` → (no match)\n- `Rnd_N_pt_refl` → (no match)\n- `Rnd_N_pt_idempotent` → (no match)\n- `Rnd_N_pt_0` → (no match)\n- `Rnd_N_pt_ge_0` → (no match)\n- `Rnd_N_pt_le_0` → (no match)\n- `Rnd_N_pt_abs` → (no match)\n- `Rnd_N_pt_DN_UP` → (no match)\n- `Rnd_N_pt_DN` → (no match)\n- `Rnd_N_pt_UP` → (no match)\n- `Rnd_NG_pt_unique` → (no match)\n- `Rnd_NG_pt_monotone` → (no match)\n- `Rnd_NG_pt_refl` → (no match)\n- `Rnd_NG_pt_opp_inv` → (no match)\n- `Rnd_NG_unique` → (no match)\n- `Rnd_NA_NG_pt` → (no match)\n- `Rnd_NA_pt_unique_prop` → (no match)\n- `Rnd_NA_pt_unique` → (no match)\n- `Rnd_NA_pt_N` → (no match)\n- `Rnd_NA_unique` → (no match)\n- `Rnd_NA_pt_monotone` → (no match)\n- `Rnd_NA_pt_refl` → (no match)\n- `Rnd_NA_pt_idempotent` → (no match)\n- `Rnd_N0_NG_pt` → (no match)\n- `Rnd_N0_pt_unique_prop` → (no match)\n- `Rnd_N0_pt_unique` → (no match)\n- `Rnd_N0_pt_N` → (no match)\n- `Rnd_N0_unique` → (no match)\n- `Rnd_N0_pt_monotone` → (no match)\n- `Rnd_N0_pt_refl` → (no match)\n- `Rnd_N0_pt_idempotent` → (no match)\n- `round_pred_ge_0` → (no match)\n- `round_pred_gt_0` → (no match)\n- `round_pred_le_0` → (no match)\n- `round_pred_lt_0` → (no match)\n- `Rnd_DN_pt_equiv_format` → (no match)\n- `Rnd_UP_pt_equiv_format` → (no match)\n- `satisfies_any_eq` → (no match)\n- `satisfies_any_imp_DN` → (no match)\n- `satisfies_any_imp_UP` → (no match)\n- `satisfies_any_imp_ZR` → (no match)\n- `satisfies_any_imp_NG` → (no match)\n- `satisfies_any_imp_NA` → (no match)\n- `satisfies_any_imp_N0` → (no match)\n\n## File: Ulp.v\n- Coq file: Ulp.v\n- Lean file(s): Ulp.lean\n\n### Coq Declarations\n- Lemma: `Z_le_dec_aux`\n- Lemma: `negligible_exp_spec`\n- Lemma: `negligible_exp_spec'`\n- Lemma: `fexp_negligible_exp_eq`\n- Lemma: `ulp_neq_0`\n- Theorem: `ulp_opp`\n- Theorem: `ulp_abs`\n- Theorem: `ulp_ge_0`\n- Theorem: `ulp_le_id`\n- Theorem: `ulp_le_abs`\n- Theorem: `round_UP_DN_ulp`\n- Theorem: `ulp_canonical`\n- Theorem: `ulp_bpow`\n- Lemma: `generic_format_ulp_0`\n- Lemma: `generic_format_bpow_ge_ulp_0`\n- Lemma: `generic_format_ulp`\n- Lemma: `not_FTZ_generic_format_ulp`\n- Lemma: `ulp_ge_ulp_0`\n- Lemma: `not_FTZ_ulp_ge_ulp_0`\n- Lemma: `ulp_le_pos`\n- Theorem: `ulp_le`\n- Theorem: `eq_0_round_0_negligible_exp`\n- Theorem: `pred_eq_pos`\n- Theorem: `succ_eq_pos`\n- Theorem: `succ_opp`\n- Theorem: `pred_opp`\n- Theorem: `pred_bpow`\n- Theorem: `id_m_ulp_ge_bpow`\n- Theorem: `id_p_ulp_le_bpow`\n- Lemma: `generic_format_pred_aux1`\n- Lemma: `generic_format_pred_aux2`\n- Lemma: `generic_format_succ_aux1`\n- Lemma: `generic_format_pred_pos`\n- Theorem: `generic_format_succ`\n- Theorem: `generic_format_pred`\n- Lemma: `pred_pos_lt_id`\n- Theorem: `succ_gt_id`\n- Theorem: `pred_lt_id`\n- Theorem: `succ_ge_id`\n- Theorem: `pred_le_id`\n- Lemma: `pred_pos_ge_0`\n- Theorem: `pred_ge_0`\n- Lemma: `pred_pos_plus_ulp_aux1`\n- Lemma: `pred_pos_plus_ulp_aux2`\n- Lemma: `pred_pos_plus_ulp_aux3`\n- Lemma: `pred_pos_plus_ulp`\n- Theorem: `pred_plus_ulp`\n- Theorem: `mag_plus_eps`\n- Theorem: `round_DN_plus_eps_pos`\n- Theorem: `round_UP_plus_eps_pos`\n- Theorem: `round_UP_pred_plus_eps_pos`\n- Theorem: `round_DN_minus_eps_pos`\n- Theorem: `round_DN_plus_eps`\n- Theorem: `round_UP_plus_eps`\n- Lemma: `le_pred_pos_lt`\n- Lemma: `succ_le_lt_aux`\n- Theorem: `succ_le_lt`\n- Theorem: `pred_ge_gt`\n- Theorem: `succ_gt_ge`\n- Theorem: `pred_lt_le`\n- Lemma: `succ_pred_pos`\n- Theorem: `pred_ulp_0`\n- Theorem: `succ_0`\n- Theorem: `pred_0`\n- Lemma: `pred_succ_pos`\n- Theorem: `succ_pred`\n- Theorem: `pred_succ`\n- Theorem: `round_UP_pred_plus_eps`\n- Theorem: `round_DN_minus_eps`\n- Theorem: `error_lt_ulp`\n- Theorem: `error_le_ulp`\n- Theorem: `error_le_half_ulp`\n- Theorem: `ulp_DN`\n- Theorem: `round_neq_0_negligible_exp`\n- Theorem: `error_lt_ulp_round`\n- Lemma: `error_le_ulp_round`\n- Theorem: `error_le_half_ulp_round`\n- Theorem: `pred_le`\n- Theorem: `succ_le`\n- Theorem: `pred_le_inv`\n- Theorem: `succ_le_inv`\n- Theorem: `pred_lt`\n- Theorem: `succ_lt`\n- Lemma: `succ_le_plus_ulp`\n- Lemma: `generic_format_plus_ulp`\n- Theorem: `round_DN_ge_UP_gt`\n- Theorem: `round_UP_le_DN_lt`\n- Theorem: `pred_UP_le_DN`\n- Theorem: `UP_le_succ_DN`\n- Theorem: `pred_UP_eq_DN`\n- Theorem: `succ_DN_eq_UP`\n- Theorem: `round_DN_eq`\n- Theorem: `round_UP_eq`\n- Lemma: `ulp_ulp_0`\n- Lemma: `ulp_succ_pos`\n- Theorem: `ulp_pred_pos`\n- Lemma: `ulp_round_pos`\n- Theorem: `ulp_round`\n- Lemma: `succ_round_ge_id`\n- Lemma: `pred_round_le_id`\n- Theorem: `round_N_le_midp`\n- Theorem: `round_N_ge_midp`\n- Lemma: `round_N_ge_ge_midp`\n- Lemma: `round_N_le_le_midp`\n- Lemma: `round_N_eq_DN`\n- Lemma: `round_N_eq_DN_pt`\n- Lemma: `round_N_eq_UP`\n- Lemma: `round_N_eq_UP_pt`\n- Lemma: `round_N_plus_ulp_ge`\n- Lemma: `round_N_eq_ties`\n\n### Lean Declarations\n- theorem: `ulp_neq_0`\n- theorem: `ulp_opp`\n- theorem: `ulp_abs`\n- theorem: `ulp_ge_0`\n- theorem: `ulp_le_id`\n- theorem: `ulp_le_abs`\n- theorem: `ulp_bpow`\n- theorem: `generic_format_ulp_0`\n- theorem: `generic_format_bpow_ge_ulp_0`\n\n### Mapping (Coq → Lean)\n- `Z_le_dec_aux` → (no match)\n- `negligible_exp_spec` → (no match)\n- `negligible_exp_spec'` → (no match)\n- `fexp_negligible_exp_eq` → (no match)\n- `ulp_neq_0` → `ulp_neq_0` (exact-name)\n- `ulp_opp` → `ulp_opp` (exact-name)\n- `ulp_abs` → `ulp_abs` (exact-name)\n- `ulp_ge_0` → `ulp_ge_0` (exact-name)\n- `ulp_le_id` → `ulp_le_id` (exact-name)\n- `ulp_le_abs` → `ulp_le_abs` (exact-name)\n- `round_UP_DN_ulp` → (no match)\n- `ulp_canonical` → (no match)\n- `ulp_bpow` → `ulp_bpow` (exact-name)\n- `generic_format_ulp_0` → `generic_format_ulp_0` (exact-name)\n- `generic_format_bpow_ge_ulp_0` → `generic_format_bpow_ge_ulp_0` (exact-name)\n- `generic_format_ulp` → `generic_format_ulp_0` (substring-name)\n- `not_FTZ_generic_format_ulp` → (no match)\n- `ulp_ge_ulp_0` → (no match)\n- `not_FTZ_ulp_ge_ulp_0` → (no match)\n- `ulp_le_pos` → (no match)\n- `ulp_le` → `ulp_le_id` (substring-name)\n- `eq_0_round_0_negligible_exp` → (no match)\n- `pred_eq_pos` → (no match)\n- `succ_eq_pos` → (no match)\n- `succ_opp` → (no match)\n- `pred_opp` → (no match)\n- `pred_bpow` → (no match)\n- `id_m_ulp_ge_bpow` → (no match)\n- `id_p_ulp_le_bpow` → (no match)\n- `generic_format_pred_aux1` → (no match)\n- `generic_format_pred_aux2` → (no match)\n- `generic_format_succ_aux1` → (no match)\n- `generic_format_pred_pos` → (no match)\n- `generic_format_succ` → (no match)\n- `generic_format_pred` → (no match)\n- `pred_pos_lt_id` → (no match)\n- `succ_gt_id` → (no match)\n- `pred_lt_id` → (no match)\n- `succ_ge_id` → (no match)\n- `pred_le_id` → (no match)\n- `pred_pos_ge_0` → (no match)\n- `pred_ge_0` → (no match)\n- `pred_pos_plus_ulp_aux1` → (no match)\n- `pred_pos_plus_ulp_aux2` → (no match)\n- `pred_pos_plus_ulp_aux3` → (no match)\n- `pred_pos_plus_ulp` → (no match)\n- `pred_plus_ulp` → (no match)\n- `mag_plus_eps` → (no match)\n- `round_DN_plus_eps_pos` → (no match)\n- `round_UP_plus_eps_pos` → (no match)\n- `round_UP_pred_plus_eps_pos` → (no match)\n- `round_DN_minus_eps_pos` → (no match)\n- `round_DN_plus_eps` → (no match)\n- `round_UP_plus_eps` → (no match)\n- `le_pred_pos_lt` → (no match)\n- `succ_le_lt_aux` → (no match)\n- `succ_le_lt` → (no match)\n- `pred_ge_gt` → (no match)\n- `succ_gt_ge` → (no match)\n- `pred_lt_le` → (no match)\n- `succ_pred_pos` → (no match)\n- `pred_ulp_0` → (no match)\n- `succ_0` → (no match)\n- `pred_0` → (no match)\n- `pred_succ_pos` → (no match)\n- `succ_pred` → (no match)\n- `pred_succ` → (no match)\n- `round_UP_pred_plus_eps` → (no match)\n- `round_DN_minus_eps` → (no match)\n- `error_lt_ulp` → (no match)\n- `error_le_ulp` → (no match)\n- `error_le_half_ulp` → (no match)\n- `ulp_DN` → (no match)\n- `round_neq_0_negligible_exp` → (no match)\n- `error_lt_ulp_round` → (no match)\n- `error_le_ulp_round` → (no match)\n- `error_le_half_ulp_round` → (no match)\n- `pred_le` → (no match)\n- `succ_le` → (no match)\n- `pred_le_inv` → (no match)\n- `succ_le_inv` → (no match)\n- `pred_lt` → (no match)\n- `succ_lt` → (no match)\n- `succ_le_plus_ulp` → (no match)\n- `generic_format_plus_ulp` → (no match)\n- `round_DN_ge_UP_gt` → (no match)\n- `round_UP_le_DN_lt` → (no match)\n- `pred_UP_le_DN` → (no match)\n- `UP_le_succ_DN` → (no match)\n- `pred_UP_eq_DN` → (no match)\n- `succ_DN_eq_UP` → (no match)\n- `round_DN_eq` → (no match)\n- `round_UP_eq` → (no match)\n- `ulp_ulp_0` → (no match)\n- `ulp_succ_pos` → (no match)\n- `ulp_pred_pos` → (no match)\n- `ulp_round_pos` → (no match)\n- `ulp_round` → (no match)\n- `succ_round_ge_id` → (no match)\n- `pred_round_le_id` → (no match)\n- `round_N_le_midp` → (no match)\n- `round_N_ge_midp` → (no match)\n- `round_N_ge_ge_midp` → (no match)\n- `round_N_le_le_midp` → (no match)\n- `round_N_eq_DN` → (no match)\n- `round_N_eq_DN_pt` → (no match)\n- `round_N_eq_UP` → (no match)\n- `round_N_eq_UP_pt` → (no match)\n- `round_N_plus_ulp_ge` → (no match)\n- `round_N_eq_ties` → (no match)\n\n## File: Zaux.v\n- Coq file: Zaux.v\n- Lean file(s): Zaux.lean\n\n### Coq Declarations\n- Theorem: `Zopp_le_cancel`\n- Theorem: `Zgt_not_eq`\n- Lemma: `eqbool_irrelevance`\n- Theorem: `Zeven_ex`\n- Theorem: `Zpower_plus`\n- Theorem: `Zpower_Zpower_nat`\n- Theorem: `Zpower_nat_S`\n- Theorem: `Zpower_pos_gt_0`\n- Theorem: `Zeven_Zpower_odd`\n- Theorem: `radix_val_inj`\n- Theorem: `radix_gt_0`\n- Theorem: `radix_gt_1`\n- Theorem: `Zpower_gt_1`\n- Theorem: `Zpower_gt_0`\n- Theorem: `Zpower_ge_0`\n- Theorem: `Zpower_le`\n- Theorem: `Zpower_lt`\n- Theorem: `Zpower_lt_Zpower`\n- Theorem: `Zpower_gt_id`\n- Theorem: `Zmod_mod_mult`\n- Theorem: `ZOmod_eq`\n- Theorem: `ZOmod_mod_mult`\n- Theorem: `Zdiv_mod_mult`\n- Theorem: `ZOdiv_mod_mult`\n- Theorem: `ZOdiv_small_abs`\n- Theorem: `ZOmod_small_abs`\n- Theorem: `ZOdiv_plus`\n- Theorem: `Zsame_sign_trans`\n- Theorem: `Zsame_sign_trans_weak`\n- Theorem: `Zsame_sign_imp`\n- Theorem: `Zsame_sign_odiv`\n- Theorem: `Zeq_bool_spec`\n- Theorem: `Zeq_bool_true`\n- Theorem: `Zeq_bool_false`\n- Theorem: `Zeq_bool_diag`\n- Theorem: `Zeq_bool_opp`\n- Theorem: `Zeq_bool_opp'`\n- Theorem: `Zle_bool_spec`\n- Theorem: `Zle_bool_true`\n- Theorem: `Zle_bool_false`\n- Theorem: `Zle_bool_opp_l`\n- Theorem: `Zle_bool_opp`\n- Theorem: `Zle_bool_opp_r`\n- Theorem: `Zlt_bool_spec`\n- Theorem: `Zlt_bool_true`\n- Theorem: `Zlt_bool_false`\n- Theorem: `negb_Zle_bool`\n- Theorem: `negb_Zlt_bool`\n- Theorem: `Zlt_bool_opp_l`\n- Theorem: `Zlt_bool_opp_r`\n- Theorem: `Zlt_bool_opp`\n- Theorem: `Zcompare_spec`\n- Theorem: `Zcompare_Lt`\n- Theorem: `Zcompare_Eq`\n- Theorem: `Zcompare_Gt`\n- Theorem: `cond_Zopp_0`\n- Theorem: `cond_Zopp_negb`\n- Theorem: `abs_cond_Zopp`\n- Theorem: `cond_Zopp_Zlt_bool`\n- Theorem: `Zeq_bool_cond_Zopp`\n- Theorem: `Zfast_pow_pos_correct`\n- Lemma: `Zdiv_eucl_unique`\n- Lemma: `Zpos_div_eucl_aux1_correct`\n- Lemma: `Zpos_div_eucl_aux_correct`\n- Theorem: `Zfast_div_eucl_correct`\n- Lemma: `iter_nat_plus`\n- Lemma: `iter_nat_S`\n- Lemma: `iter_pos_nat`\n\n### Lean Declarations\n- theorem: `Zopp_le_cancel_spec`\n- theorem: `Zgt_not_eq_spec`\n- theorem: `eqbool_irrelevance_spec`\n- theorem: `Zeven_ex_spec`\n- theorem: `Zpower_plus_spec`\n- theorem: `Zpower_Zpower_nat_spec`\n- theorem: `Zpower_nat_S_spec`\n- theorem: `Zmod_mod_mult_spec`\n- theorem: `ZOmod_eq_spec`\n- theorem: `Zdiv_mod_mult_spec`\n- theorem: `ZOmod_mod_mult_spec`\n- theorem: `ZOdiv_plus_spec`\n- theorem: `Zeq_bool_spec`\n- theorem: `Zle_bool_spec`\n- theorem: `Zlt_bool_spec`\n- theorem: `Zeq_bool_true_spec`\n- theorem: `Zeq_bool_false_spec`\n- theorem: `Zeq_bool_diag_spec`\n- theorem: `Zeq_bool_opp_spec`\n- theorem: `Zeq_bool_opp`\n- theorem: `Zle_bool_true_spec`\n- theorem: `Zle_bool_false_spec`\n- theorem: `Zle_bool_opp_l_spec`\n- theorem: `Zle_bool_opp_spec`\n- theorem: `Zle_bool_opp_r_spec`\n- theorem: `negb_Zle_bool_spec`\n- theorem: `negb_Zlt_bool_spec`\n- theorem: `Zlt_bool_true_spec`\n- theorem: `Zlt_bool_false_spec`\n- theorem: `Zlt_bool_opp_l_spec`\n- theorem: `Zlt_bool_opp_r_spec`\n- theorem: `Zlt_bool_opp_spec`\n- theorem: `Zcompare_spec`\n- theorem: `Zcompare_Lt_spec`\n- theorem: `Zcompare_Eq_spec`\n- theorem: `Zcompare_Gt_spec`\n- theorem: `cond_Zopp_spec`\n- theorem: `cond_Zopp_0_spec`\n- theorem: `cond_Zopp_negb_spec`\n- theorem: `abs_cond_Zopp_spec`\n- theorem: `cond_Zopp_Zlt_bool_spec`\n- theorem: `Zeq_bool_cond_Zopp_spec`\n- theorem: `Zfast_pow_pos_spec`\n- theorem: `Zfast_div_eucl_spec`\n- theorem: `iter_nat_spec`\n- theorem: `iter_nat_S_spec`\n- theorem: `iter_nat_plus_spec`\n- theorem: `iter_pos_nat_spec`\n\n### Mapping (Coq → Lean)\n- `Zopp_le_cancel` → `Zopp_le_cancel_spec` (substring-name)\n- `Zgt_not_eq` → `Zgt_not_eq_spec` (substring-name)\n- `eqbool_irrelevance` → `eqbool_irrelevance_spec` (substring-name)\n- `Zeven_ex` → `Zeven_ex_spec` (substring-name)\n- `Zpower_plus` → `Zpower_plus_spec` (substring-name)\n- `Zpower_Zpower_nat` → `Zpower_Zpower_nat_spec` (substring-name)\n- `Zpower_nat_S` → `Zpower_Zpower_nat_spec` (substring-name)\n- `Zpower_pos_gt_0` → (no match)\n- `Zeven_Zpower_odd` → (no match)\n- `radix_val_inj` → (no match)\n- `radix_gt_0` → (no match)\n- `radix_gt_1` → (no match)\n- `Zpower_gt_1` → (no match)\n- `Zpower_gt_0` → (no match)\n- `Zpower_ge_0` → (no match)\n- `Zpower_le` → (no match)\n- `Zpower_lt` → (no match)\n- `Zpower_lt_Zpower` → (no match)\n- `Zpower_gt_id` → (no match)\n- `Zmod_mod_mult` → `Zmod_mod_mult_spec` (substring-name)\n- `ZOmod_eq` → `ZOmod_eq_spec` (substring-name)\n- `ZOmod_mod_mult` → `ZOmod_mod_mult_spec` (substring-name)\n- `Zdiv_mod_mult` → `Zdiv_mod_mult_spec` (substring-name)\n- `ZOdiv_mod_mult` → (no match)\n- `ZOdiv_small_abs` → (no match)\n- `ZOmod_small_abs` → (no match)\n- `ZOdiv_plus` → `ZOdiv_plus_spec` (substring-name)\n- `Zsame_sign_trans` → (no match)\n- `Zsame_sign_trans_weak` → (no match)\n- `Zsame_sign_imp` → (no match)\n- `Zsame_sign_odiv` → (no match)\n- `Zeq_bool_spec` → `Zeq_bool_spec` (exact-name)\n- `Zeq_bool_true` → `Zeq_bool_true_spec` (substring-name)\n- `Zeq_bool_false` → `Zeq_bool_false_spec` (substring-name)\n- `Zeq_bool_diag` → `Zeq_bool_diag_spec` (substring-name)\n- `Zeq_bool_opp` → `Zeq_bool_opp` (exact-name)\n- `Zeq_bool_opp'` → `Zeq_bool_opp` (normalized-name)\n- `Zle_bool_spec` → `Zle_bool_spec` (exact-name)\n- `Zle_bool_true` → `Zle_bool_true_spec` (substring-name)\n- `Zle_bool_false` → `Zle_bool_false_spec` (substring-name)\n- `Zle_bool_opp_l` → `Zle_bool_opp_l_spec` (substring-name)\n- `Zle_bool_opp` → `Zle_bool_opp_l_spec` (substring-name)\n- `Zle_bool_opp_r` → `Zle_bool_opp_r_spec` (substring-name)\n- `Zlt_bool_spec` → `Zlt_bool_spec` (exact-name)\n- `Zlt_bool_true` → `Zlt_bool_true_spec` (substring-name)\n- `Zlt_bool_false` → `Zlt_bool_false_spec` (substring-name)\n- `negb_Zle_bool` → `negb_Zle_bool_spec` (substring-name)\n- `negb_Zlt_bool` → `negb_Zlt_bool_spec` (substring-name)\n- `Zlt_bool_opp_l` → `Zlt_bool_opp_l_spec` (substring-name)\n- `Zlt_bool_opp_r` → `Zlt_bool_opp_r_spec` (substring-name)\n- `Zlt_bool_opp` → `Zlt_bool_opp_l_spec` (substring-name)\n- `Zcompare_spec` → `Zcompare_spec` (exact-name)\n- `Zcompare_Lt` → `Zcompare_Lt_spec` (substring-name)\n- `Zcompare_Eq` → `Zcompare_Eq_spec` (substring-name)\n- `Zcompare_Gt` → `Zcompare_Gt_spec` (substring-name)\n- `cond_Zopp_0` → `cond_Zopp_0_spec` (substring-name)\n- `cond_Zopp_negb` → `cond_Zopp_negb_spec` (substring-name)\n- `abs_cond_Zopp` → `abs_cond_Zopp_spec` (substring-name)\n- `cond_Zopp_Zlt_bool` → `cond_Zopp_Zlt_bool_spec` (substring-name)\n- `Zeq_bool_cond_Zopp` → `Zeq_bool_cond_Zopp_spec` (substring-name)\n- `Zfast_pow_pos_correct` → (no match)\n- `Zdiv_eucl_unique` → (no match)\n- `Zpos_div_eucl_aux1_correct` → (no match)\n- `Zpos_div_eucl_aux_correct` → (no match)\n- `Zfast_div_eucl_correct` → (no match)\n- `iter_nat_plus` → `iter_nat_plus_spec` (substring-name)\n- `iter_nat_S` → `iter_nat_spec` (substring-name)\n- `iter_pos_nat` → `iter_pos_nat_spec` (substring-name)\n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "# Core Theorems Comparison: Coq vs Lean (FloatSpec)\n\nThis document lists all theorem-like declarations in flocq/src/Core (*.v) and FloatSpec/src/Core (*.lean), grouped by file, and indicates for each Coq declaration whether a corresponding Lean theorem/lemma exists. Matching is based on exact/normalized/substr name matches and, when available, explicit Coq references in Lean comments.\n\n## File: Core.v\n- Coq file: Core.v\n- Lean file(s): (none)\n\n### Coq Declarations\n\n### Lean Declarations\n\n### Mapping (Coq → Lean)\n\n## File: Defs.v\n- Coq file: Defs.v\n- Lean file(s): Defs.lean\n\n### Coq Declarations\n\n### Lean Declarations\n- theorem: `F2R_spec`\n- theorem: `Fnum_extract_spec`\n- theorem: `Fexp_extract_spec`\n- theorem: `make_float_spec`\n- theorem: `FlocqFloat_eq_spec`\n- theorem: `F2R_zero_spec`\n- theorem: `F2R_add_same_exp_spec`\n\n### Mapping (Coq → Lean)\n\n## File: Digits.v\n- Coq file: Digits.v\n- Lean file(s): Digits.lean\n\n### Coq Declarations\n- Theorem: `digits2_Pnat_correct`\n- Theorem: `Zdigit_lt`\n- Theorem: `Zdigit_0`\n- Theorem: `Zdigit_opp`\n- Theorem: `Zdigit_ge_Zpower_pos`\n- Theorem: `Zdigit_ge_Zpower`\n- Theorem: `Zdigit_not_0_pos`\n- Theorem: `Zdigit_not_0`\n- Theorem: `Zdigit_mul_pow`\n- Theorem: `Zdigit_div_pow`\n- Theorem: `Zdigit_mod_pow`\n- Theorem: `Zdigit_mod_pow_out`\n- Theorem: `Zsum_digit_digit`\n- Theorem: `Zdigit_ext`\n- Theorem: `ZOmod_plus_pow_digit`\n- Theorem: `ZOdiv_plus_pow_digit`\n- Theorem: `Zdigit_plus`\n- Theorem: `Zdigit_scale`\n- Theorem: `Zscale_0`\n- Theorem: `Zsame_sign_scale`\n- Theorem: `Zscale_mul_pow`\n- Theorem: `Zscale_scale`\n- Theorem: `Zdigit_slice`\n- Theorem: `Zdigit_slice_out`\n- Theorem: `Zslice_0`\n- Theorem: `Zsame_sign_slice`\n- Theorem: `Zslice_slice`\n- Theorem: `Zslice_mul_pow`\n- Theorem: `Zslice_div_pow`\n- Theorem: `Zslice_scale`\n- Theorem: `Zslice_div_pow_scale`\n- Theorem: `Zplus_slice`\n- Theorem: `Zdigits_correct`\n- Theorem: `Zdigits_unique`\n- Theorem: `Zdigits_abs`\n- Theorem: `Zdigits_opp`\n- Theorem: `Zdigits_cond_Zopp`\n- Theorem: `Zdigits_gt_0`\n- Theorem: `Zdigits_ge_0`\n- Theorem: `Zdigit_out`\n- Theorem: `Zdigit_digits`\n- Theorem: `Zdigits_slice`\n- Theorem: `Zdigits_mult_Zpower`\n- Theorem: `Zdigits_Zpower`\n- Theorem: `Zdigits_le`\n- Theorem: `lt_Zdigits`\n- Theorem: `Zpower_le_Zdigits`\n- Theorem: `Zdigits_le_Zpower`\n- Theorem: `Zpower_gt_Zdigits`\n- Theorem: `Zdigits_gt_Zpower`\n- Theorem: `Zdigits_mult_strong`\n- Theorem: `Zdigits_mult`\n- Theorem: `Zdigits_mult_ge`\n- Theorem: `Zdigits_div_Zpower`\n- Theorem: `Zdigits_succ_le`\n- Theorem: `Z_of_nat_S_digits2_Pnat`\n- Theorem: `Zpos_digits2_pos`\n- Lemma: `Zdigits2_Zdigits`\n\n### Lean Declarations\n- lemma: `bits_pos`\n- lemma: `split2`\n- lemma: `bits_succ`\n- lemma: `digits2_eq_bits`\n- lemma: `bits_bounds`\n- theorem: `digits2_Pnat_correct`\n- theorem: `Zdigit_lt`\n- theorem: `Zdigit_0`\n- theorem: `Zdigit_opp`\n- theorem: `Zdigit_ge_Zpower_pos`\n- theorem: `Zdigit_ge_Zpower`\n- theorem: `Zdigit_not_0_pos`\n- theorem: `Zdigit_not_0`\n- theorem: `Zdigit_mul_pow`\n- theorem: `Zdigit_div_pow`\n- theorem: `Zdigit_mod_pow`\n- theorem: `Zdigit_mod_pow_out`\n- theorem: `Zsum_digit_digit`\n- theorem: `ZOmod_plus_pow_digit`\n- theorem: `Zdigit_ext_nonneg`\n- theorem: `ZOdiv_plus_pow_digit`\n- theorem: `Zdigit_plus_nonneg`\n- theorem: `Zdigit_scale_point`\n- theorem: `Zscale_0`\n- theorem: `Zsame_sign_scale`\n- theorem: `Zscale_mul_pow`\n- theorem: `Zscale_scale`\n- theorem: `Zdigit_slice`\n- theorem: `Zdigit_slice_out`\n- theorem: `Zslice_0`\n- theorem: `Zsame_sign_slice`\n- theorem: `Zslice_slice`\n- theorem: `Zslice_mul_pow`\n- theorem: `Zslice_div_pow`\n- theorem: `Zslice_scale`\n- theorem: `Zslice_div_pow_scale_nonnegKp`\n- theorem: `Zplus_slice`\n- theorem: `Zdigits_correct`\n- theorem: `Zdigits_unique`\n- theorem: `Zdigits_abs`\n- theorem: `Zdigits_opp`\n- theorem: `Zdigits_cond_Zopp`\n- theorem: `Zdigits_ge_0`\n- theorem: `Zdigits_gt_0`\n- theorem: `Zdigit_out`\n- theorem: `Zdigit_digits`\n- theorem: `lt_Zdigits`\n- theorem: `Zdigits_le_Zpower`\n- theorem: `Zdigits_slice`\n- theorem: `Zdigits_mult_Zpower`\n- theorem: `Zdigits_Zpower`\n- theorem: `Zdigits_le`\n- theorem: `Zpower_le_Zdigits`\n- theorem: `Zdigits_le_Zdigits`\n- theorem: `Zpower_gt_Zdigits`\n- theorem: `Zdigits_gt_Zpower`\n- theorem: `Zdigits_mult_strong`\n- theorem: `Zdigits_mult`\n- theorem: `Zdigits_mult_ge`\n- theorem: `Zdigits_div_Zpower`\n- theorem: `Zdigits_succ_le`\n- theorem: `Z_of_nat_S_digits2_Pnat`\n- theorem: `Zpos_digits2_pos`\n- theorem: `Zdigits2_Zdigits`\n- lemma: `beta_pos`\n- lemma: `pow_pos_int`\n- lemma: `Zdigit_at_zero`\n- lemma: `Zdigit_eval_nonneg`\n- lemma: `tdiv_zero_iff_lt_of_nonneg_pos`\n- lemma: `tdiv_pow_succ_assoc`\n- lemma: `exists_nonzero_digit`\n- lemma: `tdiv_mod_pow_eq`\n- lemma: `pow_mono_int`\n- lemma: `pow_strict_mono_int`\n- lemma: `wp_mono_pure`\n- lemma: `zscale_div_exact`\n- lemma: `div_mul_pow_eq_div_sub`\n- lemma: `pow_base_mono`\n- lemma: `abs_lt_beta_pow_succ_natAbs`\n- theorem: `Zdigits_aux_bounds`\n- lemma: `natAbs_sub_one_gt_of_nonpos`\n- lemma: `pow_succ_ge`\n- lemma: `pow_le_pow_exponent`\n- lemma: `natAbs_sub_one_eq_add_one_of_nonpos`\n- lemma: `Zdigits_aux_abs_eq`\n- lemma: `Zdigits_pos_aux`\n- lemma: `tdiv_lower_bound`\n- lemma: `tdiv_upper_bound`\n- lemma: `digit_nonzero_at_boundary`\n- lemma: `Zdigits_implies_nonzero_digit`\n- lemma: `digit_sum_bound`\n- lemma: `highest_nonzero_digit_bound`\n- lemma: `Zdigits_nonneg`\n- lemma: `product_upper_bound`\n- lemma: `pow_add_split`\n- lemma: `Zdigits_run_eq`\n- lemma: `Zdigits_sum_product_bound`\n\n### Mapping (Coq → Lean)\n- `digits2_Pnat_correct` → `digits2_Pnat_correct` (exact-name)\n- `Zdigit_lt` → `Zdigit_lt` (exact-name)\n- `Zdigit_0` → `Zdigit_0` (exact-name)\n- `Zdigit_opp` → `Zdigit_opp` (exact-name)\n- `Zdigit_ge_Zpower_pos` → `Zdigit_ge_Zpower_pos` (exact-name)\n- `Zdigit_ge_Zpower` → `Zdigit_ge_Zpower` (exact-name)\n- `Zdigit_not_0_pos` → `Zdigit_not_0_pos` (exact-name)\n- `Zdigit_not_0` → `Zdigit_not_0` (exact-name)\n- `Zdigit_mul_pow` → `Zdigit_mul_pow` (exact-name)\n- `Zdigit_div_pow` → `Zdigit_div_pow` (exact-name)\n- `Zdigit_mod_pow` → `Zdigit_mod_pow` (exact-name)\n- `Zdigit_mod_pow_out` → `Zdigit_mod_pow_out` (exact-name)\n- `Zsum_digit_digit` → `Zsum_digit_digit` (exact-name)\n- `Zdigit_ext` → `Zdigit_ext_nonneg` (substring-name)\n- `ZOmod_plus_pow_digit` → `ZOmod_plus_pow_digit` (exact-name)\n- `ZOdiv_plus_pow_digit` → `ZOdiv_plus_pow_digit` (exact-name)\n- `Zdigit_plus` → `Zdigit_plus_nonneg` (substring-name)\n- `Zdigit_scale` → `Zdigit_scale_point` (substring-name)\n- `Zscale_0` → `Zscale_0` (exact-name)\n- `Zsame_sign_scale` → `Zsame_sign_scale` (exact-name)\n- `Zscale_mul_pow` → `Zscale_mul_pow` (exact-name)\n- `Zscale_scale` → `Zscale_scale` (exact-name)\n- `Zdigit_slice` → `Zdigit_slice` (exact-name)\n- `Zdigit_slice_out` → `Zdigit_slice_out` (exact-name)\n- `Zslice_0` → `Zslice_0` (exact-name)\n- `Zsame_sign_slice` → `Zsame_sign_slice` (exact-name)\n- `Zslice_slice` → `Zslice_slice` (exact-name)\n- `Zslice_mul_pow` → `Zslice_mul_pow` (exact-name)\n- `Zslice_div_pow` → `Zslice_div_pow` (exact-name)\n- `Zslice_scale` → `Zslice_scale` (exact-name)\n- `Zslice_div_pow_scale` → `Zslice_div_pow` (substring-name)\n- `Zplus_slice` → `Zplus_slice` (exact-name)\n- `Zdigits_correct` → `Zdigits_correct` (exact-name)\n- `Zdigits_unique` → `Zdigits_unique` (exact-name)\n- `Zdigits_abs` → `Zdigits_abs` (exact-name)\n- `Zdigits_opp` → `Zdigits_opp` (exact-name)\n- `Zdigits_cond_Zopp` → `Zdigits_cond_Zopp` (exact-name)\n- `Zdigits_gt_0` → `Zdigits_gt_0` (exact-name)\n- `Zdigits_ge_0` → `Zdigits_ge_0` (exact-name)\n- `Zdigit_out` → `Zdigit_out` (exact-name)\n- `Zdigit_digits` → `Zdigit_digits` (exact-name)\n- `Zdigits_slice` → `Zdigits_slice` (exact-name)\n- `Zdigits_mult_Zpower` → `Zdigits_mult_Zpower` (exact-name)\n- `Zdigits_Zpower` → `Zdigits_Zpower` (exact-name)\n- `Zdigits_le` → `Zdigits_le` (exact-name)\n- `lt_Zdigits` → `lt_Zdigits` (exact-name)\n- `Zpower_le_Zdigits` → `Zpower_le_Zdigits` (exact-name)\n- `Zdigits_le_Zpower` → `Zdigits_le_Zpower` (exact-name)\n- `Zpower_gt_Zdigits` → `Zpower_gt_Zdigits` (exact-name)\n- `Zdigits_gt_Zpower` → `Zdigits_gt_Zpower` (exact-name)\n- `Zdigits_mult_strong` → `Zdigits_mult_strong` (exact-name)\n- `Zdigits_mult` → `Zdigits_mult` (exact-name)\n- `Zdigits_mult_ge` → `Zdigits_mult_ge` (exact-name)\n- `Zdigits_div_Zpower` → `Zdigits_div_Zpower` (exact-name)\n- `Zdigits_succ_le` → `Zdigits_succ_le` (exact-name)\n- `Z_of_nat_S_digits2_Pnat` → `Z_of_nat_S_digits2_Pnat` (exact-name)\n- `Zpos_digits2_pos` → `Zpos_digits2_pos` (exact-name)\n- `Zdigits2_Zdigits` → `Zdigits2_Zdigits` (exact-name)\n\n## File: FIX.v\n- Coq file: FIX.v\n- Lean file(s): FIX.lean\n\n### Coq Declarations\n- Theorem: `generic_format_FIX`\n- Theorem: `FIX_format_generic`\n- Theorem: `FIX_format_satisfies_any`\n- Theorem: `ulp_FIX`\n- Theorem: `round_FIX_IZR`\n\n### Lean Declarations\n- theorem: `FIX_exp_spec`\n- theorem: `FIX_format_spec`\n- theorem: `FIX_exp_correct_spec`\n- theorem: `FIX_format_0_spec`\n- theorem: `FIX_format_opp_spec`\n\n### Mapping (Coq → Lean)\n- `generic_format_FIX` → (no match)\n- `FIX_format_generic` → (no match)\n- `FIX_format_satisfies_any` → (no match)\n- `ulp_FIX` → (no match)\n- `ulp_FIX` → `ulp_FIX` (exact-name)\n- `round_FIX_IZR` → (no match)\n - `round_FIX_IZR` → `round_FIX_IZR` (exact-name)\n\n## File: FLT.v\n- Coq file: FLT.v\n- Lean file(s): FLT.lean\n\n### Coq Declarations\n- Theorem: `generic_format_FLT`\n- Theorem: `FLT_format_generic`\n- Theorem: `generic_format_FLT_bpow`\n- Theorem: `FLT_format_bpow`\n- Theorem: `FLT_format_satisfies_any`\n- Theorem: `cexp_FLT_FLX`\n- Theorem: `generic_format_FLT_FLX`\n- Theorem: `generic_format_FLX_FLT`\n- Theorem: `round_FLT_FLX`\n- Theorem: `cexp_FLT_FIX`\n- Theorem: `generic_format_FIX_FLT`\n- Theorem: `generic_format_FLT_FIX`\n- Lemma: `negligible_exp_FLT`\n- Theorem: `generic_format_FLT_1`\n- Theorem: `ulp_FLT_0`\n- Theorem: `ulp_FLT_small`\n- Theorem: `ulp_FLT_le`\n- Theorem: `ulp_FLT_gt`\n- Lemma: `ulp_FLT_exact_shift`\n- Lemma: `succ_FLT_exact_shift_pos`\n- Lemma: `succ_FLT_exact_shift`\n- Lemma: `pred_FLT_exact_shift`\n- Theorem: `ulp_FLT_pred_pos`\n\n### Lean Declarations\n- theorem: `FLT_exp_spec`\n- theorem: `FLT_format_spec`\n- theorem: `FLT_exp_correct_spec`\n- theorem: `FLT_format_0_spec`\n- theorem: `FLT_format_opp_spec`\n- theorem: `FLT_format_abs_spec`\n- theorem: `FLT_exp_FLX_spec`\n\n### Mapping (Coq → Lean)\n - `generic_format_FLT` → `generic_format_FLT` (exact-name)\n - `FLT_format_generic` → `FLT_format_generic` (exact-name)\n- `generic_format_FLT_bpow` → (no match)\n- `FLT_format_bpow` → (no match)\n - `FLT_format_satisfies_any` → `FLT_format_satisfies_any` (exact-name)\n- `cexp_FLT_FLX` → (no match)\n - `cexp_FLT_FLX` → `cexp_FLT_FLX` (exact-name)\n- `generic_format_FLT_FLX` → (no match)\n- `generic_format_FLX_FLT` → `generic_format_FLX_FLT` (exact-name)\n- `round_FLT_FLX` → `round_FLT_FLX` (exact-name)\n - `cexp_FLT_FIX` → `cexp_FLT_FIX` (exact-name)\n- `generic_format_FIX_FLT` → (no match)\n- `generic_format_FLT_FIX` → (no match)\n- `negligible_exp_FLT` → (no match)\n- `generic_format_FLT_1` → `generic_format_FLT_1` (exact-name)\n - `ulp_FLT_0` → `ulp_FLT_0` (exact-name)\n - `ulp_FLT_small` → `ulp_FLT_small` (exact-name)\n- `ulp_FLT_le` → (no match)\n- `ulp_FLT_gt` → (no match)\n- `ulp_FLT_exact_shift` → (no match)\n- `succ_FLT_exact_shift_pos` → (no match)\n- `succ_FLT_exact_shift` → (no match)\n- `pred_FLT_exact_shift` → (no match)\n- `ulp_FLT_pred_pos` → (no match)\n\n## File: FLX.v\n- Coq file: FLX.v\n- Lean file(s): FLX.lean\n\n### Coq Declarations\n- Theorem: `FIX_format_FLX`\n- Theorem: `FLX_format_generic`\n- Theorem: `generic_format_FLX`\n- Theorem: `FLX_format_satisfies_any`\n- Theorem: `FLX_format_FIX`\n- Theorem: `generic_format_FLXN`\n- Theorem: `FLXN_format_generic`\n- Theorem: `FLXN_format_satisfies_any`\n- Lemma: `negligible_exp_FLX`\n- Theorem: `generic_format_FLX_1`\n- Theorem: `ulp_FLX_0`\n- Lemma: `ulp_FLX_1`\n- Lemma: `succ_FLX_1`\n- Theorem: `eq_0_round_0_FLX`\n- Theorem: `gt_0_round_gt_0_FLX`\n- Theorem: `ulp_FLX_le`\n- Theorem: `ulp_FLX_ge`\n- Lemma: `ulp_FLX_exact_shift`\n- Lemma: `succ_FLX_exact_shift`\n- Lemma: `pred_FLX_exact_shift`\n\n### Lean Declarations\n- theorem: `FLX_exp_spec`\n- theorem: `FLX_format_spec`\n- theorem: `FLX_exp_correct_spec`\n- theorem: `FLX_format_0_spec`\n- theorem: `FLX_format_opp_spec`\n- theorem: `FLX_format_abs_spec`\n- theorem: `ulp_FLX_1`\n\n### Mapping (Coq → Lean)\n- `FIX_format_FLX` → (no match)\n - `FLX_format_generic` → `FLX_format_generic` (exact-name)\n- `generic_format_FLX` → (no match)\n- `FLX_format_satisfies_any` → `FLX_format_satisfies_any` (exact-name)\n- `FLX_format_FIX` → (no match)\n- `generic_format_FLXN` → (no match)\n- `FLXN_format_generic` → (no match)\n- `FLXN_format_satisfies_any` → (no match)\n- `negligible_exp_FLX` → (no match)\n- `generic_format_FLX_1` → `generic_format_FLX_1` (exact-name)\n- `ulp_FLX_0` → `ulp_FLX_0` (exact-name)\n- `ulp_FLX_1` → `ulp_FLX_1` (exact-name)\n- `succ_FLX_1` → (no match)\n- `eq_0_round_0_FLX` → (no match)\n- `gt_0_round_gt_0_FLX` → (no match)\n- `ulp_FLX_le` → `ulp_FLX_le` (exact-name)\n- `ulp_FLX_ge` → (no match)\n - `ulp_FLX_ge` → `ulp_FLX_ge` (exact-name)\n- `ulp_FLX_exact_shift` → (no match)\n - `ulp_FLX_exact_shift` → `ulp_FLX_exact_shift` (exact-name)\n- `succ_FLX_exact_shift` → (no match)\n- `pred_FLX_exact_shift` → (no match)\n\n## File: FTZ.v\n- Coq file: FTZ.v\n- Lean file(s): FTZ.lean\n\n### Coq Declarations\n- Theorem: `FLXN_format_FTZ`\n- Theorem: `generic_format_FTZ`\n- Theorem: `FTZ_format_generic`\n- Theorem: `FTZ_format_satisfies_any`\n- Theorem: `FTZ_format_FLXN`\n- Theorem: `ulp_FTZ_0`\n- Theorem: `round_FTZ_FLX`\n- Theorem: `round_FTZ_small`\n\n### Lean Declarations\n- theorem: `FTZ_exp_spec`\n- theorem: `FTZ_format_spec`\n- theorem: `FTZ_exp_correct_spec`\n- theorem: `FTZ_format_0_spec`\n- theorem: `FTZ_format_opp_spec`\n- theorem: `FTZ_format_abs_spec`\n\n### Mapping (Coq → Lean)\n- `FLXN_format_FTZ` → (no match)\n- `generic_format_FTZ` → `generic_format_FTZ` (exact-name)\n- `FTZ_format_generic` → `FTZ_format_generic` (exact-name)\n- `FTZ_format_satisfies_any` → `FTZ_format_satisfies_any` (exact-name)\n- `FTZ_format_FLXN` → (no match)\n- `ulp_FTZ_0` → `ulp_FTZ_0` (exact-name)\n- `round_FTZ_FLX` → `round_FTZ_FLX` (exact-name)\n- `round_FTZ_small` → `round_FTZ_small` (exact-name)\n\n## File: Float_prop.v\n- Coq file: Float_prop.v\n- Lean file(s): Float_prop.lean\n\n### Coq Declarations\n- Theorem: `Rcompare_F2R`\n- Theorem: `le_F2R`\n- Theorem: `F2R_le`\n- Theorem: `lt_F2R`\n- Theorem: `F2R_lt`\n- Theorem: `F2R_eq`\n- Theorem: `eq_F2R`\n- Theorem: `F2R_Zabs`\n- Theorem: `F2R_Zopp`\n- Theorem: `F2R_cond_Zopp`\n- Theorem: `F2R_0`\n- Theorem: `eq_0_F2R`\n- Theorem: `ge_0_F2R`\n- Theorem: `le_0_F2R`\n- Theorem: `gt_0_F2R`\n- Theorem: `lt_0_F2R`\n- Theorem: `F2R_ge_0`\n- Theorem: `F2R_le_0`\n- Theorem: `F2R_gt_0`\n- Theorem: `F2R_lt_0`\n- Theorem: `F2R_neq_0`\n- Lemma: `Fnum_ge_0`\n- Lemma: `Fnum_le_0`\n- Theorem: `F2R_bpow`\n- Theorem: `bpow_le_F2R`\n- Theorem: `F2R_p1_le_bpow`\n- Theorem: `bpow_le_F2R_m1`\n- Theorem: `F2R_lt_bpow`\n- Theorem: `F2R_change_exp`\n- Theorem: `F2R_prec_normalize`\n- Theorem: `mag_F2R_bounds`\n- Theorem: `mag_F2R`\n- Theorem: `Zdigits_mag`\n- Theorem: `mag_F2R_Zdigits`\n- Theorem: `mag_F2R_bounds_Zdigits`\n- Theorem: `float_distribution_pos`\n\n### Lean Declarations\n- theorem: `Rcompare_F2R`\n- theorem: `le_F2R`\n- theorem: `F2R_le`\n- theorem: `lt_F2R`\n- theorem: `F2R_lt`\n- theorem: `F2R_eq`\n- theorem: `eq_F2R`\n- theorem: `F2R_Zabs`\n- theorem: `F2R_Zopp`\n- theorem: `F2R_cond_Zopp`\n- theorem: `F2R_0`\n- theorem: `eq_0_F2R`\n- theorem: `ge_0_F2R`\n- theorem: `le_0_F2R`\n- theorem: `gt_0_F2R`\n- theorem: `lt_0_F2R`\n- theorem: `F2R_ge_0`\n- theorem: `F2R_le_0`\n- theorem: `F2R_gt_0`\n- theorem: `F2R_lt_0`\n- theorem: `F2R_neq_0`\n- theorem: `F2R_bpow`\n- theorem: `bpow_le_F2R`\n- theorem: `F2R_p1_le_bpow`\n- theorem: `bpow_le_F2R_m1`\n- theorem: `F2R_lt_bpow`\n- theorem: `F2R_change_exp`\n- theorem: `F2R_prec_normalize`\n- theorem: `mag_F2R_bounds`\n- theorem: `mag_F2R`\n- theorem: `Zdigits_mag`\n- theorem: `mag_F2R_Zdigits`\n- theorem: `mag_F2R_bounds_Zdigits`\n- theorem: `float_distribution_pos`\n\n### Mapping (Coq → Lean)\n- `Rcompare_F2R` → `Rcompare_F2R` (exact-name)\n- `le_F2R` → `le_F2R` (exact-name)\n- `F2R_le` → `F2R_le` (exact-name)\n- `lt_F2R` → `lt_F2R` (exact-name)\n- `F2R_lt` → `F2R_lt` (exact-name)\n- `F2R_eq` → `F2R_eq` (exact-name)\n- `eq_F2R` → `eq_F2R` (exact-name)\n- `F2R_Zabs` → `F2R_Zabs` (exact-name)\n- `F2R_Zopp` → `F2R_Zopp` (exact-name)\n- `F2R_cond_Zopp` → `F2R_cond_Zopp` (exact-name)\n- `F2R_0` → `F2R_0` (exact-name)\n- `eq_0_F2R` → `eq_0_F2R` (exact-name)\n- `ge_0_F2R` → `ge_0_F2R` (exact-name)\n- `le_0_F2R` → `le_0_F2R` (exact-name)\n- `gt_0_F2R` → `gt_0_F2R` (exact-name)\n- `lt_0_F2R` → `lt_0_F2R` (exact-name)\n- `F2R_ge_0` → `F2R_ge_0` (exact-name)\n- `F2R_le_0` → `F2R_le_0` (exact-name)\n- `F2R_gt_0` → `F2R_gt_0` (exact-name)\n- `F2R_lt_0` → `F2R_lt_0` (exact-name)\n- `F2R_neq_0` → `F2R_neq_0` (exact-name)\n- `Fnum_ge_0` → `Fnum_ge_0` (exact-name)\n- `Fnum_le_0` → `Fnum_le_0` (exact-name)\n- `F2R_bpow` → `F2R_bpow` (exact-name)\n- `bpow_le_F2R` → `bpow_le_F2R` (exact-name)\n- `F2R_p1_le_bpow` → `F2R_p1_le_bpow` (exact-name)\n- `bpow_le_F2R_m1` → `bpow_le_F2R_m1` (exact-name)\n- `F2R_lt_bpow` → `F2R_lt_bpow` (exact-name)\n- `F2R_change_exp` → `F2R_change_exp` (exact-name)\n- `F2R_prec_normalize` → `F2R_prec_normalize` (exact-name)\n- `mag_F2R_bounds` → `mag_F2R_bounds` (exact-name)\n- `mag_F2R` → `mag_F2R` (exact-name)\n- `Zdigits_mag` → `Zdigits_mag` (exact-name)\n- `mag_F2R_Zdigits` → `mag_F2R_Zdigits` (exact-name)\n- `mag_F2R_bounds_Zdigits` → `mag_F2R_bounds_Zdigits` (exact-name)\n- `float_distribution_pos` → `float_distribution_pos` (exact-name)\n\n## File: Generic_fmt.v\n- Coq file: Generic_fmt.v\n- Lean file(s): Generic_fmt.lean, Round_generic.lean\n\n### Coq Declarations\n- Theorem: `valid_exp_large`\n- Theorem: `valid_exp_large'`\n- Theorem: `generic_format_0`\n- Theorem: `cexp_opp`\n- Theorem: `cexp_abs`\n- Theorem: `canonical_generic_format`\n- Theorem: `generic_format_bpow`\n- Theorem: `generic_format_bpow'`\n- Theorem: `generic_format_F2R`\n- Lemma: `generic_format_F2R'`\n- Theorem: `canonical_opp`\n- Theorem: `canonical_abs`\n- Theorem: `canonical_0`\n- Theorem: `canonical_unique`\n- Theorem: `scaled_mantissa_generic`\n- Theorem: `scaled_mantissa_mult_bpow`\n- Theorem: `scaled_mantissa_0`\n- Theorem: `scaled_mantissa_opp`\n- Theorem: `scaled_mantissa_abs`\n- Theorem: `generic_format_opp`\n- Theorem: `generic_format_abs`\n- Theorem: `generic_format_abs_inv`\n- Theorem: `cexp_fexp`\n- Theorem: `cexp_fexp_pos`\n- Theorem: `mantissa_small_pos`\n- Theorem: `scaled_mantissa_lt_1`\n- Theorem: `scaled_mantissa_lt_bpow`\n- Theorem: `mag_generic_gt`\n- Lemma: `mantissa_DN_small_pos`\n- Lemma: `mantissa_UP_small_pos`\n- Theorem: `generic_format_discrete`\n- Theorem: `generic_format_canonical`\n- Theorem: `generic_format_ge_bpow`\n- Theorem: `abs_lt_bpow_prec`\n- Theorem: `generic_format_bpow_inv'`\n- Theorem: `generic_format_bpow_inv`\n- Theorem: `Zrnd_DN_or_UP`\n- Theorem: `Zrnd_ZR_or_AW`\n- Theorem: `round_bounded_large_pos`\n- Theorem: `round_bounded_small_pos`\n- Lemma: `round_le_pos`\n- Theorem: `round_generic`\n- Theorem: `round_0`\n- Theorem: `exp_small_round_0_pos`\n- Lemma: `generic_format_round_pos`\n- Theorem: `round_ext`\n- Theorem: `round_opp`\n- Theorem: `round_DN_or_UP`\n- Theorem: `round_ZR_or_AW`\n- Theorem: `round_le`\n- Theorem: `round_ge_generic`\n- Theorem: `round_le_generic`\n- Theorem: `round_abs_abs`\n- Theorem: `round_bounded_large`\n- Theorem: `exp_small_round_0`\n- Theorem: `abs_round_ge_generic`\n- Theorem: `abs_round_le_generic`\n- Theorem: `round_DN_opp`\n- Theorem: `round_UP_opp`\n- Theorem: `round_ZR_opp`\n- Theorem: `round_ZR_abs`\n- Theorem: `round_AW_opp`\n- Theorem: `round_AW_abs`\n- Theorem: `round_ZR_DN`\n- Theorem: `round_ZR_UP`\n- Theorem: `round_AW_UP`\n- Theorem: `round_AW_DN`\n- Theorem: `generic_format_round`\n- Theorem: `round_DN_pt`\n- Theorem: `generic_format_satisfies_any`\n- Theorem: `round_UP_pt`\n- Theorem: `round_ZR_pt`\n- Lemma: `round_DN_small_pos`\n- Theorem: `round_DN_UP_lt`\n- Lemma: `round_UP_small_pos`\n- Theorem: `generic_format_EM`\n- Lemma: `round_large_pos_ge_bpow`\n- Theorem: `mag_round_ZR`\n- Theorem: `mag_round`\n- Theorem: `mag_DN`\n- Theorem: `cexp_DN`\n- Theorem: `scaled_mantissa_DN`\n- Theorem: `generic_N_pt_DN_or_UP`\n- Theorem: `subnormal_exponent`\n- Lemma: `cexp_le_bpow`\n- Lemma: `cexp_ge_bpow`\n- Lemma: `lt_cexp_pos`\n- Theorem: `lt_cexp`\n- Theorem: `mag_round_ge`\n- Theorem: `cexp_round_ge`\n- Theorem: `Znearest_DN_or_UP`\n- Theorem: `Znearest_ge_floor`\n- Theorem: `Znearest_le_ceil`\n- Theorem: `Znearest_N_strict`\n- Theorem: `Znearest_half`\n- Theorem: `Znearest_imp`\n- Theorem: `round_N_pt`\n- Theorem: `round_N_middle`\n- Lemma: `round_N_small_pos`\n- Theorem: `round_NA_pt`\n- Theorem: `round_N0_pt`\n- Theorem: `Znearest_opp`\n- Theorem: `round_N_opp`\n- Lemma: `round_N0_opp`\n- Lemma: `round_N_small`\n- Theorem: `generic_inclusion_mag`\n- Theorem: `generic_inclusion_lt_ge`\n- Theorem: `generic_inclusion`\n- Theorem: `generic_inclusion_le_ge`\n- Theorem: `generic_inclusion_le`\n- Theorem: `generic_inclusion_ge`\n- Theorem: `generic_round_generic`\n- Lemma: `round_NA_opp`\n\n### Lean Declarations\n- lemma: `Ztrunc_int`\n- lemma: `zpow_ne_zero_of_pos`\n- theorem: `valid_exp_large`\n- theorem: `cexp_spec`\n- theorem: `scaled_mantissa_spec`\n- theorem: `generic_format_spec`\n- theorem: `Ztrunc_neg`\n- theorem: `Ztrunc_intCast`\n- theorem: `zpow_mul_sub`\n- theorem: `zpow_sub_add`\n- theorem: `zpow_nonneg_toNat`\n- theorem: `generic_format_0`\n- theorem: `cexp_opp`\n- theorem: `cexp_abs`\n- theorem: `canonical_generic_format`\n- theorem: `scaled_mantissa_mult_bpow`\n- lemma: `Ztrunc_zero`\n- theorem: `generic_format_F2R`\n- theorem: `canonical_opp`\n- theorem: `canonical_abs`\n- theorem: `canonical_0`\n- theorem: `canonical_unique`\n- theorem: `scaled_mantissa_0`\n- theorem: `scaled_mantissa_opp`\n- theorem: `scaled_mantissa_abs`\n- theorem: `generic_format_opp`\n- theorem: `generic_format_abs`\n- theorem: `generic_format_abs_inv`\n- theorem: `generic_format_satisfies_any`\n- theorem: `round_UP_exists`\n- theorem: `generic_format_bpow`\n- theorem: `scaled_mantissa_generic`\n- theorem: `cexp_fexp`\n- theorem: `cexp_fexp_pos`\n- theorem: `mantissa_small_pos`\n- theorem: `scaled_mantissa_lt_1`\n- theorem: `scaled_mantissa_lt_bpow`\n- theorem: `generic_format_round_DN`\n- theorem: `generic_format_round_UP`\n- theorem: `generic_format_precision_bound`\n- theorem: `fexp_monotone`\n- theorem: `generic_format_equiv`\n- theorem: `round_to_generic_spec`\n- theorem: `generic_format_inter_valid`\n- theorem: `mag_generic_format`\n- theorem: `precision_generic_format`\n- theorem: `generic_format_error_bound`\n- theorem: `generic_format_relative_error`\n- theorem: `round_to_format_properties`\n- theorem: `generic_format_neg_closed`\n- theorem: `Rnd_UP_to_DN_via_neg`\n\n### Mapping (Coq → Lean)\n- `valid_exp_large` → `valid_exp_large` (exact-name)\n- `valid_exp_large'` → `valid_exp_large` (normalized-name)\n- `generic_format_0` → `generic_format_0` (exact-name)\n- `cexp_opp` → `cexp_opp` (exact-name)\n- `cexp_abs` → `cexp_abs` (exact-name)\n- `canonical_generic_format` → `canonical_generic_format` (exact-name)\n- `generic_format_bpow` → `generic_format_bpow` (exact-name)\n- `generic_format_bpow'` → `generic_format_bpow` (normalized-name)\n- `generic_format_F2R` → `generic_format_F2R` (exact-name)\n- `generic_format_F2R'` → `generic_format_F2R` (normalized-name)\n- `canonical_opp` → `canonical_opp` (exact-name)\n- `canonical_abs` → `canonical_abs` (exact-name)\n- `canonical_0` → `canonical_0` (exact-name)\n- `canonical_unique` → `canonical_unique` (exact-name)\n- `scaled_mantissa_generic` → `scaled_mantissa_generic` (exact-name)\n- `scaled_mantissa_mult_bpow` → `scaled_mantissa_mult_bpow` (exact-name)\n- `scaled_mantissa_0` → `scaled_mantissa_0` (exact-name)\n- `scaled_mantissa_opp` → `scaled_mantissa_opp` (exact-name)\n- `scaled_mantissa_abs` → `scaled_mantissa_abs` (exact-name)\n- `generic_format_opp` → `generic_format_opp` (exact-name)\n- `generic_format_abs` → `generic_format_abs` (exact-name)\n- `generic_format_abs_inv` → `generic_format_abs_inv` (exact-name)\n- `cexp_fexp` → `cexp_fexp` (exact-name)\n- `cexp_fexp_pos` → `cexp_fexp_pos` (exact-name)\n- `mantissa_small_pos` → `mantissa_small_pos` (exact-name)\n- `scaled_mantissa_lt_1` → `scaled_mantissa_lt_1` (exact-name)\n- `mag_generic_gt` → `mag_generic_gt` (exact-name)\n- `mantissa_DN_small_pos` → (no match)\n- `mantissa_UP_small_pos` → (no match)\n- `generic_format_discrete` → (no match)\n- `generic_format_canonical` → (no match)\n- `generic_format_ge_bpow` → (no match)\n- `abs_lt_bpow_prec` → (no match)\n- `generic_format_bpow_inv'` → `generic_format_bpow` (substring-name)\n- `generic_format_bpow_inv` → `generic_format_bpow` (substring-name)\n- `Zrnd_DN_or_UP` → (no match)\n- `Zrnd_ZR_or_AW` → (no match)\n- `round_bounded_large_pos` → (no match)\n- `round_bounded_small_pos` → (no match)\n- `round_le_pos` → (no match)\n- `round_generic` → (no match)\n- `round_0` → `round_0` (exact-name)\n- `exp_small_round_0_pos` → (no match)\n- `generic_format_round_pos` → (no match)\n- `round_ext` → (no match)\n- `round_opp` → (no match)\n- `round_DN_or_UP` → (no match)\n- `round_ZR_or_AW` → (no match)\n- `round_le` → (no match)\n- `round_ge_generic` → (no match)\n- `round_le_generic` → (no match)\n- `round_abs_abs` → (no match)\n- `round_bounded_large` → (no match)\n- `exp_small_round_0` → (no match)\n- `abs_round_ge_generic` → (no match)\n- `abs_round_le_generic` → (no match)\n- `round_DN_opp` → (no match)\n- `round_UP_opp` → (no match)\n- `round_ZR_opp` → (no match)\n- `round_ZR_abs` → (no match)\n- `round_AW_opp` → (no match)\n- `round_AW_abs` → (no match)\n- `round_ZR_DN` → (no match)\n- `round_ZR_UP` → (no match)\n- `round_AW_UP` → (no match)\n- `round_AW_DN` → (no match)\n- `generic_format_round` → `generic_format_round_DN` (substring-name)\n- `round_DN_pt` → (no match)\n- `generic_format_satisfies_any` → `generic_format_satisfies_any` (exact-name)\n- `round_UP_pt` → (no match)\n- `round_ZR_pt` → (no match)\n- `round_DN_small_pos` → (no match)\n- `round_DN_UP_lt` → (no match)\n- `round_UP_small_pos` → (no match)\n- `generic_format_EM` → (no match)\n- `round_large_pos_ge_bpow` → (no match)\n- `mag_round_ZR` → (no match)\n- `mag_round` → (no match)\n- `mag_DN` → (no match)\n- `cexp_DN` → (no match)\n- `scaled_mantissa_DN` → (no match)\n- `generic_N_pt_DN_or_UP` → (no match)\n- `subnormal_exponent` → (no match)\n- `cexp_le_bpow` → (no match)\n- `cexp_ge_bpow` → (no match)\n- `lt_cexp_pos` → (no match)\n- `lt_cexp` → (no match)\n- `mag_round_ge` → (no match)\n- `cexp_round_ge` → (no match)\n- `Znearest_DN_or_UP` → (no match)\n- `Znearest_ge_floor` → (no match)\n- `Znearest_le_ceil` → (no match)\n- `Znearest_N_strict` → (no match)\n- `Znearest_half` → (no match)\n- `Znearest_imp` → (no match)\n- `round_N_pt` → (no match)\n- `round_N_middle` → (no match)\n- `round_N_small_pos` → (no match)\n- `round_NA_pt` → (no match)\n- `round_N0_pt` → (no match)\n- `Znearest_opp` → (no match)\n- `round_N_opp` → (no match)\n- `round_N0_opp` → (no match)\n- `round_N_small` → (no match)\n- `generic_inclusion_mag` → (no match)\n- `generic_inclusion_lt_ge` → (no match)\n- `generic_inclusion` → (no match)\n- `generic_inclusion_le_ge` → (no match)\n- `generic_inclusion_le` → (no match)\n- `generic_inclusion_ge` → (no match)\n- `generic_round_generic` → (no match)\n- `round_NA_opp` → (no match)\n\n## File: Raux.v\n- Coq file: Raux.v\n- Lean file(s): Raux.lean\n\n### Coq Declarations\n- Theorem: `Rle_0_minus`\n- Theorem: `Rabs_eq_Rabs`\n- Theorem: `Rabs_minus_le`\n- Theorem: `Rabs_eq_R0`\n- Theorem: `Rmult_lt_compat`\n- Lemma: `Rmult_neq_reg_r`\n- Lemma: `Rmult_neq_compat_r`\n- Theorem: `Rmult_min_distr_r`\n- Theorem: `Rmult_min_distr_l`\n- Lemma: `Rmin_opp`\n- Lemma: `Rmax_opp`\n- Theorem: `exp_le`\n- Theorem: `Rinv_lt`\n- Theorem: `Rinv_le`\n- Theorem: `sqrt_ge_0`\n- Lemma: `sqrt_neg`\n- Lemma: `Rsqr_le_abs_0_alt`\n- Theorem: `Rabs_le_inv`\n- Theorem: `Rabs_ge`\n- Theorem: `Rabs_ge_inv`\n- Theorem: `Rabs_lt`\n- Theorem: `Rabs_lt_inv`\n- Theorem: `Rabs_gt`\n- Theorem: `Rabs_gt_inv`\n- Theorem: `IZR_le_lt`\n- Theorem: `le_lt_IZR`\n- Theorem: `neq_IZR`\n- Theorem: `Rcompare_spec`\n- Theorem: `Rcompare_Lt`\n- Theorem: `Rcompare_Lt_inv`\n- Theorem: `Rcompare_not_Lt`\n- Theorem: `Rcompare_not_Lt_inv`\n- Theorem: `Rcompare_Eq`\n- Theorem: `Rcompare_Eq_inv`\n- Theorem: `Rcompare_Gt`\n- Theorem: `Rcompare_Gt_inv`\n- Theorem: `Rcompare_not_Gt`\n- Theorem: `Rcompare_not_Gt_inv`\n- Theorem: `Rcompare_IZR`\n- Theorem: `Rcompare_sym`\n- Lemma: `Rcompare_opp`\n- Theorem: `Rcompare_plus_r`\n- Theorem: `Rcompare_plus_l`\n- Theorem: `Rcompare_mult_r`\n- Theorem: `Rcompare_mult_l`\n- Theorem: `Rcompare_middle`\n- Theorem: `Rcompare_half_l`\n- Theorem: `Rcompare_half_r`\n- Theorem: `Rcompare_sqr`\n- Theorem: `Rmin_compare`\n- Theorem: `Rle_bool_spec`\n- Theorem: `Rle_bool_true`\n- Theorem: `Rle_bool_false`\n- Theorem: `Rlt_bool_spec`\n- Theorem: `negb_Rlt_bool`\n- Theorem: `negb_Rle_bool`\n- Theorem: `Rlt_bool_true`\n- Theorem: `Rlt_bool_false`\n- Lemma: `Rlt_bool_opp`\n- Theorem: `Req_bool_spec`\n- Theorem: `Req_bool_true`\n- Theorem: `Req_bool_false`\n- Theorem: `Zfloor_lb`\n- Theorem: `Zfloor_ub`\n- Theorem: `Zfloor_lub`\n- Theorem: `Zfloor_imp`\n- Theorem: `Zfloor_IZR`\n- Theorem: `Zfloor_le`\n- Theorem: `Zceil_ub`\n- Theorem: `Zceil_lb`\n- Theorem: `Zceil_glb`\n- Theorem: `Zceil_imp`\n- Theorem: `Zceil_IZR`\n- Theorem: `Zceil_le`\n- Theorem: `Zceil_floor_neq`\n- Theorem: `Ztrunc_IZR`\n- Theorem: `Ztrunc_floor`\n- Theorem: `Ztrunc_ceil`\n- Theorem: `Ztrunc_le`\n- Theorem: `Ztrunc_opp`\n- Theorem: `Ztrunc_abs`\n- Theorem: `Ztrunc_lub`\n- Theorem: `Zaway_IZR`\n- Theorem: `Zaway_ceil`\n- Theorem: `Zaway_floor`\n- Theorem: `Zaway_le`\n- Theorem: `Zaway_opp`\n- Theorem: `Zaway_abs`\n- Theorem: `Rcompare_floor_ceil_middle`\n- Theorem: `Rcompare_ceil_floor_middle`\n- Theorem: `Zfloor_div`\n- Theorem: `Ztrunc_div`\n- Theorem: `radix_pos`\n- Theorem: `IZR_Zpower_pos`\n- Theorem: `bpow_powerRZ`\n- Theorem: `bpow_ge_0`\n- Theorem: `bpow_gt_0`\n- Theorem: `bpow_plus`\n- Theorem: `bpow_1`\n- Theorem: `bpow_plus_1`\n- Theorem: `bpow_opp`\n- Theorem: `IZR_Zpower_nat`\n- Theorem: `IZR_Zpower`\n- Theorem: `bpow_lt`\n- Theorem: `lt_bpow`\n- Theorem: `bpow_le`\n- Theorem: `le_bpow`\n- Theorem: `bpow_inj`\n- Theorem: `bpow_exp`\n- Lemma: `sqrt_bpow`\n- Lemma: `sqrt_bpow_ge`\n- Theorem: `bpow_lt_bpow`\n- Theorem: `bpow_unique`\n- Theorem: `mag_unique`\n- Theorem: `mag_opp`\n- Theorem: `mag_abs`\n- Theorem: `mag_unique_pos`\n- Theorem: `mag_le_abs`\n- Theorem: `mag_le`\n- Lemma: `lt_mag`\n- Theorem: `mag_bpow`\n- Theorem: `mag_mult_bpow`\n- Theorem: `mag_le_bpow`\n- Theorem: `mag_gt_bpow`\n- Theorem: `mag_ge_bpow`\n- Theorem: `bpow_mag_gt`\n- Theorem: `bpow_mag_le`\n- Theorem: `mag_le_Zpower`\n- Theorem: `mag_gt_Zpower`\n- Lemma: `mag_mult`\n- Lemma: `mag_plus`\n- Lemma: `mag_minus`\n- Lemma: `mag_minus_lb`\n- Theorem: `mag_plus_ge`\n- Lemma: `mag_div`\n- Lemma: `mag_sqrt`\n- Lemma: `mag_1`\n- Theorem: `eqb_sym`\n- Theorem: `eqb_false`\n- Theorem: `eqb_true`\n- Theorem: `IZR_cond_Zopp`\n- Theorem: `abs_cond_Ropp`\n- Theorem: `cond_Ropp_Rlt_bool`\n- Theorem: `Rlt_bool_cond_Ropp`\n- Theorem: `cond_Ropp_involutive`\n- Theorem: `cond_Ropp_inj`\n- Theorem: `cond_Ropp_mult_l`\n- Theorem: `cond_Ropp_mult_r`\n- Theorem: `cond_Ropp_plus`\n- Theorem: `LPO_min`\n- Theorem: `LPO`\n- Lemma: `LPO_Z`\n\n### Lean Declarations\n- theorem: `Rle_0_minus_spec`\n- theorem: `Rmult_lt_compat_spec`\n- theorem: `Rmult_neq_reg_r_spec`\n- theorem: `Rmult_neq_compat_r_spec`\n- theorem: `Rmult_min_distr_r_spec`\n- theorem: `Rmult_min_distr_l_spec`\n- theorem: `Rmin_opp_spec`\n- theorem: `Rmax_opp_spec`\n- theorem: `Rabs_eq_Rabs_spec`\n- theorem: `Rabs_minus_le_spec`\n - theorem: `Rabs_ge_spec`\n - theorem: `Rabs_ge_inv_spec`\n- theorem: `Rcompare_spec`\n- theorem: `Rcompare_sym_spec`\n- theorem: `Rcompare_opp_spec`\n- theorem: `Rcompare_plus_r_spec`\n- theorem: `Rcompare_plus_l_spec`\n- theorem: `Rcompare_mult_r_spec`\n- theorem: `Rcompare_mult_l_spec`\n- theorem: `Rle_bool_spec`\n- theorem: `Rlt_bool_spec`\n- theorem: `negb_Rlt_bool_spec`\n- theorem: `negb_Rle_bool_spec`\n- theorem: `Req_bool_spec`\n- theorem: `eqb_sym_spec`\n- theorem: `cond_Ropp_spec`\n- theorem: `cond_Ropp_involutive_spec`\n- theorem: `cond_Ropp_inj_spec`\n\n### Mapping (Coq → Lean)\n- `Rle_0_minus` → `Rle_0_minus_spec` (substring-name)\n- `Rabs_eq_Rabs` → (no match)\n- `Rabs_eq_Rabs` → `Rabs_eq_Rabs_spec` (substring-name)\n- `Rabs_minus_le` → `Rabs_minus_le_spec` (substring-name)\n- `Rabs_eq_R0` → `Rabs_eq_R0_spec` (substring-name)\n- `Rmult_lt_compat` → `Rmult_lt_compat_spec` (substring-name)\n- `Rmult_neq_reg_r` → `Rmult_neq_reg_r_spec` (substring-name)\n- `Rmult_neq_compat_r` → `Rmult_neq_compat_r_spec` (substring-name)\n- `Rmult_min_distr_r` → `Rmult_min_distr_r_spec` (substring-name)\n- `Rmult_min_distr_l` → `Rmult_min_distr_l_spec` (substring-name)\n- `Rmin_opp` → `Rmin_opp_spec` (substring-name)\n- `Rmax_opp` → `Rmax_opp_spec` (substring-name)\n- `exp_le` → `exp_le_spec` (substring-name)\n- `Rinv_lt` → `Rinv_lt_spec` (substring-name)\n- `Rinv_le` → `Rinv_le_spec` (substring-name)\n- `sqrt_ge_0` → `sqrt_ge_0_spec` (substring-name)\n- `sqrt_neg` → (no match)\n- `Rsqr_le_abs_0_alt` → (no match)\n- `Rabs_le_inv` → (no match)\n- `Rabs_ge` → `Rabs_ge_spec` (substring-name)\n- `Rabs_ge_inv` → `Rabs_ge_inv_spec` (substring-name)\n- `Rabs_lt` → (no match)\n- `Rabs_lt_inv` → (no match)\n- `Rabs_gt` → (no match)\n- `Rabs_gt_inv` → (no match)\n- `IZR_le_lt` → (no match)\n- `le_lt_IZR` → (no match)\n- `neq_IZR` → (no match)\n- `Rcompare_spec` → `Rcompare_spec` (exact-name)\n- `Rcompare_Lt` → (no match)\n- `Rcompare_Lt_inv` → (no match)\n- `Rcompare_not_Lt` → (no match)\n- `Rcompare_not_Lt_inv` → (no match)\n- `Rcompare_Eq` → (no match)\n- `Rcompare_Eq_inv` → (no match)\n- `Rcompare_Gt` → (no match)\n- `Rcompare_Gt_inv` → (no match)\n- `Rcompare_not_Gt` → (no match)\n- `Rcompare_not_Gt_inv` → (no match)\n- `Rcompare_IZR` → (no match)\n- `Rcompare_sym` → `Rcompare_sym_spec` (substring-name)\n- `Rcompare_opp` → `Rcompare_opp_spec` (substring-name)\n- `Rcompare_plus_r` → `Rcompare_plus_r_spec` (substring-name)\n- `Rcompare_plus_l` → `Rcompare_plus_l_spec` (substring-name)\n- `Rcompare_mult_r` → `Rcompare_mult_r_spec` (substring-name)\n- `Rcompare_mult_l` → `Rcompare_mult_l_spec` (substring-name)\n- `Rcompare_middle` → (no match)\n- `Rcompare_half_l` → (no match)\n- `Rcompare_half_r` → (no match)\n- `Rcompare_sqr` → (no match)\n- `Rmin_compare` → (no match)\n- `Rle_bool_spec` → `Rle_bool_spec` (exact-name)\n- `Rle_bool_true` → (no match)\n- `Rle_bool_false` → (no match)\n- `Rlt_bool_spec` → `Rlt_bool_spec` (exact-name)\n- `negb_Rlt_bool` → `negb_Rlt_bool_spec` (substring-name)\n- `negb_Rle_bool` → `negb_Rle_bool_spec` (substring-name)\n- `Rlt_bool_true` → (no match)\n- `Rlt_bool_false` → (no match)\n- `Rlt_bool_opp` → (no match)\n- `Req_bool_spec` → `Req_bool_spec` (exact-name)\n- `Req_bool_true` → (no match)\n- `Req_bool_false` → (no match)\n- `Zfloor_lb` → (no match)\n- `Zfloor_ub` → (no match)\n- `Zfloor_lub` → (no match)\n- `Zfloor_imp` → (no match)\n- `Zfloor_IZR` → (no match)\n- `Zfloor_le` → (no match)\n- `Zceil_ub` → (no match)\n- `Zceil_lb` → (no match)\n- `Zceil_glb` → (no match)\n- `Zceil_imp` → (no match)\n- `Zceil_IZR` → (no match)\n- `Zceil_le` → (no match)\n- `Zceil_floor_neq` → (no match)\n- `Ztrunc_IZR` → (no match)\n- `Ztrunc_floor` → (no match)\n- `Ztrunc_ceil` → (no match)\n- `Ztrunc_le` → (no match)\n- `Ztrunc_opp` → (no match)\n- `Ztrunc_abs` → (no match)\n- `Ztrunc_lub` → (no match)\n- `Zaway_IZR` → (no match)\n- `Zaway_ceil` → (no match)\n- `Zaway_floor` → (no match)\n- `Zaway_le` → (no match)\n- `Zaway_opp` → (no match)\n- `Zaway_abs` → (no match)\n- `Rcompare_floor_ceil_middle` → (no match)\n- `Rcompare_ceil_floor_middle` → (no match)\n- `Zfloor_div` → (no match)\n- `Ztrunc_div` → (no match)\n- `radix_pos` → (no match)\n- `IZR_Zpower_pos` → (no match)\n- `bpow_powerRZ` → (no match)\n- `bpow_ge_0` → (no match)\n- `bpow_gt_0` → (no match)\n- `bpow_plus` → (no match)\n- `bpow_1` → (no match)\n- `bpow_plus_1` → (no match)\n- `bpow_opp` → (no match)\n- `IZR_Zpower_nat` → (no match)\n- `IZR_Zpower` → (no match)\n- `bpow_lt` → (no match)\n- `lt_bpow` → (no match)\n- `bpow_le` → (no match)\n- `le_bpow` → (no match)\n- `bpow_inj` → (no match)\n- `bpow_exp` → (no match)\n- `sqrt_bpow` → (no match)\n- `sqrt_bpow_ge` → (no match)\n- `bpow_lt_bpow` → (no match)\n- `bpow_unique` → (no match)\n- `mag_unique` → (no match)\n- `mag_opp` → (no match)\n- `mag_abs` → (no match)\n- `mag_unique_pos` → (no match)\n- `mag_le_abs` → (no match)\n- `mag_le` → (no match)\n- `lt_mag` → (no match)\n- `mag_bpow` → (no match)\n- `mag_mult_bpow` → (no match)\n- `mag_le_bpow` → (no match)\n- `mag_gt_bpow` → (no match)\n- `mag_ge_bpow` → (no match)\n- `bpow_mag_gt` → (no match)\n- `bpow_mag_le` → (no match)\n- `mag_le_Zpower` → (no match)\n- `mag_gt_Zpower` → (no match)\n- `mag_mult` → (no match)\n- `mag_plus` → (no match)\n- `mag_minus` → (no match)\n- `mag_minus_lb` → (no match)\n- `mag_plus_ge` → (no match)\n- `mag_div` → (no match)\n- `mag_sqrt` → (no match)\n- `mag_1` → (no match)\n- `eqb_sym` → `eqb_sym_spec` (substring-name)\n- `eqb_false` → (no match)\n- `eqb_true` → (no match)\n- `IZR_cond_Zopp` → (no match)\n- `abs_cond_Ropp` → (no match)\n- `cond_Ropp_Rlt_bool` → (no match)\n- `Rlt_bool_cond_Ropp` → (no match)\n- `cond_Ropp_involutive` → `cond_Ropp_involutive_spec` (substring-name)\n- `cond_Ropp_inj` → `cond_Ropp_inj_spec` (substring-name)\n- `cond_Ropp_mult_l` → (no match)\n- `cond_Ropp_mult_r` → (no match)\n- `cond_Ropp_plus` → (no match)\n- `LPO_min` → (no match)\n- `LPO` → (no match)\n- `LPO_Z` → (no match)\n\n## File: Round_NE.v\n- Coq file: Round_NE.v\n- Lean file(s): Round_NE.lean\n\n### Coq Declarations\n- Lemma: `DN_UP_parity_aux`\n- Theorem: `DN_UP_parity_generic_pos`\n- Theorem: `DN_UP_parity_generic`\n- Theorem: `Rnd_NE_pt_total`\n- Theorem: `Rnd_NE_pt_monotone`\n- Theorem: `Rnd_NE_pt_round`\n- Lemma: `round_NE_pt_pos`\n- Theorem: `round_NE_opp`\n- Lemma: `round_NE_abs`\n- Theorem: `round_NE_pt`\n\n### Lean Declarations\n- theorem: `DN_UP_parity_aux`\n- theorem: `DN_UP_parity_generic_pos`\n- theorem: `DN_UP_parity_generic`\n- theorem: `Rnd_NE_pt_unique_prop`\n- theorem: `Rnd_NE_pt_unique`\n- theorem: `Rnd_NE_pt_monotone`\n- theorem: `Rnd_NE_pt_total`\n- theorem: `Rnd_NE_pt_round`\n- theorem: `satisfies_any_imp_NE`\n- theorem: `Rnd_NE_pt_refl`\n- theorem: `Rnd_NE_pt_idempotent`\n- theorem: `DN_UP_parity_pos_holds`\n- theorem: `Rnd_NE_pt_sign`\n- theorem: `Rnd_NE_pt_abs`\n- theorem: `round_NE_pt_pos`\n- theorem: `round_NE_opp`\n- theorem: `round_NE_abs`\n- theorem: `round_NE_pt`\n- theorem: `Rnd_NE_pt_error_bound`\n- theorem: `Rnd_NE_pt_minimal_error`\n\n### Mapping (Coq → Lean)\n- `DN_UP_parity_aux` → `DN_UP_parity_aux` (exact-name)\n- `DN_UP_parity_generic_pos` → `DN_UP_parity_generic_pos` (exact-name)\n- `DN_UP_parity_generic` → `DN_UP_parity_generic` (exact-name)\n- `Rnd_NE_pt_total` → `Rnd_NE_pt_total` (exact-name)\n- `Rnd_NE_pt_monotone` → `Rnd_NE_pt_monotone` (exact-name)\n- `Rnd_NE_pt_round` → `Rnd_NE_pt_round` (exact-name)\n- `round_NE_pt_pos` → `round_NE_pt_pos` (exact-name)\n- `round_NE_opp` → `round_NE_opp` (exact-name)\n- `round_NE_abs` → `round_NE_abs` (exact-name)\n- `round_NE_pt` → `round_NE_pt` (exact-name)\n\n## File: Round_pred.v\n- Coq file: Round_pred.v\n- Lean file(s): Round_pred.lean\n\n### Coq Declarations\n- Theorem: `round_val_of_pred`\n- Theorem: `round_fun_of_pred`\n- Theorem: `round_unique`\n- Theorem: `Rnd_DN_pt_monotone`\n- Theorem: `Rnd_DN_pt_unique`\n- Theorem: `Rnd_DN_unique`\n- Theorem: `Rnd_UP_pt_monotone`\n- Theorem: `Rnd_UP_pt_unique`\n- Theorem: `Rnd_UP_unique`\n- Theorem: `Rnd_UP_pt_opp`\n- Theorem: `Rnd_DN_pt_opp`\n- Theorem: `Rnd_DN_opp`\n- Theorem: `Rnd_DN_UP_pt_split`\n- Theorem: `Rnd_DN_pt_refl`\n- Theorem: `Rnd_DN_pt_idempotent`\n- Theorem: `Rnd_UP_pt_refl`\n- Theorem: `Rnd_UP_pt_idempotent`\n- Theorem: `Only_DN_or_UP`\n- Theorem: `Rnd_ZR_abs`\n- Theorem: `Rnd_ZR_pt_monotone`\n- Theorem: `Rnd_N_pt_DN_or_UP`\n- Theorem: `Rnd_N_pt_DN_or_UP_eq`\n- Theorem: `Rnd_N_pt_opp_inv`\n- Theorem: `Rnd_N_pt_monotone`\n- Theorem: `Rnd_N_pt_unique`\n- Theorem: `Rnd_N_pt_refl`\n- Theorem: `Rnd_N_pt_idempotent`\n- Theorem: `Rnd_N_pt_0`\n- Theorem: `Rnd_N_pt_ge_0`\n- Theorem: `Rnd_N_pt_le_0`\n- Theorem: `Rnd_N_pt_abs`\n- Theorem: `Rnd_N_pt_DN_UP`\n- Theorem: `Rnd_N_pt_DN`\n- Theorem: `Rnd_N_pt_UP`\n- Theorem: `Rnd_NG_pt_unique`\n- Theorem: `Rnd_NG_pt_monotone`\n- Theorem: `Rnd_NG_pt_refl`\n- Theorem: `Rnd_NG_pt_opp_inv`\n- Theorem: `Rnd_NG_unique`\n- Theorem: `Rnd_NA_NG_pt`\n- Lemma: `Rnd_NA_pt_unique_prop`\n- Theorem: `Rnd_NA_pt_unique`\n- Theorem: `Rnd_NA_pt_N`\n- Theorem: `Rnd_NA_unique`\n- Theorem: `Rnd_NA_pt_monotone`\n- Theorem: `Rnd_NA_pt_refl`\n- Theorem: `Rnd_NA_pt_idempotent`\n- Theorem: `Rnd_N0_NG_pt`\n- Lemma: `Rnd_N0_pt_unique_prop`\n- Theorem: `Rnd_N0_pt_unique`\n- Theorem: `Rnd_N0_pt_N`\n- Theorem: `Rnd_N0_unique`\n- Theorem: `Rnd_N0_pt_monotone`\n- Theorem: `Rnd_N0_pt_refl`\n- Theorem: `Rnd_N0_pt_idempotent`\n- Theorem: `round_pred_ge_0`\n- Theorem: `round_pred_gt_0`\n- Theorem: `round_pred_le_0`\n- Theorem: `round_pred_lt_0`\n- Theorem: `Rnd_DN_pt_equiv_format`\n- Theorem: `Rnd_UP_pt_equiv_format`\n- Theorem: `satisfies_any_eq`\n- Theorem: `satisfies_any_imp_DN`\n- Theorem: `satisfies_any_imp_UP`\n- Theorem: `satisfies_any_imp_ZR`\n- Theorem: `satisfies_any_imp_NG`\n- Theorem: `satisfies_any_imp_NA`\n- Theorem: `satisfies_any_imp_N0`\n\n### Lean Declarations\n- theorem: `Rnd_DN_spec`\n- theorem: `Rnd_UP_spec`\n- theorem: `Rnd_ZR_spec`\n- theorem: `Rnd_N_spec`\n- theorem: `Rnd_NG_spec`\n- theorem: `Rnd_NA_spec`\n- theorem: `Rnd_N0_spec`\n- theorem: `round_val_of_pred_spec`\n- theorem: `round_fun_of_pred_spec`\n- theorem: `round_unique_spec`\n- theorem: `Rnd_DN_pt_monotone_spec`\n- theorem: `Rnd_DN_pt_unique_spec`\n- theorem: `Rnd_DN_unique_spec`\n- theorem: `Rnd_UP_pt_monotone_spec`\n- theorem: `Rnd_UP_pt_unique_spec`\n- theorem: `Rnd_UP_unique_spec`\n- theorem: `Rnd_UP_pt_opp_spec`\n- theorem: `Rnd_DN_pt_opp_spec`\n- theorem: `Rnd_DN_pt_refl_spec`\n- theorem: `Rnd_DN_pt_idempotent_spec`\n- theorem: `Rnd_UP_pt_refl_spec`\n- theorem: `Rnd_UP_pt_idempotent_spec`\n- theorem: `Rnd_ZR_abs_spec`\n\n### Mapping (Coq → Lean)\n- `round_val_of_pred` → `round_val_of_pred_spec` (substring-name)\n- `round_fun_of_pred` → `round_fun_of_pred_spec` (substring-name)\n- `round_unique` → `round_unique_spec` (substring-name)\n- `Rnd_DN_pt_monotone` → `Rnd_DN_pt_monotone_spec` (substring-name)\n- `Rnd_DN_pt_unique` → `Rnd_DN_pt_unique_spec` (substring-name)\n- `Rnd_DN_unique` → `Rnd_DN_unique_spec` (substring-name)\n- `Rnd_UP_pt_monotone` → `Rnd_UP_pt_monotone_spec` (substring-name)\n- `Rnd_UP_pt_unique` → `Rnd_UP_pt_unique_spec` (substring-name)\n- `Rnd_UP_unique` → `Rnd_UP_unique_spec` (substring-name)\n- `Rnd_UP_pt_opp` → `Rnd_UP_pt_opp_spec` (substring-name)\n- `Rnd_DN_pt_opp` → `Rnd_DN_pt_opp_spec` (substring-name)\n- `Rnd_DN_opp` → (no match)\n- `Rnd_DN_UP_pt_split` → (no match)\n- `Rnd_DN_pt_refl` → `Rnd_DN_pt_refl_spec` (substring-name)\n- `Rnd_DN_pt_idempotent` → `Rnd_DN_pt_idempotent_spec` (substring-name)\n- `Rnd_UP_pt_refl` → `Rnd_UP_pt_refl_spec` (substring-name)\n- `Rnd_UP_pt_idempotent` → `Rnd_UP_pt_idempotent_spec` (substring-name)\n- `Only_DN_or_UP` → (no match)\n- `Rnd_ZR_abs` → `Rnd_ZR_abs_spec` (substring-name)\n- `Rnd_ZR_pt_monotone` → (no match)\n- `Rnd_N_pt_DN_or_UP` → (no match)\n- `Rnd_N_pt_DN_or_UP_eq` → (no match)\n- `Rnd_N_pt_opp_inv` → (no match)\n- `Rnd_N_pt_monotone` → (no match)\n- `Rnd_N_pt_unique` → (no match)\n- `Rnd_N_pt_refl` → (no match)\n- `Rnd_N_pt_idempotent` → (no match)\n- `Rnd_N_pt_0` → (no match)\n- `Rnd_N_pt_ge_0` → (no match)\n- `Rnd_N_pt_le_0` → (no match)\n- `Rnd_N_pt_abs` → (no match)\n- `Rnd_N_pt_DN_UP` → (no match)\n- `Rnd_N_pt_DN` → (no match)\n- `Rnd_N_pt_UP` → (no match)\n- `Rnd_NG_pt_unique` → (no match)\n- `Rnd_NG_pt_monotone` → (no match)\n- `Rnd_NG_pt_refl` → (no match)\n- `Rnd_NG_pt_opp_inv` → (no match)\n- `Rnd_NG_unique` → (no match)\n- `Rnd_NA_NG_pt` → (no match)\n- `Rnd_NA_pt_unique_prop` → (no match)\n- `Rnd_NA_pt_unique` → (no match)\n- `Rnd_NA_pt_N` → (no match)\n- `Rnd_NA_unique` → (no match)\n- `Rnd_NA_pt_monotone` → (no match)\n- `Rnd_NA_pt_refl` → (no match)\n- `Rnd_NA_pt_idempotent` → (no match)\n- `Rnd_N0_NG_pt` → (no match)\n- `Rnd_N0_pt_unique_prop` → (no match)\n- `Rnd_N0_pt_unique` → (no match)\n- `Rnd_N0_pt_N` → (no match)\n- `Rnd_N0_unique` → (no match)\n- `Rnd_N0_pt_monotone` → (no match)\n- `Rnd_N0_pt_refl` → (no match)\n- `Rnd_N0_pt_idempotent` → (no match)\n- `round_pred_ge_0` → (no match)\n- `round_pred_gt_0` → (no match)\n- `round_pred_le_0` → (no match)\n- `round_pred_lt_0` → (no match)\n- `Rnd_DN_pt_equiv_format` → (no match)\n- `Rnd_UP_pt_equiv_format` → (no match)\n- `satisfies_any_eq` → (no match)\n- `satisfies_any_imp_DN` → (no match)\n- `satisfies_any_imp_UP` → (no match)\n- `satisfies_any_imp_ZR` → (no match)\n- `satisfies_any_imp_NG` → (no match)\n- `satisfies_any_imp_NA` → (no match)\n- `satisfies_any_imp_N0` → (no match)\n\n## File: Ulp.v\n- Coq file: Ulp.v\n- Lean file(s): Ulp.lean\n\n### Coq Declarations\n- Lemma: `Z_le_dec_aux`\n- Lemma: `negligible_exp_spec`\n- Lemma: `negligible_exp_spec'`\n- Lemma: `fexp_negligible_exp_eq`\n- Lemma: `ulp_neq_0`\n- Theorem: `ulp_opp`\n- Theorem: `ulp_abs`\n- Theorem: `ulp_ge_0`\n- Theorem: `ulp_le_id`\n- Theorem: `ulp_le_abs`\n- Theorem: `round_UP_DN_ulp`\n- Theorem: `ulp_canonical`\n- Theorem: `ulp_bpow`\n- Lemma: `generic_format_ulp_0`\n- Lemma: `generic_format_bpow_ge_ulp_0`\n- Lemma: `generic_format_ulp`\n- Lemma: `not_FTZ_generic_format_ulp`\n- Lemma: `ulp_ge_ulp_0`\n- Lemma: `not_FTZ_ulp_ge_ulp_0`\n- Lemma: `ulp_le_pos`\n- Theorem: `ulp_le`\n- Theorem: `eq_0_round_0_negligible_exp`\n- Theorem: `pred_eq_pos`\n- Theorem: `succ_eq_pos`\n- Theorem: `succ_opp`\n- Theorem: `pred_opp`\n- Theorem: `pred_bpow`\n- Theorem: `id_m_ulp_ge_bpow`\n- Theorem: `id_p_ulp_le_bpow`\n- Lemma: `generic_format_pred_aux1`\n- Lemma: `generic_format_pred_aux2`\n- Lemma: `generic_format_succ_aux1`\n- Lemma: `generic_format_pred_pos`\n- Theorem: `generic_format_succ`\n- Theorem: `generic_format_pred`\n- Lemma: `pred_pos_lt_id`\n- Theorem: `succ_gt_id`\n- Theorem: `pred_lt_id`\n- Theorem: `succ_ge_id`\n- Theorem: `pred_le_id`\n- Lemma: `pred_pos_ge_0`\n- Theorem: `pred_ge_0`\n- Lemma: `pred_pos_plus_ulp_aux1`\n- Lemma: `pred_pos_plus_ulp_aux2`\n- Lemma: `pred_pos_plus_ulp_aux3`\n- Lemma: `pred_pos_plus_ulp`\n- Theorem: `pred_plus_ulp`\n- Theorem: `mag_plus_eps`\n- Theorem: `round_DN_plus_eps_pos`\n- Theorem: `round_UP_plus_eps_pos`\n- Theorem: `round_UP_pred_plus_eps_pos`\n- Theorem: `round_DN_minus_eps_pos`\n- Theorem: `round_DN_plus_eps`\n- Theorem: `round_UP_plus_eps`\n- Lemma: `le_pred_pos_lt`\n- Lemma: `succ_le_lt_aux`\n- Theorem: `succ_le_lt`\n- Theorem: `pred_ge_gt`\n- Theorem: `succ_gt_ge`\n- Theorem: `pred_lt_le`\n- Lemma: `succ_pred_pos`\n- Theorem: `pred_ulp_0`\n- Theorem: `succ_0`\n- Theorem: `pred_0`\n- Lemma: `pred_succ_pos`\n- Theorem: `succ_pred`\n- Theorem: `pred_succ`\n- Theorem: `round_UP_pred_plus_eps`\n- Theorem: `round_DN_minus_eps`\n- Theorem: `error_lt_ulp`\n- Theorem: `error_le_ulp`\n- Theorem: `error_le_half_ulp`\n- Theorem: `ulp_DN`\n- Theorem: `round_neq_0_negligible_exp`\n- Theorem: `error_lt_ulp_round`\n- Lemma: `error_le_ulp_round`\n- Theorem: `error_le_half_ulp_round`\n- Theorem: `pred_le`\n- Theorem: `succ_le`\n- Theorem: `pred_le_inv`\n- Theorem: `succ_le_inv`\n- Theorem: `pred_lt`\n- Theorem: `succ_lt`\n- Lemma: `succ_le_plus_ulp`\n- Lemma: `generic_format_plus_ulp`\n- Theorem: `round_DN_ge_UP_gt`\n- Theorem: `round_UP_le_DN_lt`\n- Theorem: `pred_UP_le_DN`\n- Theorem: `UP_le_succ_DN`\n- Theorem: `pred_UP_eq_DN`\n- Theorem: `succ_DN_eq_UP`\n- Theorem: `round_DN_eq`\n- Theorem: `round_UP_eq`\n- Lemma: `ulp_ulp_0`\n- Lemma: `ulp_succ_pos`\n- Theorem: `ulp_pred_pos`\n- Lemma: `ulp_round_pos`\n- Theorem: `ulp_round`\n- Lemma: `succ_round_ge_id`\n- Lemma: `pred_round_le_id`\n- Theorem: `round_N_le_midp`\n- Theorem: `round_N_ge_midp`\n- Lemma: `round_N_ge_ge_midp`\n- Lemma: `round_N_le_le_midp`\n- Lemma: `round_N_eq_DN`\n- Lemma: `round_N_eq_DN_pt`\n- Lemma: `round_N_eq_UP`\n- Lemma: `round_N_eq_UP_pt`\n- Lemma: `round_N_plus_ulp_ge`\n- Lemma: `round_N_eq_ties`\n\n### Lean Declarations\n- theorem: `ulp_neq_0`\n- theorem: `ulp_opp`\n- theorem: `ulp_abs`\n- theorem: `ulp_ge_0`\n- theorem: `ulp_le_id`\n- theorem: `ulp_le_abs`\n- theorem: `ulp_bpow`\n- theorem: `generic_format_ulp_0`\n- theorem: `generic_format_bpow_ge_ulp_0`\n\n### Mapping (Coq → Lean)\n- `Z_le_dec_aux` → (no match)\n- `negligible_exp_spec` → (no match)\n- `negligible_exp_spec'` → (no match)\n- `fexp_negligible_exp_eq` → (no match)\n- `ulp_neq_0` → `ulp_neq_0` (exact-name)\n- `ulp_opp` → `ulp_opp` (exact-name)\n- `ulp_abs` → `ulp_abs` (exact-name)\n- `ulp_ge_0` → `ulp_ge_0` (exact-name)\n- `ulp_le_id` → `ulp_le_id` (exact-name)\n- `ulp_le_abs` → `ulp_le_abs` (exact-name)\n- `round_UP_DN_ulp` → (no match)\n- `ulp_canonical` → (no match)\n- `ulp_bpow` → `ulp_bpow` (exact-name)\n- `generic_format_ulp_0` → `generic_format_ulp_0` (exact-name)\n- `generic_format_bpow_ge_ulp_0` → `generic_format_bpow_ge_ulp_0` (exact-name)\n- `generic_format_ulp` → `generic_format_ulp_0` (substring-name)\n- `not_FTZ_generic_format_ulp` → (no match)\n- `ulp_ge_ulp_0` → (no match)\n- `not_FTZ_ulp_ge_ulp_0` → (no match)\n- `ulp_le_pos` → (no match)\n- `ulp_le` → `ulp_le_id` (substring-name)\n- `eq_0_round_0_negligible_exp` → (no match)\n- `pred_eq_pos` → (no match)\n- `succ_eq_pos` → (no match)\n- `succ_opp` → (no match)\n- `pred_opp` → (no match)\n- `pred_bpow` → (no match)\n- `id_m_ulp_ge_bpow` → (no match)\n- `id_p_ulp_le_bpow` → (no match)\n- `generic_format_pred_aux1` → (no match)\n- `generic_format_pred_aux2` → (no match)\n- `generic_format_succ_aux1` → (no match)\n- `generic_format_pred_pos` → (no match)\n- `generic_format_succ` → (no match)\n- `generic_format_pred` → (no match)\n- `pred_pos_lt_id` → (no match)\n- `succ_gt_id` → (no match)\n- `pred_lt_id` → (no match)\n- `succ_ge_id` → (no match)\n- `pred_le_id` → (no match)\n- `pred_pos_ge_0` → (no match)\n- `pred_ge_0` → (no match)\n- `pred_pos_plus_ulp_aux1` → (no match)\n- `pred_pos_plus_ulp_aux2` → (no match)\n- `pred_pos_plus_ulp_aux3` → (no match)\n- `pred_pos_plus_ulp` → (no match)\n- `pred_plus_ulp` → (no match)\n- `mag_plus_eps` → (no match)\n- `round_DN_plus_eps_pos` → (no match)\n- `round_UP_plus_eps_pos` → (no match)\n- `round_UP_pred_plus_eps_pos` → (no match)\n- `round_DN_minus_eps_pos` → (no match)\n- `round_DN_plus_eps` → (no match)\n- `round_UP_plus_eps` → (no match)\n- `le_pred_pos_lt` → (no match)\n- `succ_le_lt_aux` → (no match)\n- `succ_le_lt` → (no match)\n- `pred_ge_gt` → (no match)\n- `succ_gt_ge` → (no match)\n- `pred_lt_le` → (no match)\n- `succ_pred_pos` → (no match)\n- `pred_ulp_0` → (no match)\n- `succ_0` → (no match)\n- `pred_0` → (no match)\n- `pred_succ_pos` → (no match)\n- `succ_pred` → (no match)\n- `pred_succ` → (no match)\n- `round_UP_pred_plus_eps` → (no match)\n- `round_DN_minus_eps` → (no match)\n- `error_lt_ulp` → (no match)\n- `error_le_ulp` → (no match)\n- `error_le_half_ulp` → (no match)\n- `ulp_DN` → (no match)\n- `round_neq_0_negligible_exp` → (no match)\n- `error_lt_ulp_round` → (no match)\n- `error_le_ulp_round` → (no match)\n- `error_le_half_ulp_round` → (no match)\n- `pred_le` → (no match)\n- `succ_le` → (no match)\n- `pred_le_inv` → (no match)\n- `succ_le_inv` → (no match)\n- `pred_lt` → (no match)\n- `succ_lt` → (no match)\n- `succ_le_plus_ulp` → (no match)\n- `generic_format_plus_ulp` → (no match)\n- `round_DN_ge_UP_gt` → (no match)\n- `round_UP_le_DN_lt` → (no match)\n- `pred_UP_le_DN` → (no match)\n- `UP_le_succ_DN` → (no match)\n- `pred_UP_eq_DN` → (no match)\n- `succ_DN_eq_UP` → (no match)\n- `round_DN_eq` → (no match)\n- `round_UP_eq` → (no match)\n- `ulp_ulp_0` → (no match)\n- `ulp_succ_pos` → (no match)\n- `ulp_pred_pos` → (no match)\n- `ulp_round_pos` → (no match)\n- `ulp_round` → (no match)\n- `succ_round_ge_id` → (no match)\n- `pred_round_le_id` → (no match)\n- `round_N_le_midp` → (no match)\n- `round_N_ge_midp` → (no match)\n- `round_N_ge_ge_midp` → (no match)\n- `round_N_le_le_midp` → (no match)\n- `round_N_eq_DN` → (no match)\n- `round_N_eq_DN_pt` → (no match)\n- `round_N_eq_UP` → (no match)\n- `round_N_eq_UP_pt` → (no match)\n- `round_N_plus_ulp_ge` → (no match)\n- `round_N_eq_ties` → (no match)\n\n## File: Zaux.v\n- Coq file: Zaux.v\n- Lean file(s): Zaux.lean\n\n### Coq Declarations\n- Theorem: `Zopp_le_cancel`\n- Theorem: `Zgt_not_eq`\n- Lemma: `eqbool_irrelevance`\n- Theorem: `Zeven_ex`\n- Theorem: `Zpower_plus`\n- Theorem: `Zpower_Zpower_nat`\n- Theorem: `Zpower_nat_S`\n- Theorem: `Zpower_pos_gt_0`\n- Theorem: `Zeven_Zpower_odd`\n- Theorem: `radix_val_inj`\n- Theorem: `radix_gt_0`\n- Theorem: `radix_gt_1`\n- Theorem: `Zpower_gt_1`\n- Theorem: `Zpower_gt_0`\n- Theorem: `Zpower_ge_0`\n- Theorem: `Zpower_le`\n- Theorem: `Zpower_lt`\n- Theorem: `Zpower_lt_Zpower`\n- Theorem: `Zpower_gt_id`\n- Theorem: `Zmod_mod_mult`\n- Theorem: `ZOmod_eq`\n- Theorem: `ZOmod_mod_mult`\n- Theorem: `Zdiv_mod_mult`\n- Theorem: `ZOdiv_mod_mult`\n- Theorem: `ZOdiv_small_abs`\n- Theorem: `ZOmod_small_abs`\n- Theorem: `ZOdiv_plus`\n- Theorem: `Zsame_sign_trans`\n- Theorem: `Zsame_sign_trans_weak`\n- Theorem: `Zsame_sign_imp`\n- Theorem: `Zsame_sign_odiv`\n- Theorem: `Zeq_bool_spec`\n- Theorem: `Zeq_bool_true`\n- Theorem: `Zeq_bool_false`\n- Theorem: `Zeq_bool_diag`\n- Theorem: `Zeq_bool_opp`\n- Theorem: `Zeq_bool_opp'`\n- Theorem: `Zle_bool_spec`\n- Theorem: `Zle_bool_true`\n- Theorem: `Zle_bool_false`\n- Theorem: `Zle_bool_opp_l`\n- Theorem: `Zle_bool_opp`\n- Theorem: `Zle_bool_opp_r`\n- Theorem: `Zlt_bool_spec`\n- Theorem: `Zlt_bool_true`\n- Theorem: `Zlt_bool_false`\n- Theorem: `negb_Zle_bool`\n- Theorem: `negb_Zlt_bool`\n- Theorem: `Zlt_bool_opp_l`\n- Theorem: `Zlt_bool_opp_r`\n- Theorem: `Zlt_bool_opp`\n- Theorem: `Zcompare_spec`\n- Theorem: `Zcompare_Lt`\n- Theorem: `Zcompare_Eq`\n- Theorem: `Zcompare_Gt`\n- Theorem: `cond_Zopp_0`\n- Theorem: `cond_Zopp_negb`\n- Theorem: `abs_cond_Zopp`\n- Theorem: `cond_Zopp_Zlt_bool`\n- Theorem: `Zeq_bool_cond_Zopp`\n- Theorem: `Zfast_pow_pos_correct`\n- Lemma: `Zdiv_eucl_unique`\n- Lemma: `Zpos_div_eucl_aux1_correct`\n- Lemma: `Zpos_div_eucl_aux_correct`\n- Theorem: `Zfast_div_eucl_correct`\n- Lemma: `iter_nat_plus`\n- Lemma: `iter_nat_S`\n- Lemma: `iter_pos_nat`\n\n### Lean Declarations\n- theorem: `Zopp_le_cancel_spec`\n- theorem: `Zgt_not_eq_spec`\n- theorem: `eqbool_irrelevance_spec`\n- theorem: `Zeven_ex_spec`\n- theorem: `Zpower_plus_spec`\n- theorem: `Zpower_Zpower_nat_spec`\n- theorem: `Zpower_nat_S_spec`\n- theorem: `Zmod_mod_mult_spec`\n- theorem: `ZOmod_eq_spec`\n- theorem: `Zdiv_mod_mult_spec`\n- theorem: `ZOmod_mod_mult_spec`\n- theorem: `ZOdiv_plus_spec`\n- theorem: `Zeq_bool_spec`\n- theorem: `Zle_bool_spec`\n- theorem: `Zlt_bool_spec`\n- theorem: `Zeq_bool_true_spec`\n- theorem: `Zeq_bool_false_spec`\n- theorem: `Zeq_bool_diag_spec`\n- theorem: `Zeq_bool_opp_spec`\n- theorem: `Zeq_bool_opp`\n- theorem: `Zle_bool_true_spec`\n- theorem: `Zle_bool_false_spec`\n- theorem: `Zle_bool_opp_l_spec`\n- theorem: `Zle_bool_opp_spec`\n- theorem: `Zle_bool_opp_r_spec`\n- theorem: `negb_Zle_bool_spec`\n- theorem: `negb_Zlt_bool_spec`\n- theorem: `Zlt_bool_true_spec`\n- theorem: `Zlt_bool_false_spec`\n- theorem: `Zlt_bool_opp_l_spec`\n- theorem: `Zlt_bool_opp_r_spec`\n- theorem: `Zlt_bool_opp_spec`\n- theorem: `Zcompare_spec`\n- theorem: `Zcompare_Lt_spec`\n- theorem: `Zcompare_Eq_spec`\n- theorem: `Zcompare_Gt_spec`\n- theorem: `cond_Zopp_spec`\n- theorem: `cond_Zopp_0_spec`\n- theorem: `cond_Zopp_negb_spec`\n- theorem: `abs_cond_Zopp_spec`\n- theorem: `cond_Zopp_Zlt_bool_spec`\n- theorem: `Zeq_bool_cond_Zopp_spec`\n- theorem: `Zfast_pow_pos_spec`\n- theorem: `Zfast_div_eucl_spec`\n- theorem: `iter_nat_spec`\n- theorem: `iter_nat_S_spec`\n- theorem: `iter_nat_plus_spec`\n- theorem: `iter_pos_nat_spec`\n\n### Mapping (Coq → Lean)\n- `Zopp_le_cancel` → `Zopp_le_cancel_spec` (substring-name)\n- `Zgt_not_eq` → `Zgt_not_eq_spec` (substring-name)\n- `eqbool_irrelevance` → `eqbool_irrelevance_spec` (substring-name)\n- `Zeven_ex` → `Zeven_ex_spec` (substring-name)\n- `Zpower_plus` → `Zpower_plus_spec` (substring-name)\n- `Zpower_Zpower_nat` → `Zpower_Zpower_nat_spec` (substring-name)\n- `Zpower_nat_S` → `Zpower_Zpower_nat_spec` (substring-name)\n- `Zpower_pos_gt_0` → (no match)\n- `Zeven_Zpower_odd` → (no match)\n- `radix_val_inj` → (no match)\n- `radix_gt_0` → (no match)\n- `radix_gt_1` → (no match)\n- `Zpower_gt_1` → (no match)\n- `Zpower_gt_0` → (no match)\n- `Zpower_ge_0` → (no match)\n- `Zpower_le` → (no match)\n- `Zpower_lt` → (no match)\n- `Zpower_lt_Zpower` → (no match)\n- `Zpower_gt_id` → (no match)\n- `Zmod_mod_mult` → `Zmod_mod_mult_spec` (substring-name)\n- `ZOmod_eq` → `ZOmod_eq_spec` (substring-name)\n- `ZOmod_mod_mult` → `ZOmod_mod_mult_spec` (substring-name)\n- `Zdiv_mod_mult` → `Zdiv_mod_mult_spec` (substring-name)\n- `ZOdiv_mod_mult` → (no match)\n- `ZOdiv_small_abs` → (no match)\n- `ZOmod_small_abs` → (no match)\n- `ZOdiv_plus` → `ZOdiv_plus_spec` (substring-name)\n- `Zsame_sign_trans` → (no match)\n- `Zsame_sign_trans_weak` → (no match)\n- `Zsame_sign_imp` → (no match)\n- `Zsame_sign_odiv` → (no match)\n- `Zeq_bool_spec` → `Zeq_bool_spec` (exact-name)\n- `Zeq_bool_true` → `Zeq_bool_true_spec` (substring-name)\n- `Zeq_bool_false` → `Zeq_bool_false_spec` (substring-name)\n- `Zeq_bool_diag` → `Zeq_bool_diag_spec` (substring-name)\n- `Zeq_bool_opp` → `Zeq_bool_opp` (exact-name)\n- `Zeq_bool_opp'` → `Zeq_bool_opp` (normalized-name)\n- `Zle_bool_spec` → `Zle_bool_spec` (exact-name)\n- `Zle_bool_true` → `Zle_bool_true_spec` (substring-name)\n- `Zle_bool_false` → `Zle_bool_false_spec` (substring-name)\n- `Zle_bool_opp_l` → `Zle_bool_opp_l_spec` (substring-name)\n- `Zle_bool_opp` → `Zle_bool_opp_l_spec` (substring-name)\n- `Zle_bool_opp_r` → `Zle_bool_opp_r_spec` (substring-name)\n- `Zlt_bool_spec` → `Zlt_bool_spec` (exact-name)\n- `Zlt_bool_true` → `Zlt_bool_true_spec` (substring-name)\n- `Zlt_bool_false` → `Zlt_bool_false_spec` (substring-name)\n- `negb_Zle_bool` → `negb_Zle_bool_spec` (substring-name)\n- `negb_Zlt_bool` → `negb_Zlt_bool_spec` (substring-name)\n- `Zlt_bool_opp_l` → `Zlt_bool_opp_l_spec` (substring-name)\n- `Zlt_bool_opp_r` → `Zlt_bool_opp_r_spec` (substring-name)\n- `Zlt_bool_opp` → `Zlt_bool_opp_l_spec` (substring-name)\n- `Zcompare_spec` → `Zcompare_spec` (exact-name)\n- `Zcompare_Lt` → `Zcompare_Lt_spec` (substring-name)\n- `Zcompare_Eq` → `Zcompare_Eq_spec` (substring-name)\n- `Zcompare_Gt` → `Zcompare_Gt_spec` (substring-name)\n- `cond_Zopp_0` → `cond_Zopp_0_spec` (substring-name)\n- `cond_Zopp_negb` → `cond_Zopp_negb_spec` (substring-name)\n- `abs_cond_Zopp` → `abs_cond_Zopp_spec` (substring-name)\n- `cond_Zopp_Zlt_bool` → `cond_Zopp_Zlt_bool_spec` (substring-name)\n- `Zeq_bool_cond_Zopp` → `Zeq_bool_cond_Zopp_spec` (substring-name)\n- `Zfast_pow_pos_correct` → (no match)\n- `Zdiv_eucl_unique` → (no match)\n- `Zpos_div_eucl_aux1_correct` → (no match)\n- `Zpos_div_eucl_aux_correct` → (no match)\n- `Zfast_div_eucl_correct` → (no match)\n- `iter_nat_plus` → `iter_nat_plus_spec` (substring-name)\n- `iter_nat_S` → `iter_nat_spec` (substring-name)\n- `iter_pos_nat` → `iter_pos_nat_spec` (substring-name)\n"
  }
}
[2025-09-16T03:11:00] tokens used: 7190
[2025-09-16T03:11:07] thinking

**Clarifying the user's task**

The user's request involves introducing missing theorems in a file within FloatSpec/src/Core, but they didn’t specify which file to target. I might need to ask them which file they’d like to focus on. However, I can suggest a starting point with a file that has missing theorems, such as FIX, FLT, or FLZ. But I need to confirm with them first which file they'd prefer we start with.
[2025-09-16T03:11:09] codex

Next, I’ll open the pipeline and CLAUDE docs to confirm the hoare triple syntax used for these specs.
[2025-09-16T03:11:09] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/PIPELINE.md","annotate_lines":false})
[2025-09-16T03:11:09] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/PIPELINE.md","annotate_lines":false}) success in 3ms:
{
  "content": [
    {
      "text": "# FloatSpec Proof Writing Pipeline\n\n## Key Insights from BooleanComparisons Proof Writing Experience\n\n### 1. The `decide` Pattern for Bool/Prop Compatibility\n**Critical Discovery**: When writing Hoare triple specifications that return `Bool`, the postcondition must use `decide` to convert from `Prop` to `Bool`.\n\n```lean\n-- WRONG: Type mismatch between Bool and Prop\ntheorem Zeq_bool_spec (x y : Int) :\n    ⦃⌜True⌝⦄\n    Zeq_bool x y\n    ⦃⇓result => ⌜result = (x = y)⌝⦄  -- Error: (x = y) is Prop, not Bool\n\n-- CORRECT: Using decide for proper type conversion\ntheorem Zeq_bool_spec (x y : Int) :\n    ⦃⌜True⌝⦄\n    Zeq_bool x y\n    ⦃⇓result => ⌜result = decide (x = y)⌝⦄  -- decide converts Prop to Bool\n```\n\n### 2. Standard Proof Pattern for Simple Specifications\n\nFor functions that directly compute their specified result, use this pattern:\n\n```lean\ntheorem function_spec (params) :\n    ⦃⌜precondition⌝⦄\n    function_call\n    ⦃⇓result => ⌜postcondition⌝⦄ := by\n  intro _              -- Introduce precondition (use _ if not needed)\n  unfold function_name -- Unfold the function definition\n  rfl                  -- Reflexivity completes the proof\n```\n\n### 3. Incremental Verification Strategy\n\n**ALWAYS** check compilation after EACH proof, not after completing a batch:\n1. Write ONE proof\n2. Check compilation with `mcp__lean-lsp-mcp__lean_diagnostic_messages`\n3. Fix any errors immediately\n4. Only then proceed to the next proof\n\nThis prevents cascading errors and makes debugging much easier.\n\n### 4. Common Patterns in Boolean Comparison Proofs\n\n#### Pattern A: Direct Boolean Computation\nFunctions that return `decide (condition)` can be proved with just `unfold` and `rfl`:\n```lean\ndef Zeq_bool (x y : Int) : Id Bool := decide (x = y)\n-- Proof: intro _, unfold Zeq_bool, rfl\n```\n\n#### Pattern B: Constant Return Functions\nFunctions that always return a constant need only `unfold` and `rfl`:\n```lean\ndef Zeq_bool_true (_ _ : Int) : Id Bool := true\n-- Proof: intro _, unfold Zeq_bool_true, rfl\n```\n\n#### Pattern C: Boolean Property Verification\nFunctions that verify properties (returning `decide (property)`) follow the same pattern:\n```lean\ndef Zle_bool_opp (x y : Int) : Id Bool := decide ((- x ≤ - y) = (y ≤ x))\n-- Proof: intro _, unfold Zle_bool_opp, rfl\n```\n\n### 5. Type-Checking Hints\n\nWhen Lean reports type mismatches involving `Bool` and `Prop`:\n- If comparing booleans with propositions, use `decide` \n- If the function returns `Bool` but you're asserting a `Prop`, wrap with `decide`\n- Remember: `decide : Prop → Bool` for decidable propositions\n\n### 6. Hoare Triple Syntax Reminder\n\nThe Hoare triple syntax in this project:\n```lean\n⦃⌜precondition⌝⦄    -- Precondition (Prop)\ncomputation          -- The computation being specified\n⦃⇓result => ⌜postcondition using result⌝⦄  -- Postcondition\n```\n\nThe `⇓result =>` binds the computation's result for use in the postcondition.\n\n### 7. Proof Development Workflow\n\n1. **Read the function implementation** - Understand what it actually does\n2. **Check the specification** - Ensure it matches the implementation\n3. **Identify the proof pattern** - Most simple functions use the standard pattern\n4. **Write the proof** - Start with the standard pattern\n5. **Compile immediately** - Don't accumulate unverified proofs\n6. **Fix type issues** - Usually involves adding `decide` for Bool/Prop conversions\n\n### 8. When Proofs Get Complex\n\nFor more complex proofs (like `Zfast_div_eucl_spec`), additional tactics may be needed:\n- `split` for case analysis on if-then-else\n- `have` for intermediate results  \n- `calc` for calculation chains\n- `simp` for simplification\n- Named hypothesis introduction with `intro h` instead of `intro _`\n\nBut start simple - many proofs just need `intro _, unfold, rfl`.\n\n## Digits Proofs Playbook (Core Lessons + Steps)\n\nThis section distills what worked when proving theorems in `FloatSpec/src/Core/Digits.lean` (e.g., `digits2_Pnat_correct`) and similar arithmetic specs.\n\n### A. Strategy Patterns That Worked Well\n\n- Pure-helper equality: Prove that the monadic program equals a pure function, then reduce the Hoare triple to a pure proposition.\n  - Example: define a total helper `bits : Nat → Nat` mirroring the recursion and prove `digits2_Pnat n = pure (bits n)` via `Nat.strongRecOn`.\n- Strong induction with divide-by-2: Use `Nat.strongRecOn` + split by `n = 2*(n/2) + n%2`.\n  - Lemma to reuse: `split2 (n) : n = 2 * (n / 2) + n % 2 ∧ n % 2 < 2` (wraps `Nat.div_add_mod`).\n  - Strict decrease: `((k+1)/2) < (k+1)` via `Nat.div_lt_self`.\n- Calc over simp for tricky rewrites: Prefer explicit `calc` chains to avoid `simp` recursion blowups.\n  - Rewrite helpers that avoid loops:\n    - `2^(k+1) = 2 * 2^k` (`Nat.pow_succ`).\n    - If `k > 0`, then `2^k = 2 * 2^(k-1)` (index manipulation via `Nat.sub_add_cancel`).\n    - `2*m + 2 = 2*(m+1)` via a short `calc` using `Nat.mul_add` rather than `simp`.\n- Index translation for recursive definitions: When you have `bits (n) = 1 + bits (n/2)`, translate bounds using an explicit index identity like `(1 + x) - 1 = x`.\n\n### B. Minimal Lemmas To Scaffold Arithmetic Proofs\n\n- `bits_succ`: `bits (k + 1) = 1 + bits ((k + 1) / 2)` (by `simp` on the definition).\n- `digits2_eq_bits`: `digits2_Pnat n = pure (bits n)` (by `Nat.strongRecOn`, apply recursion on `(n+1)/2`).\n- `split2`: `n = 2*(n/2) + n%2 ∧ n%2 < 2` (wrap `Nat.div_add_mod`).\n- `div2_lt_self_succ`: `((k+1)/2) < (k+1)` (via `Nat.div_lt_self`).\n- Power rewrites: `2^(k+1) = 2 * 2^k`, and for `k>0`, `2^k = 2 * 2^(k-1)`.\n\n### C. Hoare Triples: Reducing to Pure Facts\n\nFor `⦃P⦄ prog ⦃⇓d => Q d⦄`, if you can show `prog = pure f`, rewrite the triple to prove `Q (f)` under `P`. This keeps executable specs clean and proofs robust.\n\n### D. Common Pitfalls + Fixes\n\n- `simp` recursion depth reached: Replace with explicit `calc` and small helper equalities; avoid heavy `simpa` chains over composite equalities.\n- Nat index off-by-one: Use explicit equalities like `((k-1)+1 = k)` to move between `2^k` and `2^(k-1)` safely.\n- When rewriting `n` via `n = 2*m + r`, make all later rewrites refer back to this named equality to avoid goal drift.\n\n### E. Restart Checklist (Context-Free Boot Sequence)\n\nUse this when picking up proofs without prior context:\n\n1) Read: `PIPELINE.md` (this file) and `CLAUDE.md` (mvcgen + proof notes).\n2) Build once: `lake build` to surface current error locations.\n3) Pick one target theorem only; do not batch.\n4) Verify the function body and spec match (do not change triple syntax unless necessary).\n5) If the proof is complex, sketch helper lemmas first (see B), prove them, build.\n6) Reduce monadic specs to pure goals via a helper equality if applicable.\n7) Prefer `calc` + small rewrites over aggressive `simp/simpa` on composite goals.\n8) After every small step: build. Fix issues immediately.\n9) If stuck on an algebraic step: add a tiny lemma with a direct proof rather than fighting `simp`.\n10) Keep the “one-proof-at-a-time” rhythm until the file compiles cleanly.\n\n### F. Commands / Quick Actions\n\n- Build project: `lake build`\n- Locate diagnostics (LSP): use your editor’s Lean diagnostics pane; keep the loop fast.\n- Search for prior lemmas in the file to avoid duplicate work.\n\nFollowing this playbook consistently kept proofs small, maintainable, and debuggable.\n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "# FloatSpec Proof Writing Pipeline\n\n## Key Insights from BooleanComparisons Proof Writing Experience\n\n### 1. The `decide` Pattern for Bool/Prop Compatibility\n**Critical Discovery**: When writing Hoare triple specifications that return `Bool`, the postcondition must use `decide` to convert from `Prop` to `Bool`.\n\n```lean\n-- WRONG: Type mismatch between Bool and Prop\ntheorem Zeq_bool_spec (x y : Int) :\n    ⦃⌜True⌝⦄\n    Zeq_bool x y\n    ⦃⇓result => ⌜result = (x = y)⌝⦄  -- Error: (x = y) is Prop, not Bool\n\n-- CORRECT: Using decide for proper type conversion\ntheorem Zeq_bool_spec (x y : Int) :\n    ⦃⌜True⌝⦄\n    Zeq_bool x y\n    ⦃⇓result => ⌜result = decide (x = y)⌝⦄  -- decide converts Prop to Bool\n```\n\n### 2. Standard Proof Pattern for Simple Specifications\n\nFor functions that directly compute their specified result, use this pattern:\n\n```lean\ntheorem function_spec (params) :\n    ⦃⌜precondition⌝⦄\n    function_call\n    ⦃⇓result => ⌜postcondition⌝⦄ := by\n  intro _              -- Introduce precondition (use _ if not needed)\n  unfold function_name -- Unfold the function definition\n  rfl                  -- Reflexivity completes the proof\n```\n\n### 3. Incremental Verification Strategy\n\n**ALWAYS** check compilation after EACH proof, not after completing a batch:\n1. Write ONE proof\n2. Check compilation with `mcp__lean-lsp-mcp__lean_diagnostic_messages`\n3. Fix any errors immediately\n4. Only then proceed to the next proof\n\nThis prevents cascading errors and makes debugging much easier.\n\n### 4. Common Patterns in Boolean Comparison Proofs\n\n#### Pattern A: Direct Boolean Computation\nFunctions that return `decide (condition)` can be proved with just `unfold` and `rfl`:\n```lean\ndef Zeq_bool (x y : Int) : Id Bool := decide (x = y)\n-- Proof: intro _, unfold Zeq_bool, rfl\n```\n\n#### Pattern B: Constant Return Functions\nFunctions that always return a constant need only `unfold` and `rfl`:\n```lean\ndef Zeq_bool_true (_ _ : Int) : Id Bool := true\n-- Proof: intro _, unfold Zeq_bool_true, rfl\n```\n\n#### Pattern C: Boolean Property Verification\nFunctions that verify properties (returning `decide (property)`) follow the same pattern:\n```lean\ndef Zle_bool_opp (x y : Int) : Id Bool := decide ((- x ≤ - y) = (y ≤ x))\n-- Proof: intro _, unfold Zle_bool_opp, rfl\n```\n\n### 5. Type-Checking Hints\n\nWhen Lean reports type mismatches involving `Bool` and `Prop`:\n- If comparing booleans with propositions, use `decide` \n- If the function returns `Bool` but you're asserting a `Prop`, wrap with `decide`\n- Remember: `decide : Prop → Bool` for decidable propositions\n\n### 6. Hoare Triple Syntax Reminder\n\nThe Hoare triple syntax in this project:\n```lean\n⦃⌜precondition⌝⦄    -- Precondition (Prop)\ncomputation          -- The computation being specified\n⦃⇓result => ⌜postcondition using result⌝⦄  -- Postcondition\n```\n\nThe `⇓result =>` binds the computation's result for use in the postcondition.\n\n### 7. Proof Development Workflow\n\n1. **Read the function implementation** - Understand what it actually does\n2. **Check the specification** - Ensure it matches the implementation\n3. **Identify the proof pattern** - Most simple functions use the standard pattern\n4. **Write the proof** - Start with the standard pattern\n5. **Compile immediately** - Don't accumulate unverified proofs\n6. **Fix type issues** - Usually involves adding `decide` for Bool/Prop conversions\n\n### 8. When Proofs Get Complex\n\nFor more complex proofs (like `Zfast_div_eucl_spec`), additional tactics may be needed:\n- `split` for case analysis on if-then-else\n- `have` for intermediate results  \n- `calc` for calculation chains\n- `simp` for simplification\n- Named hypothesis introduction with `intro h` instead of `intro _`\n\nBut start simple - many proofs just need `intro _, unfold, rfl`.\n\n## Digits Proofs Playbook (Core Lessons + Steps)\n\nThis section distills what worked when proving theorems in `FloatSpec/src/Core/Digits.lean` (e.g., `digits2_Pnat_correct`) and similar arithmetic specs.\n\n### A. Strategy Patterns That Worked Well\n\n- Pure-helper equality: Prove that the monadic program equals a pure function, then reduce the Hoare triple to a pure proposition.\n  - Example: define a total helper `bits : Nat → Nat` mirroring the recursion and prove `digits2_Pnat n = pure (bits n)` via `Nat.strongRecOn`.\n- Strong induction with divide-by-2: Use `Nat.strongRecOn` + split by `n = 2*(n/2) + n%2`.\n  - Lemma to reuse: `split2 (n) : n = 2 * (n / 2) + n % 2 ∧ n % 2 < 2` (wraps `Nat.div_add_mod`).\n  - Strict decrease: `((k+1)/2) < (k+1)` via `Nat.div_lt_self`.\n- Calc over simp for tricky rewrites: Prefer explicit `calc` chains to avoid `simp` recursion blowups.\n  - Rewrite helpers that avoid loops:\n    - `2^(k+1) = 2 * 2^k` (`Nat.pow_succ`).\n    - If `k > 0`, then `2^k = 2 * 2^(k-1)` (index manipulation via `Nat.sub_add_cancel`).\n    - `2*m + 2 = 2*(m+1)` via a short `calc` using `Nat.mul_add` rather than `simp`.\n- Index translation for recursive definitions: When you have `bits (n) = 1 + bits (n/2)`, translate bounds using an explicit index identity like `(1 + x) - 1 = x`.\n\n### B. Minimal Lemmas To Scaffold Arithmetic Proofs\n\n- `bits_succ`: `bits (k + 1) = 1 + bits ((k + 1) / 2)` (by `simp` on the definition).\n- `digits2_eq_bits`: `digits2_Pnat n = pure (bits n)` (by `Nat.strongRecOn`, apply recursion on `(n+1)/2`).\n- `split2`: `n = 2*(n/2) + n%2 ∧ n%2 < 2` (wrap `Nat.div_add_mod`).\n- `div2_lt_self_succ`: `((k+1)/2) < (k+1)` (via `Nat.div_lt_self`).\n- Power rewrites: `2^(k+1) = 2 * 2^k`, and for `k>0`, `2^k = 2 * 2^(k-1)`.\n\n### C. Hoare Triples: Reducing to Pure Facts\n\nFor `⦃P⦄ prog ⦃⇓d => Q d⦄`, if you can show `prog = pure f`, rewrite the triple to prove `Q (f)` under `P`. This keeps executable specs clean and proofs robust.\n\n### D. Common Pitfalls + Fixes\n\n- `simp` recursion depth reached: Replace with explicit `calc` and small helper equalities; avoid heavy `simpa` chains over composite equalities.\n- Nat index off-by-one: Use explicit equalities like `((k-1)+1 = k)` to move between `2^k` and `2^(k-1)` safely.\n- When rewriting `n` via `n = 2*m + r`, make all later rewrites refer back to this named equality to avoid goal drift.\n\n### E. Restart Checklist (Context-Free Boot Sequence)\n\nUse this when picking up proofs without prior context:\n\n1) Read: `PIPELINE.md` (this file) and `CLAUDE.md` (mvcgen + proof notes).\n2) Build once: `lake build` to surface current error locations.\n3) Pick one target theorem only; do not batch.\n4) Verify the function body and spec match (do not change triple syntax unless necessary).\n5) If the proof is complex, sketch helper lemmas first (see B), prove them, build.\n6) Reduce monadic specs to pure goals via a helper equality if applicable.\n7) Prefer `calc` + small rewrites over aggressive `simp/simpa` on composite goals.\n8) After every small step: build. Fix issues immediately.\n9) If stuck on an algebraic step: add a tiny lemma with a direct proof rather than fighting `simp`.\n10) Keep the “one-proof-at-a-time” rhythm until the file compiles cleanly.\n\n### F. Commands / Quick Actions\n\n- Build project: `lake build`\n- Locate diagnostics (LSP): use your editor’s Lean diagnostics pane; keep the loop fast.\n- Search for prior lemmas in the file to avoid duplicate work.\n\nFollowing this playbook consistently kept proofs small, maintainable, and debuggable.\n"
  }
}
[2025-09-16T03:11:10] tokens used: 30701
[2025-09-16T03:11:13] tool lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/CLAUDE.md","annotate_lines":false})
[2025-09-16T03:11:13] lean-lsp-mcp.lean_file_contents({"file_path":"/Users/louhantao/Desktop/code/semester_6.5/FloatSpec/CLAUDE.md","annotate_lines":false}) success in 71ms:
{
  "content": [
    {
      "text": "# FloatSpec Project Overview\n\nYou are a functional programmer working in Lean 4.\n\n**Main Goal**: Create a provable Lean float implementation with formal verification. Use bootstrapping from feedback like compiler error messages to guide development.\n\n## IMPORTANT: \"Keep Going\" Context\n\nIf you're told to \"keep going\" without context, you're likely working on:\n1. **Float Implementation** - Developing provable floating-point arithmetic\n2. **Specification Writing** - Creating formal specifications for float operations\n3. **Test Writing** - Add more property-based tests using Plausible\n\n## General Programming Philosophy\n\nProgramming is about onomastics (naming), composition (functoriality), and caching. Think conformally at every scale and across scales.\n\nBuild a pit of success: internal systems that grow as a whole outwards, never allowing the fallible external world to leak in except at boundaries. Meet the external world at well-defined interfaces.\n\nWhen solving problems, write tooling/linters/auto-fixers to widen the pit of success. Use rigid compiler error messages and linter warnings to guide future users (**including** AI) toward correct solutions.\n\nFavor statically typed functional programming but use mutability where it makes sense or is easier to port.\n\n## Project Structure\n\n- `FloatSpec.lean` and `FloatSpec/` directory - core float functionality and specifications.\n- `lakefile.lean` - Lean 4 project configuration.\n\n## Development Commands\n\n**`just` is our main program runner.** It provides a unified interface for all common development tasks. Run `just` without arguments to see all available commands.\n\nKey commands:\n- `just build` - Build Lean project\n- `just test` - Run the Python test suite  \n- `just bootstrap` - Bootstrap developer environment (Rust, Elan, UV)\n\nYou can also run underlying tools directly:\n- `lake build` - Build Lean project (use frequently for constant feedback)\n- `uv run -m pytest` - Run Python tests directly\n\n## Commit Logging Process\n\nAfter making a commit, create a log entry:\n\n1. Create timestamped directory: `.log/YYYYMMDD_HHMMSS/`\n2. Store commit information:\n   - `change_stats.txt` - Basic change statistics (see `.log/20250808_102956/change_stats.txt` for an example)\n   - `change_stats.txt` - Basic commit metadata (hash, author, date, subject)\n   - `full_diff.txt` - Full diff of changes (see `.log/20250808_102956/full_diff.txt` for an example)\n   - `detailed_changelog.md` - Detailed summary of changes and their impact (see `.log/20250808_102956/detailed_changelog.md` for an example)\n\nThis provides a searchable history of all significant changes to the codebase.\n\n### Recent Commits\n\n- **2025-08-08 10:29:56** - Replace Float with Real (ℝ) throughout codebase\n  - Major architectural fix replacing Lean's Float with mathematical reals\n  - 54 files changed across entire codebase\n  - See `.log/20250808_102956/` for details\n\nUse `uvx lean-lsp-mcp` to get feedback on your code (primary workflow). Prefer these tools for fast, local diagnostics after every change; use `lake build` for broader checks or when you need a full project build.\n\nUsage:\n\n- `lean_diagnostic_messages`: Get all diagnostic messages for a Lean file. This includes infos, warnings and errors.\n\n```text\nExample output\nl20c42-l20c46, severity: 1\nsimp made no progress\n\nl21c11-l21c45, severity: 1\nfunction expected at h_empty term has type T ∩ compl T = ∅\n```\n\n- `lean_goal`: Get the proof goal at a specific location (line or line & column) in a Lean file.\n\nExample output (line):\n\n```text\nBefore:\nS : Type u_1\ninst✝¹ : Fintype S\ninst✝ : Nonempty S\nP : Finset (Set S)\nhPP : ∀ T ∈ P, ∀ U ∈ P, T ∩ U ≠ ∅\nhPS : ¬∃ T ∉ P, ∀ U ∈ P, T ∩ U ≠ ∅\ncompl : Set S → Set S := fun T ↦ univ \\ T\nhcompl : ∀ T ∈ P, compl T ∉ P\nall_subsets : Finset (Set S) := Finset.univ\nh_comp_in_P : ∀ T ∉ P, compl T ∈ P\nh_partition : ∀ (T : Set S), T ∈ P ∨ compl T ∈ P\n⊢ P.card = 2 ^ (Fintype.card S - 1)\nAfter:\nno goals\n```\n\n- `lean_term_goal`: Get the term goal at a specific position (line & column) in a Lean file.\n\n- `lean_hover_info`: Retrieve hover information (documentation) for symbols, terms, and expressions in a Lean file (at a specific line & column).\n\nExample output (hover info on a `sorry`):\n\n```text\nThe `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses sorry, so you aren't likely to miss it,\nbut you can double check if a theorem depends on sorry by looking for sorryAx in the output\nof the #print axioms my_thm command, the axiom used by the implementation of sorry.\n```\n\n- `lean_declaration_file`: Get the file contents where a symbol or term is declared. Use this to find the definition of a symbol.\n\n- `lean_completions`: Code auto-completion: Find available identifiers or import suggestions at a specific position (line & column) in a Lean file. Use this to fill in program fragments.\n\n- `lean_multi_attempt`:  Attempt multiple lean code snippets on a line and return goal state and diagnostics for each snippet. This tool is useful to screen different attempts before using the most promising one.\n\n```text\nExample output (attempting `rw [Nat.pow_sub (Fintype.card_pos_of_nonempty S)]` and `by_contra h_neq`)\nrw [Nat.pow_sub (Fintype.card_pos_of_nonempty S)]:\nS : Type u_1\ninst✝¹ : Fintype S\ninst✝ : Nonempty S\nP : Finset (Set S)\nhPP : ∀ T ∈ P, ∀ U ∈ P, T ∩ U ≠ ∅\nhPS : ¬∃ T ∉ P, ∀ U ∈ P, T ∩ U ≠ ∅\n⊢ P.card = 2 ^ (Fintype.card S - 1)\n\nl14c7-l14c51, severity: 1\nunknown constant 'Nat.pow_sub'\n\nby_contra h_neq:\nS : Type u_1\ninst✝¹ : Fintype S\ninst✝ : Nonempty S\nP : Finset (Set S)\nhPP : ∀ T ∈ P, ∀ U ∈ P, T ∩ U ≠ ∅\nhPS : ¬∃ T ∉ P, ∀ U ∈ P, T ∩ U ≠ ∅\nh_neq : ¬P.card = 2 ^ (Fintype.card S - 1)\n⊢ False\n```\n\n### Building and Testing\n\n```bash\n# Build using just (recommended)\njust build        # Build Lean project\njust test         # Run Python tests\n\n# Or use direct commands:\nlake build        # Full Lean build (slower; use as a cross-check)\nuv run -m pytest -q  # Run tests directly\n\n# Check Lean syntax and types\nlake build --verbose\n```\n\n## Proof Writing Playbook\n\n- One-by-one: Write exactly one proof, run LSP diagnostics immediately (via `lean_lsp_mcp`), fix issues, then move on. Do not batch multiple new proofs without checking.\n- Follow examples: Mirror patterns from existing proofs, especially `Zfast_div_eucl_spec` in `FloatSpec/src/Core/Zaux.lean` and nearby lemmas in the same file you are editing.\n- Before each proof:\n  - Verify the function body is correct and stable.\n  - Check existing specs to understand precisely what needs to be proven.\n  - Preserve specification/Hoare triple syntax; avoid changing it unless absolutely necessary. If change is unavoidable, decompose the spec into simpler lemmas rather than rewriting wholesale.\n- Compilation verification:\n  - After every proof, run `lean_lsp_mcp.lean_diagnostic_messages` for the edited file.\n  - Use `lake build` as a fallback or for a project-wide typecheck.\n  - “Complete” means: no `sorry` in the edited proof and the file typechecks.\n- When stuck:\n  - Search for relevant lemmas with MCP hover/decl tools or Mathlib; if a lemma doesn’t exist, write a small private helper lemma close to the proof.\n  - Decompose complex statements into smaller, local lemmas.\n  - Reference nearby proofs for patterns and naming.\n\n## Practical Lean Tips (FloatSpec)\n\n- Magnitude and logs:\n  - `mag` is defined with `Int.ceil (log (|x|)/log β)`. To get `|x| ≤ β^e`, sandwich `L := log|x|/logβ` and use `Real.log_le_iff_le_exp` plus `Real.log_zpow`.\n  - Keep a clean chain: derive `log |x| ≤ log (β^e)`, then exponentiate; avoid brittle simp rewrites between `exp (e*log β)` and `β^e`—prove equality explicitly using `Real.exp_log` and `Real.log_zpow`.\n- Powers and positivity:\n  - Use `zpow_pos : 0 < a → 0 < a^n` and `abs_of_nonneg` for `a^n` when the base is positive.\n  - Collapse products with `FloatSpec.Core.Generic_fmt.zpow_mul_sub` and reconstruct with `zpow_add₀` or `zpow_sub_add` (requires nonzero base).\n  - For nonnegative exponent `k ≥ 0`, switch to Nat powers via `zpow_nonneg_toNat`.\n- Absolute values with scaling factors:\n  - Prefer `abs (x * y) = |x| * |y|` and ensure `y ≥ 0` so `|y| = y`.\n  - When the scale is `β^(-c)`, consider rewriting as `((β^c)⁻¹)` and use `inv_nonneg.mpr (le_of_lt (zpow_pos …))` to keep monotonicity simple.\n- Integer truncation:\n  - Use `Ztrunc_intCast` and `Ztrunc_zero` to compute truncations on integer-valued expressions.\n- Calc blocks over heavy simp:\n  - Prefer explicit `calc`/`have` chains with named lemmas instead of relying on `simp` to bridge nondefinitional equalities (especially around `log/exp`, `zpow`, and `abs`).\n\n## Plan + Preambles (for AI agents)\n\n- Maintain a short, evolving plan (use the `update_plan` tool) with exactly one `in_progress` step.\n- Before grouped tool calls, write a concise 1–2 sentence preamble explaining what you are about to do.\n- Share progress updates after nontrivial steps, and re-align the plan if scope changes.\n\n## Quality Bar\n\n- 30-second reality check: After each change, be able to answer “yes” to all:\n  - Did I run/build the code (via MCP or `lake build`)?\n  - Did I trigger the exact feature I changed?\n  - Did I see expected results, and check for errors?\n  - Would I bet $100 it works?\n- Phrases to avoid: “should work”, “fixed the issue” (without verification), “try it now” (without running it yourself).\n\n## FloatSpec Roadmap\n\n### 1. Float Representation and Core Operations\n\n- **IEEE 754 compliant types**: Implement single and double precision floating-point numbers\n- **Bit-level representation**: Use `BitVec` for accurate bit-level manipulation\n- **Core arithmetic**: Addition, subtraction, multiplication, division with proper rounding\n\n### 2. Formal Specifications\n\n- **IEEE 754 semantics**: Formalize the IEEE 754 standard in Lean\n- **Error bounds**: Specify and prove error bounds for operations\n- **Special values**: Handle infinities, NaN, and subnormal numbers correctly\n\n### 3. Next Steps\n\n1. **Core types**: Implement IEEE 754 float types with bit-accurate representation\n2. **Property test probe**: Use <https://github.com/leanprover-community/plausible> to test properties of the spec in a cheap way, a sort of Pareto frontier point in between unit tests and formal proofs. Write code with an eye towards generalizing to future use.\n   - [ ] make `lean_lib` in `lakefile.lean` for property tests\n3. **Benchmark & test**: small-scale benchmarks (`#eval`, `timeIt`) for performance validation.\n\n- [ ] investigate `lake bench`\n\n4. **Docs & examples**: <https://github.com/leanprover/verso> is the (meta)-doc tool. It is very extensible.\n   - [ ] add any accumulated verso extensions to `VersoExt`\n     - [ ] update `lakefile.lean` to include `VersoExt`\n\n## Lean 4 Development Guidelines\n\n- Use named holes (`?foo`) for incremental development\n- Wrap reserved names in «guillemets» when needed\n- Implement \"notation typeclasses\" like `GetElem`, `Add`, etc where appropriate.\n- Practice \"sorry-friendly programming\": Instead of a comment you put down a spec, but it is only \"proved\" with `sorry`. This is strictly better than a comment, because the typechecker will use it for program generation.\n- Decompose proofs until tools like `canonical`, `grind`, and `simp` dissolve the pieces. Use them to do the \"how\", the AI should do the \"what\".\n- Don't use `i` and `j` as variable names when you could use `r`(ow) and `c`(olumn) instead. Ditto for `m` and `n` as matrix dimensions. Use `R` and `C`.\n\n## Verifying Imperative Programs using mvcgen\n\nThe `mvcgen` tactic implements a monadic verification condition generator that breaks down goals involving imperative programs written using Lean's `do` notation into pure verification conditions.\n\n### Key Features:\n- **Monadic verification**: Handles programs with local mutability, for loops, and early returns\n- **Hoare triple support**: Specifications use the notation `⦃P⦄ prog ⦃Q⦄` for pre/postconditions\n- **Loop invariants**: Supports specifying invariants for loops using zipper data structures\n- **Compositional reasoning**: Allows building specifications for individual monadic functions\n- **Monad transformer stacks**: Works with StateT, ReaderT, ExceptT and custom monad combinations\n\n### Basic Usage Pattern:\n```lean\ntheorem program_correct : program_spec := by\n  generalize h : (program args) = result\n  apply MonadType.of_wp_run_eq h  -- Focus on monadic part\n  mvcgen [unfold_hints]           -- Generate verification conditions\n  case inv1 => exact invariant_spec  -- Specify loop invariants\n  all_goals mleave; grind         -- Discharge pure goals\n```\n\n### Loop Invariants:\n- Use zipper data structures (`xs.pref` for processed elements, `xs.suff` for remaining)\n- Early returns supported with `Invariant.withEarlyReturn`\n- State-dependent invariants can reference monadic state through function arguments\n\nThis approach scales to complex imperative programs while maintaining compositional reasoning and avoiding the need to replicate control flow in proofs.\n### Import and Module Structure\n\n- Imports MUST come before any syntax elements, including module and doc comments\n  - [ ] set extensible error messages to suggest a fix for AI. Then remove this admonishment.\n- Set `linter.missingDocs = true` and `relaxedAutoImplicit = false` in `lakefile.lean`.\n\n### Common Errors and Solutions\n\n- **\"unexpected token 'namespace'\"**: Module/doc comment placed incorrectly (should be after imports)\n- **\"unexpected token\"**: Often caused by misplaced docstrings - use multiline comments instead\n  - [ ] use extensible error messages to suggest a fix for AI. Then remove this admonishment.\n- [ ] make a pre-push hook that runs lake build\n\n\n## Python Development Guidelines\n\n- Always use `uv` for Python package management (not pip). Use `uv add` over `uv pip install`, `uv sync`, and `uv run` over `python`. If a tool requires further build integration, use hatch to do it in the `pyproject.toml`.\n\n## Additional Guidelines\n\n- Use `rg` and `fd` instead of grep/find\n- Make atomic commits and use branches liberally\n\n\n## Development Strategies\n\n### Lean 4 Development Approach\n\n- Read the reference manual assiduously. Ultrathink.\n- Figure out the parser by interactively building up toy components.\n- [ ] install https://github.com/GasStationManager/LeanTool as mcp tool\n- Spam `lake build` to verify the pieces work and build up FUNCTORIALLY.\n- **IMPORTANT**: Check compilation with `lake build` every time before marking anything as complete\n- **IMPORTANT**: In Lean 4, `Int.emod` always returns a positive value (Euclidean modulo)\n- Use compiler tooling like extensible error messages, `simproc` (pattern guided reductions), and metaprogramming for pit of success\n- If you solve a hard problem, write a tactic or simproc to pave the way\n- Try harder to index without `!` or `?` - name `match`/`if` branches for better inference\n- Raw string syntax: `r#\"..\"#`, multiline strings use `\\` continuation\n- Use `lakefile.lean` over `lakefile.toml` for better AI introspection and metaprogramming\n- Incorporate positive surprises into memories - stay curious!\n\n### Debugging and Development Process\n\n- Use named holes like `?holeName` for well-typed fragment programs\n- Make mermaid diagrams with labeled edges describing data flow\n- Category theory wiring diagram style for complex systems\n- Apply the scientific method for debugging\n\n## FloatSpec Implementation Progress\n\n### Current Status\n\n- ✓ **Project Setup**: Basic Lean 4 project structure with lakefile.lean\n- ✓ **Build System**: Lake configuration for Lean 4 development\n- ✓ **Zaux.lean**: Complete formalization of auxiliary integer functions (80 functions from Coq)\n\n### Flocq to Lean 4 Transformation Order\n\nBased on the dependency analysis in `Deps/flocq_dependency_graph.dot`, the proper transformation order is:\n\n#### **Phase 1: Core Foundation (Ready Now)**\n1. ✓ **Zaux.lean** - Integer auxiliary functions (completed)\n2. **Raux.lean** - Real auxiliary functions (169 defs) - **NEXT PRIORITY**\n   - Depends on: Zaux\n   - Required by: Most other Core files\n3. **Defs.lean** - Basic definitions (12 defs)\n   - Depends on: Zaux, Raux\n   - Required by: Almost all other files\n\n#### **Phase 2: Core Data Structures (After Phase 1)**\n4. **Digits.lean** - Digit manipulation (62 defs)\n   - Depends on: Zaux\n   - Required by: Float_prop, Generic_fmt, and higher-level operations\n5. **Float_prop.lean** - Basic float properties (36 defs)  \n   - Depends on: Defs, Digits, Raux, Zaux\n   - Required by: Most formatting and rounding operations\n\n#### **Phase 3: Generic Formatting (After Phase 2)**\n6. **Round_pred.lean** - Rounding predicates (78 defs)\n   - Depends on: Defs, Raux\n   - Required by: Generic_fmt, Ulp, Round_NE, FIX, FLX, FLT, FTZ\n7. **Generic_fmt.lean** - Generic formatting (124 defs) - **MAJOR COMPONENT**\n   - Depends on: Defs, Float_prop, Raux, Round_pred, Zaux\n   - Required by: Ulp, Round_NE, FIX, FLX, FLT, FTZ and all higher-level operations\n\n#### **Phase 4: Precision Systems (After Phase 3)**\n8. **Ulp.lean** - Unit in the last place (116 defs)\n9. **Round_NE.lean** - Nearest-even rounding (99 defs) \n10. **FIX.lean** - Fixed-point format (7 defs)\n11. **FLX.lean** - Fixed-precision format (23 defs)\n12. **FLT.lean** - Floating-point format (25 defs)\n13. **FTZ.lean** - Flush-to-zero format (11 defs)\n\n#### **Phase 5: IEEE 754 Implementation (After Phase 4)**\n14. **Core.lean** - Top-level Core module (0 defs, imports all Core files)\n\n#### **Phase 6: Calculations (After Core)**\n15. **Calc/Bracket.lean** - Bracketing operations (37 defs)\n16. **Calc/Operations.lean** - Basic operations (16 defs)\n17. **Calc/Div.lean**, **Calc/Sqrt.lean**, **Calc/Round.lean**, **Calc/Plus.lean**\n\n#### **Phase 7: Properties and IEEE754 (Final)**\n18. **Prop/** modules - Error analysis and properties\n19. **IEEE754/** modules - Full IEEE 754 implementation\n20. **Pff/** modules - Legacy compatibility\n\n### Current Next Steps\n\n**Immediate Priority: Raux.lean**\n- 169 definitions covering real number auxiliary functions\n- Critical dependency for almost all other Core files\n- Should be started immediately after Zaux completion\n\n**Key Dependencies Insight:**\n- Zaux → Raux → Defs forms the foundational triangle\n- Generic_fmt is the central heavyweight component (124 defs)\n- Most IEEE754 functionality requires the complete Core foundation\n- Zaux has the widest fan-out (used by 12/13 Core modules)\n- The dependency graph shows clear layering: Core → Calc → Prop → IEEE754\n- Phase approach minimizes rework and enables parallel development within phases\n\n### Design Principles\n\n- **Correctness First**: Every operation should have formal verification\n- **IEEE 754 Compliance**: Strict adherence to the IEEE 754 standard\n- **Bit-level Accuracy**: Use precise bit-level representations\n- **Type Safety**: Use Lean's type system to prevent numerical errors\n\n## Important Lean Documentation Resources\n\nWhen working with Lean 4, consult these authoritative sources:\n\n- **Lean 4 Official Documentation**: <https://lean-lang.org/lean4/doc> - The formal Lean documentation covering language features, tactics, and standard library\n- **Mathlib Manual**: <https://leanprover-community.github.io/mathlib-manual/html-multi/Guides/> - Comprehensive guide to mathlib conventions, tactics, and best practices\n- **Lean Language Reference**: <https://lean-lang.org/doc/reference/latest/> - The definitive Lean language reference for syntax and semantics\n\n## ✅ COMPLETED: Replace Float with Real (ℝ)\n\n**Issue**: The implementation was using Lean's built-in `Float` type throughout the formalization, which created a circular definition - we were using floating-point numbers to define floating-point numbers!\n\n**Solution Implemented**: Replaced all occurrences of `Float` with `ℝ` (Real) from Mathlib. This matches the original Coq Flocq library which uses `R` (Coq's real number type).\n\n**Files updated**:\n- ✅ All files in `FloatSpec/src/Core/` (Defs.lean, Raux.lean, Float_prop.lean, Round_pred.lean, Generic_fmt.lean, Ulp.lean, Round_NE.lean, FIX.lean, FLX.lean, FLT.lean, FTZ.lean)\n- ✅ All files in `FloatSpec/src/Calc/` (Bracket.lean, Operations.lean, Div.lean, Sqrt.lean, Round.lean, Plus.lean)\n- ✅ All files in `FloatSpec/src/Prop/` (All 7 property files)\n- ✅ All files in `FloatSpec/src/IEEE754/` (Binary.lean, BinarySingleNaN.lean, Bits.lean, PrimFloat.lean)\n- ✅ All files in `FloatSpec/src/Pff/` (Pff.lean, Pff2Flocq.lean, Pff2FlocqAux.lean)\n\n**Changes completed**:\n1. ✅ Added Mathlib dependency to lakefile.lean\n2. ✅ Imported Mathlib's real number support (`import Mathlib.Data.Real.Basic` and `open Real`) in all files\n3. ✅ Replaced `Float` with `ℝ` throughout all type annotations\n4. ✅ Updated absolute value operations from `Float.abs` to `|·|` notation\n5. ✅ Added `noncomputable` to functions involving real number operations\n\nThis fundamental architectural fix has been completed, ensuring the formalization correctly uses mathematical real numbers instead of computational floats.\n\n\n\n## Development Tools and Workflow\n\n### Version Control\n\n**Jujutsu (jj) Setup for GitHub-friendly Development:**\n\n- Use `jj git init --colocate` for existing git repos (recommended for this project)\n- Colocated repos automatically sync jj and git on every command\n- Enables mixing `jj` and `git` commands seamlessly\n- Tools expecting `.git` directory continue to work\n\n**Essential jj configuration:**\n\n```bash\njj config edit --user\n```\n\nAdd these settings:\n\n```toml\n[git]\nauto-local-bookmark = true  # Import all remote bookmarks automatically\n\n[snapshot]  \nauto-update-stale = true    # Auto-update stale working copies when switching contexts\n```\n\n**Key workflow improvements over git:**\n\n- Anonymous branches - no need to name every small change\n- Better conflict resolution and interactive rebase\n- `jj absorb` automatically squashes changes into relevant ancestor commits\n- `jj undo` and `jj op restore` for powerful history manipulation\n- Empty commit on top by default (enables easier experimentation)\n\n**GitHub integration commands:**\n\n- `jj git fetch` + `jj rebase -d main` (replaces `git pull`)\n- `jj bookmark create <name>` for named branches\n- SSH keys recommended for GitHub (as of Oct 2023)\n- Support for both \"add commits\" and \"rewrite commits\" review workflows\n\n## Common Lean Pitfalls\n\n- [Automatic implicit parameters](https://github.com/nielsvoss/lean-pitfalls#automatic-implicit-parameters)\n- [Forgetting the Mathlib cache](https://github.com/nielsvoss/lean-pitfalls#forgetting-the-mathlib-cache)\n- [Using `have` for data](https://github.com/nielsvoss/lean-pitfalls#using-have-for-data)\n- [Rewriting under binders](https://github.com/nielsvoss/lean-pitfalls#rewriting-under-binders)\n- [Trusting tactics to unfold definitions](https://github.com/nielsvoss/lean-pitfalls#trusting-tactics-to-unfold-definitions)\n- [Using `b > a` instead of `a < b`](https://github.com/nielsvoss/lean-pitfalls#using-b--a-instead-of-a--b)\n- [Confusing `Prop` and `Bool`](https://github.com/nielsvoss/lean-pitfalls#confusing-prop-and-bool)\n- [Not checking for distinctness](https://github.com/nielsvoss/lean-pitfalls#not-checking-for-distinctness)\n- [Not accounting for 0](https://github.com/nielsvoss/lean-pitfalls#not-accounting-for-0)\n- [Division by 0](https://github.com/nielsvoss/lean-pitfalls#division-by-0)\n- [Integer division](https://github.com/nielsvoss/lean-pitfalls#integer-division)\n- [Natural number subtraction](https://github.com/nielsvoss/lean-pitfalls#natural-number-subtraction)\n- [Other partial functions](https://github.com/nielsvoss/lean-pitfalls#other-partial-functions)\n- [Wrapping arithmetic in `Fin`](https://github.com/nielsvoss/lean-pitfalls#wrapping-arithmetic-in-fin)\n- [Real power](https://github.com/nielsvoss/lean-pitfalls#real-power)\n- [Distance in `Fin n → ℝ`](https://github.com/nielsvoss/lean-pitfalls#distance-in-fin-n-%E2%86%92-%E2%84%9D)\n- [Accidental double `iInf` or `iSup`](https://github.com/nielsvoss/lean-pitfalls#accidental-double-iinf-or-isup)\n- [Trying to extract data from proofs of propositions](https://github.com/nielsvoss/lean-pitfalls#trying-to-extract-data-from-proofs-of-propositions)\n- [Working with equality of types](https://github.com/nielsvoss/lean-pitfalls#working-with-equality-of-types)\n- [Parameters for instances that already exist](https://github.com/nielsvoss/lean-pitfalls#parameters-for-instances-that-already-exist)\n- [Using `Set`s as types](https://github.com/nielsvoss/lean-pitfalls#using-sets-as-types)\n- [Sort _](https://github.com/nielsvoss/lean-pitfalls#sort-_)\n- [Trying to prove properties about Float](https://github.com/nielsvoss/lean-pitfalls#trying-to-prove-properties-about-float)\n- [`native_decide`](https://github.com/nielsvoss/lean-pitfalls#native_decide)\n- [Panic does not abort](https://github.com/nielsvoss/lean-pitfalls#panic-does-not-abort)\n- [Lean 3 code](https://github.com/nielsvoss/lean-pitfalls#lean-3-code)\n- [Non-terminal simp](https://github.com/nielsvoss/lean-pitfalls#non-terminal-simp)\n- [Ignoring warnings](https://github.com/nielsvoss/lean-pitfalls#ignoring-warnings)\n- [Ambiguous unicode characters](https://github.com/nielsvoss/lean-pitfalls#ambiguous-unicode-characters)\n",
      "type": "text"
    }
  ],
  "isError": false,
  "structuredContent": {
    "result": "# FloatSpec Project Overview\n\nYou are a functional programmer working in Lean 4.\n\n**Main Goal**: Create a provable Lean float implementation with formal verification. Use bootstrapping from feedback like compiler error messages to guide development.\n\n## IMPORTANT: \"Keep Going\" Context\n\nIf you're told to \"keep going\" without context, you're likely working on:\n1. **Float Implementation** - Developing provable floating-point arithmetic\n2. **Specification Writing** - Creating formal specifications for float operations\n3. **Test Writing** - Add more property-based tests using Plausible\n\n## General Programming Philosophy\n\nProgramming is about onomastics (naming), composition (functoriality), and caching. Think conformally at every scale and across scales.\n\nBuild a pit of success: internal systems that grow as a whole outwards, never allowing the fallible external world to leak in except at boundaries. Meet the external world at well-defined interfaces.\n\nWhen solving problems, write tooling/linters/auto-fixers to widen the pit of success. Use rigid compiler error messages and linter warnings to guide future users (**including** AI) toward correct solutions.\n\nFavor statically typed functional programming but use mutability where it makes sense or is easier to port.\n\n## Project Structure\n\n- `FloatSpec.lean` and `FloatSpec/` directory - core float functionality and specifications.\n- `lakefile.lean` - Lean 4 project configuration.\n\n## Development Commands\n\n**`just` is our main program runner.** It provides a unified interface for all common development tasks. Run `just` without arguments to see all available commands.\n\nKey commands:\n- `just build` - Build Lean project\n- `just test` - Run the Python test suite  \n- `just bootstrap` - Bootstrap developer environment (Rust, Elan, UV)\n\nYou can also run underlying tools directly:\n- `lake build` - Build Lean project (use frequently for constant feedback)\n- `uv run -m pytest` - Run Python tests directly\n\n## Commit Logging Process\n\nAfter making a commit, create a log entry:\n\n1. Create timestamped directory: `.log/YYYYMMDD_HHMMSS/`\n2. Store commit information:\n   - `change_stats.txt` - Basic change statistics (see `.log/20250808_102956/change_stats.txt` for an example)\n   - `change_stats.txt` - Basic commit metadata (hash, author, date, subject)\n   - `full_diff.txt` - Full diff of changes (see `.log/20250808_102956/full_diff.txt` for an example)\n   - `detailed_changelog.md` - Detailed summary of changes and their impact (see `.log/20250808_102956/detailed_changelog.md` for an example)\n\nThis provides a searchable history of all significant changes to the codebase.\n\n### Recent Commits\n\n- **2025-08-08 10:29:56** - Replace Float with Real (ℝ) throughout codebase\n  - Major architectural fix replacing Lean's Float with mathematical reals\n  - 54 files changed across entire codebase\n  - See `.log/20250808_102956/` for details\n\nUse `uvx lean-lsp-mcp` to get feedback on your code (primary workflow). Prefer these tools for fast, local diagnostics after every change; use `lake build` for broader checks or when you need a full project build.\n\nUsage:\n\n- `lean_diagnostic_messages`: Get all diagnostic messages for a Lean file. This includes infos, warnings and errors.\n\n```text\nExample output\nl20c42-l20c46, severity: 1\nsimp made no progress\n\nl21c11-l21c45, severity: 1\nfunction expected at h_empty term has type T ∩ compl T = ∅\n```\n\n- `lean_goal`: Get the proof goal at a specific location (line or line & column) in a Lean file.\n\nExample output (line):\n\n```text\nBefore:\nS : Type u_1\ninst✝¹ : Fintype S\ninst✝ : Nonempty S\nP : Finset (Set S)\nhPP : ∀ T ∈ P, ∀ U ∈ P, T ∩ U ≠ ∅\nhPS : ¬∃ T ∉ P, ∀ U ∈ P, T ∩ U ≠ ∅\ncompl : Set S → Set S := fun T ↦ univ \\ T\nhcompl : ∀ T ∈ P, compl T ∉ P\nall_subsets : Finset (Set S) := Finset.univ\nh_comp_in_P : ∀ T ∉ P, compl T ∈ P\nh_partition : ∀ (T : Set S), T ∈ P ∨ compl T ∈ P\n⊢ P.card = 2 ^ (Fintype.card S - 1)\nAfter:\nno goals\n```\n\n- `lean_term_goal`: Get the term goal at a specific position (line & column) in a Lean file.\n\n- `lean_hover_info`: Retrieve hover information (documentation) for symbols, terms, and expressions in a Lean file (at a specific line & column).\n\nExample output (hover info on a `sorry`):\n\n```text\nThe `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses sorry, so you aren't likely to miss it,\nbut you can double check if a theorem depends on sorry by looking for sorryAx in the output\nof the #print axioms my_thm command, the axiom used by the implementation of sorry.\n```\n\n- `lean_declaration_file`: Get the file contents where a symbol or term is declared. Use this to find the definition of a symbol.\n\n- `lean_completions`: Code auto-completion: Find available identifiers or import suggestions at a specific position (line & column) in a Lean file. Use this to fill in program fragments.\n\n- `lean_multi_attempt`:  Attempt multiple lean code snippets on a line and return goal state and diagnostics for each snippet. This tool is useful to screen different attempts before using the most promising one.\n\n```text\nExample output (attempting `rw [Nat.pow_sub (Fintype.card_pos_of_nonempty S)]` and `by_contra h_neq`)\nrw [Nat.pow_sub (Fintype.card_pos_of_nonempty S)]:\nS : Type u_1\ninst✝¹ : Fintype S\ninst✝ : Nonempty S\nP : Finset (Set S)\nhPP : ∀ T ∈ P, ∀ U ∈ P, T ∩ U ≠ ∅\nhPS : ¬∃ T ∉ P, ∀ U ∈ P, T ∩ U ≠ ∅\n⊢ P.card = 2 ^ (Fintype.card S - 1)\n\nl14c7-l14c51, severity: 1\nunknown constant 'Nat.pow_sub'\n\nby_contra h_neq:\nS : Type u_1\ninst✝¹ : Fintype S\ninst✝ : Nonempty S\nP : Finset (Set S)\nhPP : ∀ T ∈ P, ∀ U ∈ P, T ∩ U ≠ ∅\nhPS : ¬∃ T ∉ P, ∀ U ∈ P, T ∩ U ≠ ∅\nh_neq : ¬P.card = 2 ^ (Fintype.card S - 1)\n⊢ False\n```\n\n### Building and Testing\n\n```bash\n# Build using just (recommended)\njust build        # Build Lean project\njust test         # Run Python tests\n\n# Or use direct commands:\nlake build        # Full Lean build (slower; use as a cross-check)\nuv run -m pytest -q  # Run tests directly\n\n# Check Lean syntax and types\nlake build --verbose\n```\n\n## Proof Writing Playbook\n\n- One-by-one: Write exactly one proof, run LSP diagnostics immediately (via `lean_lsp_mcp`), fix issues, then move on. Do not batch multiple new proofs without checking.\n- Follow examples: Mirror patterns from existing proofs, especially `Zfast_div_eucl_spec` in `FloatSpec/src/Core/Zaux.lean` and nearby lemmas in the same file you are editing.\n- Before each proof:\n  - Verify the function body is correct and stable.\n  - Check existing specs to understand precisely what needs to be proven.\n  - Preserve specification/Hoare triple syntax; avoid changing it unless absolutely necessary. If change is unavoidable, decompose the spec into simpler lemmas rather than rewriting wholesale.\n- Compilation verification:\n  - After every proof, run `lean_lsp_mcp.lean_diagnostic_messages` for the edited file.\n  - Use `lake build` as a fallback or for a project-wide typecheck.\n  - “Complete” means: no `sorry` in the edited proof and the file typechecks.\n- When stuck:\n  - Search for relevant lemmas with MCP hover/decl tools or Mathlib; if a lemma doesn’t exist, write a small private helper lemma close to the proof.\n  - Decompose complex statements into smaller, local lemmas.\n  - Reference nearby proofs for patterns and naming.\n\n## Practical Lean Tips (FloatSpec)\n\n- Magnitude and logs:\n  - `mag` is defined with `Int.ceil (log (|x|)/log β)`. To get `|x| ≤ β^e`, sandwich `L := log|x|/logβ` and use `Real.log_le_iff_le_exp` plus `Real.log_zpow`.\n  - Keep a clean chain: derive `log |x| ≤ log (β^e)`, then exponentiate; avoid brittle simp rewrites between `exp (e*log β)` and `β^e`—prove equality explicitly using `Real.exp_log` and `Real.log_zpow`.\n- Powers and positivity:\n  - Use `zpow_pos : 0 < a → 0 < a^n` and `abs_of_nonneg` for `a^n` when the base is positive.\n  - Collapse products with `FloatSpec.Core.Generic_fmt.zpow_mul_sub` and reconstruct with `zpow_add₀` or `zpow_sub_add` (requires nonzero base).\n  - For nonnegative exponent `k ≥ 0`, switch to Nat powers via `zpow_nonneg_toNat`.\n- Absolute values with scaling factors:\n  - Prefer `abs (x * y) = |x| * |y|` and ensure `y ≥ 0` so `|y| = y`.\n  - When the scale is `β^(-c)`, consider rewriting as `((β^c)⁻¹)` and use `inv_nonneg.mpr (le_of_lt (zpow_pos …))` to keep monotonicity simple.\n- Integer truncation:\n  - Use `Ztrunc_intCast` and `Ztrunc_zero` to compute truncations on integer-valued expressions.\n- Calc blocks over heavy simp:\n  - Prefer explicit `calc`/`have` chains with named lemmas instead of relying on `simp` to bridge nondefinitional equalities (especially around `log/exp`, `zpow`, and `abs`).\n\n## Plan + Preambles (for AI agents)\n\n- Maintain a short, evolving plan (use the `update_plan` tool) with exactly one `in_progress` step.\n- Before grouped tool calls, write a concise 1–2 sentence preamble explaining what you are about to do.\n- Share progress updates after nontrivial steps, and re-align the plan if scope changes.\n\n## Quality Bar\n\n- 30-second reality check: After each change, be able to answer “yes” to all:\n  - Did I run/build the code (via MCP or `lake build`)?\n  - Did I trigger the exact feature I changed?\n  - Did I see expected results, and check for errors?\n  - Would I bet $100 it works?\n- Phrases to avoid: “should work”, “fixed the issue” (without verification), “try it now” (without running it yourself).\n\n## FloatSpec Roadmap\n\n### 1. Float Representation and Core Operations\n\n- **IEEE 754 compliant types**: Implement single and double precision floating-point numbers\n- **Bit-level representation**: Use `BitVec` for accurate bit-level manipulation\n- **Core arithmetic**: Addition, subtraction, multiplication, division with proper rounding\n\n### 2. Formal Specifications\n\n- **IEEE 754 semantics**: Formalize the IEEE 754 standard in Lean\n- **Error bounds**: Specify and prove error bounds for operations\n- **Special values**: Handle infinities, NaN, and subnormal numbers correctly\n\n### 3. Next Steps\n\n1. **Core types**: Implement IEEE 754 float types with bit-accurate representation\n2. **Property test probe**: Use <https://github.com/leanprover-community/plausible> to test properties of the spec in a cheap way, a sort of Pareto frontier point in between unit tests and formal proofs. Write code with an eye towards generalizing to future use.\n   - [ ] make `lean_lib` in `lakefile.lean` for property tests\n3. **Benchmark & test**: small-scale benchmarks (`#eval`, `timeIt`) for performance validation.\n\n- [ ] investigate `lake bench`\n\n4. **Docs & examples**: <https://github.com/leanprover/verso> is the (meta)-doc tool. It is very extensible.\n   - [ ] add any accumulated verso extensions to `VersoExt`\n     - [ ] update `lakefile.lean` to include `VersoExt`\n\n## Lean 4 Development Guidelines\n\n- Use named holes (`?foo`) for incremental development\n- Wrap reserved names in «guillemets» when needed\n- Implement \"notation typeclasses\" like `GetElem`, `Add`, etc where appropriate.\n- Practice \"sorry-friendly programming\": Instead of a comment you put down a spec, but it is only \"proved\" with `sorry`. This is strictly better than a comment, because the typechecker will use it for program generation.\n- Decompose proofs until tools like `canonical`, `grind`, and `simp` dissolve the pieces. Use them to do the \"how\", the AI should do the \"what\".\n- Don't use `i` and `j` as variable names when you could use `r`(ow) and `c`(olumn) instead. Ditto for `m` and `n` as matrix dimensions. Use `R` and `C`.\n\n## Verifying Imperative Programs using mvcgen\n\nThe `mvcgen` tactic implements a monadic verification condition generator that breaks down goals involving imperative programs written using Lean's `do` notation into pure verification conditions.\n\n### Key Features:\n- **Monadic verification**: Handles programs with local mutability, for loops, and early returns\n- **Hoare triple support**: Specifications use the notation `⦃P⦄ prog ⦃Q⦄` for pre/postconditions\n- **Loop invariants**: Supports specifying invariants for loops using zipper data structures\n- **Compositional reasoning**: Allows building specifications for individual monadic functions\n- **Monad transformer stacks**: Works with StateT, ReaderT, ExceptT and custom monad combinations\n\n### Basic Usage Pattern:\n```lean\ntheorem program_correct : program_spec := by\n  generalize h : (program args) = result\n  apply MonadType.of_wp_run_eq h  -- Focus on monadic part\n  mvcgen [unfold_hints]           -- Generate verification conditions\n  case inv1 => exact invariant_spec  -- Specify loop invariants\n  all_goals mleave; grind         -- Discharge pure goals\n```\n\n### Loop Invariants:\n- Use zipper data structures (`xs.pref` for processed elements, `xs.suff` for remaining)\n- Early returns supported with `Invariant.withEarlyReturn`\n- State-dependent invariants can reference monadic state through function arguments\n\nThis approach scales to complex imperative programs while maintaining compositional reasoning and avoiding the need to replicate control flow in proofs.\n### Import and Module Structure\n\n- Imports MUST come before any syntax elements, including module and doc comments\n  - [ ] set extensible error messages to suggest a fix for AI. Then remove this admonishment.\n- Set `linter.missingDocs = true` and `relaxedAutoImplicit = false` in `lakefile.lean`.\n\n### Common Errors and Solutions\n\n- **\"unexpected token 'namespace'\"**: Module/doc comment placed incorrectly (should be after imports)\n- **\"unexpected token\"**: Often caused by misplaced docstrings - use multiline comments instead\n  - [ ] use extensible error messages to suggest a fix for AI. Then remove this admonishment.\n- [ ] make a pre-push hook that runs lake build\n\n\n## Python Development Guidelines\n\n- Always use `uv` for Python package management (not pip). Use `uv add` over `uv pip install`, `uv sync`, and `uv run` over `python`. If a tool requires further build integration, use hatch to do it in the `pyproject.toml`.\n\n## Additional Guidelines\n\n- Use `rg` and `fd` instead of grep/find\n- Make atomic commits and use branches liberally\n\n\n## Development Strategies\n\n### Lean 4 Development Approach\n\n- Read the reference manual assiduously. Ultrathink.\n- Figure out the parser by interactively building up toy components.\n- [ ] install https://github.com/GasStationManager/LeanTool as mcp tool\n- Spam `lake build` to verify the pieces work and build up FUNCTORIALLY.\n- **IMPORTANT**: Check compilation with `lake build` every time before marking anything as complete\n- **IMPORTANT**: In Lean 4, `Int.emod` always returns a positive value (Euclidean modulo)\n- Use compiler tooling like extensible error messages, `simproc` (pattern guided reductions), and metaprogramming for pit of success\n- If you solve a hard problem, write a tactic or simproc to pave the way\n- Try harder to index without `!` or `?` - name `match`/`if` branches for better inference\n- Raw string syntax: `r#\"..\"#`, multiline strings use `\\` continuation\n- Use `lakefile.lean` over `lakefile.toml` for better AI introspection and metaprogramming\n- Incorporate positive surprises into memories - stay curious!\n\n### Debugging and Development Process\n\n- Use named holes like `?holeName` for well-typed fragment programs\n- Make mermaid diagrams with labeled edges describing data flow\n- Category theory wiring diagram style for complex systems\n- Apply the scientific method for debugging\n\n## FloatSpec Implementation Progress\n\n### Current Status\n\n- ✓ **Project Setup**: Basic Lean 4 project structure with lakefile.lean\n- ✓ **Build System**: Lake configuration for Lean 4 development\n- ✓ **Zaux.lean**: Complete formalization of auxiliary integer functions (80 functions from Coq)\n\n### Flocq to Lean 4 Transformation Order\n\nBased on the dependency analysis in `Deps/flocq_dependency_graph.dot`, the proper transformation order is:\n\n#### **Phase 1: Core Foundation (Ready Now)**\n1. ✓ **Zaux.lean** - Integer auxiliary functions (completed)\n2. **Raux.lean** - Real auxiliary functions (169 defs) - **NEXT PRIORITY**\n   - Depends on: Zaux\n   - Required by: Most other Core files\n3. **Defs.lean** - Basic definitions (12 defs)\n   - Depends on: Zaux, Raux\n   - Required by: Almost all other files\n\n#### **Phase 2: Core Data Structures (After Phase 1)**\n4. **Digits.lean** - Digit manipulation (62 defs)\n   - Depends on: Zaux\n   - Required by: Float_prop, Generic_fmt, and higher-level operations\n5. **Float_prop.lean** - Basic float properties (36 defs)  \n   - Depends on: Defs, Digits, Raux, Zaux\n   - Required by: Most formatting and rounding operations\n\n#### **Phase 3: Generic Formatting (After Phase 2)**\n6. **Round_pred.lean** - Rounding predicates (78 defs)\n   - Depends on: Defs, Raux\n   - Required by: Generic_fmt, Ulp, Round_NE, FIX, FLX, FLT, FTZ\n7. **Generic_fmt.lean** - Generic formatting (124 defs) - **MAJOR COMPONENT**\n   - Depends on: Defs, Float_prop, Raux, Round_pred, Zaux\n   - Required by: Ulp, Round_NE, FIX, FLX, FLT, FTZ and all higher-level operations\n\n#### **Phase 4: Precision Systems (After Phase 3)**\n8. **Ulp.lean** - Unit in the last place (116 defs)\n9. **Round_NE.lean** - Nearest-even rounding (99 defs) \n10. **FIX.lean** - Fixed-point format (7 defs)\n11. **FLX.lean** - Fixed-precision format (23 defs)\n12. **FLT.lean** - Floating-point format (25 defs)\n13. **FTZ.lean** - Flush-to-zero format (11 defs)\n\n#### **Phase 5: IEEE 754 Implementation (After Phase 4)**\n14. **Core.lean** - Top-level Core module (0 defs, imports all Core files)\n\n#### **Phase 6: Calculations (After Core)**\n15. **Calc/Bracket.lean** - Bracketing operations (37 defs)\n16. **Calc/Operations.lean** - Basic operations (16 defs)\n17. **Calc/Div.lean**, **Calc/Sqrt.lean**, **Calc/Round.lean**, **Calc/Plus.lean**\n\n#### **Phase 7: Properties and IEEE754 (Final)**\n18. **Prop/** modules - Error analysis and properties\n19. **IEEE754/** modules - Full IEEE 754 implementation\n20. **Pff/** modules - Legacy compatibility\n\n### Current Next Steps\n\n**Immediate Priority: Raux.lean**\n- 169 definitions covering real number auxiliary functions\n- Critical dependency for almost all other Core files\n- Should be started immediately after Zaux completion\n\n**Key Dependencies Insight:**\n- Zaux → Raux → Defs forms the foundational triangle\n- Generic_fmt is the central heavyweight component (124 defs)\n- Most IEEE754 functionality requires the complete Core foundation\n- Zaux has the widest fan-out (used by 12/13 Core modules)\n- The dependency graph shows clear layering: Core → Calc → Prop → IEEE754\n- Phase approach minimizes rework and enables parallel development within phases\n\n### Design Principles\n\n- **Correctness First**: Every operation should have formal verification\n- **IEEE 754 Compliance**: Strict adherence to the IEEE 754 standard\n- **Bit-level Accuracy**: Use precise bit-level representations\n- **Type Safety**: Use Lean's type system to prevent numerical errors\n\n## Important Lean Documentation Resources\n\nWhen working with Lean 4, consult these authoritative sources:\n\n- **Lean 4 Official Documentation**: <https://lean-lang.org/lean4/doc> - The formal Lean documentation covering language features, tactics, and standard library\n- **Mathlib Manual**: <https://leanprover-community.github.io/mathlib-manual/html-multi/Guides/> - Comprehensive guide to mathlib conventions, tactics, and best practices\n- **Lean Language Reference**: <https://lean-lang.org/doc/reference/latest/> - The definitive Lean language reference for syntax and semantics\n\n## ✅ COMPLETED: Replace Float with Real (ℝ)\n\n**Issue**: The implementation was using Lean's built-in `Float` type throughout the formalization, which created a circular definition - we were using floating-point numbers to define floating-point numbers!\n\n**Solution Implemented**: Replaced all occurrences of `Float` with `ℝ` (Real) from Mathlib. This matches the original Coq Flocq library which uses `R` (Coq's real number type).\n\n**Files updated**:\n- ✅ All files in `FloatSpec/src/Core/` (Defs.lean, Raux.lean, Float_prop.lean, Round_pred.lean, Generic_fmt.lean, Ulp.lean, Round_NE.lean, FIX.lean, FLX.lean, FLT.lean, FTZ.lean)\n- ✅ All files in `FloatSpec/src/Calc/` (Bracket.lean, Operations.lean, Div.lean, Sqrt.lean, Round.lean, Plus.lean)\n- ✅ All files in `FloatSpec/src/Prop/` (All 7 property files)\n- ✅ All files in `FloatSpec/src/IEEE754/` (Binary.lean, BinarySingleNaN.lean, Bits.lean, PrimFloat.lean)\n- ✅ All files in `FloatSpec/src/Pff/` (Pff.lean, Pff2Flocq.lean, Pff2FlocqAux.lean)\n\n**Changes completed**:\n1. ✅ Added Mathlib dependency to lakefile.lean\n2. ✅ Imported Mathlib's real number support (`import Mathlib.Data.Real.Basic` and `open Real`) in all files\n3. ✅ Replaced `Float` with `ℝ` throughout all type annotations\n4. ✅ Updated absolute value operations from `Float.abs` to `|·|` notation\n5. ✅ Added `noncomputable` to functions involving real number operations\n\nThis fundamental architectural fix has been completed, ensuring the formalization correctly uses mathematical real numbers instead of computational floats.\n\n\n\n## Development Tools and Workflow\n\n### Version Control\n\n**Jujutsu (jj) Setup for GitHub-friendly Development:**\n\n- Use `jj git init --colocate` for existing git repos (recommended for this project)\n- Colocated repos automatically sync jj and git on every command\n- Enables mixing `jj` and `git` commands seamlessly\n- Tools expecting `.git` directory continue to work\n\n**Essential jj configuration:**\n\n```bash\njj config edit --user\n```\n\nAdd these settings:\n\n```toml\n[git]\nauto-local-bookmark = true  # Import all remote bookmarks automatically\n\n[snapshot]  \nauto-update-stale = true    # Auto-update stale working copies when switching contexts\n```\n\n**Key workflow improvements over git:**\n\n- Anonymous branches - no need to name every small change\n- Better conflict resolution and interactive rebase\n- `jj absorb` automatically squashes changes into relevant ancestor commits\n- `jj undo` and `jj op restore` for powerful history manipulation\n- Empty commit on top by default (enables easier experimentation)\n\n**GitHub integration commands:**\n\n- `jj git fetch` + `jj rebase -d main` (replaces `git pull`)\n- `jj bookmark create <name>` for named branches\n- SSH keys recommended for GitHub (as of Oct 2023)\n- Support for both \"add commits\" and \"rewrite commits\" review workflows\n\n## Common Lean Pitfalls\n\n- [Automatic implicit parameters](https://github.com/nielsvoss/lean-pitfalls#automatic-implicit-parameters)\n- [Forgetting the Mathlib cache](https://github.com/nielsvoss/lean-pitfalls#forgetting-the-mathlib-cache)\n- [Using `have` for data](https://github.com/nielsvoss/lean-pitfalls#using-have-for-data)\n- [Rewriting under binders](https://github.com/nielsvoss/lean-pitfalls#rewriting-under-binders)\n- [Trusting tactics to unfold definitions](https://github.com/nielsvoss/lean-pitfalls#trusting-tactics-to-unfold-definitions)\n- [Using `b > a` instead of `a < b`](https://github.com/nielsvoss/lean-pitfalls#using-b--a-instead-of-a--b)\n- [Confusing `Prop` and `Bool`](https://github.com/nielsvoss/lean-pitfalls#confusing-prop-and-bool)\n- [Not checking for distinctness](https://github.com/nielsvoss/lean-pitfalls#not-checking-for-distinctness)\n- [Not accounting for 0](https://github.com/nielsvoss/lean-pitfalls#not-accounting-for-0)\n- [Division by 0](https://github.com/nielsvoss/lean-pitfalls#division-by-0)\n- [Integer division](https://github.com/nielsvoss/lean-pitfalls#integer-division)\n- [Natural number subtraction](https://github.com/nielsvoss/lean-pitfalls#natural-number-subtraction)\n- [Other partial functions](https://github.com/nielsvoss/lean-pitfalls#other-partial-functions)\n- [Wrapping arithmetic in `Fin`](https://github.com/nielsvoss/lean-pitfalls#wrapping-arithmetic-in-fin)\n- [Real power](https://github.com/nielsvoss/lean-pitfalls#real-power)\n- [Distance in `Fin n → ℝ`](https://github.com/nielsvoss/lean-pitfalls#distance-in-fin-n-%E2%86%92-%E2%84%9D)\n- [Accidental double `iInf` or `iSup`](https://github.com/nielsvoss/lean-pitfalls#accidental-double-iinf-or-isup)\n- [Trying to extract data from proofs of propositions](https://github.com/nielsvoss/lean-pitfalls#trying-to-extract-data-from-proofs-of-propositions)\n- [Working with equality of types](https://github.com/nielsvoss/lean-pitfalls#working-with-equality-of-types)\n- [Parameters for instances that already exist](https://github.com/nielsvoss/lean-pitfalls#parameters-for-instances-that-already-exist)\n- [Using `Set`s as types](https://github.com/nielsvoss/lean-pitfalls#using-sets-as-types)\n- [Sort _](https://github.com/nielsvoss/lean-pitfalls#sort-_)\n- [Trying to prove properties about Float](https://github.com/nielsvoss/lean-pitfalls#trying-to-prove-properties-about-float)\n- [`native_decide`](https://github.com/nielsvoss/lean-pitfalls#native_decide)\n- [Panic does not abort](https://github.com/nielsvoss/lean-pitfalls#panic-does-not-abort)\n- [Lean 3 code](https://github.com/nielsvoss/lean-pitfalls#lean-3-code)\n- [Non-terminal simp](https://github.com/nielsvoss/lean-pitfalls#non-terminal-simp)\n- [Ignoring warnings](https://github.com/nielsvoss/lean-pitfalls#ignoring-warnings)\n- [Ambiguous unicode characters](https://github.com/nielsvoss/lean-pitfalls#ambiguous-unicode-characters)\n"
  }
}
[2025-09-16T03:11:13] tokens used: 33090
[2025-09-16T03:11:21] thinking

**Planning file options**

I need to provide options based on the record, like FIX, FLT, FLX, and so on. I'm considering opening one file to examine the structure to be more efficient, but I should be cautious about running trivial reads unless it's part of a grouped task. It might be helpful, though. Also, since the user replaced "file" with a variable, they should specify which target file they need. Let's make sure to ask clearly!
[2025-09-16T03:11:22] codex

Quick check done. I’ve reviewed the comparison record and the pipeline/CLAUDE docs, so I’m ready to add missing theorems with the required Hoare triple style and verify after each addition.

Which Core file should I work on first? Options with missing theorems include:
- `Generic_fmt.lean` (many)
- `Raux.lean` (many)
- `Ulp.lean` (many)
- `Round_pred.lean` (many)
- `FIX.lean`, `FLX.lean`, `FLT.lean`, `FTZ.lean` (several each)

Name the exact file (e.g., `FIX.lean`), and I’ll proceed one theorem at a time, compiling after each.
[2025-09-16T03:11:23] tokens used: 40569
