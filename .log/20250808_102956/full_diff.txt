diff --git a/CLAUDE.md b/CLAUDE.md
index c295400..ed83577 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -39,6 +39,25 @@ You can also run underlying tools directly:
 - `lake build` - Build Lean project (use frequently for constant feedback)
 - `uv run -m pytest` - Run Python tests directly
 
+## Commit Logging Process
+
+After making a commit, create a log entry:
+
+1. Create timestamped directory: `.log/YYYYMMDD_HHMMSS/`
+2. Store commit information:
+   - `commit_info.txt` - Basic commit metadata (hash, author, date, subject)
+   - `change_stats.txt` - File change statistics
+   - `summary.md` - Detailed summary of changes and their impact
+
+This provides a searchable history of all significant changes to the codebase.
+
+### Recent Commits
+
+- **2025-08-08 10:29:56** - Replace Float with Real (ℝ) throughout codebase
+  - Major architectural fix replacing Lean's Float with mathematical reals
+  - 54 files changed across entire codebase
+  - See `.log/20250808_102956/` for details
+
 Use `uvx lean-lsp-mcp` to get feedback on your code. Usage:
 
 - `lean_diagnostic_messages`: Get all diagnostic messages for a Lean file. This includes infos, warnings and errors.
@@ -305,6 +324,28 @@ When working with Lean 4, consult these authoritative sources:
 - **Mathlib Manual**: <https://leanprover-community.github.io/mathlib-manual/html-multi/Guides/> - Comprehensive guide to mathlib conventions, tactics, and best practices
 - **Lean Language Reference**: <https://lean-lang.org/doc/reference/latest/> - The definitive Lean language reference for syntax and semantics
 
+## ✅ COMPLETED: Replace Float with Real (ℝ)
+
+**Issue**: The implementation was using Lean's built-in `Float` type throughout the formalization, which created a circular definition - we were using floating-point numbers to define floating-point numbers!
+
+**Solution Implemented**: Replaced all occurrences of `Float` with `ℝ` (Real) from Mathlib. This matches the original Coq Flocq library which uses `R` (Coq's real number type).
+
+**Files updated**:
+- ✅ All files in `FloatSpec/src/Core/` (Defs.lean, Raux.lean, Float_prop.lean, Round_pred.lean, Generic_fmt.lean, Ulp.lean, Round_NE.lean, FIX.lean, FLX.lean, FLT.lean, FTZ.lean)
+- ✅ All files in `FloatSpec/src/Calc/` (Bracket.lean, Operations.lean, Div.lean, Sqrt.lean, Round.lean, Plus.lean)
+- ✅ All files in `FloatSpec/src/Prop/` (All 7 property files)
+- ✅ All files in `FloatSpec/src/IEEE754/` (Binary.lean, BinarySingleNaN.lean, Bits.lean, PrimFloat.lean)
+- ✅ All files in `FloatSpec/src/Pff/` (Pff.lean, Pff2Flocq.lean, Pff2FlocqAux.lean)
+
+**Changes completed**:
+1. ✅ Added Mathlib dependency to lakefile.lean
+2. ✅ Imported Mathlib's real number support (`import Mathlib.Data.Real.Basic` and `open Real`) in all files
+3. ✅ Replaced `Float` with `ℝ` throughout all type annotations
+4. ✅ Updated absolute value operations from `Float.abs` to `|·|` notation
+5. ✅ Added `noncomputable` to functions involving real number operations
+
+This fundamental architectural fix has been completed, ensuring the formalization correctly uses mathematical real numbers instead of computational floats.
+
 
 
 ## Development Tools and Workflow
diff --git a/FloatSpec/src/Calc/Bracket.lean b/FloatSpec/src/Calc/Bracket.lean
index 11ddc00..c4c04d8 100644
--- a/FloatSpec/src/Calc/Bracket.lean
+++ b/FloatSpec/src/Calc/Bracket.lean
@@ -5,15 +5,18 @@ import FloatSpec.src.Core.Zaux
 import FloatSpec.src.Core.Raux
 import FloatSpec.src.Core.Defs
 import FloatSpec.src.Core.Float_prop
+import Mathlib.Data.Real.Basic
+
+open Real
 
 -- Location type for bracketing
 inductive Location where
   | loc_Exact : Location
   | loc_Inexact : Ordering → Location
 
-variable (d u : Float)
+variable (d u : ℝ)
 variable (Hdu : d < u)
-variable (x : Float)
+variable (x : ℝ)
 
 -- Location determination based on comparison with middle point
 def inbetween_loc : Location :=
@@ -50,16 +53,16 @@ theorem inbetween_distance_inexact (l : Ordering) (h : inbetween d u x (Location
 
 -- Absolute distance comparison
 theorem inbetween_distance_inexact_abs (l : Ordering) (h : inbetween d u x (Location.loc_Inexact l)) :
-    compare (Float.abs (d - x)) (Float.abs (u - x)) = l := by
+    compare (|d - x|) (|u - x|) = l := by
   sorry
 
 -- Existence theorem for locations
-theorem inbetween_ex (d u : Float) (l : Location) (Hdu : d < u) :
+theorem inbetween_ex (d u : ℝ) (l : Location) (Hdu : d < u) :
     ∃ x, inbetween d u x l := by
   sorry
 
 -- Section for stepping through ranges
-variable (start step : Float)
+variable (start step : ℝ)
 variable (nb_steps : Int)
 variable (Hstep : 0 < step)
 
@@ -76,20 +79,20 @@ lemma middle_range (k : Int) :
 variable (Hnb_steps : 1 < nb_steps)
 
 -- Step location theorems
-theorem inbetween_step_not_Eq (x : Float) (k : Int) (l l' : Location)
+theorem inbetween_step_not_Eq (x : ℝ) (k : Int) (l l' : Location)
     (Hx : inbetween (start + k * step) (start + (k + 1) * step) x l)
     (Hk : 0 < k ∧ k < nb_steps)
     (Hl' : compare x (start + (nb_steps / 2 * step)) = l') :
     inbetween start (start + nb_steps * step) x (Location.loc_Inexact l') := by
   sorry
 
-theorem inbetween_step_Lo (x : Float) (k : Int) (l : Location)
+theorem inbetween_step_Lo (x : ℝ) (k : Int) (l : Location)
     (Hx : inbetween (start + k * step) (start + (k + 1) * step) x l)
     (Hk1 : 0 < k) (Hk2 : 2 * k + 1 < nb_steps) :
     inbetween start (start + nb_steps * step) x (Location.loc_Inexact Ordering.lt) := by
   sorry
 
-theorem inbetween_step_Hi (x : Float) (k : Int) (l : Location)
+theorem inbetween_step_Hi (x : ℝ) (k : Int) (l : Location)
     (Hx : inbetween (start + k * step) (start + (k + 1) * step) x l)
     (Hk1 : nb_steps < 2 * k) (Hk2 : k < nb_steps) :
     inbetween start (start + nb_steps * step) x (Location.loc_Inexact Ordering.gt) := by
@@ -129,39 +132,39 @@ def new_location (k : Int) (l : Location) : Location :=
   else new_location_odd start step nb_steps k l
 
 -- Correctness theorems for new location functions
-theorem new_location_even_correct (He : nb_steps % 2 = 0) (x : Float) (k : Int) (l : Location)
+theorem new_location_even_correct (He : nb_steps % 2 = 0) (x : ℝ) (k : Int) (l : Location)
     (Hk : 0 ≤ k ∧ k < nb_steps)
     (Hx : inbetween (start + k * step) (start + (k + 1) * step) x l) :
     inbetween start (start + nb_steps * step) x (new_location_even start step nb_steps k l) := by
   sorry
 
-theorem new_location_odd_correct (Ho : nb_steps % 2 = 1) (x : Float) (k : Int) (l : Location)
+theorem new_location_odd_correct (Ho : nb_steps % 2 = 1) (x : ℝ) (k : Int) (l : Location)
     (Hk : 0 ≤ k ∧ k < nb_steps)
     (Hx : inbetween (start + k * step) (start + (k + 1) * step) x l) :
     inbetween start (start + nb_steps * step) x (new_location_odd start step nb_steps k l) := by
   sorry
 
-theorem new_location_correct (x : Float) (k : Int) (l : Location)
+theorem new_location_correct (x : ℝ) (k : Int) (l : Location)
     (Hk : 0 ≤ k ∧ k < nb_steps)
     (Hx : inbetween (start + k * step) (start + (k + 1) * step) x l) :
     inbetween start (start + nb_steps * step) x (new_location start step nb_steps k l) := by
   sorry
 
 -- Section for addition compatibility
-theorem inbetween_plus_compat (x d u : Float) (l : Location) (t : Float)
+theorem inbetween_plus_compat (x d u : ℝ) (l : Location) (t : ℝ)
     (h : inbetween x d u l) : inbetween (x + t) (d + t) (u + t) l := by
   sorry
 
-theorem inbetween_plus_reg (x d u : Float) (l : Location) (t : Float)
+theorem inbetween_plus_reg (x d u : ℝ) (l : Location) (t : ℝ)
     (h : inbetween (x + t) (d + t) (u + t) l) : inbetween x d u l := by
   sorry
 
 -- Section for scaling compatibility
-theorem inbetween_mult_compat (x d u : Float) (l : Location) (s : Float)
+theorem inbetween_mult_compat (x d u : ℝ) (l : Location) (s : ℝ)
     (Hs : 0 < s) (h : inbetween x d u l) : inbetween (x * s) (d * s) (u * s) l := by
   sorry
 
-theorem inbetween_mult_reg (x d u : Float) (l : Location) (s : Float)
+theorem inbetween_mult_reg (x d u : ℝ) (l : Location) (s : ℝ)
     (Hs : 0 < s) (h : inbetween (x * s) (d * s) (u * s) l) : inbetween x d u l := by
   sorry
 
@@ -169,27 +172,27 @@ theorem inbetween_mult_reg (x d u : Float) (l : Location) (s : Float)
 variable (beta : Int)
 
 -- Specialization for consecutive floating-point numbers
-def inbetween_float (m e : Int) (x : Float) (l : Location) : Prop :=
+def inbetween_float (m e : Int) (x : ℝ) (l : Location) : Prop :=
   inbetween (F2R (FlocqFloat.mk m e : FlocqFloat beta)) (F2R (FlocqFloat.mk (m + 1) e : FlocqFloat beta)) x l
 
-theorem inbetween_float_bounds (x : Float) (m e : Int) (l : Location)
+theorem inbetween_float_bounds (x : ℝ) (m e : Int) (l : Location)
     (h : inbetween_float beta m e x l) :
     F2R (FlocqFloat.mk m e : FlocqFloat beta) ≤ x ∧ x < F2R (FlocqFloat.mk (m + 1) e : FlocqFloat beta) := by
   sorry
 
 -- Specialization for consecutive integers
-def inbetween_int (m : Int) (x : Float) (l : Location) : Prop :=
+def inbetween_int (m : Int) (x : ℝ) (l : Location) : Prop :=
   inbetween m (m + 1) x l
 
 -- New location for float with power scaling
-theorem inbetween_float_new_location (x : Float) (m e : Int) (l : Location) (k : Int)
+theorem inbetween_float_new_location (x : ℝ) (m e : Int) (l : Location) (k : Int)
     (Hk : 0 < k) (Hx : inbetween_float beta m e x l) :
     inbetween_float beta (m / (beta ^ k)) (e + k) x 
       (new_location (beta ^ k) (m % (beta ^ k)) l) := by
   sorry
 
 -- Single digit new location
-theorem inbetween_float_new_location_single (x : Float) (m e : Int) (l : Location)
+theorem inbetween_float_new_location_single (x : ℝ) (m e : Int) (l : Location)
     (Hx : inbetween_float beta m e x l) :
     inbetween_float beta (m / beta) (e + 1) x (new_location beta (m % beta) l) := by
   sorry
@@ -199,7 +202,7 @@ theorem inbetween_float_ex (m e : Int) (l : Location) :
     ∃ x, inbetween_float beta m e x l := by
   sorry
 
-theorem inbetween_float_unique (x : Float) (e m m' : Int) (l l' : Location)
+theorem inbetween_float_unique (x : ℝ) (e m m' : Int) (l l' : Location)
     (H : inbetween_float beta m e x l) (H' : inbetween_float beta m' e x l') :
     m = m' ∧ l = l' := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Calc/Bracket.lean.bak b/FloatSpec/src/Calc/Bracket.lean.bak
new file mode 100644
index 0000000..11ddc00
--- /dev/null
+++ b/FloatSpec/src/Calc/Bracket.lean.bak
@@ -0,0 +1,205 @@
+-- Locations: where a real number is positioned with respect to its rounded-down value in an arbitrary format
+-- Translated from Coq file: flocq/src/Calc/Bracket.v
+
+import FloatSpec.src.Core.Zaux
+import FloatSpec.src.Core.Raux
+import FloatSpec.src.Core.Defs
+import FloatSpec.src.Core.Float_prop
+
+-- Location type for bracketing
+inductive Location where
+  | loc_Exact : Location
+  | loc_Inexact : Ordering → Location
+
+variable (d u : Float)
+variable (Hdu : d < u)
+variable (x : Float)
+
+-- Location determination based on comparison with middle point
+def inbetween_loc : Location :=
+  if x > d then Location.loc_Inexact (compare x ((d + u) / 2)) else Location.loc_Exact
+
+-- Inductive predicate for location relationship
+inductive inbetween : Location → Prop where
+  | inbetween_Exact : x = d → inbetween Location.loc_Exact
+  | inbetween_Inexact (l : Ordering) : (d < x ∧ x < u) → compare x ((d + u) / 2) = l → inbetween (Location.loc_Inexact l)
+
+-- Location specification theorem
+theorem inbetween_spec (Hx : d ≤ x ∧ x < u) : inbetween d u x inbetween_loc := by
+  sorry
+
+-- Location uniqueness theorem
+theorem inbetween_unique (l l' : Location) (Hl : inbetween d u x l) (Hl' : inbetween d u x l') : l = l' := by
+  sorry
+
+-- Section for any location
+variable (l : Location)
+
+-- Bounds from inbetween property
+theorem inbetween_bounds (h : inbetween d u x l) : d ≤ x ∧ x < u := by
+  sorry
+
+-- Bounds for non-exact locations
+theorem inbetween_bounds_not_Eq (h : inbetween d u x l) (hl : l ≠ Location.loc_Exact) : d < x ∧ x < u := by
+  sorry
+
+-- Distance comparison for inexact locations
+theorem inbetween_distance_inexact (l : Ordering) (h : inbetween d u x (Location.loc_Inexact l)) :
+    compare (x - d) (u - x) = l := by
+  sorry
+
+-- Absolute distance comparison
+theorem inbetween_distance_inexact_abs (l : Ordering) (h : inbetween d u x (Location.loc_Inexact l)) :
+    compare (Float.abs (d - x)) (Float.abs (u - x)) = l := by
+  sorry
+
+-- Existence theorem for locations
+theorem inbetween_ex (d u : Float) (l : Location) (Hdu : d < u) :
+    ∃ x, inbetween d u x l := by
+  sorry
+
+-- Section for stepping through ranges
+variable (start step : Float)
+variable (nb_steps : Int)
+variable (Hstep : 0 < step)
+
+-- Ordered steps lemma
+lemma ordered_steps (k : Int) :
+    start + k * step < start + (k + 1) * step := by
+  sorry
+
+-- Middle range calculation
+lemma middle_range (k : Int) :
+    (start + (start + k * step)) / 2 = start + (k / 2 * step) := by
+  sorry
+
+variable (Hnb_steps : 1 < nb_steps)
+
+-- Step location theorems
+theorem inbetween_step_not_Eq (x : Float) (k : Int) (l l' : Location)
+    (Hx : inbetween (start + k * step) (start + (k + 1) * step) x l)
+    (Hk : 0 < k ∧ k < nb_steps)
+    (Hl' : compare x (start + (nb_steps / 2 * step)) = l') :
+    inbetween start (start + nb_steps * step) x (Location.loc_Inexact l') := by
+  sorry
+
+theorem inbetween_step_Lo (x : Float) (k : Int) (l : Location)
+    (Hx : inbetween (start + k * step) (start + (k + 1) * step) x l)
+    (Hk1 : 0 < k) (Hk2 : 2 * k + 1 < nb_steps) :
+    inbetween start (start + nb_steps * step) x (Location.loc_Inexact Ordering.lt) := by
+  sorry
+
+theorem inbetween_step_Hi (x : Float) (k : Int) (l : Location)
+    (Hx : inbetween (start + k * step) (start + (k + 1) * step) x l)
+    (Hk1 : nb_steps < 2 * k) (Hk2 : k < nb_steps) :
+    inbetween start (start + nb_steps * step) x (Location.loc_Inexact Ordering.gt) := by
+  sorry
+
+-- New location computation functions
+def new_location_even (k : Int) (l : Location) : Location :=
+  if k = 0 then
+    match l with
+    | Location.loc_Exact => l
+    | _ => Location.loc_Inexact Ordering.lt
+  else
+    Location.loc_Inexact
+    match compare (2 * k) nb_steps with
+    | Ordering.lt => Ordering.lt
+    | Ordering.eq => match l with 
+      | Location.loc_Exact => Ordering.eq 
+      | _ => Ordering.gt
+    | Ordering.gt => Ordering.gt
+
+def new_location_odd (k : Int) (l : Location) : Location :=
+  if k = 0 then
+    match l with
+    | Location.loc_Exact => l
+    | _ => Location.loc_Inexact Ordering.lt
+  else
+    Location.loc_Inexact
+    match compare (2 * k + 1) nb_steps with
+    | Ordering.lt => Ordering.lt
+    | Ordering.eq => match l with
+      | Location.loc_Inexact l => l
+      | Location.loc_Exact => Ordering.lt
+    | Ordering.gt => Ordering.gt
+
+def new_location (k : Int) (l : Location) : Location :=
+  if nb_steps % 2 = 0 then new_location_even start step nb_steps k l
+  else new_location_odd start step nb_steps k l
+
+-- Correctness theorems for new location functions
+theorem new_location_even_correct (He : nb_steps % 2 = 0) (x : Float) (k : Int) (l : Location)
+    (Hk : 0 ≤ k ∧ k < nb_steps)
+    (Hx : inbetween (start + k * step) (start + (k + 1) * step) x l) :
+    inbetween start (start + nb_steps * step) x (new_location_even start step nb_steps k l) := by
+  sorry
+
+theorem new_location_odd_correct (Ho : nb_steps % 2 = 1) (x : Float) (k : Int) (l : Location)
+    (Hk : 0 ≤ k ∧ k < nb_steps)
+    (Hx : inbetween (start + k * step) (start + (k + 1) * step) x l) :
+    inbetween start (start + nb_steps * step) x (new_location_odd start step nb_steps k l) := by
+  sorry
+
+theorem new_location_correct (x : Float) (k : Int) (l : Location)
+    (Hk : 0 ≤ k ∧ k < nb_steps)
+    (Hx : inbetween (start + k * step) (start + (k + 1) * step) x l) :
+    inbetween start (start + nb_steps * step) x (new_location start step nb_steps k l) := by
+  sorry
+
+-- Section for addition compatibility
+theorem inbetween_plus_compat (x d u : Float) (l : Location) (t : Float)
+    (h : inbetween x d u l) : inbetween (x + t) (d + t) (u + t) l := by
+  sorry
+
+theorem inbetween_plus_reg (x d u : Float) (l : Location) (t : Float)
+    (h : inbetween (x + t) (d + t) (u + t) l) : inbetween x d u l := by
+  sorry
+
+-- Section for scaling compatibility
+theorem inbetween_mult_compat (x d u : Float) (l : Location) (s : Float)
+    (Hs : 0 < s) (h : inbetween x d u l) : inbetween (x * s) (d * s) (u * s) l := by
+  sorry
+
+theorem inbetween_mult_reg (x d u : Float) (l : Location) (s : Float)
+    (Hs : 0 < s) (h : inbetween (x * s) (d * s) (u * s) l) : inbetween x d u l := by
+  sorry
+
+-- Section for floating-point specific bracketing
+variable (beta : Int)
+
+-- Specialization for consecutive floating-point numbers
+def inbetween_float (m e : Int) (x : Float) (l : Location) : Prop :=
+  inbetween (F2R (FlocqFloat.mk m e : FlocqFloat beta)) (F2R (FlocqFloat.mk (m + 1) e : FlocqFloat beta)) x l
+
+theorem inbetween_float_bounds (x : Float) (m e : Int) (l : Location)
+    (h : inbetween_float beta m e x l) :
+    F2R (FlocqFloat.mk m e : FlocqFloat beta) ≤ x ∧ x < F2R (FlocqFloat.mk (m + 1) e : FlocqFloat beta) := by
+  sorry
+
+-- Specialization for consecutive integers
+def inbetween_int (m : Int) (x : Float) (l : Location) : Prop :=
+  inbetween m (m + 1) x l
+
+-- New location for float with power scaling
+theorem inbetween_float_new_location (x : Float) (m e : Int) (l : Location) (k : Int)
+    (Hk : 0 < k) (Hx : inbetween_float beta m e x l) :
+    inbetween_float beta (m / (beta ^ k)) (e + k) x 
+      (new_location (beta ^ k) (m % (beta ^ k)) l) := by
+  sorry
+
+-- Single digit new location
+theorem inbetween_float_new_location_single (x : Float) (m e : Int) (l : Location)
+    (Hx : inbetween_float beta m e x l) :
+    inbetween_float beta (m / beta) (e + 1) x (new_location beta (m % beta) l) := by
+  sorry
+
+-- Existence and uniqueness for float intervals
+theorem inbetween_float_ex (m e : Int) (l : Location) :
+    ∃ x, inbetween_float beta m e x l := by
+  sorry
+
+theorem inbetween_float_unique (x : Float) (e m m' : Int) (l l' : Location)
+    (H : inbetween_float beta m e x l) (H' : inbetween_float beta m' e x l') :
+    m = m' ∧ l = l' := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Calc/Div.lean b/FloatSpec/src/Calc/Div.lean
index b714d34..712dd4e 100644
--- a/FloatSpec/src/Calc/Div.lean
+++ b/FloatSpec/src/Calc/Div.lean
@@ -8,6 +8,9 @@ import FloatSpec.src.Core.Generic_fmt
 import FloatSpec.src.Core.Float_prop
 import FloatSpec.src.Core.Digits
 import FloatSpec.src.Calc.Bracket
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 variable (fexp : Int → Int)
diff --git a/FloatSpec/src/Calc/Div.lean.bak b/FloatSpec/src/Calc/Div.lean.bak
new file mode 100644
index 0000000..b714d34
--- /dev/null
+++ b/FloatSpec/src/Calc/Div.lean.bak
@@ -0,0 +1,55 @@
+-- Helper function and theorem for computing the rounded quotient of two floating-point numbers
+-- Translated from Coq file: flocq/src/Calc/Div.v
+
+import FloatSpec.src.Core.Zaux
+import FloatSpec.src.Core.Raux
+import FloatSpec.src.Core.Defs
+import FloatSpec.src.Core.Generic_fmt
+import FloatSpec.src.Core.Float_prop
+import FloatSpec.src.Core.Digits
+import FloatSpec.src.Calc.Bracket
+
+variable (beta : Int)
+variable (fexp : Int → Int)
+
+-- Magnitude bound for division of F2R values
+lemma mag_div_F2R (m1 e1 m2 e2 : Int) (Hm1 : 0 < m1) (Hm2 : 0 < m2) :
+    let e := (Zdigits beta m1 + e1) - (Zdigits beta m2 + e2)
+    e ≤ mag beta (F2R (FlocqFloat.mk m1 e1 : FlocqFloat beta) / F2R (FlocqFloat.mk m2 e2 : FlocqFloat beta)) ∧
+    mag beta (F2R (FlocqFloat.mk m1 e1 : FlocqFloat beta) / F2R (FlocqFloat.mk m2 e2 : FlocqFloat beta)) ≤ e + 1 := by
+  sorry
+
+-- Core division function with precision control
+def Fdiv_core (m1 e1 m2 e2 e : Int) : Int × Location :=
+  let (m1', m2') := 
+    if e ≤ e1 - e2 then
+      (m1 * beta ^ (e1 - e2 - e), m2)
+    else
+      (m1, m2 * beta ^ (e - (e1 - e2)))
+  let (q, r) := Int.divMod m1' m2'
+  (q, new_location m2' r Location.loc_Exact)
+
+-- Correctness of core division
+theorem Fdiv_core_correct (m1 e1 m2 e2 e : Int) (Hm1 : 0 < m1) (Hm2 : 0 < m2) :
+    let (m, l) := Fdiv_core beta m1 e1 m2 e2 e
+    inbetween_float beta m e (F2R (FlocqFloat.mk m1 e1 : FlocqFloat beta) / F2R (FlocqFloat.mk m2 e2 : FlocqFloat beta)) l := by
+  sorry
+
+-- Main division function
+def Fdiv (x y : FlocqFloat beta) : Int × Int × Location :=
+  let m1 := x.Fnum
+  let e1 := x.Fexp
+  let m2 := y.Fnum
+  let e2 := y.Fexp
+  let e' := (Zdigits beta m1 + e1) - (Zdigits beta m2 + e2)
+  let e := min (min (fexp e') (fexp (e' + 1))) (e1 - e2)
+  let (m, l) := Fdiv_core beta m1 e1 m2 e2 e
+  (m, e, l)
+
+-- Correctness of division
+theorem Fdiv_correct (x y : FlocqFloat beta) 
+    (Hx : 0 < F2R x) (Hy : 0 < F2R y) :
+    let (m, e, l) := Fdiv beta fexp x y
+    e ≤ cexp beta fexp (F2R x / F2R y) ∧
+    inbetween_float beta m e (F2R x / F2R y) l := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Calc/Operations.lean b/FloatSpec/src/Calc/Operations.lean
index 2a84aae..ef95485 100644
--- a/FloatSpec/src/Calc/Operations.lean
+++ b/FloatSpec/src/Calc/Operations.lean
@@ -5,6 +5,9 @@ import FloatSpec.src.Core.Zaux
 import FloatSpec.src.Core.Raux
 import FloatSpec.src.Core.Defs
 import FloatSpec.src.Core.Float_prop
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 
@@ -46,7 +49,7 @@ def Fabs (f1 : FlocqFloat beta) : FlocqFloat beta :=
 
 -- F2R of absolute value theorem
 theorem F2R_abs (f1 : FlocqFloat beta) :
-    F2R (Fabs beta f1) = Float.abs (F2R f1) := by
+    F2R (Fabs beta f1) = |F2R f1| := by
   sorry
 
 -- Float addition
diff --git a/FloatSpec/src/Calc/Plus.lean b/FloatSpec/src/Calc/Plus.lean
index 65816c2..65f11cd 100644
--- a/FloatSpec/src/Calc/Plus.lean
+++ b/FloatSpec/src/Calc/Plus.lean
@@ -5,6 +5,9 @@ import FloatSpec.src.Core
 import FloatSpec.src.Calc.Bracket
 import FloatSpec.src.Calc.Operations
 import FloatSpec.src.Calc.Round
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 variable (fexp : Int → Int)
diff --git a/FloatSpec/src/Calc/Plus.lean.bak b/FloatSpec/src/Calc/Plus.lean.bak
new file mode 100644
index 0000000..65816c2
--- /dev/null
+++ b/FloatSpec/src/Calc/Plus.lean.bak
@@ -0,0 +1,58 @@
+-- Helper function and theorem for computing the rounded sum of two floating-point numbers
+-- Translated from Coq file: flocq/src/Calc/Plus.v
+
+import FloatSpec.src.Core
+import FloatSpec.src.Calc.Bracket
+import FloatSpec.src.Calc.Operations
+import FloatSpec.src.Calc.Round
+
+variable (beta : Int)
+variable (fexp : Int → Int)
+variable [Monotone_exp fexp]
+
+-- Core addition function with precision control
+def Fplus_core (m1 e1 m2 e2 e : Int) : Int × Location :=
+  let k := e - e2
+  let (m2', _, l) := 
+    if 0 < k then truncate_aux beta (m2, e2, Location.loc_Exact) k
+    else (m2 * beta ^ (-k), e, Location.loc_Exact)
+  let m1' := m1 * beta ^ (e1 - e)
+  (m1' + m2', l)
+
+-- Correctness of core addition
+theorem Fplus_core_correct (m1 e1 m2 e2 e : Int) (He1 : e ≤ e1) :
+    let (m, l) := Fplus_core beta m1 e1 m2 e2 e
+    inbetween_float beta m e (F2R (FlocqFloat.mk m1 e1 : FlocqFloat beta) + F2R (FlocqFloat.mk m2 e2 : FlocqFloat beta)) l := by
+  sorry
+
+-- Main addition function
+def Fplus (f1 f2 : FlocqFloat beta) : Int × Int × Location :=
+  let m1 := f1.Fnum
+  let e1 := f1.Fexp
+  let m2 := f2.Fnum
+  let e2 := f2.Fexp
+  if m1 = 0 then
+    (m2, e2, Location.loc_Exact)
+  else if m2 = 0 then
+    (m1, e1, Location.loc_Exact)
+  else
+    let p1 := Zdigits beta m1 + e1
+    let p2 := Zdigits beta m2 + e2
+    if 2 ≤ Int.natAbs (p1 - p2) then
+      let e := min (max e1 e2) (fexp (max p1 p2 - 1))
+      let (m, l) := 
+        if e1 < e then
+          Fplus_core beta m2 e2 m1 e1 e
+        else
+          Fplus_core beta m1 e1 m2 e2 e
+      (m, e, l)
+    else
+      let (m, e) := Operations.Fplus beta f1 f2
+      (m.Fnum, m.Fexp, Location.loc_Exact)
+
+-- Correctness of addition
+theorem Fplus_correct (x y : FlocqFloat beta) :
+    let (m, e, l) := Fplus beta fexp x y
+    (l = Location.loc_Exact ∨ e ≤ cexp beta fexp (F2R x + F2R y)) ∧
+    inbetween_float beta m e (F2R x + F2R y) l := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Calc/Round.lean b/FloatSpec/src/Calc/Round.lean
index bca6150..55e1c78 100644
--- a/FloatSpec/src/Calc/Round.lean
+++ b/FloatSpec/src/Calc/Round.lean
@@ -5,6 +5,9 @@ import FloatSpec.src.Core
 import FloatSpec.src.Core.Digits
 import FloatSpec.src.Core.Float_prop
 import FloatSpec.src.Calc.Bracket
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 variable (fexp : Int → Int)
@@ -14,23 +17,23 @@ variable [Valid_exp beta fexp]
 notation "format" => generic_format beta fexp
 
 -- Canonical exponent for inbetween float
-theorem cexp_inbetween_float (x : Float) (m e : Int) (l : Location)
+theorem cexp_inbetween_float (x : ℝ) (m e : Int) (l : Location)
     (Px : 0 < x) (Bx : inbetween_float beta m e x l)
     (He : e ≤ cexp beta fexp x ∨ e ≤ fexp (Zdigits beta m + e)) :
     cexp beta fexp x = fexp (Zdigits beta m + e) := by
   sorry
 
 -- Canonical exponent with location exact condition
-theorem cexp_inbetween_float_loc_Exact (x : Float) (m e : Int) (l : Location)
+theorem cexp_inbetween_float_loc_Exact (x : ℝ) (m e : Int) (l : Location)
     (Px : 0 ≤ x) (Bx : inbetween_float beta m e x l) :
     (e ≤ cexp beta fexp x ∨ l = Location.loc_Exact) ↔
     (e ≤ fexp (Zdigits beta m + e) ∨ l = Location.loc_Exact) := by
   sorry
 
 -- Inbetween float rounding theorem
-theorem inbetween_float_round (rnd : Float → Float) (choice : Int → Location → Int)
+theorem inbetween_float_round (rnd : ℝ → Float) (choice : Int → Location → Int)
     (Hc : ∀ x m l, inbetween_int m x l → rnd x = choice m l)
-    (x : Float) (m : Int) (l : Location) :
+    (x : ℝ) (m : Int) (l : Location) :
     let e := cexp beta fexp x
     inbetween_float beta m e x l →
     round beta fexp rnd x = F2R (FlocqFloat.mk (choice m l) e : FlocqFloat beta) := by
@@ -44,12 +47,12 @@ lemma le_cond_incr_le (b : Bool) (m : Int) : m ≤ cond_incr b m ∧ cond_incr b
   sorry
 
 -- Round down for integers
-theorem inbetween_int_DN (x : Float) (m : Int) (l : Location)
+theorem inbetween_int_DN (x : ℝ) (m : Int) (l : Location)
     (Hl : inbetween_int m x l) : Zfloor x = m := by
   sorry
 
 -- Round down for floats
-theorem inbetween_float_DN (x : Float) (m : Int) (l : Location) :
+theorem inbetween_float_DN (x : ℝ) (m : Int) (l : Location) :
     let e := cexp beta fexp x
     inbetween_float beta m e x l →
     round beta fexp Zfloor x = F2R (FlocqFloat.mk m e : FlocqFloat beta) := by
@@ -62,12 +65,12 @@ def round_UP (l : Location) : Bool :=
   | _ => true
 
 -- Round up for integers
-theorem inbetween_int_UP (x : Float) (m : Int) (l : Location)
+theorem inbetween_int_UP (x : ℝ) (m : Int) (l : Location)
     (Hl : inbetween_int m x l) : Zceil x = cond_incr (round_UP l) m := by
   sorry
 
 -- Round up for floats
-theorem inbetween_float_UP (x : Float) (m : Int) (l : Location) :
+theorem inbetween_float_UP (x : ℝ) (m : Int) (l : Location) :
     let e := cexp beta fexp x
     inbetween_float beta m e x l →
     round beta fexp Zceil x = F2R (FlocqFloat.mk (cond_incr (round_UP l) m) e : FlocqFloat beta) := by
@@ -80,12 +83,12 @@ def round_ZR (s : Bool) (l : Location) : Bool :=
   | _ => s
 
 -- Round toward zero for integers
-theorem inbetween_int_ZR (x : Float) (m : Int) (l : Location)
+theorem inbetween_int_ZR (x : ℝ) (m : Int) (l : Location)
     (Hl : inbetween_int m x l) : Ztrunc x = cond_incr (round_ZR (m < 0) l) m := by
   sorry
 
 -- Round toward zero for floats
-theorem inbetween_float_ZR (x : Float) (m : Int) (l : Location) :
+theorem inbetween_float_ZR (x : ℝ) (m : Int) (l : Location) :
     let e := cexp beta fexp x
     inbetween_float beta m e x l →
     round beta fexp Ztrunc x = F2R (FlocqFloat.mk (cond_incr (round_ZR (m < 0) l) m) e : FlocqFloat beta) := by
@@ -100,29 +103,29 @@ def round_N (p : Bool) (l : Location) : Bool :=
   | Location.loc_Inexact Ordering.gt => true
 
 -- Round to nearest for integers
-theorem inbetween_int_N (choice : Int → Bool) (x : Float) (m : Int) (l : Location)
+theorem inbetween_int_N (choice : Int → Bool) (x : ℝ) (m : Int) (l : Location)
     (Hl : inbetween_int m x l) : Znearest choice x = cond_incr (round_N (choice m) l) m := by
   sorry
 
 -- Round to nearest even for integers
-theorem inbetween_int_NE (x : Float) (m : Int) (l : Location)
+theorem inbetween_int_NE (x : ℝ) (m : Int) (l : Location)
     (Hl : inbetween_int m x l) : ZnearestE x = cond_incr (round_N (¬(m % 2 = 0)) l) m := by
   sorry
 
 -- Round to nearest even for floats
-theorem inbetween_float_NE (x : Float) (m : Int) (l : Location) :
+theorem inbetween_float_NE (x : ℝ) (m : Int) (l : Location) :
     let e := cexp beta fexp x
     inbetween_float beta m e x l →
     round beta fexp ZnearestE x = F2R (FlocqFloat.mk (cond_incr (round_N (¬(m % 2 = 0)) l) m) e : FlocqFloat beta) := by
   sorry
 
 -- Round to nearest away for integers
-theorem inbetween_int_NA (x : Float) (m : Int) (l : Location)
+theorem inbetween_int_NA (x : ℝ) (m : Int) (l : Location)
     (Hl : inbetween_int m x l) : ZnearestA x = cond_incr (round_N (0 ≤ m) l) m := by
   sorry
 
 -- Round to nearest away for floats
-theorem inbetween_float_NA (x : Float) (m : Int) (l : Location) :
+theorem inbetween_float_NA (x : ℝ) (m : Int) (l : Location) :
     let e := cexp beta fexp x
     inbetween_float beta m e x l →
     round beta fexp ZnearestA x = F2R (FlocqFloat.mk (cond_incr (round_N (0 ≤ m) l) m) e : FlocqFloat beta) := by
@@ -159,14 +162,14 @@ theorem generic_format_truncate (m e : Int) (l : Location) (Hm : 0 ≤ m) :
   sorry
 
 -- Truncate correctness for partial precision
-theorem truncate_correct_partial (x : Float) (m e : Int) (l : Location)
+theorem truncate_correct_partial (x : ℝ) (m e : Int) (l : Location)
     (Hx : 0 < x) (H1 : inbetween_float beta m e x l) (H2 : e ≤ fexp (Zdigits beta m + e)) :
     let (m', e', l') := truncate beta fexp (m, e, l)
     inbetween_float beta m' e' x l' ∧ e' = cexp beta fexp x := by
   sorry
 
 -- Truncate correctness theorem
-theorem truncate_correct (x : Float) (m e : Int) (l : Location)
+theorem truncate_correct (x : ℝ) (m e : Int) (l : Location)
     (Hx : 0 ≤ x) (H1 : inbetween_float beta m e x l) 
     (H2 : e ≤ fexp (Zdigits beta m + e) ∨ l = Location.loc_Exact) :
     let (m', e', l') := truncate beta fexp (m, e, l)
@@ -175,18 +178,18 @@ theorem truncate_correct (x : Float) (m e : Int) (l : Location)
   sorry
 
 -- Round any with choice function
-theorem round_any_correct (rnd : Float → Float) [Valid_rnd rnd] (choice : Int → Location → Int)
+theorem round_any_correct (rnd : ℝ → Float) [Valid_rnd rnd] (choice : Int → Location → Int)
     (H : ∀ x m l, inbetween_int m x l → rnd x = choice m l)
-    (x : Float) (m e : Int) (l : Location)
+    (x : ℝ) (m e : Int) (l : Location)
     (Hin : inbetween_float beta m e x l)
     (He : e = cexp beta fexp x ∨ (l = Location.loc_Exact ∧ format x)) :
     round beta fexp rnd x = F2R (FlocqFloat.mk (choice m l) e : FlocqFloat beta) := by
   sorry
 
 -- Round truncate any correctness
-theorem round_trunc_any_correct (rnd : Float → Float) [Valid_rnd rnd] (choice : Int → Location → Int)
+theorem round_trunc_any_correct (rnd : ℝ → Float) [Valid_rnd rnd] (choice : Int → Location → Int)
     (H : ∀ x m l, inbetween_int m x l → rnd x = choice m l)
-    (x : Float) (m e : Int) (l : Location)
+    (x : ℝ) (m e : Int) (l : Location)
     (Hx : 0 ≤ x) (Hl : inbetween_float beta m e x l)
     (He : e ≤ fexp (Zdigits beta m + e) ∨ l = Location.loc_Exact) :
     round beta fexp rnd x = 
@@ -204,7 +207,7 @@ def truncate_FIX (emin : Int) (t : Int × Int × Location) : Int × Int × Locat
   else t
 
 -- Truncate FIX correctness
-theorem truncate_FIX_correct (emin : Int) (x : Float) (m e : Int) (l : Location)
+theorem truncate_FIX_correct (emin : Int) (x : ℝ) (m e : Int) (l : Location)
     (H1 : inbetween_float beta m e x l) (H2 : e ≤ emin ∨ l = Location.loc_Exact) :
     let (m', e', l') := truncate_FIX beta emin (m, e, l)
     inbetween_float beta m' e' x l' ∧
diff --git a/FloatSpec/src/Calc/Round.lean.bak b/FloatSpec/src/Calc/Round.lean.bak
new file mode 100644
index 0000000..9b982a5
--- /dev/null
+++ b/FloatSpec/src/Calc/Round.lean.bak
@@ -0,0 +1,212 @@
+-- Helper function for computing the rounded value of a real number
+-- Translated from Coq file: flocq/src/Calc/Round.v
+
+import FloatSpec.src.Core
+import FloatSpec.src.Core.Digits
+import FloatSpec.src.Core.Float_prop
+import FloatSpec.src.Calc.Bracket
+
+variable (beta : Int)
+variable (fexp : Int → Int)
+variable [Valid_exp beta fexp]
+
+-- Generic format notation
+notation "format" => generic_format beta fexp
+
+-- Canonical exponent for inbetween float
+theorem cexp_inbetween_float (x : ℝ) (m e : Int) (l : Location)
+    (Px : 0 < x) (Bx : inbetween_float beta m e x l)
+    (He : e ≤ cexp beta fexp x ∨ e ≤ fexp (Zdigits beta m + e)) :
+    cexp beta fexp x = fexp (Zdigits beta m + e) := by
+  sorry
+
+-- Canonical exponent with location exact condition
+theorem cexp_inbetween_float_loc_Exact (x : ℝ) (m e : Int) (l : Location)
+    (Px : 0 ≤ x) (Bx : inbetween_float beta m e x l) :
+    (e ≤ cexp beta fexp x ∨ l = Location.loc_Exact) ↔
+    (e ≤ fexp (Zdigits beta m + e) ∨ l = Location.loc_Exact) := by
+  sorry
+
+-- Inbetween float rounding theorem
+theorem inbetween_float_round (rnd : ℝ → Float) (choice : Int → Location → Int)
+    (Hc : ∀ x m l, inbetween_int m x l → rnd x = choice m l)
+    (x : ℝ) (m : Int) (l : Location) :
+    let e := cexp beta fexp x
+    inbetween_float beta m e x l →
+    round beta fexp rnd x = F2R (FlocqFloat.mk (choice m l) e : FlocqFloat beta) := by
+  sorry
+
+-- Conditional increment function
+def cond_incr (b : Bool) (m : Int) : Int := if b then m + 1 else m
+
+-- Conditional increment bounds
+lemma le_cond_incr_le (b : Bool) (m : Int) : m ≤ cond_incr b m ∧ cond_incr b m ≤ m + 1 := by
+  sorry
+
+-- Round down for integers
+theorem inbetween_int_DN (x : ℝ) (m : Int) (l : Location)
+    (Hl : inbetween_int m x l) : Zfloor x = m := by
+  sorry
+
+-- Round down for floats
+theorem inbetween_float_DN (x : ℝ) (m : Int) (l : Location) :
+    let e := cexp beta fexp x
+    inbetween_float beta m e x l →
+    round beta fexp Zfloor x = F2R (FlocqFloat.mk m e : FlocqFloat beta) := by
+  sorry
+
+-- Round up location function
+def round_UP (l : Location) : Bool :=
+  match l with
+  | Location.loc_Exact => false
+  | _ => true
+
+-- Round up for integers
+theorem inbetween_int_UP (x : ℝ) (m : Int) (l : Location)
+    (Hl : inbetween_int m x l) : Zceil x = cond_incr (round_UP l) m := by
+  sorry
+
+-- Round up for floats
+theorem inbetween_float_UP (x : ℝ) (m : Int) (l : Location) :
+    let e := cexp beta fexp x
+    inbetween_float beta m e x l →
+    round beta fexp Zceil x = F2R (FlocqFloat.mk (cond_incr (round_UP l) m) e : FlocqFloat beta) := by
+  sorry
+
+-- Round toward zero function
+def round_ZR (s : Bool) (l : Location) : Bool :=
+  match l with
+  | Location.loc_Exact => false
+  | _ => s
+
+-- Round toward zero for integers
+theorem inbetween_int_ZR (x : ℝ) (m : Int) (l : Location)
+    (Hl : inbetween_int m x l) : Ztrunc x = cond_incr (round_ZR (m < 0) l) m := by
+  sorry
+
+-- Round toward zero for floats
+theorem inbetween_float_ZR (x : ℝ) (m : Int) (l : Location) :
+    let e := cexp beta fexp x
+    inbetween_float beta m e x l →
+    round beta fexp Ztrunc x = F2R (FlocqFloat.mk (cond_incr (round_ZR (m < 0) l) m) e : FlocqFloat beta) := by
+  sorry
+
+-- Round to nearest function
+def round_N (p : Bool) (l : Location) : Bool :=
+  match l with
+  | Location.loc_Exact => false
+  | Location.loc_Inexact Ordering.lt => false
+  | Location.loc_Inexact Ordering.eq => p
+  | Location.loc_Inexact Ordering.gt => true
+
+-- Round to nearest for integers
+theorem inbetween_int_N (choice : Int → Bool) (x : ℝ) (m : Int) (l : Location)
+    (Hl : inbetween_int m x l) : Znearest choice x = cond_incr (round_N (choice m) l) m := by
+  sorry
+
+-- Round to nearest even for integers
+theorem inbetween_int_NE (x : ℝ) (m : Int) (l : Location)
+    (Hl : inbetween_int m x l) : ZnearestE x = cond_incr (round_N (¬(m % 2 = 0)) l) m := by
+  sorry
+
+-- Round to nearest even for floats
+theorem inbetween_float_NE (x : ℝ) (m : Int) (l : Location) :
+    let e := cexp beta fexp x
+    inbetween_float beta m e x l →
+    round beta fexp ZnearestE x = F2R (FlocqFloat.mk (cond_incr (round_N (¬(m % 2 = 0)) l) m) e : FlocqFloat beta) := by
+  sorry
+
+-- Round to nearest away for integers
+theorem inbetween_int_NA (x : ℝ) (m : Int) (l : Location)
+    (Hl : inbetween_int m x l) : ZnearestA x = cond_incr (round_N (0 ≤ m) l) m := by
+  sorry
+
+-- Round to nearest away for floats
+theorem inbetween_float_NA (x : ℝ) (m : Int) (l : Location) :
+    let e := cexp beta fexp x
+    inbetween_float beta m e x l →
+    round beta fexp ZnearestA x = F2R (FlocqFloat.mk (cond_incr (round_N (0 ≤ m) l) m) e : FlocqFloat beta) := by
+  sorry
+
+-- Truncate auxiliary function
+def truncate_aux (t : Int × Int × Location) (k : Int) : Int × Int × Location :=
+  let (m, e, l) := t
+  let p := beta ^ k
+  (m / p, e + k, new_location p (m % p) l)
+
+-- Truncate auxiliary composition
+theorem truncate_aux_comp (t : Int × Int × Location) (k1 k2 : Int)
+    (Hk1 : 0 < k1) (Hk2 : 0 < k2) :
+    truncate_aux beta t (k1 + k2) = truncate_aux beta (truncate_aux beta t k1) k2 := by
+  sorry
+
+-- Main truncate function
+def truncate (t : Int × Int × Location) : Int × Int × Location :=
+  let (m, e, l) := t
+  let k := fexp (Zdigits beta m + e) - e
+  if 0 < k then truncate_aux beta t k else t
+
+-- Truncate preserves zero mantissa
+theorem truncate_0 (e : Int) (l : Location) :
+    let (m', _, _) := truncate beta fexp (0, e, l)
+    m' = 0 := by
+  sorry
+
+-- Truncate produces generic format
+theorem generic_format_truncate (m e : Int) (l : Location) (Hm : 0 ≤ m) :
+    let (m', e', _) := truncate beta fexp (m, e, l)
+    format (F2R (FlocqFloat.mk m' e' : FlocqFloat beta)) := by
+  sorry
+
+-- Truncate correctness for partial precision
+theorem truncate_correct_partial (x : ℝ) (m e : Int) (l : Location)
+    (Hx : 0 < x) (H1 : inbetween_float beta m e x l) (H2 : e ≤ fexp (Zdigits beta m + e)) :
+    let (m', e', l') := truncate beta fexp (m, e, l)
+    inbetween_float beta m' e' x l' ∧ e' = cexp beta fexp x := by
+  sorry
+
+-- Truncate correctness theorem
+theorem truncate_correct (x : ℝ) (m e : Int) (l : Location)
+    (Hx : 0 ≤ x) (H1 : inbetween_float beta m e x l) 
+    (H2 : e ≤ fexp (Zdigits beta m + e) ∨ l = Location.loc_Exact) :
+    let (m', e', l') := truncate beta fexp (m, e, l)
+    inbetween_float beta m' e' x l' ∧
+    (e' = cexp beta fexp x ∨ (l' = Location.loc_Exact ∧ format x)) := by
+  sorry
+
+-- Round any with choice function
+theorem round_any_correct (rnd : ℝ → Float) [Valid_rnd rnd] (choice : Int → Location → Int)
+    (H : ∀ x m l, inbetween_int m x l → rnd x = choice m l)
+    (x : ℝ) (m e : Int) (l : Location)
+    (Hin : inbetween_float beta m e x l)
+    (He : e = cexp beta fexp x ∨ (l = Location.loc_Exact ∧ format x)) :
+    round beta fexp rnd x = F2R (FlocqFloat.mk (choice m l) e : FlocqFloat beta) := by
+  sorry
+
+-- Round truncate any correctness
+theorem round_trunc_any_correct (rnd : ℝ → Float) [Valid_rnd rnd] (choice : Int → Location → Int)
+    (H : ∀ x m l, inbetween_int m x l → rnd x = choice m l)
+    (x : ℝ) (m e : Int) (l : Location)
+    (Hx : 0 ≤ x) (Hl : inbetween_float beta m e x l)
+    (He : e ≤ fexp (Zdigits beta m + e) ∨ l = Location.loc_Exact) :
+    round beta fexp rnd x = 
+      let (m', e', l') := truncate beta fexp (m, e, l)
+      F2R (FlocqFloat.mk (choice m' l') e' : FlocqFloat beta) := by
+  sorry
+
+-- Truncate for FIX format
+def truncate_FIX (emin : Int) (t : Int × Int × Location) : Int × Int × Location :=
+  let (m, e, l) := t
+  let k := emin - e
+  if 0 < k then
+    let p := beta ^ k
+    (m / p, e + k, new_location p (m % p) l)
+  else t
+
+-- Truncate FIX correctness
+theorem truncate_FIX_correct (emin : Int) (x : ℝ) (m e : Int) (l : Location)
+    (H1 : inbetween_float beta m e x l) (H2 : e ≤ emin ∨ l = Location.loc_Exact) :
+    let (m', e', l') := truncate_FIX beta emin (m, e, l)
+    inbetween_float beta m' e' x l' ∧
+    (e' = cexp beta (FIX_exp emin) x ∨ (l' = Location.loc_Exact ∧ generic_format beta (FIX_exp emin) x)) := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Calc/Sqrt.lean b/FloatSpec/src/Calc/Sqrt.lean
index 6072944..c658afa 100644
--- a/FloatSpec/src/Calc/Sqrt.lean
+++ b/FloatSpec/src/Calc/Sqrt.lean
@@ -8,6 +8,9 @@ import FloatSpec.src.Core.Digits
 import FloatSpec.src.Core.Generic_fmt
 import FloatSpec.src.Core.Float_prop
 import FloatSpec.src.Calc.Bracket
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 variable (fexp : Int → Int)
diff --git a/FloatSpec/src/Calc/Sqrt.lean.bak b/FloatSpec/src/Calc/Sqrt.lean.bak
new file mode 100644
index 0000000..6072944
--- /dev/null
+++ b/FloatSpec/src/Calc/Sqrt.lean.bak
@@ -0,0 +1,49 @@
+-- Helper functions and theorems for computing the rounded square root of a floating-point number
+-- Translated from Coq file: flocq/src/Calc/Sqrt.v
+
+import FloatSpec.src.Core.Zaux
+import FloatSpec.src.Core.Raux
+import FloatSpec.src.Core.Defs
+import FloatSpec.src.Core.Digits
+import FloatSpec.src.Core.Generic_fmt
+import FloatSpec.src.Core.Float_prop
+import FloatSpec.src.Calc.Bracket
+
+variable (beta : Int)
+variable (fexp : Int → Int)
+
+-- Magnitude of square root of F2R
+lemma mag_sqrt_F2R (m1 e1 : Int) (Hm1 : 0 < m1) :
+    mag beta (Float.sqrt (F2R (FlocqFloat.mk m1 e1 : FlocqFloat beta))) = (Zdigits beta m1 + e1 + 1) / 2 := by
+  sorry
+
+-- Core square root function
+def Fsqrt_core (m1 e1 e : Int) : Int × Location :=
+  let d1 := Zdigits beta m1
+  let m1' := m1 * beta ^ (e1 - 2 * e)
+  let (q, r) := Int.sqrtRem m1'
+  let l := if r = 0 then Location.loc_Exact
+           else Location.loc_Inexact (if r ≤ q then Ordering.lt else Ordering.gt)
+  (q, l)
+
+-- Correctness of core square root
+theorem Fsqrt_core_correct (m1 e1 e : Int) (Hm1 : 0 < m1) (He : 2 * e ≤ e1) :
+    let (m, l) := Fsqrt_core beta m1 e1 e
+    inbetween_float beta m e (Float.sqrt (F2R (FlocqFloat.mk m1 e1 : FlocqFloat beta))) l := by
+  sorry
+
+-- Main square root function
+def Fsqrt (x : FlocqFloat beta) : Int × Int × Location :=
+  let m1 := x.Fnum
+  let e1 := x.Fexp
+  let e' := Zdigits beta m1 + e1 + 1
+  let e := min (fexp (e' / 2)) (e1 / 2)
+  let (m, l) := Fsqrt_core beta m1 e1 e
+  (m, e, l)
+
+-- Correctness of square root
+theorem Fsqrt_correct (x : FlocqFloat beta) (Hx : 0 < F2R x) :
+    let (m, e, l) := Fsqrt beta fexp x
+    e ≤ cexp beta fexp (Float.sqrt (F2R x)) ∧
+    inbetween_float beta m e (Float.sqrt (F2R x)) l := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Core/Defs.lean b/FloatSpec/src/Core/Defs.lean
index bf008b7..3a16204 100644
--- a/FloatSpec/src/Core/Defs.lean
+++ b/FloatSpec/src/Core/Defs.lean
@@ -3,6 +3,9 @@
 
 import FloatSpec.src.Core.Raux
 import FloatSpec.src.Core.Zaux
+import Mathlib.Data.Real.Basic
+
+open Real
 
 -- Basic float representation
 /-- Floating-point number representation with mantissa and exponent 
@@ -17,7 +20,7 @@ structure FlocqFloat (beta : Int) where
 variable {beta : Int}
 
 /-- Convert FlocqFloat to real number: Fnum * beta^Fexp -/
-def F2R (f : FlocqFloat beta) : Float := 
+noncomputable def F2R (f : FlocqFloat beta) : ℝ := 
   sorry -- Will be properly implemented later
 
 /-- Specification for F2R -/
@@ -28,46 +31,46 @@ theorem F2R_spec (f : FlocqFloat beta) (h : beta > 1) :
 -- Rounding predicates and properties
 
 /-- A rounding predicate is total: for every real, there exists a rounded value -/
-def round_pred_total (P : Float → Float → Prop) : Prop :=
-  ∀ x : Float, ∃ f : Float, P x f
+def round_pred_total (P : ℝ → ℝ → Prop) : Prop :=
+  ∀ x : ℝ, ∃ f : ℝ, P x f
 
 /-- A rounding predicate is monotone: preserves order -/
-def round_pred_monotone (P : Float → Float → Prop) : Prop :=
-  ∀ x y f g : Float, P x f → P y g → x ≤ y → f ≤ g
+def round_pred_monotone (P : ℝ → ℝ → Prop) : Prop :=
+  ∀ x y f g : ℝ, P x f → P y g → x ≤ y → f ≤ g
 
 /-- A proper rounding predicate is both total and monotone -/
-def round_pred (P : Float → Float → Prop) : Prop :=
+def round_pred (P : ℝ → ℝ → Prop) : Prop :=
   round_pred_total P ∧ round_pred_monotone P
 
 -- Rounding modes definitions
 
 /-- Rounding toward negative infinity (down) -/
-def Rnd_DN_pt (F : Float → Prop) (x f : Float) : Prop :=
-  F f ∧ f ≤ x ∧ ∀ g : Float, F g → g ≤ x → g ≤ f
+def Rnd_DN_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=
+  F f ∧ f ≤ x ∧ ∀ g : ℝ, F g → g ≤ x → g ≤ f
 
 /-- Rounding toward positive infinity (up) -/
-def Rnd_UP_pt (F : Float → Prop) (x f : Float) : Prop :=
-  F f ∧ x ≤ f ∧ ∀ g : Float, F g → x ≤ g → f ≤ g
+def Rnd_UP_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=
+  F f ∧ x ≤ f ∧ ∀ g : ℝ, F g → x ≤ g → f ≤ g
 
 /-- Rounding toward zero (truncation) -/
-def Rnd_ZR_pt (F : Float → Prop) (x f : Float) : Prop :=
+def Rnd_ZR_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=
   (0 ≤ x → Rnd_DN_pt F x f) ∧ (x ≤ 0 → Rnd_UP_pt F x f)
 
 /-- Rounding to nearest (any tie-breaking rule) -/
-def Rnd_N_pt (F : Float → Prop) (x f : Float) : Prop :=
-  F f ∧ ∀ g : Float, F g → (f - x).abs ≤ (g - x).abs
+def Rnd_N_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=
+  F f ∧ ∀ g : ℝ, F g → |f - x| ≤ |g - x|
 
 /-- Generic rounding to nearest with custom tie-breaking predicate -/
-def Rnd_NG_pt (F : Float → Prop) (P : Float → Float → Prop) (x f : Float) : Prop :=
-  Rnd_N_pt F x f ∧ (P x f ∨ ∀ f2 : Float, Rnd_N_pt F x f2 → f2 = f)
+def Rnd_NG_pt (F : ℝ → Prop) (P : ℝ → ℝ → Prop) (x f : ℝ) : Prop :=
+  Rnd_N_pt F x f ∧ (P x f ∨ ∀ f2 : ℝ, Rnd_N_pt F x f2 → f2 = f)
 
 /-- Rounding to nearest, ties away from zero -/
-def Rnd_NA_pt (F : Float → Prop) (x f : Float) : Prop :=
-  Rnd_N_pt F x f ∧ ∀ f2 : Float, Rnd_N_pt F x f2 → f2.abs ≤ f.abs
+def Rnd_NA_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=
+  Rnd_N_pt F x f ∧ ∀ f2 : ℝ, Rnd_N_pt F x f2 → |f2| ≤ |f|
 
 /-- Rounding to nearest, ties toward zero -/
-def Rnd_N0_pt (F : Float → Prop) (x f : Float) : Prop :=
-  Rnd_N_pt F x f ∧ ∀ f2 : Float, Rnd_N_pt F x f2 → f.abs ≤ f2.abs
+def Rnd_N0_pt (F : ℝ → Prop) (x f : ℝ) : Prop :=
+  Rnd_N_pt F x f ∧ ∀ f2 : ℝ, Rnd_N_pt F x f2 → |f| ≤ |f2|
 
 -- Helper functions for working with the float structure
 
@@ -98,55 +101,55 @@ theorem make_float_spec {beta : Int} (num exp : Int) :
 -- Properties of rounding predicates
 
 /-- Total rounding characterization -/
-theorem round_pred_total_iff (P : Float → Float → Prop) :
-  round_pred_total P ↔ (∀ x : Float, ∃ f : Float, P x f) := by
+theorem round_pred_total_iff (P : ℝ → ℝ → Prop) :
+  round_pred_total P ↔ (∀ x : ℝ, ∃ f : ℝ, P x f) := by
   rfl
 
 /-- Monotone rounding characterization -/
-theorem round_pred_monotone_iff (P : Float → Float → Prop) :
-  round_pred_monotone P ↔ (∀ x y f g : Float, P x f → P y g → x ≤ y → f ≤ g) := by
+theorem round_pred_monotone_iff (P : ℝ → ℝ → Prop) :
+  round_pred_monotone P ↔ (∀ x y f g : ℝ, P x f → P y g → x ≤ y → f ≤ g) := by
   rfl
 
 /-- Round predicate characterization -/
-theorem round_pred_iff (P : Float → Float → Prop) :
+theorem round_pred_iff (P : ℝ → ℝ → Prop) :
   round_pred P ↔ (round_pred_total P ∧ round_pred_monotone P) := by
   rfl
 
 -- Properties of specific rounding modes
 
 /-- Down rounding characterization -/
-theorem Rnd_DN_pt_iff (F : Float → Prop) (x f : Float) :
-  Rnd_DN_pt F x f ↔ (F f ∧ f ≤ x ∧ ∀ g : Float, F g → g ≤ x → g ≤ f) := by
+theorem Rnd_DN_pt_iff (F : ℝ → Prop) (x f : ℝ) :
+  Rnd_DN_pt F x f ↔ (F f ∧ f ≤ x ∧ ∀ g : ℝ, F g → g ≤ x → g ≤ f) := by
   rfl
 
 /-- Up rounding characterization -/
-theorem Rnd_UP_pt_iff (F : Float → Prop) (x f : Float) :
-  Rnd_UP_pt F x f ↔ (F f ∧ x ≤ f ∧ ∀ g : Float, F g → x ≤ g → f ≤ g) := by
+theorem Rnd_UP_pt_iff (F : ℝ → Prop) (x f : ℝ) :
+  Rnd_UP_pt F x f ↔ (F f ∧ x ≤ f ∧ ∀ g : ℝ, F g → x ≤ g → f ≤ g) := by
   rfl
 
 /-- Zero rounding characterization -/
-theorem Rnd_ZR_pt_iff (F : Float → Prop) (x f : Float) :
+theorem Rnd_ZR_pt_iff (F : ℝ → Prop) (x f : ℝ) :
   Rnd_ZR_pt F x f ↔ ((0 ≤ x → Rnd_DN_pt F x f) ∧ (x ≤ 0 → Rnd_UP_pt F x f)) := by
   rfl
 
 /-- Nearest rounding characterization -/
-theorem Rnd_N_pt_iff (F : Float → Prop) (x f : Float) :
-  Rnd_N_pt F x f ↔ (F f ∧ ∀ g : Float, F g → (f - x).abs ≤ (g - x).abs) := by
+theorem Rnd_N_pt_iff (F : ℝ → Prop) (x f : ℝ) :
+  Rnd_N_pt F x f ↔ (F f ∧ ∀ g : ℝ, F g → |f - x| ≤ |g - x|) := by
   rfl
 
 /-- Generic nearest rounding characterization -/
-theorem Rnd_NG_pt_iff (F : Float → Prop) (P : Float → Float → Prop) (x f : Float) :
-  Rnd_NG_pt F P x f ↔ (Rnd_N_pt F x f ∧ (P x f ∨ ∀ f2 : Float, Rnd_N_pt F x f2 → f2 = f)) := by
+theorem Rnd_NG_pt_iff (F : ℝ → Prop) (P : ℝ → ℝ → Prop) (x f : ℝ) :
+  Rnd_NG_pt F P x f ↔ (Rnd_N_pt F x f ∧ (P x f ∨ ∀ f2 : ℝ, Rnd_N_pt F x f2 → f2 = f)) := by
   rfl
 
 /-- Away from zero nearest rounding characterization -/
-theorem Rnd_NA_pt_iff (F : Float → Prop) (x f : Float) :
-  Rnd_NA_pt F x f ↔ (Rnd_N_pt F x f ∧ ∀ f2 : Float, Rnd_N_pt F x f2 → f2.abs ≤ f.abs) := by
+theorem Rnd_NA_pt_iff (F : ℝ → Prop) (x f : ℝ) :
+  Rnd_NA_pt F x f ↔ (Rnd_N_pt F x f ∧ ∀ f2 : ℝ, Rnd_N_pt F x f2 → |f2| ≤ |f|) := by
   rfl
 
 /-- Toward zero nearest rounding characterization -/
-theorem Rnd_N0_pt_iff (F : Float → Prop) (x f : Float) :
-  Rnd_N0_pt F x f ↔ (Rnd_N_pt F x f ∧ ∀ f2 : Float, Rnd_N_pt F x f2 → f.abs ≤ f2.abs) := by
+theorem Rnd_N0_pt_iff (F : ℝ → Prop) (x f : ℝ) :
+  Rnd_N0_pt F x f ↔ (Rnd_N_pt F x f ∧ ∀ f2 : ℝ, Rnd_N_pt F x f2 → |f| ≤ |f2|) := by
   rfl
 
 -- Basic properties of the FlocqFloat structure
diff --git a/FloatSpec/src/Core/FIX.lean b/FloatSpec/src/Core/FIX.lean
index 26fbaa3..5862735 100644
--- a/FloatSpec/src/Core/FIX.lean
+++ b/FloatSpec/src/Core/FIX.lean
@@ -3,6 +3,9 @@
 
 import FloatSpec.src.Core.Defs
 import FloatSpec.src.Core.Generic_fmt
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (emin : Int)
 
@@ -10,14 +13,14 @@ variable (emin : Int)
 def FIX_exp (e : Int) : Int := emin
 
 -- Fixed-point format
-def FIX_format (beta : Int) (x : Float) : Prop :=
+def FIX_format (beta : Int) (x : ℝ) : Prop :=
   generic_format beta FIX_exp x
 
 -- FIX format properties
 theorem FIX_exp_correct : ∀ e, FIX_exp emin e = emin := by
   sorry
 
-theorem FIX_format_generic (beta : Int) (x : Float) :
+theorem FIX_format_generic (beta : Int) (x : ℝ) :
     FIX_format beta emin x ↔ generic_format beta FIX_exp x := by
   sorry
 
@@ -25,6 +28,6 @@ theorem FIX_format_generic (beta : Int) (x : Float) :
 theorem FIX_format_0 (beta : Int) : FIX_format beta emin 0 := by
   sorry
 
-theorem FIX_format_opp (beta : Int) (x : Float) (h : FIX_format beta emin x) :
+theorem FIX_format_opp (beta : Int) (x : ℝ) (h : FIX_format beta emin x) :
     FIX_format beta emin (-x) := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Core/FLT.lean b/FloatSpec/src/Core/FLT.lean
index 3c55235..6530077 100644
--- a/FloatSpec/src/Core/FLT.lean
+++ b/FloatSpec/src/Core/FLT.lean
@@ -3,6 +3,10 @@
 
 import FloatSpec.src.Core.Defs  
 import FloatSpec.src.Core.Generic_fmt
+import FloatSpec.src.Core.FLX
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (prec emin : Int)
 
@@ -10,14 +14,14 @@ variable (prec emin : Int)
 def FLT_exp (e : Int) : Int := max (e - prec) emin
 
 -- Floating-point format
-def FLT_format (beta : Int) (x : Float) : Prop :=
+def FLT_format (beta : Int) (x : ℝ) : Prop :=
   generic_format beta FLT_exp x
 
 -- FLT format properties
 theorem FLT_exp_correct : ∀ e, FLT_exp prec emin e = max (e - prec) emin := by
   sorry
 
-theorem FLT_format_generic (beta : Int) (x : Float) :
+theorem FLT_format_generic (beta : Int) (x : ℝ) :
     FLT_format beta prec emin x ↔ generic_format beta FLT_exp x := by
   sorry
 
@@ -25,13 +29,13 @@ theorem FLT_format_generic (beta : Int) (x : Float) :
 theorem FLT_format_0 (beta : Int) : FLT_format beta prec emin 0 := by
   sorry
 
-theorem FLT_format_opp (beta : Int) (x : Float) (h : FLT_format beta prec emin x) :
+theorem FLT_format_opp (beta : Int) (x : ℝ) (h : FLT_format beta prec emin x) :
     FLT_format beta prec emin (-x) := by
   sorry
 
 -- More FLT properties  
-theorem FLT_format_abs (beta : Int) (x : Float) (h : FLT_format beta prec emin x) :
-    FLT_format beta prec emin (Float.abs x) := by
+theorem FLT_format_abs (beta : Int) (x : ℝ) (h : FLT_format beta prec emin x) :
+    FLT_format beta prec emin |x| := by
   sorry
 
 -- Relationship with FLX
diff --git a/FloatSpec/src/Core/FLX.lean b/FloatSpec/src/Core/FLX.lean
index ecf31c4..8d10b8a 100644
--- a/FloatSpec/src/Core/FLX.lean
+++ b/FloatSpec/src/Core/FLX.lean
@@ -3,6 +3,9 @@
 
 import FloatSpec.src.Core.Defs
 import FloatSpec.src.Core.Generic_fmt
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (prec : Int)
 
@@ -10,14 +13,14 @@ variable (prec : Int)
 def FLX_exp (e : Int) : Int := e - prec
 
 -- Fixed-precision format
-def FLX_format (beta : Int) (x : Float) : Prop :=
+def FLX_format (beta : Int) (x : ℝ) : Prop :=
   generic_format beta FLX_exp x
 
 -- FLX format properties
 theorem FLX_exp_correct : ∀ e, FLX_exp prec e = e - prec := by
   sorry
 
-theorem FLX_format_generic (beta : Int) (x : Float) :
+theorem FLX_format_generic (beta : Int) (x : ℝ) :
     FLX_format beta prec x ↔ generic_format beta FLX_exp x := by
   sorry
 
@@ -25,11 +28,11 @@ theorem FLX_format_generic (beta : Int) (x : Float) :
 theorem FLX_format_0 (beta : Int) : FLX_format beta prec 0 := by
   sorry
 
-theorem FLX_format_opp (beta : Int) (x : Float) (h : FLX_format beta prec x) :
+theorem FLX_format_opp (beta : Int) (x : ℝ) (h : FLX_format beta prec x) :
     FLX_format beta prec (-x) := by
   sorry
 
 -- More FLX properties
-theorem FLX_format_abs (beta : Int) (x : Float) (h : FLX_format beta prec x) :
-    FLX_format beta prec (Float.abs x) := by
+theorem FLX_format_abs (beta : Int) (x : ℝ) (h : FLX_format beta prec x) :
+    FLX_format beta prec |x| := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Core/FTZ.lean b/FloatSpec/src/Core/FTZ.lean
index 8e1cc56..7cadb2d 100644
--- a/FloatSpec/src/Core/FTZ.lean
+++ b/FloatSpec/src/Core/FTZ.lean
@@ -3,6 +3,9 @@
 
 import FloatSpec.src.Core.Defs
 import FloatSpec.src.Core.Generic_fmt
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (prec emin : Int)
 
@@ -10,14 +13,14 @@ variable (prec emin : Int)
 def FTZ_exp (e : Int) : Int := if emin ≤ e - prec then e - prec else emin
 
 -- Flush-to-zero format  
-def FTZ_format (beta : Int) (x : Float) : Prop :=
+def FTZ_format (beta : Int) (x : ℝ) : Prop :=
   generic_format beta FTZ_exp x
 
 -- FTZ format properties
 theorem FTZ_exp_correct : ∀ e, FTZ_exp prec emin e = if emin ≤ e - prec then e - prec else emin := by
   sorry
 
-theorem FTZ_format_generic (beta : Int) (x : Float) :
+theorem FTZ_format_generic (beta : Int) (x : ℝ) :
     FTZ_format beta prec emin x ↔ generic_format beta FTZ_exp x := by
   sorry
 
@@ -25,11 +28,11 @@ theorem FTZ_format_generic (beta : Int) (x : Float) :
 theorem FTZ_format_0 (beta : Int) : FTZ_format beta prec emin 0 := by
   sorry
 
-theorem FTZ_format_opp (beta : Int) (x : Float) (h : FTZ_format beta prec emin x) :
+theorem FTZ_format_opp (beta : Int) (x : ℝ) (h : FTZ_format beta prec emin x) :
     FTZ_format beta prec emin (-x) := by
   sorry
 
 -- More FTZ properties
-theorem FTZ_format_abs (beta : Int) (x : Float) (h : FTZ_format beta prec emin x) :
-    FTZ_format beta prec emin (Float.abs x) := by
+theorem FTZ_format_abs (beta : Int) (x : ℝ) (h : FTZ_format beta prec emin x) :
+    FTZ_format beta prec emin |x| := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Core/Float_prop.lean b/FloatSpec/src/Core/Float_prop.lean
index 8311d26..0bc8e77 100644
--- a/FloatSpec/src/Core/Float_prop.lean
+++ b/FloatSpec/src/Core/Float_prop.lean
@@ -5,6 +5,9 @@ import FloatSpec.src.Core.Zaux
 import FloatSpec.src.Core.Raux  
 import FloatSpec.src.Core.Defs
 import FloatSpec.src.Core.Digits
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 
@@ -59,7 +62,7 @@ theorem eq_F2R (e m1 m2 : Int) :
 
 /-- F2R commutes with absolute value -/
 theorem F2R_Zabs (m e : Int) :
-  F2R (FlocqFloat.mk (Int.natAbs m) e : FlocqFloat beta) = Float.abs (F2R (FlocqFloat.mk m e : FlocqFloat beta)) := by
+  F2R (FlocqFloat.mk (Int.natAbs m) e : FlocqFloat beta) = |F2R (FlocqFloat.mk m e : FlocqFloat beta)| := by
   sorry
 
 /-- F2R commutes with negation -/
@@ -143,30 +146,30 @@ theorem Fnum_le_0 (f : FlocqFloat beta) :
 
 /-- F2R of unit mantissa equals power of beta -/
 theorem F2R_bpow (e : Int) :
-  F2R (FlocqFloat.mk 1 e : FlocqFloat beta) = (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat) := by
+  F2R (FlocqFloat.mk 1 e : FlocqFloat beta) = (Int.natAbs beta : ℝ) ^ (Int.natAbs e : Nat) := by
   sorry
 
 /-- Power of beta bounds F2R from below -/
 theorem bpow_le_F2R (m e : Int) (h : 0 < m) :
-  (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat) ≤ F2R (FlocqFloat.mk m e : FlocqFloat beta) := by
+  (Int.natAbs beta : ℝ) ^ (Int.natAbs e : Nat) ≤ F2R (FlocqFloat.mk m e : FlocqFloat beta) := by
   sorry
 
 /-- Successor bound for powers -/
 theorem F2R_p1_le_bpow (m e1 e2 : Int) (h1 : 0 < m) 
-  (h2 : F2R (FlocqFloat.mk m e1 : FlocqFloat beta) < (Int.natAbs beta : Float) ^ (Int.natAbs e2 : Nat)) :
-  F2R (FlocqFloat.mk (m + 1) e1 : FlocqFloat beta) ≤ (Int.natAbs beta : Float) ^ (Int.natAbs e2 : Nat) := by
+  (h2 : F2R (FlocqFloat.mk m e1 : FlocqFloat beta) < (Int.natAbs beta : ℝ) ^ (Int.natAbs e2 : Nat)) :
+  F2R (FlocqFloat.mk (m + 1) e1 : FlocqFloat beta) ≤ (Int.natAbs beta : ℝ) ^ (Int.natAbs e2 : Nat) := by
   sorry
 
 /-- Predecessor bound for powers -/  
 theorem bpow_le_F2R_m1 (m e1 e2 : Int) (h1 : 1 < m)
-  (h2 : (Int.natAbs beta : Float) ^ (Int.natAbs e2 : Nat) < F2R (FlocqFloat.mk m e1 : FlocqFloat beta)) :
-  (Int.natAbs beta : Float) ^ (Int.natAbs e2 : Nat) ≤ F2R (FlocqFloat.mk (m - 1) e1 : FlocqFloat beta) := by
+  (h2 : (Int.natAbs beta : ℝ) ^ (Int.natAbs e2 : Nat) < F2R (FlocqFloat.mk m e1 : FlocqFloat beta)) :
+  (Int.natAbs beta : ℝ) ^ (Int.natAbs e2 : Nat) ≤ F2R (FlocqFloat.mk (m - 1) e1 : FlocqFloat beta) := by
   sorry
 
 /-- F2R bounded by power -/
 theorem F2R_lt_bpow (f : FlocqFloat beta) (e' : Int)
   (h : Int.natAbs f.Fnum < beta ^ Int.natAbs (e' - f.Fexp)) :
-  Float.abs (F2R f) < (Int.natAbs beta : Float) ^ (Int.natAbs e' : Nat) := by
+  |F2R f| < (Int.natAbs beta : ℝ) ^ (Int.natAbs e' : Nat) := by
   sorry
 
 -- Section: Exponent changes
@@ -180,7 +183,7 @@ theorem F2R_change_exp (e' m e : Int) (h : e' ≤ e) :
 /-- Normalization with precision bound -/
 theorem F2R_prec_normalize (m e e' p : Int) 
   (h1 : Int.natAbs m < beta ^ Int.natAbs p)
-  (h2 : (Int.natAbs beta : Float) ^ (Int.natAbs (e' - 1) : Nat) ≤ Float.abs (F2R (FlocqFloat.mk m e : FlocqFloat beta))) :
+  (h2 : (Int.natAbs beta : ℝ) ^ (Int.natAbs (e' - 1) : Nat) ≤ |F2R (FlocqFloat.mk m e : FlocqFloat beta)|) :
   F2R (FlocqFloat.mk m e : FlocqFloat beta) = 
   F2R (FlocqFloat.mk (m * beta ^ Int.natAbs (e - e' + p)) (e' - p) : FlocqFloat beta) := by
   sorry
@@ -188,7 +191,7 @@ theorem F2R_prec_normalize (m e e' p : Int)
 -- Section: Magnitude properties  
 
 /-- Magnitude bounds for F2R -/
-theorem mag_F2R_bounds (x : Float) (m e : Int) (h1 : 0 < m)
+theorem mag_F2R_bounds (x : ℝ) (m e : Int) (h1 : 0 < m)
   (h2 : F2R (FlocqFloat.mk m e : FlocqFloat beta) ≤ x)
   (h3 : x < F2R (FlocqFloat.mk (m + 1) e : FlocqFloat beta)) :
   -- Placeholder for magnitude relationship
@@ -214,7 +217,7 @@ theorem mag_F2R_Zdigits (m e : Int) (h : m ≠ 0) :
   sorry
 
 /-- Magnitude bounds with digit count -/
-theorem mag_F2R_bounds_Zdigits (x : Float) (m e : Int) (h1 : 0 < m)
+theorem mag_F2R_bounds_Zdigits (x : ℝ) (m e : Int) (h1 : 0 < m)
   (h2 : F2R (FlocqFloat.mk m e : FlocqFloat beta) ≤ x)
   (h3 : x < F2R (FlocqFloat.mk (m + 1) e : FlocqFloat beta)) :
   -- Placeholder for magnitude-digits relationship
diff --git a/FloatSpec/src/Core/Generic_fmt.lean b/FloatSpec/src/Core/Generic_fmt.lean
index ce7e7d6..7f59e8f 100644
--- a/FloatSpec/src/Core/Generic_fmt.lean
+++ b/FloatSpec/src/Core/Generic_fmt.lean
@@ -7,6 +7,9 @@ import FloatSpec.src.Core.Defs
 import FloatSpec.src.Core.Round_pred
 import FloatSpec.src.Core.Float_prop
 import FloatSpec.src.Core.Digits
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int) (h_beta : beta > 1)
 
@@ -38,7 +41,7 @@ theorem valid_exp_large' (k l : Int) (hk : fexp k < k) (h : l ≤ k) :
 -- Section: Canonical exponent and format
 
 /-- Canonical exponent function -/
-def cexp (x : Float) : Int :=
+noncomputable def cexp (x : ℝ) : Int :=
   fexp (mag beta x)
 
 /-- Canonical float property -/
@@ -46,11 +49,11 @@ def canonical (f : FlocqFloat beta) : Prop :=
   f.Fexp = cexp beta fexp (F2R f)
 
 /-- Scaled mantissa -/
-def scaled_mantissa (x : Float) : Float :=
-  x * (beta : Float) ^ (-(cexp beta fexp x))
+noncomputable def scaled_mantissa (x : ℝ) : ℝ :=
+  x * (beta : ℝ) ^ (-(cexp beta fexp x))
 
 /-- Generic format predicate -/
-def generic_format (x : Float) : Prop :=
+noncomputable def generic_format (x : ℝ) : Prop :=
   x = F2R (FlocqFloat.mk (Ztrunc (scaled_mantissa beta fexp x)) (cexp beta fexp x) : FlocqFloat beta)
 
 -- Section: Basic properties
@@ -60,26 +63,26 @@ theorem generic_format_0 : generic_format beta fexp 0 := by
   sorry
 
 /-- Canonical exponent of opposite -/
-theorem cexp_opp (x : Float) : cexp beta fexp (-x) = cexp beta fexp x := by
+theorem cexp_opp (x : ℝ) : cexp beta fexp (-x) = cexp beta fexp x := by
   sorry
 
 /-- Canonical exponent of absolute value -/
-theorem cexp_abs (x : Float) : cexp beta fexp (abs x) = cexp beta fexp x := by
+theorem cexp_abs (x : ℝ) : cexp beta fexp (abs x) = cexp beta fexp x := by
   sorry
 
 /-- Generic format implies canonical representation -/
-theorem canonical_generic_format (x : Float) (h : generic_format beta fexp x) :
+theorem canonical_generic_format (x : ℝ) (h : generic_format beta fexp x) :
     ∃ f : FlocqFloat beta, x = F2R f ∧ canonical beta fexp f := by
   sorry
 
 /-- Powers of beta in generic format -/
 theorem generic_format_bpow (e : Int) (h : fexp (e + 1) ≤ e) :
-    generic_format beta fexp ((beta : Float) ^ e) := by
+    generic_format beta fexp ((beta : ℝ) ^ e) := by
   sorry
 
 /-- Alternative power condition -/
 theorem generic_format_bpow' (e : Int) (h : fexp e ≤ e) :
-    generic_format beta fexp ((beta : Float) ^ e) := by
+    generic_format beta fexp ((beta : ℝ) ^ e) := by
   sorry
 
 /-- F2R in generic format -/
@@ -89,7 +92,7 @@ theorem generic_format_F2R (m e : Int)
   sorry
 
 /-- Alternative F2R generic format -/
-theorem generic_format_F2R' (x : Float) (f : FlocqFloat beta) (h1 : F2R f = x)
+theorem generic_format_F2R' (x : ℝ) (f : FlocqFloat beta) (h1 : F2R f = x)
     (h2 : x ≠ 0 → cexp beta fexp x ≤ f.Fexp) :
     generic_format beta fexp x := by
   sorry
@@ -118,13 +121,13 @@ theorem canonical_unique (f1 f2 : FlocqFloat beta) (h1 : canonical beta fexp f1)
 -- Section: Scaled mantissa properties
 
 /-- Scaled mantissa for generic format -/
-theorem scaled_mantissa_generic (x : Float) (h : generic_format beta fexp x) :
+theorem scaled_mantissa_generic (x : ℝ) (h : generic_format beta fexp x) :
     scaled_mantissa beta fexp x = Ztrunc (scaled_mantissa beta fexp x) := by
   sorry
 
 /-- Scaled mantissa multiplication -/
-theorem scaled_mantissa_mult_bpow (x : Float) :
-    scaled_mantissa beta fexp x * (beta : Float) ^ (cexp beta fexp x) = x := by
+theorem scaled_mantissa_mult_bpow (x : ℝ) :
+    scaled_mantissa beta fexp x * (beta : ℝ) ^ (cexp beta fexp x) = x := by
   sorry
 
 /-- Scaled mantissa of zero -/
@@ -132,92 +135,92 @@ theorem scaled_mantissa_0 : scaled_mantissa beta fexp 0 = 0 := by
   sorry
 
 /-- Scaled mantissa of opposite -/
-theorem scaled_mantissa_opp (x : Float) :
+theorem scaled_mantissa_opp (x : ℝ) :
     scaled_mantissa beta fexp (-x) = -(scaled_mantissa beta fexp x) := by
   sorry
 
 /-- Scaled mantissa of absolute value -/
-theorem scaled_mantissa_abs (x : Float) :
+theorem scaled_mantissa_abs (x : ℝ) :
     scaled_mantissa beta fexp (abs x) = abs (scaled_mantissa beta fexp x) := by
   sorry
 
 -- Section: Generic format closure properties
 
 /-- Generic format opposite -/
-theorem generic_format_opp (x : Float) (h : generic_format beta fexp x) :
+theorem generic_format_opp (x : ℝ) (h : generic_format beta fexp x) :
     generic_format beta fexp (-x) := by
   sorry
 
 /-- Generic format absolute value -/
-theorem generic_format_abs (x : Float) (h : generic_format beta fexp x) :
+theorem generic_format_abs (x : ℝ) (h : generic_format beta fexp x) :
     generic_format beta fexp (abs x) := by
   sorry
 
 /-- Generic format absolute value inverse -/
-theorem generic_format_abs_inv (x : Float) (h : generic_format beta fexp (abs x)) :
+theorem generic_format_abs_inv (x : ℝ) (h : generic_format beta fexp (abs x)) :
     generic_format beta fexp x := by
   sorry
 
 -- Section: Canonical exponent bounds
 
 /-- Canonical exponent from bounds -/
-theorem cexp_fexp (x : Float) (ex : Int)
-    (h : (beta : Float) ^ (ex - 1) ≤ abs x ∧ abs x < (beta : Float) ^ ex) :
+theorem cexp_fexp (x : ℝ) (ex : Int)
+    (h : (beta : ℝ) ^ (ex - 1) ≤ abs x ∧ abs x < (beta : ℝ) ^ ex) :
     cexp beta fexp x = fexp ex := by
   sorry
 
 /-- Canonical exponent from positive bounds -/
-theorem cexp_fexp_pos (x : Float) (ex : Int)
-    (h : (beta : Float) ^ (ex - 1) ≤ x ∧ x < (beta : Float) ^ ex) :
+theorem cexp_fexp_pos (x : ℝ) (ex : Int)
+    (h : (beta : ℝ) ^ (ex - 1) ≤ x ∧ x < (beta : ℝ) ^ ex) :
     cexp beta fexp x = fexp ex := by
   sorry
 
 -- Section: Small number properties
 
 /-- Mantissa for small positive numbers -/
-theorem mantissa_small_pos (x : Float) (ex : Int)
-    (hx : (beta : Float) ^ (ex - 1) ≤ x ∧ x < (beta : Float) ^ ex)
+theorem mantissa_small_pos (x : ℝ) (ex : Int)
+    (hx : (beta : ℝ) ^ (ex - 1) ≤ x ∧ x < (beta : ℝ) ^ ex)
     (he : ex ≤ fexp ex) :
-    0 < x * (beta : Float) ^ (-(fexp ex)) ∧ x * (beta : Float) ^ (-(fexp ex)) < 1 := by
+    0 < x * (beta : ℝ) ^ (-(fexp ex)) ∧ x * (beta : ℝ) ^ (-(fexp ex)) < 1 := by
   sorry
 
 /-- Scaled mantissa bound for small numbers -/
-theorem scaled_mantissa_lt_1 (x : Float) (ex : Int) (hx : abs x < (beta : Float) ^ ex)
+theorem scaled_mantissa_lt_1 (x : ℝ) (ex : Int) (hx : abs x < (beta : ℝ) ^ ex)
     (he : ex ≤ fexp ex) : abs (scaled_mantissa beta fexp x) < 1 := by
   sorry
 
 /-- Scaled mantissa general bound -/
-theorem scaled_mantissa_lt_bpow (x : Float) :
-    abs (scaled_mantissa beta fexp x) < (beta : Float) ^ (mag beta x - cexp beta fexp x) := by
+theorem scaled_mantissa_lt_bpow (x : ℝ) :
+    abs (scaled_mantissa beta fexp x) < (beta : ℝ) ^ (mag beta x - cexp beta fexp x) := by
   sorry
 
 -- Section: Advanced properties
 
 /-- Ulp (unit in the last place) preliminary definition -/
-def ulp_prelim (x : Float) : Float :=
-  (beta : Float) ^ (cexp beta fexp x)
+noncomputable def ulp_prelim (x : ℝ) : ℝ :=
+  (beta : ℝ) ^ (cexp beta fexp x)
 
 /-- Round to format property -/
-def round_to_format (F : Float → Prop) : Prop :=
+def round_to_format (F : ℝ → Prop) : Prop :=
   ∀ x, ∃ f, F f ∧ (∀ g, F g → abs (f - x) ≤ abs (g - x))
 
 /-- Format bounded property -/
-def format_bounded (F : Float → Prop) : Prop :=
-  ∃ M : Float, ∀ x, F x → abs x ≤ M
+def format_bounded (F : ℝ → Prop) : Prop :=
+  ∃ M : ℝ, ∀ x, F x → abs x ≤ M
 
 /-- Format discrete property -/
-def format_discrete (F : Float → Prop) : Prop :=
-  ∀ x, F x → x ≠ 0 → ∃ δ : Float, δ > 0 ∧ ∀ y, F y → y ≠ x → abs (y - x) ≥ δ
+def format_discrete (F : ℝ → Prop) : Prop :=
+  ∀ x, F x → x ≠ 0 → ∃ δ : ℝ, δ > 0 ∧ ∀ y, F y → y ≠ x → abs (y - x) ≥ δ
 
 -- Section: Generic format satisfies properties
 
 /-- Generic format is closed under rounding down -/
-theorem generic_format_round_DN (x : Float) :
+theorem generic_format_round_DN (x : ℝ) :
     ∃ f, generic_format beta fexp f ∧ Rnd_DN_pt (generic_format beta fexp) x f := by
   sorry
 
 /-- Generic format is closed under rounding up -/
-theorem generic_format_round_UP (x : Float) :
+theorem generic_format_round_UP (x : ℝ) :
     ∃ f, generic_format beta fexp f ∧ Rnd_UP_pt (generic_format beta fexp) x f := by
   sorry
 
@@ -228,8 +231,8 @@ theorem generic_format_satisfies_any : satisfies_any (generic_format beta fexp)
 -- Section: Precision and exponent bounds
 
 /-- Precision bounds for generic format -/
-theorem generic_format_precision_bound (x : Float) (h : generic_format beta fexp x) (hx : x ≠ 0) :
-    abs (scaled_mantissa beta fexp x) < (beta : Float) ^ (mag beta x - cexp beta fexp x) := by
+theorem generic_format_precision_bound (x : ℝ) (h : generic_format beta fexp x) (hx : x ≠ 0) :
+    abs (scaled_mantissa beta fexp x) < (beta : ℝ) ^ (mag beta x - cexp beta fexp x) := by
   sorry
 
 /-- Exponent monotonicity -/
@@ -237,7 +240,7 @@ theorem fexp_monotone : ∀ e1 e2 : Int, e1 ≤ e2 → fexp e1 ≤ fexp e2 := by
   sorry
 
 /-- Format equivalence under exponent bounds -/
-theorem generic_format_equiv (x : Float) (e1 e2 : Int) (h : e1 ≤ e2)
+theorem generic_format_equiv (x : ℝ) (e1 e2 : Int) (h : e1 ≤ e2)
     (h1 : generic_format beta (fun _ => e1) x) :
     generic_format beta (fun _ => e2) x := by
   sorry
@@ -245,23 +248,23 @@ theorem generic_format_equiv (x : Float) (e1 e2 : Int) (h : e1 ≤ e2)
 -- Section: Special format constructions
 
 /-- Generic format from rounding -/
-def round_to_generic (mode : Float → Float → Prop) (x : Float) : Float :=
+noncomputable def round_to_generic (mode : ℝ → ℝ → Prop) (x : ℝ) : ℝ :=
   Classical.choose (Classical.choose_spec 
     (generic_format_round_DN beta fexp x).exists)
 
 /-- Round to generic is well-defined -/
-theorem round_to_generic_spec (mode : Float → Float → Prop) (x : Float) :
+theorem round_to_generic_spec (mode : ℝ → ℝ → Prop) (x : ℝ) :
     generic_format beta fexp (round_to_generic beta fexp mode x) := by
   sorry
 
 -- Section: Format intersection and union
 
 /-- Intersection of two generic formats -/
-def generic_format_inter (fexp1 fexp2 : Int → Int) (x : Float) : Prop :=
+def generic_format_inter (fexp1 fexp2 : Int → Int) (x : ℝ) : Prop :=
   generic_format beta fexp1 x ∧ generic_format beta fexp2 x
 
 /-- Union of two generic formats -/
-def generic_format_union (fexp1 fexp2 : Int → Int) (x : Float) : Prop :=
+def generic_format_union (fexp1 fexp2 : Int → Int) (x : ℝ) : Prop :=
   generic_format beta fexp1 x ∨ generic_format beta fexp2 x
 
 /-- Intersection is a generic format -/
@@ -273,12 +276,12 @@ theorem generic_format_inter_valid (fexp1 fexp2 : Int → Int)
 -- Section: Magnitude and precision relationships
 
 /-- Magnitude is compatible with generic format -/
-theorem mag_generic_format (x : Float) (h : generic_format beta fexp x) (hx : x ≠ 0) :
+theorem mag_generic_format (x : ℝ) (h : generic_format beta fexp x) (hx : x ≠ 0) :
     fexp (mag beta x + 1) ≤ mag beta x := by
   sorry
 
 /-- Precision characterization -/
-theorem precision_generic_format (x : Float) (h : generic_format beta fexp x) (hx : x ≠ 0) :
+theorem precision_generic_format (x : ℝ) (h : generic_format beta fexp x) (hx : x ≠ 0) :
     ∃ m : Int, x = F2R (FlocqFloat.mk m (cexp beta fexp x)) ∧ 
     abs m < (beta : Int) ^ (mag beta x - cexp beta fexp x) := by
   sorry
@@ -286,36 +289,36 @@ theorem precision_generic_format (x : Float) (h : generic_format beta fexp x) (h
 -- Section: Error bounds
 
 /-- Generic format error bound -/
-theorem generic_format_error_bound (x : Float) :
+theorem generic_format_error_bound (x : ℝ) :
     ∃ f, generic_format beta fexp f ∧ 
-    abs (f - x) ≤ (1/2) * (beta : Float) ^ (cexp beta fexp x) := by
+    abs (f - x) ≤ (1/2) * (beta : ℝ) ^ (cexp beta fexp x) := by
   sorry
 
 /-- Relative error bound -/
-theorem generic_format_relative_error (x : Float) (hx : x ≠ 0) :
+theorem generic_format_relative_error (x : ℝ) (hx : x ≠ 0) :
     ∃ f, generic_format beta fexp f ∧ f ≠ 0 ∧
-    abs (f - x) / abs x ≤ (1/2) * (beta : Float) ^ (cexp beta fexp x - mag beta x) := by
+    abs (f - x) / abs x ≤ (1/2) * (beta : ℝ) ^ (cexp beta fexp x - mag beta x) := by
   sorry
 
 -- Section: Format-specific rounding modes
 
 /-- Round to nearest in generic format -/
-def round_N_to_format (x : Float) : Float :=
+noncomputable def round_N_to_format (x : ℝ) : ℝ :=
   Classical.choose (Classical.choose_spec 
     (generic_format_round_DN beta fexp x).exists)
 
 /-- Round down to generic format -/
-def round_DN_to_format (x : Float) : Float :=
+noncomputable def round_DN_to_format (x : ℝ) : ℝ :=
   Classical.choose (Classical.choose_spec 
     (generic_format_round_DN beta fexp x).exists)
 
 /-- Round up to generic format -/
-def round_UP_to_format (x : Float) : Float :=
+noncomputable def round_UP_to_format (x : ℝ) : ℝ :=
   Classical.choose (Classical.choose_spec 
     (generic_format_round_UP beta fexp x).exists)
 
 /-- Properties of format-specific rounding -/
-theorem round_to_format_properties (x : Float) :
+theorem round_to_format_properties (x : ℝ) :
     generic_format beta fexp (round_DN_to_format beta fexp x) ∧
     generic_format beta fexp (round_UP_to_format beta fexp x) ∧
     round_DN_to_format beta fexp x ≤ x ∧
diff --git a/FloatSpec/src/Core/Raux.lean b/FloatSpec/src/Core/Raux.lean
index f0898f2..b2ef474 100644
--- a/FloatSpec/src/Core/Raux.lean
+++ b/FloatSpec/src/Core/Raux.lean
@@ -2,110 +2,114 @@
 -- Translated from Coq file: flocq/src/Core/Raux.v
 
 import FloatSpec.src.Core.Zaux
+import Mathlib.Data.Real.Basic
+import Mathlib.Data.Real.Sqrt
+
+open Real
 
 -- Section: Rmissing (Real number missing definitions and lemmas)
 
 /-- If x ≤ y, then 0 ≤ y - x -/
-theorem Rle_0_minus (x y : Float) (h : x ≤ y) : 0 ≤ y - x := by
+theorem Rle_0_minus (x y : ℝ) (h : x ≤ y) : 0 ≤ y - x := by
   sorry
 
 /-- Multiplication compatibility with strict inequalities -/
-theorem Rmult_lt_compat (r1 r2 r3 r4 : Float) (h1 : 0 ≤ r1) (h2 : 0 ≤ r3) (h3 : r1 < r2) (h4 : r3 < r4) : 
+theorem Rmult_lt_compat (r1 r2 r3 r4 : ℝ) (h1 : 0 ≤ r1) (h2 : 0 ≤ r3) (h3 : r1 < r2) (h4 : r3 < r4) : 
   r1 * r3 < r2 * r4 := by
   sorry
 
 /-- Multiplication non-equality by cancellation -/
-theorem Rmult_neq_reg_r (r1 r2 r3 : Float) (h : r2 * r1 ≠ r3 * r1) : r2 ≠ r3 := by
+theorem Rmult_neq_reg_r (r1 r2 r3 : ℝ) (h : r2 * r1 ≠ r3 * r1) : r2 ≠ r3 := by
   sorry
 
 /-- Multiplication preserves non-equality -/
-theorem Rmult_neq_compat_r (r1 r2 r3 : Float) (h1 : r1 ≠ 0) (h2 : r2 ≠ r3) : r2 * r1 ≠ r3 * r1 := by
+theorem Rmult_neq_compat_r (r1 r2 r3 : ℝ) (h1 : r1 ≠ 0) (h2 : r2 ≠ r3) : r2 * r1 ≠ r3 * r1 := by
   sorry
 
 /-- Right distributivity of minimum over multiplication -/
-theorem Rmult_min_distr_r (x y z : Float) (h : 0 ≤ z) : min (x * z) (y * z) = min x y * z := by
+theorem Rmult_min_distr_r (x y z : ℝ) (h : 0 ≤ z) : min (x * z) (y * z) = min x y * z := by
   sorry
 
 /-- Left distributivity of minimum over multiplication -/
-theorem Rmult_min_distr_l (x y z : Float) (h : 0 ≤ x) : min (x * y) (x * z) = x * min y z := by
+theorem Rmult_min_distr_l (x y z : ℝ) (h : 0 ≤ x) : min (x * y) (x * z) = x * min y z := by
   sorry
 
 /-- Minimum of opposites equals negative maximum -/
-theorem Rmin_opp (x y : Float) : min (-x) (-y) = -(max x y) := by
+theorem Rmin_opp (x y : ℝ) : min (-x) (-y) = -(max x y) := by
   sorry
 
 /-- Maximum of opposites equals negative minimum -/
-theorem Rmax_opp (x y : Float) : max (-x) (-y) = -(min x y) := by
+theorem Rmax_opp (x y : ℝ) : max (-x) (-y) = -(min x y) := by
   sorry
 
 -- Section: Rcompare (Real comparison)
 
 /-- Real number comparison function -/
-def Rcompare (x y : Float) : Int :=
+noncomputable def Rcompare (x y : ℝ) : Int :=
   if x < y then -1
   else if x == y then 0
   else 1
 
 /-- Specification of Rcompare -/
-theorem Rcompare_spec (x y : Float) : 
+theorem Rcompare_spec (x y : ℝ) : 
   (Rcompare x y = -1 ↔ x < y) ∧ 
   (Rcompare x y = 0 ↔ x = y) ∧ 
   (Rcompare x y = 1 ↔ y < x) := by
   sorry
 
 /-- Rcompare is antisymmetric -/
-theorem Rcompare_sym (x y : Float) : Rcompare x y = -(Rcompare y x) := by
+theorem Rcompare_sym (x y : ℝ) : Rcompare x y = -(Rcompare y x) := by
   sorry
 
 /-- Rcompare with opposite -/
-theorem Rcompare_opp (x y : Float) : Rcompare (-x) (-y) = Rcompare y x := by
+theorem Rcompare_opp (x y : ℝ) : Rcompare (-x) (-y) = Rcompare y x := by
   sorry
 
 /-- Rcompare with addition -/
-theorem Rcompare_plus_r (x y z : Float) : Rcompare (x + z) (y + z) = Rcompare x y := by
+theorem Rcompare_plus_r (x y z : ℝ) : Rcompare (x + z) (y + z) = Rcompare x y := by
   sorry
 
 /-- Rcompare with left addition -/
-theorem Rcompare_plus_l (x y z : Float) : Rcompare (z + x) (z + y) = Rcompare x y := by
+theorem Rcompare_plus_l (x y z : ℝ) : Rcompare (z + x) (z + y) = Rcompare x y := by
   sorry
 
 /-- Rcompare with multiplication by positive -/
-theorem Rcompare_mult_r (x y z : Float) (h : 0 < z) : Rcompare (x * z) (y * z) = Rcompare x y := by
+theorem Rcompare_mult_r (x y z : ℝ) (h : 0 < z) : Rcompare (x * z) (y * z) = Rcompare x y := by
   sorry
 
 /-- Rcompare with left multiplication by positive -/
-theorem Rcompare_mult_l (x y z : Float) (h : 0 < z) : Rcompare (z * x) (z * y) = Rcompare x y := by
+theorem Rcompare_mult_l (x y z : ℝ) (h : 0 < z) : Rcompare (z * x) (z * y) = Rcompare x y := by
   sorry
 
 -- Section: Boolean comparisons
 
 /-- Boolean less-or-equal comparison -/
-def Rle_bool (x y : Float) : Bool := (x ≤ y)
+noncomputable def Rle_bool (x y : ℝ) : Bool := (x ≤ y)
 
 /-- Specification of Rle_bool -/
-theorem Rle_bool_spec (x y : Float) : Rle_bool x y = true ↔ x ≤ y := by
+theorem Rle_bool_spec (x y : ℝ) : Rle_bool x y = true ↔ x ≤ y := by
   sorry
 
 /-- Boolean less-than comparison -/
-def Rlt_bool (x y : Float) : Bool := (x < y)
+noncomputable def Rlt_bool (x y : ℝ) : Bool := (x < y)
 
 /-- Specification of Rlt_bool -/
-theorem Rlt_bool_spec (x y : Float) : Rlt_bool x y = true ↔ x < y := by
+theorem Rlt_bool_spec (x y : ℝ) : Rlt_bool x y = true ↔ x < y := by
   sorry
 
 /-- Negation of Rlt_bool -/
-theorem negb_Rlt_bool (x y : Float) : !(Rlt_bool x y) ↔ (y ≤ x) := by
+theorem negb_Rlt_bool (x y : ℝ) : !(Rlt_bool x y) ↔ (y ≤ x) := by
   sorry
 
 /-- Negation of Rle_bool -/
-theorem negb_Rle_bool (x y : Float) : !(Rle_bool x y) ↔ (y < x) := by
+theorem negb_Rle_bool (x y : ℝ) : !(Rle_bool x y) ↔ (y < x) := by
   sorry
 
 /-- Boolean equality comparison -/
-def Req_bool (x y : Float) : Bool := (x == y)
+noncomputable def Req_bool (x y : ℝ) : Bool := (x == y)
 
 /-- Specification of Req_bool -/
-theorem Req_bool_spec (x y : Float) : Req_bool x y = true ↔ x = y := by
+theorem Req_bool_spec (x y : ℝ) : Req_bool x y = true ↔ x = y := by
   sorry
 
 -- Section: Boolean operations
@@ -117,15 +121,15 @@ theorem eqb_sym (a b : Bool) : (a == b) = (b == a) := by
 -- Section: Conditional opposite
 
 /-- Conditional opposite operation -/
-def cond_Ropp (b : Bool) (m : Float) : Float :=
+def cond_Ropp (b : Bool) (m : ℝ) : ℝ :=
   if b then -m else m
 
 /-- Conditional opposite involutive property -/
-theorem cond_Ropp_involutive (b : Bool) (m : Float) : 
+theorem cond_Ropp_involutive (b : Bool) (m : ℝ) : 
   cond_Ropp b (cond_Ropp b m) = m := by
   sorry
 
 /-- Conditional opposite injection -/
-theorem cond_Ropp_inj (b : Bool) (m1 m2 : Float) (h : cond_Ropp b m1 = cond_Ropp b m2) : 
+theorem cond_Ropp_inj (b : Bool) (m1 m2 : ℝ) (h : cond_Ropp b m1 = cond_Ropp b m2) : 
   m1 = m2 := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Core/Round_NE.lean b/FloatSpec/src/Core/Round_NE.lean
index c1dc7b6..89bb51c 100644
--- a/FloatSpec/src/Core/Round_NE.lean
+++ b/FloatSpec/src/Core/Round_NE.lean
@@ -8,17 +8,20 @@ import FloatSpec.src.Core.Round_pred
 import FloatSpec.src.Core.Generic_fmt
 import FloatSpec.src.Core.Float_prop
 import FloatSpec.src.Core.Ulp
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 variable (fexp : Int → Int)
 variable [Valid_exp beta fexp]
 
 -- Nearest-even rounding property
-def NE_prop (x : Float) (f : Float) : Prop :=
+def NE_prop (x : ℝ) (f : ℝ) : Prop :=
   ∃ g : FlocqFloat beta, f = F2R g ∧ canonical beta fexp g ∧ g.Fnum % 2 = 0
 
 -- Nearest-even rounding predicate
-def Rnd_NE_pt : Float → Float → Prop :=
+def Rnd_NE_pt : ℝ → ℝ → Prop :=
   Rnd_NG_pt (generic_format beta fexp) NE_prop
 
 -- Down-up parity property for positive numbers
@@ -38,7 +41,7 @@ theorem Rnd_NE_pt_unique_prop : Rnd_NG_pt_unique_prop (generic_format beta fexp)
   sorry
 
 -- Nearest-even rounding is unique
-theorem Rnd_NE_pt_unique (x f1 f2 : Float)
+theorem Rnd_NE_pt_unique (x f1 f2 : ℝ)
     (h1 : Rnd_NE_pt beta fexp x f1) (h2 : Rnd_NE_pt beta fexp x f2) : f1 = f2 := by
   sorry
 
@@ -51,8 +54,8 @@ theorem satisfies_any_imp_NE : satisfies_any (generic_format beta fexp) → roun
   sorry
 
 -- More theorems would be here...
-theorem Rnd_NE_pt_refl (x : Float) (hx : generic_format beta fexp x) : Rnd_NE_pt beta fexp x x := by
+theorem Rnd_NE_pt_refl (x : ℝ) (hx : generic_format beta fexp x) : Rnd_NE_pt beta fexp x x := by
   sorry
 
-theorem Rnd_NE_pt_idempotent (x f : Float) (h : Rnd_NE_pt beta fexp x f) (hx : generic_format beta fexp x) : f = x := by
+theorem Rnd_NE_pt_idempotent (x f : ℝ) (h : Rnd_NE_pt beta fexp x f) (hx : generic_format beta fexp x) : f = x := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Core/Round_pred.lean b/FloatSpec/src/Core/Round_pred.lean
index 97de681..083fdd0 100644
--- a/FloatSpec/src/Core/Round_pred.lean
+++ b/FloatSpec/src/Core/Round_pred.lean
@@ -3,138 +3,141 @@
 
 import FloatSpec.src.Core.Raux
 import FloatSpec.src.Core.Defs
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable {beta : Int}
 
 -- Section: Rounding property definitions
 
 /-- Rounding down property for functions -/
-def Rnd_DN (F : Float → Prop) (rnd : Float → Float) : Prop :=
-  ∀ x : Float, Rnd_DN_pt F x (rnd x)
+def Rnd_DN (F : ℝ → Prop) (rnd : ℝ → ℝ) : Prop :=
+  ∀ x : ℝ, Rnd_DN_pt F x (rnd x)
 
 /-- Rounding up property for functions -/
-def Rnd_UP (F : Float → Prop) (rnd : Float → Float) : Prop :=
-  ∀ x : Float, Rnd_UP_pt F x (rnd x)
+def Rnd_UP (F : ℝ → Prop) (rnd : ℝ → ℝ) : Prop :=
+  ∀ x : ℝ, Rnd_UP_pt F x (rnd x)
 
 /-- Rounding toward zero property for functions -/
-def Rnd_ZR (F : Float → Prop) (rnd : Float → Float) : Prop :=
-  ∀ x : Float, Rnd_ZR_pt F x (rnd x)
+def Rnd_ZR (F : ℝ → Prop) (rnd : ℝ → ℝ) : Prop :=
+  ∀ x : ℝ, Rnd_ZR_pt F x (rnd x)
 
 /-- Round to nearest property for functions -/
-def Rnd_N (F : Float → Prop) (rnd : Float → Float) : Prop :=
-  ∀ x : Float, Rnd_N_pt F x (rnd x)
+def Rnd_N (F : ℝ → Prop) (rnd : ℝ → ℝ) : Prop :=
+  ∀ x : ℝ, Rnd_N_pt F x (rnd x)
 
 /-- Generic rounding property with tie-breaking predicate -/
-def Rnd_NG (F : Float → Prop) (P : Float → Float → Prop) (rnd : Float → Float) : Prop :=
-  ∀ x : Float, Rnd_NG_pt F P x (rnd x)
+def Rnd_NG (F : ℝ → Prop) (P : ℝ → ℝ → Prop) (rnd : ℝ → ℝ) : Prop :=
+  ∀ x : ℝ, Rnd_NG_pt F P x (rnd x)
 
 /-- Round ties away from zero property -/
-def Rnd_NA (F : Float → Prop) (rnd : Float → Float) : Prop :=
-  ∀ x : Float, Rnd_NA_pt F x (rnd x)
+def Rnd_NA (F : ℝ → Prop) (rnd : ℝ → ℝ) : Prop :=
+  ∀ x : ℝ, Rnd_NA_pt F x (rnd x)
 
 /-- Round ties toward zero property -/
-def Rnd_N0 (F : Float → Prop) (rnd : Float → Float) : Prop :=
-  ∀ x : Float, Rnd_N0_pt F x (rnd x)
+def Rnd_N0 (F : ℝ → Prop) (rnd : ℝ → ℝ) : Prop :=
+  ∀ x : ℝ, Rnd_N0_pt F x (rnd x)
 
 -- Section: Basic theorems
 
 /-- Value existence from round predicate -/
-theorem round_val_of_pred (rnd : Float → Float → Prop) (h : round_pred rnd) (x : Float) :
-    ∃ f : Float, rnd x f := by
+theorem round_val_of_pred (rnd : ℝ → ℝ → Prop) (h : round_pred rnd) (x : ℝ) :
+    ∃ f : ℝ, rnd x f := by
   sorry
 
 /-- Function existence from round predicate -/
-theorem round_fun_of_pred (rnd : Float → Float → Prop) (h : round_pred rnd) :
-    ∃ f : Float → Float, ∀ x, rnd x (f x) := by
+theorem round_fun_of_pred (rnd : ℝ → ℝ → Prop) (h : round_pred rnd) :
+    ∃ f : ℝ → ℝ, ∀ x, rnd x (f x) := by
   sorry
 
 /-- Uniqueness of rounding result -/
-theorem round_unique (rnd : Float → Float → Prop) (hr : round_pred_monotone rnd)
-    (x f1 f2 : Float) (h1 : rnd x f1) (h2 : rnd x f2) : f1 = f2 := by
+theorem round_unique (rnd : ℝ → ℝ → Prop) (hr : round_pred_monotone rnd)
+    (x f1 f2 : ℝ) (h1 : rnd x f1) (h2 : rnd x f2) : f1 = f2 := by
   sorry
 
 -- Section: Round down properties
 
 /-- Round down is monotone -/
-theorem Rnd_DN_pt_monotone (F : Float → Prop) : round_pred_monotone (Rnd_DN_pt F) := by
+theorem Rnd_DN_pt_monotone (F : ℝ → Prop) : round_pred_monotone (Rnd_DN_pt F) := by
   sorry
 
 /-- Round down point is unique -/
-theorem Rnd_DN_pt_unique (F : Float → Prop) (x f1 f2 : Float) 
+theorem Rnd_DN_pt_unique (F : ℝ → Prop) (x f1 f2 : ℝ) 
     (h1 : Rnd_DN_pt F x f1) (h2 : Rnd_DN_pt F x f2) : f1 = f2 := by
   sorry
 
 /-- Round down function is unique -/
-theorem Rnd_DN_unique (F : Float → Prop) (rnd1 rnd2 : Float → Float)
-    (h1 : Rnd_DN F rnd1) (h2 : Rnd_DN F rnd2) (x : Float) : rnd1 x = rnd2 x := by
+theorem Rnd_DN_unique (F : ℝ → Prop) (rnd1 rnd2 : ℝ → ℝ)
+    (h1 : Rnd_DN F rnd1) (h2 : Rnd_DN F rnd2) (x : ℝ) : rnd1 x = rnd2 x := by
   sorry
 
 -- Section: Round up properties
 
 /-- Round up is monotone -/
-theorem Rnd_UP_pt_monotone (F : Float → Prop) : round_pred_monotone (Rnd_UP_pt F) := by
+theorem Rnd_UP_pt_monotone (F : ℝ → Prop) : round_pred_monotone (Rnd_UP_pt F) := by
   sorry
 
 /-- Round up point is unique -/
-theorem Rnd_UP_pt_unique (F : Float → Prop) (x f1 f2 : Float)
+theorem Rnd_UP_pt_unique (F : ℝ → Prop) (x f1 f2 : ℝ)
     (h1 : Rnd_UP_pt F x f1) (h2 : Rnd_UP_pt F x f2) : f1 = f2 := by
   sorry
 
 /-- Round up function is unique -/
-theorem Rnd_UP_unique (F : Float → Prop) (rnd1 rnd2 : Float → Float)
-    (h1 : Rnd_UP F rnd1) (h2 : Rnd_UP F rnd2) (x : Float) : rnd1 x = rnd2 x := by
+theorem Rnd_UP_unique (F : ℝ → Prop) (rnd1 rnd2 : ℝ → ℝ)
+    (h1 : Rnd_UP F rnd1) (h2 : Rnd_UP F rnd2) (x : ℝ) : rnd1 x = rnd2 x := by
   sorry
 
 -- Section: Round up/down duality
 
 /-- Round up from round down with opposite -/
-theorem Rnd_UP_pt_opp (F : Float → Prop) (hF : ∀ x, F x → F (-x))
-    (x f : Float) (h : Rnd_DN_pt F x f) : Rnd_UP_pt F (-x) (-f) := by
+theorem Rnd_UP_pt_opp (F : ℝ → Prop) (hF : ∀ x, F x → F (-x))
+    (x f : ℝ) (h : Rnd_DN_pt F x f) : Rnd_UP_pt F (-x) (-f) := by
   sorry
 
 /-- Round down from round up with opposite -/
-theorem Rnd_DN_pt_opp (F : Float → Prop) (hF : ∀ x, F x → F (-x))
-    (x f : Float) (h : Rnd_UP_pt F x f) : Rnd_DN_pt F (-x) (-f) := by
+theorem Rnd_DN_pt_opp (F : ℝ → Prop) (hF : ∀ x, F x → F (-x))
+    (x f : ℝ) (h : Rnd_UP_pt F x f) : Rnd_DN_pt F (-x) (-f) := by
   sorry
 
 /-- Round down opposite relation -/
-theorem Rnd_DN_opp (F : Float → Prop) (hF : ∀ x, F x → F (-x))
-    (rnd1 rnd2 : Float → Float) (h1 : Rnd_DN F rnd1) (h2 : Rnd_UP F rnd2)
-    (x : Float) : rnd1 (-x) = -(rnd2 x) := by
+theorem Rnd_DN_opp (F : ℝ → Prop) (hF : ∀ x, F x → F (-x))
+    (rnd1 rnd2 : ℝ → ℝ) (h1 : Rnd_DN F rnd1) (h2 : Rnd_UP F rnd2)
+    (x : ℝ) : rnd1 (-x) = -(rnd2 x) := by
   sorry
 
 -- Section: Split property
 
 /-- Split property for round down/up -/
-theorem Rnd_DN_UP_pt_split (F : Float → Prop) (x d u : Float)
-    (hd : Rnd_DN_pt F x d) (hu : Rnd_UP_pt F x u) (f : Float) (hf : F f) :
+theorem Rnd_DN_UP_pt_split (F : ℝ → Prop) (x d u : ℝ)
+    (hd : Rnd_DN_pt F x d) (hu : Rnd_UP_pt F x u) (f : ℝ) (hf : F f) :
     f ≤ d ∨ u ≤ f := by
   sorry
 
 -- Section: Reflexivity and idempotency
 
 /-- Round down is reflexive -/
-theorem Rnd_DN_pt_refl (F : Float → Prop) (x : Float) (hx : F x) :
+theorem Rnd_DN_pt_refl (F : ℝ → Prop) (x : ℝ) (hx : F x) :
     Rnd_DN_pt F x x := by
   sorry
 
 /-- Round down is idempotent -/
-theorem Rnd_DN_pt_idempotent (F : Float → Prop) (x f : Float)
+theorem Rnd_DN_pt_idempotent (F : ℝ → Prop) (x f : ℝ)
     (h : Rnd_DN_pt F x f) (hx : F x) : f = x := by
   sorry
 
 /-- Round up is reflexive -/
-theorem Rnd_UP_pt_refl (F : Float → Prop) (x : Float) (hx : F x) :
+theorem Rnd_UP_pt_refl (F : ℝ → Prop) (x : ℝ) (hx : F x) :
     Rnd_UP_pt F x x := by
   sorry
 
 /-- Round up is idempotent -/
-theorem Rnd_UP_pt_idempotent (F : Float → Prop) (x f : Float)
+theorem Rnd_UP_pt_idempotent (F : ℝ → Prop) (x f : ℝ)
     (h : Rnd_UP_pt F x f) (hx : F x) : f = x := by
   sorry
 
 /-- Only round down or up possible -/
-theorem Only_DN_or_UP (F : Float → Prop) (x fd fu f : Float)
+theorem Only_DN_or_UP (F : ℝ → Prop) (x fd fu f : ℝ)
     (hd : Rnd_DN_pt F x fd) (hu : Rnd_UP_pt F x fu) (hf : F f) (h : fd ≤ f ∧ f ≤ fu) :
     f = fd ∨ f = fu := by
   sorry
@@ -142,90 +145,90 @@ theorem Only_DN_or_UP (F : Float → Prop) (x fd fu f : Float)
 -- Section: Round toward zero properties
 
 /-- Round toward zero absolute value bound -/
-theorem Rnd_ZR_abs (F : Float → Prop) (rnd : Float → Float) (h : Rnd_ZR F rnd)
-    (x : Float) : Float.abs (rnd x) ≤ Float.abs x := by
+theorem Rnd_ZR_abs (F : ℝ → Prop) (rnd : ℝ → ℝ) (h : Rnd_ZR F rnd)
+    (x : ℝ) : |rnd x| ≤ |x| := by
   sorry
 
 /-- Round toward zero is monotone -/
-theorem Rnd_ZR_pt_monotone (F : Float → Prop) (f0 : F 0) :
+theorem Rnd_ZR_pt_monotone (F : ℝ → Prop) (f0 : F 0) :
     round_pred_monotone (Rnd_ZR_pt F) := by
   sorry
 
 -- Section: Round to nearest properties
 
 /-- Round to nearest is either round down or up -/
-theorem Rnd_N_pt_DN_or_UP (F : Float → Prop) (x f : Float) (h : Rnd_N_pt F x f) :
+theorem Rnd_N_pt_DN_or_UP (F : ℝ → Prop) (x f : ℝ) (h : Rnd_N_pt F x f) :
     Rnd_DN_pt F x f ∨ Rnd_UP_pt F x f := by
   sorry
 
 /-- Round to nearest equals either round down or up -/
-theorem Rnd_N_pt_DN_or_UP_eq (F : Float → Prop) (x fd fu f : Float)
+theorem Rnd_N_pt_DN_or_UP_eq (F : ℝ → Prop) (x fd fu f : ℝ)
     (hd : Rnd_DN_pt F x fd) (hu : Rnd_UP_pt F x fu) (hf : Rnd_N_pt F x f) :
     f = fd ∨ f = fu := by
   sorry
 
 /-- Round to nearest opposite invariance -/
-theorem Rnd_N_pt_opp_inv (F : Float → Prop) (hF : ∀ x, F x → F (-x))
-    (x f : Float) (h : Rnd_N_pt F (-x) (-f)) : Rnd_N_pt F x f := by
+theorem Rnd_N_pt_opp_inv (F : ℝ → Prop) (hF : ∀ x, F x → F (-x))
+    (x f : ℝ) (h : Rnd_N_pt F (-x) (-f)) : Rnd_N_pt F x f := by
   sorry
 
 /-- Round to nearest is monotone -/
-theorem Rnd_N_pt_monotone (F : Float → Prop) (x y f g : Float)
+theorem Rnd_N_pt_monotone (F : ℝ → Prop) (x y f g : ℝ)
     (hf : Rnd_N_pt F x f) (hg : Rnd_N_pt F y g) (h : x < y) : f ≤ g := by
   sorry
 
 /-- Round to nearest uniqueness under tie-breaking conditions -/
-theorem Rnd_N_pt_unique (F : Float → Prop) (x d u f1 f2 : Float)
+theorem Rnd_N_pt_unique (F : ℝ → Prop) (x d u f1 f2 : ℝ)
     (hd : Rnd_DN_pt F x d) (hu : Rnd_UP_pt F x u) (hdu : x - d ≠ u - x)
     (hf1 : Rnd_N_pt F x f1) (hf2 : Rnd_N_pt F x f2) : f1 = f2 := by
   sorry
 
 /-- Round to nearest is reflexive -/
-theorem Rnd_N_pt_refl (F : Float → Prop) (x : Float) (hx : F x) :
+theorem Rnd_N_pt_refl (F : ℝ → Prop) (x : ℝ) (hx : F x) :
     Rnd_N_pt F x x := by
   sorry
 
 /-- Round to nearest is idempotent -/
-theorem Rnd_N_pt_idempotent (F : Float → Prop) (x f : Float)
+theorem Rnd_N_pt_idempotent (F : ℝ → Prop) (x f : ℝ)
     (h : Rnd_N_pt F x f) (hx : F x) : f = x := by
   sorry
 
 /-- Round to nearest of zero -/
-theorem Rnd_N_pt_0 (F : Float → Prop) (hF : F 0) : Rnd_N_pt F 0 0 := by
+theorem Rnd_N_pt_0 (F : ℝ → Prop) (hF : F 0) : Rnd_N_pt F 0 0 := by
   sorry
 
 /-- Round to nearest preserves non-negativity -/
-theorem Rnd_N_pt_ge_0 (F : Float → Prop) (hF : F 0) (x f : Float)
+theorem Rnd_N_pt_ge_0 (F : ℝ → Prop) (hF : F 0) (x f : ℝ)
     (hx : 0 ≤ x) (h : Rnd_N_pt F x f) : 0 ≤ f := by
   sorry
 
 /-- Round to nearest preserves non-positivity -/
-theorem Rnd_N_pt_le_0 (F : Float → Prop) (hF : F 0) (x f : Float)
+theorem Rnd_N_pt_le_0 (F : ℝ → Prop) (hF : F 0) (x f : ℝ)
     (hx : x ≤ 0) (h : Rnd_N_pt F x f) : f ≤ 0 := by
   sorry
 
 /-- Round to nearest preserves absolute value -/
-theorem Rnd_N_pt_abs (F : Float → Prop) (hF0 : F 0) (hF : ∀ x, F x → F (-x))
-    (x f : Float) (h : Rnd_N_pt F x f) : Rnd_N_pt F (Float.abs x) (Float.abs f) := by
+theorem Rnd_N_pt_abs (F : ℝ → Prop) (hF0 : F 0) (hF : ∀ x, F x → F (-x))
+    (x f : ℝ) (h : Rnd_N_pt F x f) : Rnd_N_pt F |x| |f| := by
   sorry
 
 -- Section: Round to nearest constructions
 
 /-- Round to nearest from bounds -/
-theorem Rnd_N_pt_DN_UP (F : Float → Prop) (x d u f : Float) (hf : F f)
+theorem Rnd_N_pt_DN_UP (F : ℝ → Prop) (x d u f : ℝ) (hf : F f)
     (hd : Rnd_DN_pt F x d) (hu : Rnd_UP_pt F x u)
-    (hd_bound : Float.abs (f - x) ≤ x - d) (hu_bound : Float.abs (f - x) ≤ u - x) : 
+    (hd_bound : |f - x| ≤ x - d) (hu_bound : |f - x| ≤ u - x) : 
     Rnd_N_pt F x f := by
   sorry
 
 /-- Round to nearest down -/
-theorem Rnd_N_pt_DN (F : Float → Prop) (x d u : Float)
+theorem Rnd_N_pt_DN (F : ℝ → Prop) (x d u : ℝ)
     (hd : Rnd_DN_pt F x d) (hu : Rnd_UP_pt F x u) (h : x - d ≤ u - x) :
     Rnd_N_pt F x d := by
   sorry
 
 /-- Round to nearest up -/
-theorem Rnd_N_pt_UP (F : Float → Prop) (x d u : Float)
+theorem Rnd_N_pt_UP (F : ℝ → Prop) (x d u : ℝ)
     (hd : Rnd_DN_pt F x d) (hu : Rnd_UP_pt F x u) (h : u - x ≤ x - d) :
     Rnd_N_pt F x u := by
   sorry
@@ -233,201 +236,201 @@ theorem Rnd_N_pt_UP (F : Float → Prop) (x d u : Float)
 -- Section: Generic rounding with tie-breaking
 
 /-- Generic rounding uniqueness property -/
-def Rnd_NG_pt_unique_prop (F : Float → Prop) (P : Float → Float → Prop) : Prop :=
+def Rnd_NG_pt_unique_prop (F : ℝ → Prop) (P : ℝ → ℝ → Prop) : Prop :=
   ∀ x d u, Rnd_DN_pt F x d → Rnd_N_pt F x d → Rnd_UP_pt F x u → Rnd_N_pt F x u →
   P x d → P x u → d = u
 
 /-- Generic rounding uniqueness -/
-theorem Rnd_NG_pt_unique (F : Float → Prop) (P : Float → Float → Prop)
-    (hp : Rnd_NG_pt_unique_prop F P) (x f1 f2 : Float)
+theorem Rnd_NG_pt_unique (F : ℝ → Prop) (P : ℝ → ℝ → Prop)
+    (hp : Rnd_NG_pt_unique_prop F P) (x f1 f2 : ℝ)
     (h1 : Rnd_NG_pt F P x f1) (h2 : Rnd_NG_pt F P x f2) : f1 = f2 := by
   sorry
 
 /-- Generic rounding is monotone -/
-theorem Rnd_NG_pt_monotone (F : Float → Prop) (P : Float → Float → Prop)
+theorem Rnd_NG_pt_monotone (F : ℝ → Prop) (P : ℝ → ℝ → Prop)
     (hp : Rnd_NG_pt_unique_prop F P) : round_pred_monotone (Rnd_NG_pt F P) := by
   sorry
 
 /-- Generic rounding is reflexive -/
-theorem Rnd_NG_pt_refl (F : Float → Prop) (P : Float → Float → Prop)
-    (x : Float) (hx : F x) : Rnd_NG_pt F P x x := by
+theorem Rnd_NG_pt_refl (F : ℝ → Prop) (P : ℝ → ℝ → Prop)
+    (x : ℝ) (hx : F x) : Rnd_NG_pt F P x x := by
   sorry
 
 /-- Generic rounding opposite invariance -/
-theorem Rnd_NG_pt_opp_inv (F : Float → Prop) (P : Float → Float → Prop)
+theorem Rnd_NG_pt_opp_inv (F : ℝ → Prop) (P : ℝ → ℝ → Prop)
     (hF : ∀ x, F x → F (-x)) (hP : ∀ x f, P x f → P (-x) (-f))
-    (x f : Float) (h : Rnd_NG_pt F P (-x) (-f)) : Rnd_NG_pt F P x f := by
+    (x f : ℝ) (h : Rnd_NG_pt F P (-x) (-f)) : Rnd_NG_pt F P x f := by
   sorry
 
 /-- Generic rounding function uniqueness -/
-theorem Rnd_NG_unique (F : Float → Prop) (P : Float → Float → Prop)
-    (hp : Rnd_NG_pt_unique_prop F P) (rnd1 rnd2 : Float → Float)
-    (h1 : Rnd_NG F P rnd1) (h2 : Rnd_NG F P rnd2) (x : Float) : rnd1 x = rnd2 x := by
+theorem Rnd_NG_unique (F : ℝ → Prop) (P : ℝ → ℝ → Prop)
+    (hp : Rnd_NG_pt_unique_prop F P) (rnd1 rnd2 : ℝ → ℝ)
+    (h1 : Rnd_NG F P rnd1) (h2 : Rnd_NG F P rnd2) (x : ℝ) : rnd1 x = rnd2 x := by
   sorry
 
 -- Section: Round ties away from zero
 
 /-- Round ties away relates to generic rounding -/
-theorem Rnd_NA_NG_pt (F : Float → Prop) (hF : F 0) (x f : Float) :
-    Rnd_NA_pt F x f ↔ Rnd_NG_pt F (fun x f => Float.abs x ≤ Float.abs f) x f := by
+theorem Rnd_NA_NG_pt (F : ℝ → Prop) (hF : F 0) (x f : ℝ) :
+    Rnd_NA_pt F x f ↔ Rnd_NG_pt F (fun x f => |x| ≤ |f|) x f := by
   sorry
 
 /-- Round ties away uniqueness property -/
-theorem Rnd_NA_pt_unique_prop (F : Float → Prop) (hF : F 0) :
-    Rnd_NG_pt_unique_prop F (fun a b => Float.abs a ≤ Float.abs b) := by
+theorem Rnd_NA_pt_unique_prop (F : ℝ → Prop) (hF : F 0) :
+    Rnd_NG_pt_unique_prop F (fun a b => |a| ≤ |b|) := by
   sorry
 
 /-- Round ties away uniqueness -/
-theorem Rnd_NA_pt_unique (F : Float → Prop) (hF : F 0) (x f1 f2 : Float)
+theorem Rnd_NA_pt_unique (F : ℝ → Prop) (hF : F 0) (x f1 f2 : ℝ)
     (h1 : Rnd_NA_pt F x f1) (h2 : Rnd_NA_pt F x f2) : f1 = f2 := by
   sorry
 
 /-- Round ties away from nearest -/
-theorem Rnd_NA_pt_N (F : Float → Prop) (hF : F 0) (x f : Float)
-    (hf : Rnd_N_pt F x f) (h : Float.abs x ≤ Float.abs f) : Rnd_NA_pt F x f := by
+theorem Rnd_NA_pt_N (F : ℝ → Prop) (hF : F 0) (x f : ℝ)
+    (hf : Rnd_N_pt F x f) (h : |x| ≤ |f|) : Rnd_NA_pt F x f := by
   sorry
 
 /-- Round ties away function uniqueness -/
-theorem Rnd_NA_unique (F : Float → Prop) (hF : F 0) (rnd1 rnd2 : Float → Float)
-    (h1 : Rnd_NA F rnd1) (h2 : Rnd_NA F rnd2) (x : Float) : rnd1 x = rnd2 x := by
+theorem Rnd_NA_unique (F : ℝ → Prop) (hF : F 0) (rnd1 rnd2 : ℝ → ℝ)
+    (h1 : Rnd_NA F rnd1) (h2 : Rnd_NA F rnd2) (x : ℝ) : rnd1 x = rnd2 x := by
   sorry
 
 /-- Round ties away is monotone -/
-theorem Rnd_NA_pt_monotone (F : Float → Prop) (hF : F 0) :
+theorem Rnd_NA_pt_monotone (F : ℝ → Prop) (hF : F 0) :
     round_pred_monotone (Rnd_NA_pt F) := by
   sorry
 
 /-- Round ties away is reflexive -/
-theorem Rnd_NA_pt_refl (F : Float → Prop) (x : Float) (hx : F x) :
+theorem Rnd_NA_pt_refl (F : ℝ → Prop) (x : ℝ) (hx : F x) :
     Rnd_NA_pt F x x := by
   sorry
 
 /-- Round ties away is idempotent -/
-theorem Rnd_NA_pt_idempotent (F : Float → Prop) (x f : Float)
+theorem Rnd_NA_pt_idempotent (F : ℝ → Prop) (x f : ℝ)
     (h : Rnd_NA_pt F x f) (hx : F x) : f = x := by
   sorry
 
 -- Section: Round ties toward zero
 
 /-- Round ties toward zero relates to generic rounding -/
-theorem Rnd_N0_NG_pt (F : Float → Prop) (hF : F 0) (x f : Float) :
-    Rnd_N0_pt F x f ↔ Rnd_NG_pt F (fun x f => Float.abs f ≤ Float.abs x) x f := by
+theorem Rnd_N0_NG_pt (F : ℝ → Prop) (hF : F 0) (x f : ℝ) :
+    Rnd_N0_pt F x f ↔ Rnd_NG_pt F (fun x f => |f| ≤ |x|) x f := by
   sorry
 
 /-- Round ties toward zero uniqueness property -/
-theorem Rnd_N0_pt_unique_prop (F : Float → Prop) (hF : F 0) :
-    Rnd_NG_pt_unique_prop F (fun x f => Float.abs f ≤ Float.abs x) := by
+theorem Rnd_N0_pt_unique_prop (F : ℝ → Prop) (hF : F 0) :
+    Rnd_NG_pt_unique_prop F (fun x f => |f| ≤ |x|) := by
   sorry
 
 /-- Round ties toward zero uniqueness -/
-theorem Rnd_N0_pt_unique (F : Float → Prop) (hF : F 0) (x f1 f2 : Float)
+theorem Rnd_N0_pt_unique (F : ℝ → Prop) (hF : F 0) (x f1 f2 : ℝ)
     (h1 : Rnd_N0_pt F x f1) (h2 : Rnd_N0_pt F x f2) : f1 = f2 := by
   sorry
 
 /-- Round ties toward zero from nearest -/
-theorem Rnd_N0_pt_N (F : Float → Prop) (hF : F 0) (x f : Float)
-    (hf : Rnd_N_pt F x f) (h : Float.abs f ≤ Float.abs x) : Rnd_N0_pt F x f := by
+theorem Rnd_N0_pt_N (F : ℝ → Prop) (hF : F 0) (x f : ℝ)
+    (hf : Rnd_N_pt F x f) (h : |f| ≤ |x|) : Rnd_N0_pt F x f := by
   sorry
 
 /-- Round ties toward zero function uniqueness -/
-theorem Rnd_N0_unique (F : Float → Prop) (hF : F 0) (rnd1 rnd2 : Float → Float)
-    (h1 : Rnd_N0 F rnd1) (h2 : Rnd_N0 F rnd2) (x : Float) : rnd1 x = rnd2 x := by
+theorem Rnd_N0_unique (F : ℝ → Prop) (hF : F 0) (rnd1 rnd2 : ℝ → ℝ)
+    (h1 : Rnd_N0 F rnd1) (h2 : Rnd_N0 F rnd2) (x : ℝ) : rnd1 x = rnd2 x := by
   sorry
 
 /-- Round ties toward zero is monotone -/
-theorem Rnd_N0_pt_monotone (F : Float → Prop) (hF : F 0) :
+theorem Rnd_N0_pt_monotone (F : ℝ → Prop) (hF : F 0) :
     round_pred_monotone (Rnd_N0_pt F) := by
   sorry
 
 /-- Round ties toward zero is reflexive -/
-theorem Rnd_N0_pt_refl (F : Float → Prop) (x : Float) (hx : F x) :
+theorem Rnd_N0_pt_refl (F : ℝ → Prop) (x : ℝ) (hx : F x) :
     Rnd_N0_pt F x x := by
   sorry
 
 /-- Round ties toward zero is idempotent -/
-theorem Rnd_N0_pt_idempotent (F : Float → Prop) (x f : Float)
+theorem Rnd_N0_pt_idempotent (F : ℝ → Prop) (x f : ℝ)
     (h : Rnd_N0_pt F x f) (hx : F x) : f = x := by
   sorry
 
 -- Section: General round predicate properties
 
 /-- Round predicate preserves non-negativity -/
-theorem round_pred_ge_0 (P : Float → Float → Prop) (hp : round_pred_monotone P)
-    (h0 : P 0 0) (x f : Float) (h : P x f) (hx : 0 ≤ x) : 0 ≤ f := by
+theorem round_pred_ge_0 (P : ℝ → ℝ → Prop) (hp : round_pred_monotone P)
+    (h0 : P 0 0) (x f : ℝ) (h : P x f) (hx : 0 ≤ x) : 0 ≤ f := by
   sorry
 
 /-- Round predicate with positive result implies positive input -/
-theorem round_pred_gt_0 (P : Float → Float → Prop) (hp : round_pred_monotone P)
-    (h0 : P 0 0) (x f : Float) (h : P x f) (hf : 0 < f) : 0 < x := by
+theorem round_pred_gt_0 (P : ℝ → ℝ → Prop) (hp : round_pred_monotone P)
+    (h0 : P 0 0) (x f : ℝ) (h : P x f) (hf : 0 < f) : 0 < x := by
   sorry
 
 /-- Round predicate preserves non-positivity -/
-theorem round_pred_le_0 (P : Float → Float → Prop) (hp : round_pred_monotone P)
-    (h0 : P 0 0) (x f : Float) (h : P x f) (hx : x ≤ 0) : f ≤ 0 := by
+theorem round_pred_le_0 (P : ℝ → ℝ → Prop) (hp : round_pred_monotone P)
+    (h0 : P 0 0) (x f : ℝ) (h : P x f) (hx : x ≤ 0) : f ≤ 0 := by
   sorry
 
 /-- Round predicate with negative result implies negative input -/
-theorem round_pred_lt_0 (P : Float → Float → Prop) (hp : round_pred_monotone P)
-    (h0 : P 0 0) (x f : Float) (h : P x f) (hf : f < 0) : x < 0 := by
+theorem round_pred_lt_0 (P : ℝ → ℝ → Prop) (hp : round_pred_monotone P)
+    (h0 : P 0 0) (x f : ℝ) (h : P x f) (hf : f < 0) : x < 0 := by
   sorry
 
 -- Section: Format equivalence
 
 /-- Round down point equivalence across formats -/
-theorem Rnd_DN_pt_equiv_format (F1 F2 : Float → Prop) (a b : Float) (ha : F1 a)
-    (hF : ∀ x, a ≤ x ∧ x ≤ b → (F1 x ↔ F2 x)) (x f : Float) 
+theorem Rnd_DN_pt_equiv_format (F1 F2 : ℝ → Prop) (a b : ℝ) (ha : F1 a)
+    (hF : ∀ x, a ≤ x ∧ x ≤ b → (F1 x ↔ F2 x)) (x f : ℝ) 
     (hx : a ≤ x ∧ x ≤ b) (h : Rnd_DN_pt F1 x f) : Rnd_DN_pt F2 x f := by
   sorry
 
 /-- Round up point equivalence across formats -/
-theorem Rnd_UP_pt_equiv_format (F1 F2 : Float → Prop) (a b : Float) (hb : F1 b)
-    (hF : ∀ x, a ≤ x ∧ x ≤ b → (F1 x ↔ F2 x)) (x f : Float)
+theorem Rnd_UP_pt_equiv_format (F1 F2 : ℝ → Prop) (a b : ℝ) (hb : F1 b)
+    (hF : ∀ x, a ≤ x ∧ x ≤ b → (F1 x ↔ F2 x)) (x f : ℝ)
     (hx : a ≤ x ∧ x ≤ b) (h : Rnd_UP_pt F1 x f) : Rnd_UP_pt F2 x f := by
   sorry
 
 -- Section: Format satisfaction properties
 
 /-- Format satisfaction inductive type -/
-inductive satisfies_any (F : Float → Prop) : Prop where
+inductive satisfies_any (F : ℝ → Prop) : Prop where
   /-- Constructor for format satisfaction -/
   | mk : F 0 → (∀ x, F x → F (-x)) → round_pred_total (Rnd_DN_pt F) → satisfies_any F
 
 /-- Format satisfaction equivalence -/
-theorem satisfies_any_eq (F1 F2 : Float → Prop) (heq : ∀ x, F1 x ↔ F2 x)
+theorem satisfies_any_eq (F1 F2 : ℝ → Prop) (heq : ∀ x, F1 x ↔ F2 x)
     (h : satisfies_any F1) : satisfies_any F2 := by
   sorry
 
 /-- Satisfies any implies round down -/
-theorem satisfies_any_imp_DN (F : Float → Prop) (h : satisfies_any F) :
+theorem satisfies_any_imp_DN (F : ℝ → Prop) (h : satisfies_any F) :
     round_pred (Rnd_DN_pt F) := by
   sorry
 
 /-- Satisfies any implies round up -/
-theorem satisfies_any_imp_UP (F : Float → Prop) (h : satisfies_any F) :
+theorem satisfies_any_imp_UP (F : ℝ → Prop) (h : satisfies_any F) :
     round_pred (Rnd_UP_pt F) := by
   sorry
 
 /-- Satisfies any implies round toward zero -/
-theorem satisfies_any_imp_ZR (F : Float → Prop) (h : satisfies_any F) :
+theorem satisfies_any_imp_ZR (F : ℝ → Prop) (h : satisfies_any F) :
     round_pred (Rnd_ZR_pt F) := by
   sorry
 
 /-- Generic rounding existence property -/
-def NG_existence_prop (F : Float → Prop) (P : Float → Float → Prop) : Prop :=
+def NG_existence_prop (F : ℝ → Prop) (P : ℝ → ℝ → Prop) : Prop :=
   ∀ x d u, ¬F x → Rnd_DN_pt F x d → Rnd_UP_pt F x u → P x u ∨ P x d
 
 /-- Satisfies any implies generic rounding -/
-theorem satisfies_any_imp_NG (F : Float → Prop) (P : Float → Float → Prop)
+theorem satisfies_any_imp_NG (F : ℝ → Prop) (P : ℝ → ℝ → Prop)
     (h : satisfies_any F) (hp : NG_existence_prop F P) :
     round_pred_total (Rnd_NG_pt F P) := by
   sorry
 
 /-- Satisfies any implies round ties away -/
-theorem satisfies_any_imp_NA (F : Float → Prop) (h : satisfies_any F) :
+theorem satisfies_any_imp_NA (F : ℝ → Prop) (h : satisfies_any F) :
     round_pred (Rnd_NA_pt F) := by
   sorry
 
 /-- Satisfies any implies round ties toward zero -/
-theorem satisfies_any_imp_N0 (F : Float → Prop) (hF : F 0) (h : satisfies_any F) :
+theorem satisfies_any_imp_N0 (F : ℝ → Prop) (hF : F 0) (h : satisfies_any F) :
     round_pred (Rnd_N0_pt F) := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Core/Ulp.lean b/FloatSpec/src/Core/Ulp.lean
index 60d968b..1dc7e99 100644
--- a/FloatSpec/src/Core/Ulp.lean
+++ b/FloatSpec/src/Core/Ulp.lean
@@ -4,55 +4,58 @@
 import FloatSpec.src.Core.Defs
 import FloatSpec.src.Core.Generic_fmt
 import FloatSpec.src.Core.Float_prop
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 variable (fexp : Int → Int)
 
 -- Unit in the last place function
-def ulp (x : Float) : Float :=
-  if x = 0 then (beta : Float) ^ (fexp 1)
-  else (beta : Float) ^ (cexp beta fexp x)
+noncomputable def ulp (x : ℝ) : ℝ :=
+  if x = 0 then (beta : ℝ) ^ (fexp 1)
+  else (beta : ℝ) ^ (cexp beta fexp x)
 
 -- ULP properties
-theorem ulp_ge_0 (x : Float) : 0 ≤ ulp beta fexp x := by
+theorem ulp_ge_0 (x : ℝ) : 0 ≤ ulp beta fexp x := by
   sorry
 
-theorem ulp_opp (x : Float) : ulp beta fexp (-x) = ulp beta fexp x := by
+theorem ulp_opp (x : ℝ) : ulp beta fexp (-x) = ulp beta fexp x := by
   sorry
 
-theorem ulp_abs (x : Float) : ulp beta fexp (Float.abs x) = ulp beta fexp x := by
+theorem ulp_abs (x : ℝ) : ulp beta fexp |x| = ulp beta fexp x := by
   sorry
 
 -- ULP and generic format
-theorem generic_format_ulp (x : Float) (hx : x ≠ 0) :
+theorem generic_format_ulp (x : ℝ) (hx : x ≠ 0) :
     generic_format beta fexp (ulp beta fexp x) := by
   sorry
 
 -- ULP bounds
-theorem ulp_le_id (x : Float) (hx : 0 < x) (hf : generic_format beta fexp x) :
+theorem ulp_le_id (x : ℝ) (hx : 0 < x) (hf : generic_format beta fexp x) :
     ulp beta fexp x ≤ x := by
   sorry
 
 -- Successor in format
-def succ (x : Float) : Float := x + ulp beta fexp x
+noncomputable def succ (x : ℝ) : ℝ := x + ulp beta fexp x
 
 -- Predecessor in format  
-def pred (x : Float) : Float := x - ulp beta fexp x
+noncomputable def pred (x : ℝ) : ℝ := x - ulp beta fexp x
 
 -- Successor properties
-theorem succ_ge_id (x : Float) : x ≤ succ beta fexp x := by
+theorem succ_ge_id (x : ℝ) : x ≤ succ beta fexp x := by
   sorry
 
-theorem generic_format_succ (x : Float) (hf : generic_format beta fexp x) :
+theorem generic_format_succ (x : ℝ) (hf : generic_format beta fexp x) :
     generic_format beta fexp (succ beta fexp x) := by
   sorry
 
 -- More ULP theorems would be here...
-theorem ulp_neq_0 (x : Float) : ulp beta fexp x ≠ 0 := by
+theorem ulp_neq_0 (x : ℝ) : ulp beta fexp x ≠ 0 := by
   sorry
 
 -- Error bounds with ULP
-theorem error_lt_ulp (x : Float) (f : Float) (hf : generic_format beta fexp f)
-    (h : Float.abs (f - x) < ulp beta fexp x / 2) :
+theorem error_lt_ulp (x : ℝ) (f : ℝ) (hf : generic_format beta fexp f)
+    (h : |f - x| < ulp beta fexp x / 2) :
     round beta fexp ZnearestE x = f := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/IEEE754/Binary.lean b/FloatSpec/src/IEEE754/Binary.lean
index edf3f4e..7d50ddb 100644
--- a/FloatSpec/src/IEEE754/Binary.lean
+++ b/FloatSpec/src/IEEE754/Binary.lean
@@ -3,6 +3,9 @@
 
 import FloatSpec.src.Core
 import FloatSpec.src.Calc
+import Mathlib.Data.Real.Basic
+
+open Real
 
 -- IEEE 754 full float representation
 inductive FullFloat where
@@ -27,14 +30,14 @@ def FF2SF (x : FullFloat) : StandardFloat :=
   | FullFloat.F754_finite s m e => StandardFloat.S754_finite s m e
 
 -- Conversion from FullFloat to real number
-def FF2R (beta : Int) (x : FullFloat) : Float :=
+def FF2R (beta : Int) (x : FullFloat) : ℝ :=
   match x with
   | FullFloat.F754_finite s m e => 
     F2R (FlocqFloat.mk (if s then -(m : Int) else (m : Int)) e : FlocqFloat beta)
   | _ => 0
 
 -- Conversion from StandardFloat to real number
-def SF2R (beta : Int) (x : StandardFloat) : Float :=
+def SF2R (beta : Int) (x : StandardFloat) : ℝ :=
   match x with
   | StandardFloat.S754_finite s m e => 
     F2R (FlocqFloat.mk (if s then -(m : Int) else (m : Int)) e : FlocqFloat beta)
@@ -153,7 +156,7 @@ inductive RoundingMode where
   | RTZ : RoundingMode  -- Round toward zero
 
 -- Convert rounding mode to rounding function
-def rnd_of_mode (mode : RoundingMode) : Float → Int := by
+def rnd_of_mode (mode : RoundingMode) : ℝ → Int := by
   sorry
 
 -- Binary format properties
diff --git a/FloatSpec/src/IEEE754/Binary.lean.bak b/FloatSpec/src/IEEE754/Binary.lean.bak
new file mode 100644
index 0000000..edf3f4e
--- /dev/null
+++ b/FloatSpec/src/IEEE754/Binary.lean.bak
@@ -0,0 +1,176 @@
+-- IEEE-754 binary arithmetic
+-- Translated from Coq file: flocq/src/IEEE754/Binary.v
+
+import FloatSpec.src.Core
+import FloatSpec.src.Calc
+
+-- IEEE 754 full float representation
+inductive FullFloat where
+  | F754_zero (s : Bool) : FullFloat
+  | F754_infinity (s : Bool) : FullFloat
+  | F754_nan (s : Bool) (m : Nat) : FullFloat
+  | F754_finite (s : Bool) (m : Nat) (e : Int) : FullFloat
+
+-- Standard float representation
+inductive StandardFloat where
+  | S754_zero (s : Bool) : StandardFloat
+  | S754_infinity (s : Bool) : StandardFloat
+  | S754_nan : StandardFloat
+  | S754_finite (s : Bool) (m : Nat) (e : Int) : StandardFloat
+
+-- Conversion from FullFloat to StandardFloat
+def FF2SF (x : FullFloat) : StandardFloat :=
+  match x with
+  | FullFloat.F754_zero s => StandardFloat.S754_zero s
+  | FullFloat.F754_infinity s => StandardFloat.S754_infinity s
+  | FullFloat.F754_nan _ _ => StandardFloat.S754_nan
+  | FullFloat.F754_finite s m e => StandardFloat.S754_finite s m e
+
+-- Conversion from FullFloat to real number
+def FF2R (beta : Int) (x : FullFloat) : Float :=
+  match x with
+  | FullFloat.F754_finite s m e => 
+    F2R (FlocqFloat.mk (if s then -(m : Int) else (m : Int)) e : FlocqFloat beta)
+  | _ => 0
+
+-- Conversion from StandardFloat to real number
+def SF2R (beta : Int) (x : StandardFloat) : Float :=
+  match x with
+  | StandardFloat.S754_finite s m e => 
+    F2R (FlocqFloat.mk (if s then -(m : Int) else (m : Int)) e : FlocqFloat beta)
+  | _ => 0
+
+-- SF2R and FF2SF consistency
+theorem SF2R_FF2SF (beta : Int) (x : FullFloat) :
+  SF2R beta (FF2SF x) = FF2R beta x := by
+  sorry
+
+-- Conversion from StandardFloat to FullFloat
+def SF2FF (x : StandardFloat) : FullFloat :=
+  match x with
+  | StandardFloat.S754_zero s => FullFloat.F754_zero s
+  | StandardFloat.S754_infinity s => FullFloat.F754_infinity s
+  | StandardFloat.S754_nan => FullFloat.F754_nan false 1
+  | StandardFloat.S754_finite s m e => FullFloat.F754_finite s m e
+
+-- Round-trip property
+theorem FF2SF_SF2FF (x : StandardFloat) :
+  FF2SF (SF2FF x) = x := by
+  sorry
+
+-- NaN detection for FullFloat
+def is_nan_FF (f : FullFloat) : Bool :=
+  match f with
+  | FullFloat.F754_nan _ _ => true
+  | _ => false
+
+-- NaN detection for StandardFloat
+def is_nan_SF (f : StandardFloat) : Bool :=
+  match f with
+  | StandardFloat.S754_nan => true
+  | _ => false
+
+-- NaN detection consistency
+theorem is_nan_SF2FF (x : StandardFloat) :
+  is_nan_FF (SF2FF x) = is_nan_SF x := by
+  sorry
+
+-- Sign extraction for FullFloat
+def sign_FF (x : FullFloat) : Bool :=
+  match x with
+  | FullFloat.F754_nan s _ => s
+  | FullFloat.F754_zero s => s
+  | FullFloat.F754_infinity s => s
+  | FullFloat.F754_finite s _ _ => s
+
+-- Sign extraction for StandardFloat
+def sign_SF (x : StandardFloat) : Bool :=
+  match x with
+  | StandardFloat.S754_zero s => s
+  | StandardFloat.S754_infinity s => s
+  | StandardFloat.S754_nan => false
+  | StandardFloat.S754_finite s _ _ => s
+
+-- Finite check for FullFloat
+def is_finite_FF (f : FullFloat) : Bool :=
+  match f with
+  | FullFloat.F754_finite _ _ _ => true
+  | FullFloat.F754_zero _ => true
+  | _ => false
+
+-- Finite check for StandardFloat
+def is_finite_SF (f : StandardFloat) : Bool :=
+  match f with
+  | StandardFloat.S754_finite _ _ _ => true
+  | StandardFloat.S754_zero _ => true
+  | _ => false
+
+-- Finite check consistency
+theorem is_finite_SF2FF (x : StandardFloat) :
+  is_finite_FF (SF2FF x) = is_finite_SF x := by
+  sorry
+
+-- Sign consistency
+theorem sign_SF2FF (x : StandardFloat) :
+  sign_FF (SF2FF x) = sign_SF x := by
+  sorry
+
+-- Section: Binary IEEE 754 formats
+
+variable (prec emax : Int)
+variable [Prec_gt_0 prec]
+variable [Prec_lt_emax prec emax]
+
+-- IEEE 754 binary format
+structure Binary754 where
+  val : FullFloat
+  valid : is_finite_FF val = true → 
+    -- Valid range and precision constraints
+    True
+
+-- Standard IEEE 754 operations
+def binary_add (x y : Binary754 prec emax) : Binary754 prec emax := by
+  sorry
+
+def binary_sub (x y : Binary754 prec emax) : Binary754 prec emax := by
+  sorry
+
+def binary_mul (x y : Binary754 prec emax) : Binary754 prec emax := by
+  sorry
+
+def binary_div (x y : Binary754 prec emax) : Binary754 prec emax := by
+  sorry
+
+def binary_sqrt (x : Binary754 prec emax) : Binary754 prec emax := by
+  sorry
+
+-- IEEE 754 rounding modes
+inductive RoundingMode where
+  | RNE : RoundingMode  -- Round to nearest, ties to even
+  | RNA : RoundingMode  -- Round to nearest, ties away from zero
+  | RTP : RoundingMode  -- Round toward positive infinity
+  | RTN : RoundingMode  -- Round toward negative infinity
+  | RTZ : RoundingMode  -- Round toward zero
+
+-- Convert rounding mode to rounding function
+def rnd_of_mode (mode : RoundingMode) : Float → Int := by
+  sorry
+
+-- Binary format properties
+theorem binary_add_correct (mode : RoundingMode) (x y : Binary754 prec emax) :
+  FF2R 2 (binary_add x y).val = 
+  round 2 (FLT_exp (3 - emax - prec) prec) (rnd_of_mode mode) 
+    (FF2R 2 x.val + FF2R 2 y.val) := by
+  sorry
+
+theorem binary_mul_correct (mode : RoundingMode) (x y : Binary754 prec emax) :
+  FF2R 2 (binary_mul x y).val = 
+  round 2 (FLT_exp (3 - emax - prec) prec) (rnd_of_mode mode) 
+    (FF2R 2 x.val * FF2R 2 y.val) := by
+  sorry
+
+-- Common IEEE 754 formats
+def Binary16 := Binary754 11 15
+def Binary32 := Binary754 24 127
+def Binary64 := Binary754 53 1023
+def Binary128 := Binary754 113 16383
\ No newline at end of file
diff --git a/FloatSpec/src/IEEE754/BinarySingleNaN.lean b/FloatSpec/src/IEEE754/BinarySingleNaN.lean
index 481d8ef..d887ecd 100644
--- a/FloatSpec/src/IEEE754/BinarySingleNaN.lean
+++ b/FloatSpec/src/IEEE754/BinarySingleNaN.lean
@@ -2,6 +2,9 @@
 -- Translated from Coq file: flocq/src/IEEE754/BinarySingleNaN.v
 
 import FloatSpec.src.IEEE754.Binary
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (prec emax : Int)
 variable [Prec_gt_0 prec]
@@ -15,7 +18,7 @@ inductive B754 where
   | B754_finite (s : Bool) (m : Nat) (e : Int) : B754
 
 -- Conversion to real number
-def B754_to_R (x : B754 prec emax) : Float :=
+def B754_to_R (x : B754 prec emax) : ℝ :=
   match x with
   | B754.B754_finite s m e => 
     F2R (FlocqFloat.mk (if s then -(m : Int) else (m : Int)) e : FlocqFloat 2)
diff --git a/FloatSpec/src/IEEE754/BinarySingleNaN.lean.bak b/FloatSpec/src/IEEE754/BinarySingleNaN.lean.bak
new file mode 100644
index 0000000..481d8ef
--- /dev/null
+++ b/FloatSpec/src/IEEE754/BinarySingleNaN.lean.bak
@@ -0,0 +1,82 @@
+-- Binary single NaN operations
+-- Translated from Coq file: flocq/src/IEEE754/BinarySingleNaN.v
+
+import FloatSpec.src.IEEE754.Binary
+
+variable (prec emax : Int)
+variable [Prec_gt_0 prec]
+variable [Prec_lt_emax prec emax]
+
+-- Binary float with single NaN representation
+inductive B754 where
+  | B754_zero (s : Bool) : B754
+  | B754_infinity (s : Bool) : B754
+  | B754_nan : B754
+  | B754_finite (s : Bool) (m : Nat) (e : Int) : B754
+
+-- Conversion to real number
+def B754_to_R (x : B754 prec emax) : Float :=
+  match x with
+  | B754.B754_finite s m e => 
+    F2R (FlocqFloat.mk (if s then -(m : Int) else (m : Int)) e : FlocqFloat 2)
+  | _ => 0
+
+-- Valid B754 predicate
+def valid_B754 (x : B754 prec emax) : Prop :=
+  match x with
+  | B754.B754_finite s m e => 
+    -- Mantissa in range and exponent constraints
+    (1 ≤ m : Prop) ∧ (m < 2^(Int.natAbs (prec - 1) : Nat) : Prop) ∧
+    (3 - emax - prec ≤ e : Prop) ∧ (e ≤ emax - prec : Prop)
+  | _ => True
+
+-- Operations preserving single NaN
+def B754_plus (mode : RoundingMode) (x y : B754 prec emax) : B754 prec emax := by
+  sorry
+
+def B754_mult (mode : RoundingMode) (x y : B754 prec emax) : B754 prec emax := by
+  sorry
+
+def B754_div (mode : RoundingMode) (x y : B754 prec emax) : B754 prec emax := by
+  sorry
+
+def B754_sqrt (mode : RoundingMode) (x : B754 prec emax) : B754 prec emax := by
+  sorry
+
+-- Classification functions
+def B754_is_finite (x : B754 prec emax) : Bool :=
+  match x with
+  | B754.B754_finite _ _ _ => true
+  | B754.B754_zero _ => true
+  | _ => false
+
+def B754_is_nan (x : B754 prec emax) : Bool :=
+  match x with
+  | B754.B754_nan => true
+  | _ => false
+
+def B754_sign (x : B754 prec emax) : Bool :=
+  match x with
+  | B754.B754_zero s => s
+  | B754.B754_infinity s => s
+  | B754.B754_finite s _ _ => s
+  | B754.B754_nan => false
+
+-- Correctness of operations
+theorem B754_plus_correct (mode : RoundingMode) (x y : B754 prec emax)
+  (hx : valid_B754 x) (hy : valid_B754 y) :
+  valid_B754 (B754_plus mode x y) ∧
+  (¬B754_is_nan (B754_plus mode x y) → 
+   B754_to_R (B754_plus mode x y) = 
+   round 2 (FLT_exp (3 - emax - prec) prec) (rnd_of_mode mode) 
+     (B754_to_R x + B754_to_R y)) := by
+  sorry
+
+theorem B754_mult_correct (mode : RoundingMode) (x y : B754 prec emax)
+  (hx : valid_B754 x) (hy : valid_B754 y) :
+  valid_B754 (B754_mult mode x y) ∧
+  (¬B754_is_nan (B754_mult mode x y) → 
+   B754_to_R (B754_mult mode x y) = 
+   round 2 (FLT_exp (3 - emax - prec) prec) (rnd_of_mode mode) 
+     (B754_to_R x * B754_to_R y)) := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/IEEE754/Bits.lean b/FloatSpec/src/IEEE754/Bits.lean
index 2577f47..ed763a8 100644
--- a/FloatSpec/src/IEEE754/Bits.lean
+++ b/FloatSpec/src/IEEE754/Bits.lean
@@ -3,6 +3,9 @@
 
 import FloatSpec.src.Core
 import FloatSpec.src.IEEE754.Binary
+import Mathlib.Data.Real.Basic
+
+open Real
 
 -- Number of bits for the fraction and exponent
 variable (mw ew : Int)
diff --git a/FloatSpec/src/IEEE754/Bits.lean.bak b/FloatSpec/src/IEEE754/Bits.lean.bak
new file mode 100644
index 0000000..2577f47
--- /dev/null
+++ b/FloatSpec/src/IEEE754/Bits.lean.bak
@@ -0,0 +1,102 @@
+-- IEEE-754 encoding of binary floating-point data
+-- Translated from Coq file: flocq/src/IEEE754/Bits.v
+
+import FloatSpec.src.Core
+import FloatSpec.src.IEEE754.Binary
+
+-- Number of bits for the fraction and exponent
+variable (mw ew : Int)
+
+-- Join bits into IEEE 754 bit representation
+def join_bits (s : Bool) (m e : Int) : Int :=
+  let sign_bit := if s then 2^ew else 0
+  (sign_bit + e) * 2^mw + m
+
+-- Join bits range theorem
+theorem join_bits_range (s : Bool) (m e : Int)
+  (hm : 0 ≤ m ∧ m < 2^mw) (he : 0 ≤ e ∧ e < 2^ew) :
+  0 ≤ join_bits mw ew s m e ∧ join_bits mw ew s m e < 2^(mw + ew + 1) := by
+  sorry
+
+-- Split bits from IEEE 754 bit representation
+def split_bits (x : Int) : Bool × Int × Int :=
+  let mm := 2^mw
+  let em := 2^ew
+  (mm * em ≤ x, x % mm, (x / mm) % em)
+
+-- Split-join consistency
+theorem split_join_bits (s : Bool) (m e : Int)
+  (hm : 0 ≤ m ∧ m < 2^mw) (he : 0 ≤ e ∧ e < 2^ew) :
+  split_bits mw ew (join_bits mw ew s m e) = (s, m, e) := by
+  sorry
+
+-- Join-split consistency
+theorem join_split_bits (x : Int) (hx : 0 ≤ x ∧ x < 2^(mw + ew + 1)) :
+  let (s, m, e) := split_bits mw ew x
+  join_bits mw ew s m e = x := by
+  sorry
+
+-- IEEE 754 bit-level operations
+section IEEE754_Bits
+
+variable (prec emax : Int)
+variable [Prec_gt_0 prec]
+variable [Prec_lt_emax prec emax]
+
+-- Mantissa width (including implicit bit)
+def mant_width : Int := prec - 1
+
+-- Exponent width
+def exp_width : Int := Int.log 2 (2 * emax + 1)
+
+-- Convert Binary754 to bit representation
+def binary_to_bits (x : Binary754 prec emax) : Int := by
+  sorry
+
+-- Convert bit representation to Binary754
+def bits_to_binary (bits : Int) : Binary754 prec emax := by
+  sorry
+
+-- Round-trip property for bit operations
+theorem binary_bits_roundtrip (x : Binary754 prec emax) :
+  bits_to_binary prec emax (binary_to_bits prec emax x) = x := by
+  sorry
+
+theorem bits_binary_roundtrip (bits : Int) 
+  (h_valid : 0 ≤ bits ∧ bits < 2^(mant_width prec + exp_width emax + 1)) :
+  binary_to_bits prec emax (bits_to_binary prec emax bits) = bits := by
+  sorry
+
+-- Extract components from bits
+def extract_sign (bits : Int) : Bool :=
+  2^(mant_width prec + exp_width emax) ≤ bits
+
+def extract_exponent (bits : Int) : Int :=
+  (bits / 2^(mant_width prec)) % 2^(exp_width emax)
+
+def extract_mantissa (bits : Int) : Int :=
+  bits % 2^(mant_width prec)
+
+-- IEEE 754 special values in bit representation
+def zero_bits (sign : Bool) : Int :=
+  join_bits (mant_width prec) (exp_width emax) sign 0 0
+
+def infinity_bits (sign : Bool) : Int :=
+  join_bits (mant_width prec) (exp_width emax) sign 0 (2^(exp_width emax) - 1)
+
+def nan_bits (sign : Bool) (payload : Int) : Int :=
+  join_bits (mant_width prec) (exp_width emax) sign payload (2^(exp_width emax) - 1)
+
+-- Check for special values
+def is_zero_bits (bits : Int) : Bool :=
+  extract_exponent prec emax bits = 0 ∧ extract_mantissa prec emax bits = 0
+
+def is_infinity_bits (bits : Int) : Bool :=
+  extract_exponent prec emax bits = 2^(exp_width emax) - 1 ∧ 
+  extract_mantissa prec emax bits = 0
+
+def is_nan_bits (bits : Int) : Bool :=
+  extract_exponent prec emax bits = 2^(exp_width emax) - 1 ∧ 
+  extract_mantissa prec emax bits ≠ 0
+
+end IEEE754_Bits
\ No newline at end of file
diff --git a/FloatSpec/src/IEEE754/PrimFloat.lean b/FloatSpec/src/IEEE754/PrimFloat.lean
index 1647e67..7559e8f 100644
--- a/FloatSpec/src/IEEE754/PrimFloat.lean
+++ b/FloatSpec/src/IEEE754/PrimFloat.lean
@@ -3,6 +3,9 @@
 
 import FloatSpec.src.IEEE754.Binary
 import FloatSpec.src.IEEE754.Bits
+import Mathlib.Data.Real.Basic
+
+open Real
 
 -- Primitive float type (using platform float)
 def PrimFloat := Float
@@ -32,7 +35,7 @@ def prim_nan : PrimFloat := Float.nan
 
 -- Sign operations
 def prim_neg (x : PrimFloat) : PrimFloat := -x
-def prim_abs (x : PrimFloat) : PrimFloat := Float.abs x
+def prim_abs (x : PrimFloat) : PrimFloat := |x|
 def prim_sign (x : PrimFloat) : Bool := x < 0
 
 -- Conversion between Binary754 and PrimFloat
diff --git a/FloatSpec/src/IEEE754/PrimFloat.lean.bak b/FloatSpec/src/IEEE754/PrimFloat.lean.bak
new file mode 100644
index 0000000..1647e67
--- /dev/null
+++ b/FloatSpec/src/IEEE754/PrimFloat.lean.bak
@@ -0,0 +1,58 @@
+-- Primitive floating-point operations
+-- Translated from Coq file: flocq/src/IEEE754/PrimFloat.v
+
+import FloatSpec.src.IEEE754.Binary
+import FloatSpec.src.IEEE754.Bits
+
+-- Primitive float type (using platform float)
+def PrimFloat := Float
+
+-- Operations on primitive floats
+def prim_add (x y : PrimFloat) : PrimFloat := x + y
+def prim_sub (x y : PrimFloat) : PrimFloat := x - y
+def prim_mul (x y : PrimFloat) : PrimFloat := x * y
+def prim_div (x y : PrimFloat) : PrimFloat := x / y
+def prim_sqrt (x : PrimFloat) : PrimFloat := Float.sqrt x
+
+-- Comparison operations
+def prim_eq (x y : PrimFloat) : Bool := x = y
+def prim_lt (x y : PrimFloat) : Bool := x < y
+def prim_le (x y : PrimFloat) : Bool := x ≤ y
+
+-- Classification functions
+def prim_is_zero (x : PrimFloat) : Bool := x = 0
+def prim_is_finite (x : PrimFloat) : Bool := x.isFinite
+def prim_is_nan (x : PrimFloat) : Bool := x.isNaN
+def prim_is_infinite (x : PrimFloat) : Bool := x.isInf
+
+-- Special values
+def prim_zero : PrimFloat := 0
+def prim_infinity : PrimFloat := Float.inf
+def prim_nan : PrimFloat := Float.nan
+
+-- Sign operations
+def prim_neg (x : PrimFloat) : PrimFloat := -x
+def prim_abs (x : PrimFloat) : PrimFloat := Float.abs x
+def prim_sign (x : PrimFloat) : Bool := x < 0
+
+-- Conversion between Binary754 and PrimFloat
+def binary_to_prim (prec emax : Int) [Prec_gt_0 prec] [Prec_lt_emax prec emax]
+  (x : Binary754 prec emax) : PrimFloat := by
+  sorry
+
+def prim_to_binary (prec emax : Int) [Prec_gt_0 prec] [Prec_lt_emax prec emax]
+  (x : PrimFloat) : Binary754 prec emax := by
+  sorry
+
+-- Correctness theorems
+theorem prim_add_correct (prec emax : Int) [Prec_gt_0 prec] [Prec_lt_emax prec emax]
+  (x y : Binary754 prec emax) :
+  binary_to_prim prec emax (binary_add x y) = 
+  prim_add (binary_to_prim prec emax x) (binary_to_prim prec emax y) := by
+  sorry
+
+theorem prim_mul_correct (prec emax : Int) [Prec_gt_0 prec] [Prec_lt_emax prec emax]
+  (x y : Binary754 prec emax) :
+  binary_to_prim prec emax (binary_mul x y) = 
+  prim_mul (binary_to_prim prec emax x) (binary_to_prim prec emax y) := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Pff/Pff.lean b/FloatSpec/src/Pff/Pff.lean
index 38ca9d5..fc1cd39 100644
--- a/FloatSpec/src/Pff/Pff.lean
+++ b/FloatSpec/src/Pff/Pff.lean
@@ -2,6 +2,9 @@
 -- Translated from Coq file: flocq/src/Pff/Pff.v
 
 import FloatSpec.src.Core
+import Mathlib.Data.Real.Basic
+
+open Real
 
 -- Compatibility definitions for Pff legacy support
 
@@ -52,23 +55,23 @@ theorem arith_helper (a b c : Int) : a + b = c → a = c - b := by
 end LegacyTactics
 
 -- Power operations compatibility
-theorem pow_inv (r : Float) (n : Nat) (h : r ≠ 0) : 
+theorem pow_inv (r : ℝ) (n : Nat) (h : r ≠ 0) : 
   (r^n)⁻¹ = r⁻¹^n := by
   sorry
 
-theorem pow_neg (r : Float) (z : Int) : 
+theorem pow_neg (r : ℝ) (z : Int) : 
   r^(-z) = (r^z)⁻¹ := by
   sorry
 
 -- Real number compatibility
-theorem abs_inv (r : Float) : Float.abs (r⁻¹) = (Float.abs r)⁻¹ := by
+theorem abs_inv (r : ℝ) : |r⁻¹| = |r|⁻¹ := by
   sorry
 
 -- List operations used in Pff
-def list_sum (l : List Float) : Float :=
+def list_sum (l : List Float) : ℝ :=
   l.foldr (· + ·) 0
 
-def list_prod (l : List Float) : Float :=
+def list_prod (l : List Float) : ℝ :=
   l.foldr (· * ·) 1
 
 -- Legacy floating-point format compatibility
@@ -94,8 +97,8 @@ def pff_mul (x y : PffFloat) : PffFloat := by
   sorry
 
 -- Error bounds compatibility
-def pff_error_bound (prec : Int) : Float :=
-  (2 : Float)^(-prec)
+def pff_error_bound (prec : Int) : ℝ :=
+  (2 : ℝ)^(-prec)
 
 -- Legacy rounding modes
 inductive PffRounding where
@@ -105,5 +108,5 @@ inductive PffRounding where
   | RM : PffRounding  -- Round toward minus infinity
 
 -- Convert Pff rounding to Flocq rounding
-def pff_to_flocq_rnd (mode : PffRounding) : Float → Int := by
+def pff_to_flocq_rnd (mode : PffRounding) : ℝ → Int := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Pff/Pff.lean.bak b/FloatSpec/src/Pff/Pff.lean.bak
new file mode 100644
index 0000000..38ca9d5
--- /dev/null
+++ b/FloatSpec/src/Pff/Pff.lean.bak
@@ -0,0 +1,109 @@
+-- Legacy Pff library compatibility layer
+-- Translated from Coq file: flocq/src/Pff/Pff.v
+
+import FloatSpec.src.Core
+
+-- Compatibility definitions for Pff legacy support
+
+-- Even number properties
+def nat_even (n : Nat) : Prop := ∃ k, n = 2 * k
+
+def nat_odd (n : Nat) : Prop := ∃ k, n = 2 * k + 1
+
+-- Even/Odd lemmas
+theorem even_0 : nat_even 0 := ⟨0, rfl⟩
+
+theorem odd_1 : nat_odd 1 := ⟨0, rfl⟩
+
+theorem not_even_1 : ¬nat_even 1 := by
+  intro ⟨k, h⟩
+  cases k with
+  | zero => simp at h
+  | succ k => simp [Nat.succ_mul] at h
+
+theorem not_odd_0 : ¬nat_odd 0 := by
+  intro ⟨k, h⟩
+  simp at h
+
+-- Double operation
+def nat_double (n : Nat) : Nat := 2 * n
+
+-- Division by 2
+def nat_div2 (n : Nat) : Nat := n / 2
+
+-- Even/Odd characterization
+theorem even_iff_double (n : Nat) : nat_even n ↔ n = nat_double (nat_div2 n) := by
+  sorry
+
+theorem odd_iff_double (n : Nat) : nat_odd n ↔ n = nat_double (nat_div2 n) + 1 := by
+  sorry
+
+-- Legacy tactical support (simplified)
+section LegacyTactics
+
+-- Case analysis preserving equality
+def case_eq {α β : Type*} (x : α) (f : α → β) : β := f x
+
+-- Simple automation for arithmetic
+theorem arith_helper (a b c : Int) : a + b = c → a = c - b := by
+  intro h
+  linarith
+
+end LegacyTactics
+
+-- Power operations compatibility
+theorem pow_inv (r : Float) (n : Nat) (h : r ≠ 0) : 
+  (r^n)⁻¹ = r⁻¹^n := by
+  sorry
+
+theorem pow_neg (r : Float) (z : Int) : 
+  r^(-z) = (r^z)⁻¹ := by
+  sorry
+
+-- Real number compatibility
+theorem abs_inv (r : Float) : Float.abs (r⁻¹) = (Float.abs r)⁻¹ := by
+  sorry
+
+-- List operations used in Pff
+def list_sum (l : List Float) : Float :=
+  l.foldr (· + ·) 0
+
+def list_prod (l : List Float) : Float :=
+  l.foldr (· * ·) 1
+
+-- Legacy floating-point format compatibility
+structure PffFloat where
+  mantissa : Int
+  exponent : Int
+  sign : Bool
+
+-- Conversion between Pff and Flocq formats
+def pff_to_flocq (beta : Int) (f : PffFloat) : FlocqFloat beta :=
+  FlocqFloat.mk (if f.sign then -f.mantissa else f.mantissa) f.exponent
+
+def flocq_to_pff (f : FlocqFloat beta) : PffFloat :=
+  { mantissa := Int.natAbs f.Fnum,
+    exponent := f.Fexp,
+    sign := f.Fnum < 0 }
+
+-- Compatibility operations
+def pff_add (x y : PffFloat) : PffFloat := by
+  sorry
+
+def pff_mul (x y : PffFloat) : PffFloat := by
+  sorry
+
+-- Error bounds compatibility
+def pff_error_bound (prec : Int) : Float :=
+  (2 : Float)^(-prec)
+
+-- Legacy rounding modes
+inductive PffRounding where
+  | RN : PffRounding  -- Round to nearest
+  | RZ : PffRounding  -- Round toward zero
+  | RP : PffRounding  -- Round toward plus infinity
+  | RM : PffRounding  -- Round toward minus infinity
+
+-- Convert Pff rounding to Flocq rounding
+def pff_to_flocq_rnd (mode : PffRounding) : Float → Int := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Pff/Pff2Flocq.lean b/FloatSpec/src/Pff/Pff2Flocq.lean
index 7373ed5..e74dd6b 100644
--- a/FloatSpec/src/Pff/Pff2Flocq.lean
+++ b/FloatSpec/src/Pff/Pff2Flocq.lean
@@ -3,6 +3,9 @@
 
 import FloatSpec.src.Core
 import FloatSpec.src.Pff.Pff
+import Mathlib.Data.Real.Basic
+
+open Real
 
 -- Conversion functions between Pff and Flocq representations
 
@@ -13,7 +16,7 @@ def pff_to_float (f : PffFloat) : FlocqFloat beta :=
   pff_to_flocq beta f
 
 -- Convert Flocq float to real number via Pff
-def pff_to_R (f : PffFloat) : Float :=
+def pff_to_R (f : PffFloat) : ℝ :=
   F2R (pff_to_flocq beta f)
 
 -- Conversion preserves value
@@ -33,7 +36,7 @@ theorem pff_mul_equiv (x y : PffFloat) :
   sorry
 
 -- Pff rounding corresponds to Flocq rounding
-theorem pff_round_equiv (mode : PffRounding) (x : Float) (prec : Int) :
+theorem pff_round_equiv (mode : PffRounding) (x : ℝ) (prec : Int) :
   let flocq_rnd := pff_to_flocq_rnd mode
   let fexp := FLX_exp prec
   pff_to_R beta (flocq_to_pff (round_float beta fexp flocq_rnd x)) = 
@@ -42,7 +45,7 @@ theorem pff_round_equiv (mode : PffRounding) (x : Float) (prec : Int) :
 
 -- Error bounds are preserved
 theorem pff_error_bound_equiv (prec : Int) :
-  pff_error_bound prec = (2 : Float)^(-prec) := by
+  pff_error_bound prec = (2 : ℝ)^(-prec) := by
   sorry
 
 -- Conversion is bijective for valid inputs
diff --git a/FloatSpec/src/Pff/Pff2Flocq.lean.bak b/FloatSpec/src/Pff/Pff2Flocq.lean.bak
new file mode 100644
index 0000000..7373ed5
--- /dev/null
+++ b/FloatSpec/src/Pff/Pff2Flocq.lean.bak
@@ -0,0 +1,55 @@
+-- Conversion from Pff to Flocq formats
+-- Translated from Coq file: flocq/src/Pff/Pff2Flocq.v
+
+import FloatSpec.src.Core
+import FloatSpec.src.Pff.Pff
+
+-- Conversion functions between Pff and Flocq representations
+
+variable (beta : Int)
+
+-- Convert Pff float to Flocq float
+def pff_to_float (f : PffFloat) : FlocqFloat beta :=
+  pff_to_flocq beta f
+
+-- Convert Flocq float to real number via Pff
+def pff_to_R (f : PffFloat) : Float :=
+  F2R (pff_to_flocq beta f)
+
+-- Conversion preserves value
+theorem pff_flocq_equiv (f : PffFloat) :
+  pff_to_R beta f = F2R (pff_to_flocq beta f) := by
+  sorry
+
+-- Pff operations match Flocq operations
+theorem pff_add_equiv (x y : PffFloat) :
+  pff_to_R beta (pff_add x y) = 
+  F2R (Fplus (pff_to_flocq beta x) (pff_to_flocq beta y)) := by
+  sorry
+
+theorem pff_mul_equiv (x y : PffFloat) :
+  pff_to_R beta (pff_mul x y) = 
+  F2R (Fmult (pff_to_flocq beta x) (pff_to_flocq beta y)) := by
+  sorry
+
+-- Pff rounding corresponds to Flocq rounding
+theorem pff_round_equiv (mode : PffRounding) (x : Float) (prec : Int) :
+  let flocq_rnd := pff_to_flocq_rnd mode
+  let fexp := FLX_exp prec
+  pff_to_R beta (flocq_to_pff (round_float beta fexp flocq_rnd x)) = 
+  round beta fexp flocq_rnd x := by
+  sorry
+
+-- Error bounds are preserved
+theorem pff_error_bound_equiv (prec : Int) :
+  pff_error_bound prec = (2 : Float)^(-prec) := by
+  sorry
+
+-- Conversion is bijective for valid inputs
+theorem pff_flocq_bijection (f : FlocqFloat beta) :
+  pff_to_flocq beta (flocq_to_pff f) = f := by
+  sorry
+
+theorem flocq_pff_bijection (f : PffFloat) :
+  flocq_to_pff (pff_to_flocq beta f) = f := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Pff/Pff2FlocqAux.lean b/FloatSpec/src/Pff/Pff2FlocqAux.lean
index e2b56ec..7da863d 100644
--- a/FloatSpec/src/Pff/Pff2FlocqAux.lean
+++ b/FloatSpec/src/Pff/Pff2FlocqAux.lean
@@ -2,6 +2,9 @@
 -- Translated from Coq file: flocq/src/Pff/Pff2FlocqAux.v
 
 import FloatSpec.src.Pff.Pff2Flocq
+import Mathlib.Data.Real.Basic
+
+open Real
 
 -- Auxiliary lemmas and functions for Pff/Flocq conversion
 
@@ -33,7 +36,7 @@ theorem pff_normalize_idempotent (f : PffFloat) :
   sorry
 
 theorem pff_abs_correct (f : PffFloat) :
-  pff_to_R beta (pff_abs f) = Float.abs (pff_to_R beta f) := by
+  pff_to_R beta (pff_abs f) = |pff_to_R beta f| := by
   sorry
 
 theorem pff_opp_correct (f : PffFloat) :
@@ -70,7 +73,7 @@ def pff_shift_mant (f : PffFloat) (n : Int) : PffFloat :=
 -- Shifting properties
 theorem pff_shift_exp_correct (f : PffFloat) (n : Int) :
   pff_to_R beta (pff_shift_exp f n) = 
-  pff_to_R beta f * (beta : Float)^n := by
+  pff_to_R beta f * (beta : ℝ)^n := by
   sorry
 
 theorem pff_shift_mant_correct (f : PffFloat) (n : Int) :
diff --git a/FloatSpec/src/Pff/Pff2FlocqAux.lean.bak b/FloatSpec/src/Pff/Pff2FlocqAux.lean.bak
new file mode 100644
index 0000000..e2b56ec
--- /dev/null
+++ b/FloatSpec/src/Pff/Pff2FlocqAux.lean.bak
@@ -0,0 +1,79 @@
+-- Auxiliary functions for Pff to Flocq conversion
+-- Translated from Coq file: flocq/src/Pff/Pff2FlocqAux.v
+
+import FloatSpec.src.Pff.Pff2Flocq
+
+-- Auxiliary lemmas and functions for Pff/Flocq conversion
+
+variable (beta : Int)
+
+-- Auxiliary conversion functions
+def pff_normalize (f : PffFloat) : PffFloat := by
+  sorry
+
+def pff_abs (f : PffFloat) : PffFloat :=
+  { f with sign := false }
+
+def pff_opp (f : PffFloat) : PffFloat :=
+  { f with sign := !f.sign }
+
+-- Auxiliary operations
+def pff_compare (x y : PffFloat) : Int := by
+  sorry
+
+def pff_max (x y : PffFloat) : PffFloat := by
+  sorry
+
+def pff_min (x y : PffFloat) : PffFloat := by
+  sorry
+
+-- Auxiliary properties
+theorem pff_normalize_idempotent (f : PffFloat) :
+  pff_normalize (pff_normalize f) = pff_normalize f := by
+  sorry
+
+theorem pff_abs_correct (f : PffFloat) :
+  pff_to_R beta (pff_abs f) = Float.abs (pff_to_R beta f) := by
+  sorry
+
+theorem pff_opp_correct (f : PffFloat) :
+  pff_to_R beta (pff_opp f) = -(pff_to_R beta f) := by
+  sorry
+
+-- Compatibility with Flocq operations
+theorem pff_abs_flocq_equiv (f : PffFloat) :
+  pff_to_flocq beta (pff_abs f) = Fabs (pff_to_flocq beta f) := by
+  sorry
+
+theorem pff_opp_flocq_equiv (f : PffFloat) :
+  pff_to_flocq beta (pff_opp f) = Fopp (pff_to_flocq beta f) := by
+  sorry
+
+-- Helper lemmas for conversion correctness
+lemma pff_sign_correct (f : PffFloat) :
+  (pff_to_R beta f < 0) ↔ f.sign := by
+  sorry
+
+lemma pff_mantissa_bounds (f : PffFloat) (prec : Int) :
+  0 ≤ f.mantissa ∧ f.mantissa < 2^prec → 
+  0 ≤ Int.natAbs (pff_to_flocq beta f).Fnum ∧ 
+  Int.natAbs (pff_to_flocq beta f).Fnum < 2^prec := by
+  sorry
+
+-- Auxiliary arithmetic operations
+def pff_shift_exp (f : PffFloat) (n : Int) : PffFloat :=
+  { f with exponent := f.exponent + n }
+
+def pff_shift_mant (f : PffFloat) (n : Int) : PffFloat :=
+  { f with mantissa := f.mantissa * 2^n }
+
+-- Shifting properties
+theorem pff_shift_exp_correct (f : PffFloat) (n : Int) :
+  pff_to_R beta (pff_shift_exp f n) = 
+  pff_to_R beta f * (beta : Float)^n := by
+  sorry
+
+theorem pff_shift_mant_correct (f : PffFloat) (n : Int) :
+  pff_to_R beta (pff_shift_mant f n) = 
+  pff_to_R beta f * 2^n := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Prop/Div_sqrt_error.lean b/FloatSpec/src/Prop/Div_sqrt_error.lean
index e11b4e3..772769b 100644
--- a/FloatSpec/src/Prop/Div_sqrt_error.lean
+++ b/FloatSpec/src/Prop/Div_sqrt_error.lean
@@ -5,6 +5,9 @@ import FloatSpec.src.Core
 import FloatSpec.src.Prop.Relative
 import FloatSpec.src.Prop.Sterbenz
 import FloatSpec.src.Prop.Mult_error
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 variable (prec : Int)
@@ -13,37 +16,37 @@ variable [Prec_gt_0 prec]
 /-- Generic format plus with precision bound -/
 lemma generic_format_plus_prec (fexp : Int → Int) 
   (h_bound : ∀ e, fexp e ≤ e - prec)
-  (x y : Float) (fx fy : FlocqFloat beta)
+  (x y : ℝ) (fx fy : FlocqFloat beta)
   (hx : x = F2R fx) (hy : y = F2R fy)
-  (h1 : Float.abs (x + y) < (Int.natAbs beta : Float) ^ (Int.natAbs (prec + fx.Fexp) : Nat))
-  (h2 : Float.abs (x + y) < (Int.natAbs beta : Float) ^ (Int.natAbs (prec + fy.Fexp) : Nat)) :
+  (h1 : |x + y| < (Int.natAbs beta : ℝ) ^ (Int.natAbs (prec + fx.Fexp) : Nat))
+  (h2 : |x + y| < (Int.natAbs beta : ℝ) ^ (Int.natAbs (prec + fy.Fexp) : Nat)) :
   generic_format beta fexp (x + y) := by
   sorry
 
 variable (choice : Int → Bool)
 
 /-- Remainder of the division in FLX -/
-theorem div_error_FLX (rnd : Float → Int) [Valid_rnd rnd] (x y : Float)
+theorem div_error_FLX (rnd : ℝ → Int) [Valid_rnd rnd] (x y : ℝ)
   (hx : generic_format beta (FLX_exp prec) x) (hy : generic_format beta (FLX_exp prec) y) :
   generic_format beta (FLX_exp prec) (x - round beta (FLX_exp prec) rnd (x / y) * y) := by
   sorry
 
 /-- Square root error in FLX -/
-theorem sqrt_error_FLX (rnd : Float → Int) [Valid_rnd rnd] (x : Float)
+theorem sqrt_error_FLX (rnd : ℝ → Int) [Valid_rnd rnd] (x : ℝ)
   (hx : generic_format beta (FLX_exp prec) x) :
   generic_format beta (FLX_exp prec) (x - (round beta (FLX_exp prec) rnd (Float.sqrt x))^2) := by
   sorry
 
 /-- Division error in FLT -/
-theorem div_error_FLT (emin : Int) (rnd : Float → Int) [Valid_rnd rnd] (x y : Float)
+theorem div_error_FLT (emin : Int) (rnd : ℝ → Int) [Valid_rnd rnd] (x y : ℝ)
   (hx : generic_format beta (FLT_exp emin prec) x) (hy : generic_format beta (FLT_exp emin prec) y)
-  (h_no_underflow : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + 2 * prec - 1) : Nat) ≤ Float.abs (x / y)) :
+  (h_no_underflow : (Int.natAbs beta : ℝ) ^ (Int.natAbs (emin + 2 * prec - 1) : Nat) ≤ |x / y|) :
   generic_format beta (FLT_exp emin prec) (x - round beta (FLT_exp emin prec) rnd (x / y) * y) := by
   sorry
 
 /-- Square root error in FLT -/
-theorem sqrt_error_FLT (emin : Int) (rnd : Float → Int) [Valid_rnd rnd] (x : Float)
+theorem sqrt_error_FLT (emin : Int) (rnd : ℝ → Int) [Valid_rnd rnd] (x : ℝ)
   (hx : generic_format beta (FLT_exp emin prec) x)
-  (h_no_underflow : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + 2 * prec - 1) : Nat) ≤ Float.abs (Float.sqrt x)) :
+  (h_no_underflow : (Int.natAbs beta : ℝ) ^ (Int.natAbs (emin + 2 * prec - 1) : Nat) ≤ |Float.sqrt x|) :
   generic_format beta (FLT_exp emin prec) (x - (round beta (FLT_exp emin prec) rnd (Float.sqrt x))^2) := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Prop/Div_sqrt_error.lean.bak b/FloatSpec/src/Prop/Div_sqrt_error.lean.bak
new file mode 100644
index 0000000..e11b4e3
--- /dev/null
+++ b/FloatSpec/src/Prop/Div_sqrt_error.lean.bak
@@ -0,0 +1,49 @@
+-- Remainder of the division and square root are in the FLX format
+-- Translated from Coq file: flocq/src/Prop/Div_sqrt_error.v
+
+import FloatSpec.src.Core
+import FloatSpec.src.Prop.Relative
+import FloatSpec.src.Prop.Sterbenz
+import FloatSpec.src.Prop.Mult_error
+
+variable (beta : Int)
+variable (prec : Int)
+variable [Prec_gt_0 prec]
+
+/-- Generic format plus with precision bound -/
+lemma generic_format_plus_prec (fexp : Int → Int) 
+  (h_bound : ∀ e, fexp e ≤ e - prec)
+  (x y : Float) (fx fy : FlocqFloat beta)
+  (hx : x = F2R fx) (hy : y = F2R fy)
+  (h1 : Float.abs (x + y) < (Int.natAbs beta : Float) ^ (Int.natAbs (prec + fx.Fexp) : Nat))
+  (h2 : Float.abs (x + y) < (Int.natAbs beta : Float) ^ (Int.natAbs (prec + fy.Fexp) : Nat)) :
+  generic_format beta fexp (x + y) := by
+  sorry
+
+variable (choice : Int → Bool)
+
+/-- Remainder of the division in FLX -/
+theorem div_error_FLX (rnd : Float → Int) [Valid_rnd rnd] (x y : Float)
+  (hx : generic_format beta (FLX_exp prec) x) (hy : generic_format beta (FLX_exp prec) y) :
+  generic_format beta (FLX_exp prec) (x - round beta (FLX_exp prec) rnd (x / y) * y) := by
+  sorry
+
+/-- Square root error in FLX -/
+theorem sqrt_error_FLX (rnd : Float → Int) [Valid_rnd rnd] (x : Float)
+  (hx : generic_format beta (FLX_exp prec) x) :
+  generic_format beta (FLX_exp prec) (x - (round beta (FLX_exp prec) rnd (Float.sqrt x))^2) := by
+  sorry
+
+/-- Division error in FLT -/
+theorem div_error_FLT (emin : Int) (rnd : Float → Int) [Valid_rnd rnd] (x y : Float)
+  (hx : generic_format beta (FLT_exp emin prec) x) (hy : generic_format beta (FLT_exp emin prec) y)
+  (h_no_underflow : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + 2 * prec - 1) : Nat) ≤ Float.abs (x / y)) :
+  generic_format beta (FLT_exp emin prec) (x - round beta (FLT_exp emin prec) rnd (x / y) * y) := by
+  sorry
+
+/-- Square root error in FLT -/
+theorem sqrt_error_FLT (emin : Int) (rnd : Float → Int) [Valid_rnd rnd] (x : Float)
+  (hx : generic_format beta (FLT_exp emin prec) x)
+  (h_no_underflow : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + 2 * prec - 1) : Nat) ≤ Float.abs (Float.sqrt x)) :
+  generic_format beta (FLT_exp emin prec) (x - (round beta (FLT_exp emin prec) rnd (Float.sqrt x))^2) := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Prop/Double_rounding.lean b/FloatSpec/src/Prop/Double_rounding.lean
index 03f0e21..c0633c6 100644
--- a/FloatSpec/src/Prop/Double_rounding.lean
+++ b/FloatSpec/src/Prop/Double_rounding.lean
@@ -2,19 +2,22 @@
 -- Translated from Coq file: flocq/src/Prop/Double_rounding.v
 
 import FloatSpec.src.Core
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 
 /-- Double rounding with two different precisions -/
 theorem double_round_eq (fexp1 fexp2 : Int → Int) [Valid_exp fexp1] [Valid_exp fexp2]
-  (choice1 choice2 : Int → Bool) (x : Float)
+  (choice1 choice2 : Int → Bool) (x : ℝ)
   (h_precision : ∀ e, fexp2 e ≤ fexp1 e) :
   round beta fexp2 (Znearest choice2) (round beta fexp1 (Znearest choice1) x) = 
   round beta fexp2 (Znearest choice2) x := by
   sorry
 
 /-- Double rounding property for FLX and FLT -/
-theorem double_round_FLX_FLT (prec1 prec2 emin : Int) (choice1 choice2 : Int → Bool) (x : Float)
+theorem double_round_FLX_FLT (prec1 prec2 emin : Int) (choice1 choice2 : Int → Bool) (x : ℝ)
   (h_prec : prec2 ≤ prec1) :
   round beta (FLT_exp emin prec2) (Znearest choice2) 
     (round beta (FLX_exp prec1) (Znearest choice1) x) = 
@@ -22,7 +25,7 @@ theorem double_round_FLX_FLT (prec1 prec2 emin : Int) (choice1 choice2 : Int →
   sorry
 
 /-- Double rounding for same format is identity -/
-theorem double_round_same (fexp : Int → Int) [Valid_exp fexp] (choice : Int → Bool) (x : Float) :
+theorem double_round_same (fexp : Int → Int) [Valid_exp fexp] (choice : Int → Bool) (x : ℝ) :
   round beta fexp (Znearest choice) (round beta fexp (Znearest choice) x) = 
   round beta fexp (Znearest choice) x := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Prop/Double_rounding.lean.bak b/FloatSpec/src/Prop/Double_rounding.lean.bak
new file mode 100644
index 0000000..03f0e21
--- /dev/null
+++ b/FloatSpec/src/Prop/Double_rounding.lean.bak
@@ -0,0 +1,28 @@
+-- Double rounding properties
+-- Translated from Coq file: flocq/src/Prop/Double_rounding.v
+
+import FloatSpec.src.Core
+
+variable (beta : Int)
+
+/-- Double rounding with two different precisions -/
+theorem double_round_eq (fexp1 fexp2 : Int → Int) [Valid_exp fexp1] [Valid_exp fexp2]
+  (choice1 choice2 : Int → Bool) (x : Float)
+  (h_precision : ∀ e, fexp2 e ≤ fexp1 e) :
+  round beta fexp2 (Znearest choice2) (round beta fexp1 (Znearest choice1) x) = 
+  round beta fexp2 (Znearest choice2) x := by
+  sorry
+
+/-- Double rounding property for FLX and FLT -/
+theorem double_round_FLX_FLT (prec1 prec2 emin : Int) (choice1 choice2 : Int → Bool) (x : Float)
+  (h_prec : prec2 ≤ prec1) :
+  round beta (FLT_exp emin prec2) (Znearest choice2) 
+    (round beta (FLX_exp prec1) (Znearest choice1) x) = 
+  round beta (FLT_exp emin prec2) (Znearest choice2) x := by
+  sorry
+
+/-- Double rounding for same format is identity -/
+theorem double_round_same (fexp : Int → Int) [Valid_exp fexp] (choice : Int → Bool) (x : Float) :
+  round beta fexp (Znearest choice) (round beta fexp (Znearest choice) x) = 
+  round beta fexp (Znearest choice) x := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Prop/Mult_error.lean b/FloatSpec/src/Prop/Mult_error.lean
index 614ef7e..28bfd4d 100644
--- a/FloatSpec/src/Prop/Mult_error.lean
+++ b/FloatSpec/src/Prop/Mult_error.lean
@@ -3,6 +3,9 @@
 
 import FloatSpec.src.Core
 import FloatSpec.src.Prop.Plus_error
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 variable (prec : Int)
@@ -10,11 +13,11 @@ variable [Prec_gt_0 prec]
 
 -- Section: FLX multiplication error
 
-variable (rnd : Float → Int)
+variable (rnd : ℝ → Int)
 variable [Valid_rnd rnd]
 
 /-- Auxiliary result that provides the exponent for FLX multiplication error -/
-lemma mult_error_FLX_aux (x y : Float)
+lemma mult_error_FLX_aux (x y : ℝ)
   (hx : generic_format beta (FLX_exp prec) x) (hy : generic_format beta (FLX_exp prec) y)
   (h_nonzero : round beta (FLX_exp prec) rnd (x * y) - (x * y) ≠ 0) :
   ∃ f : FlocqFloat beta, F2R f = round beta (FLX_exp prec) rnd (x * y) - (x * y) ∧
@@ -23,15 +26,15 @@ lemma mult_error_FLX_aux (x y : Float)
   sorry
 
 /-- Error of the multiplication in FLX -/
-theorem mult_error_FLX (x y : Float)
+theorem mult_error_FLX (x y : ℝ)
   (hx : generic_format beta (FLX_exp prec) x) (hy : generic_format beta (FLX_exp prec) y) :
   generic_format beta (FLX_exp prec) (round beta (FLX_exp prec) rnd (x * y) - (x * y)) := by
   sorry
 
 /-- Multiplication by power of beta is exact in FLX -/
-lemma mult_bpow_exact_FLX (x : Float) (e : Int)
+lemma mult_bpow_exact_FLX (x : ℝ) (e : Int)
   (hx : generic_format beta (FLX_exp prec) x) :
-  generic_format beta (FLX_exp prec) (x * (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat)) := by
+  generic_format beta (FLX_exp prec) (x * (Int.natAbs beta : ℝ) ^ (Int.natAbs e : Nat)) := by
   sorry
 
 -- Section: FLT multiplication error
@@ -39,37 +42,37 @@ lemma mult_bpow_exact_FLX (x : Float) (e : Int)
 variable (emin : Int)
 
 /-- Error of the multiplication in FLT with underflow requirements -/
-theorem mult_error_FLT (x y : Float)
+theorem mult_error_FLT (x y : ℝ)
   (hx : generic_format beta (FLT_exp emin prec) x) (hy : generic_format beta (FLT_exp emin prec) y)
   (h_underflow : x * y ≠ 0 → 
-    (Int.natAbs beta : Float) ^ (Int.natAbs (emin + 2 * prec - 1) : Nat) ≤ Float.abs (x * y)) :
+    (Int.natAbs beta : ℝ) ^ (Int.natAbs (emin + 2 * prec - 1) : Nat) ≤ |x * y|) :
   generic_format beta (FLT_exp emin prec) (round beta (FLT_exp emin prec) rnd (x * y) - (x * y)) := by
   sorry
 
 /-- F2R greater than or equal to power bound -/
 lemma F2R_ge (f : FlocqFloat beta) (h_nonzero : F2R f ≠ 0) :
-  (Int.natAbs beta : Float) ^ (Int.natAbs f.Fexp : Nat) ≤ Float.abs (F2R f) := by
+  (Int.natAbs beta : ℝ) ^ (Int.natAbs f.Fexp : Nat) ≤ |F2R f| := by
   sorry
 
 /-- FLT multiplication error greater than or equal to power bound -/
-theorem mult_error_FLT_ge_bpow (x y : Float) (e : Int)
+theorem mult_error_FLT_ge_bpow (x y : ℝ) (e : Int)
   (hx : generic_format beta (FLT_exp emin prec) x) (hy : generic_format beta (FLT_exp emin prec) y)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (e + 2 * prec - 1) : Nat) ≤ Float.abs (x * y))
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs (e + 2 * prec - 1) : Nat) ≤ |x * y|)
   (h_nonzero : round beta (FLT_exp emin prec) rnd (x * y) - (x * y) ≠ 0) :
-  (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat) ≤ 
-    Float.abs (round beta (FLT_exp emin prec) rnd (x * y) - (x * y)) := by
+  (Int.natAbs beta : ℝ) ^ (Int.natAbs e : Nat) ≤ 
+    |round beta (FLT_exp emin prec) rnd (x * y) - (x * y)| := by
   sorry
 
 /-- Multiplication by power of beta is exact in FLT -/
-lemma mult_bpow_exact_FLT (x : Float) (e : Int)
+lemma mult_bpow_exact_FLT (x : ℝ) (e : Int)
   (hx : generic_format beta (FLT_exp emin prec) x)
   (h_bound : emin + prec - mag beta x ≤ e) :
-  generic_format beta (FLT_exp emin prec) (x * (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat)) := by
+  generic_format beta (FLT_exp emin prec) (x * (Int.natAbs beta : ℝ) ^ (Int.natAbs e : Nat)) := by
   sorry
 
 /-- Multiplication by positive power of beta is exact in FLT -/
-lemma mult_bpow_pos_exact_FLT (x : Float) (e : Int)
+lemma mult_bpow_pos_exact_FLT (x : ℝ) (e : Int)
   (hx : generic_format beta (FLT_exp emin prec) x)
   (h_nonneg : 0 ≤ e) :
-  generic_format beta (FLT_exp emin prec) (x * (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat)) := by
+  generic_format beta (FLT_exp emin prec) (x * (Int.natAbs beta : ℝ) ^ (Int.natAbs e : Nat)) := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Prop/Mult_error.lean.bak b/FloatSpec/src/Prop/Mult_error.lean.bak
new file mode 100644
index 0000000..614ef7e
--- /dev/null
+++ b/FloatSpec/src/Prop/Mult_error.lean.bak
@@ -0,0 +1,75 @@
+-- Error of the multiplication is in the FLX/FLT format
+-- Translated from Coq file: flocq/src/Prop/Mult_error.v
+
+import FloatSpec.src.Core
+import FloatSpec.src.Prop.Plus_error
+
+variable (beta : Int)
+variable (prec : Int)
+variable [Prec_gt_0 prec]
+
+-- Section: FLX multiplication error
+
+variable (rnd : Float → Int)
+variable [Valid_rnd rnd]
+
+/-- Auxiliary result that provides the exponent for FLX multiplication error -/
+lemma mult_error_FLX_aux (x y : Float)
+  (hx : generic_format beta (FLX_exp prec) x) (hy : generic_format beta (FLX_exp prec) y)
+  (h_nonzero : round beta (FLX_exp prec) rnd (x * y) - (x * y) ≠ 0) :
+  ∃ f : FlocqFloat beta, F2R f = round beta (FLX_exp prec) rnd (x * y) - (x * y) ∧
+    cexp beta (FLX_exp prec) (F2R f) ≤ f.Fexp ∧
+    f.Fexp = cexp beta (FLX_exp prec) x + cexp beta (FLX_exp prec) y := by
+  sorry
+
+/-- Error of the multiplication in FLX -/
+theorem mult_error_FLX (x y : Float)
+  (hx : generic_format beta (FLX_exp prec) x) (hy : generic_format beta (FLX_exp prec) y) :
+  generic_format beta (FLX_exp prec) (round beta (FLX_exp prec) rnd (x * y) - (x * y)) := by
+  sorry
+
+/-- Multiplication by power of beta is exact in FLX -/
+lemma mult_bpow_exact_FLX (x : Float) (e : Int)
+  (hx : generic_format beta (FLX_exp prec) x) :
+  generic_format beta (FLX_exp prec) (x * (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat)) := by
+  sorry
+
+-- Section: FLT multiplication error
+
+variable (emin : Int)
+
+/-- Error of the multiplication in FLT with underflow requirements -/
+theorem mult_error_FLT (x y : Float)
+  (hx : generic_format beta (FLT_exp emin prec) x) (hy : generic_format beta (FLT_exp emin prec) y)
+  (h_underflow : x * y ≠ 0 → 
+    (Int.natAbs beta : Float) ^ (Int.natAbs (emin + 2 * prec - 1) : Nat) ≤ Float.abs (x * y)) :
+  generic_format beta (FLT_exp emin prec) (round beta (FLT_exp emin prec) rnd (x * y) - (x * y)) := by
+  sorry
+
+/-- F2R greater than or equal to power bound -/
+lemma F2R_ge (f : FlocqFloat beta) (h_nonzero : F2R f ≠ 0) :
+  (Int.natAbs beta : Float) ^ (Int.natAbs f.Fexp : Nat) ≤ Float.abs (F2R f) := by
+  sorry
+
+/-- FLT multiplication error greater than or equal to power bound -/
+theorem mult_error_FLT_ge_bpow (x y : Float) (e : Int)
+  (hx : generic_format beta (FLT_exp emin prec) x) (hy : generic_format beta (FLT_exp emin prec) y)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (e + 2 * prec - 1) : Nat) ≤ Float.abs (x * y))
+  (h_nonzero : round beta (FLT_exp emin prec) rnd (x * y) - (x * y) ≠ 0) :
+  (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat) ≤ 
+    Float.abs (round beta (FLT_exp emin prec) rnd (x * y) - (x * y)) := by
+  sorry
+
+/-- Multiplication by power of beta is exact in FLT -/
+lemma mult_bpow_exact_FLT (x : Float) (e : Int)
+  (hx : generic_format beta (FLT_exp emin prec) x)
+  (h_bound : emin + prec - mag beta x ≤ e) :
+  generic_format beta (FLT_exp emin prec) (x * (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat)) := by
+  sorry
+
+/-- Multiplication by positive power of beta is exact in FLT -/
+lemma mult_bpow_pos_exact_FLT (x : Float) (e : Int)
+  (hx : generic_format beta (FLT_exp emin prec) x)
+  (h_nonneg : 0 ≤ e) :
+  generic_format beta (FLT_exp emin prec) (x * (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat)) := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Prop/Plus_error.lean b/FloatSpec/src/Prop/Plus_error.lean
index b2775d0..3064d6a 100644
--- a/FloatSpec/src/Prop/Plus_error.lean
+++ b/FloatSpec/src/Prop/Plus_error.lean
@@ -3,6 +3,9 @@
 
 import FloatSpec.src.Core
 import FloatSpec.src.Prop.Relative
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 variable (fexp : Int → Int)
@@ -11,7 +14,7 @@ variable [Valid_exp fexp]
 -- Section: Plus error representability
 
 /-- Round representation with same exponent -/
-theorem round_repr_same_exp (rnd : Float → Int) [Valid_rnd rnd] (m e : Int) :
+theorem round_repr_same_exp (rnd : ℝ → Int) [Valid_rnd rnd] (m e : Int) :
   ∃ m', round beta fexp rnd (F2R (FlocqFloat.mk m e : FlocqFloat beta)) = 
         F2R (FlocqFloat.mk m' e : FlocqFloat beta) := by
   sorry
@@ -20,14 +23,14 @@ variable [Monotone_exp fexp]
 variable (choice : Int → Bool)
 
 /-- Plus error auxiliary lemma -/
-lemma plus_error_aux (x y : Float) 
+lemma plus_error_aux (x y : ℝ) 
   (h_exp : cexp beta fexp x ≤ cexp beta fexp y)
   (hx : generic_format beta fexp x) (hy : generic_format beta fexp y) :
   generic_format beta fexp (round beta fexp (Znearest choice) (x + y) - (x + y)) := by
   sorry
 
 /-- Error of the addition -/
-theorem plus_error (x y : Float)
+theorem plus_error (x y : ℝ)
   (hx : generic_format beta fexp x) (hy : generic_format beta fexp y) :
   generic_format beta fexp (round beta fexp (Znearest choice) (x + y) - (x + y)) := by
   sorry
@@ -37,7 +40,7 @@ theorem plus_error (x y : Float)
 variable [Exp_not_FTZ fexp]
 
 /-- Round plus not equal to zero auxiliary -/
-lemma round_plus_neq_0_aux (rnd : Float → Int) [Valid_rnd rnd] (x y : Float)
+lemma round_plus_neq_0_aux (rnd : ℝ → Int) [Valid_rnd rnd] (x y : ℝ)
   (h_exp : cexp beta fexp x ≤ cexp beta fexp y)
   (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
   (h_pos : 0 < x + y) :
@@ -45,14 +48,14 @@ lemma round_plus_neq_0_aux (rnd : Float → Int) [Valid_rnd rnd] (x y : Float)
   sorry
 
 /-- rnd(x+y)=0 → x+y ≠ 0 (provided this is not a FTZ format) -/
-theorem round_plus_neq_0 (rnd : Float → Int) [Valid_rnd rnd] (x y : Float)
+theorem round_plus_neq_0 (rnd : ℝ → Int) [Valid_rnd rnd] (x y : ℝ)
   (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
   (h_nonzero : x + y ≠ 0) :
   round beta fexp rnd (x + y) ≠ 0 := by
   sorry
 
 /-- rnd(x+y)=0 → x+y = 0 -/
-theorem round_plus_eq_0 (rnd : Float → Int) [Valid_rnd rnd] (x y : Float)
+theorem round_plus_eq_0 (rnd : ℝ → Int) [Valid_rnd rnd] (x y : ℝ)
   (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
   (h_zero : round beta fexp rnd (x + y) = 0) :
   x + y = 0 := by
@@ -64,104 +67,104 @@ variable (emin prec : Int)
 variable [Prec_gt_0 prec]
 
 /-- FLT format plus small -/
-theorem FLT_format_plus_small (x y : Float)
+theorem FLT_format_plus_small (x y : ℝ)
   (hx : generic_format beta (FLT_exp emin prec) x)
   (hy : generic_format beta (FLT_exp emin prec) y)
-  (h_bound : Float.abs (x + y) ≤ (Int.natAbs beta : Float) ^ (Int.natAbs (prec + emin) : Nat)) :
+  (h_bound : |x + y| ≤ (Int.natAbs beta : ℝ) ^ (Int.natAbs (prec + emin) : Nat)) :
   generic_format beta (FLT_exp emin prec) (x + y) := by
   sorry
 
 /-- FLT plus error with nearest rounding existence -/
-lemma FLT_plus_error_N_ex (x y : Float)
+lemma FLT_plus_error_N_ex (x y : ℝ)
   (hx : generic_format beta (FLT_exp emin prec) x)
   (hy : generic_format beta (FLT_exp emin prec) y) :
-  ∃ eps, Float.abs eps ≤ u_ro beta prec / (1 + u_ro beta prec) ∧
+  ∃ eps, |eps| ≤ u_ro beta prec / (1 + u_ro beta prec) ∧
     round beta (FLT_exp emin prec) (Znearest choice) (x + y) = (x + y) * (1 + eps) := by
   sorry
 
 /-- FLT plus error with round existence -/
-lemma FLT_plus_error_N_round_ex (x y : Float)
+lemma FLT_plus_error_N_round_ex (x y : ℝ)
   (hx : generic_format beta (FLT_exp emin prec) x)
   (hy : generic_format beta (FLT_exp emin prec) y) :
-  ∃ eps, Float.abs eps ≤ u_ro beta prec ∧
+  ∃ eps, |eps| ≤ u_ro beta prec ∧
     x + y = round beta (FLT_exp emin prec) (Znearest choice) (x + y) * (1 + eps) := by
   sorry
 
 -- Section: Plus mult ulp properties
 
-variable (rnd : Float → Int)
+variable (rnd : ℝ → Int)
 variable [Valid_rnd rnd]
 
 /-- Existence of shift representation -/
-lemma ex_shift (x : Float) (e : Int) 
+lemma ex_shift (x : ℝ) (e : Int) 
   (hx : generic_format beta fexp x) (h_exp : e ≤ cexp beta fexp x) :
-  ∃ m : Int, x = (m : Float) * ((Int.natAbs beta : Float) ^ (Int.natAbs e : Nat)) := by
+  ∃ m : Int, x = (m : ℝ) * ((Int.natAbs beta : ℝ) ^ (Int.natAbs e : Nat)) := by
   sorry
 
 /-- Magnitude minus one relation -/
-lemma mag_minus1 (z : Float) (h_nonzero : z ≠ 0) :
-  mag beta z - 1 = mag beta (z / (beta : Float)) := by
+lemma mag_minus1 (z : ℝ) (h_nonzero : z ≠ 0) :
+  mag beta z - 1 = mag beta (z / (beta : ℝ)) := by
   sorry
 
 /-- Round plus F2R representation -/
-theorem round_plus_F2R (x y : Float) 
+theorem round_plus_F2R (x y : ℝ) 
   (hx : generic_format beta fexp x) (hy : generic_format beta fexp y) (h_nonzero : x ≠ 0) :
   ∃ m : Int, round beta fexp rnd (x + y) = 
-    F2R (FlocqFloat.mk m (cexp beta fexp (x / (beta : Float))) : FlocqFloat beta) := by
+    F2R (FlocqFloat.mk m (cexp beta fexp (x / (beta : ℝ))) : FlocqFloat beta) := by
   sorry
 
 variable [Exp_not_FTZ fexp]
 
 /-- Round plus greater equal ulp -/
-theorem round_plus_ge_ulp (x y : Float)
+theorem round_plus_ge_ulp (x y : ℝ)
   (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
   (h_nonzero : round beta fexp rnd (x + y) ≠ 0) :
-  ulp beta fexp (x / (beta : Float)) ≤ Float.abs (round beta fexp rnd (x + y)) := by
+  ulp beta fexp (x / (beta : ℝ)) ≤ |round beta fexp rnd (x + y)| := by
   sorry
 
 -- Section: FLT plus bounds
 
 /-- Round FLT plus greater equal bound -/
-theorem round_FLT_plus_ge (x y : Float) (e : Int)
+theorem round_FLT_plus_ge (x y : ℝ) (e : Int)
   (hx : generic_format beta (FLT_exp emin prec) x)
   (hy : generic_format beta (FLT_exp emin prec) y)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (e + prec) : Nat) ≤ Float.abs x)
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs (e + prec) : Nat) ≤ |x|)
   (h_nonzero : round beta (FLT_exp emin prec) rnd (x + y) ≠ 0) :
-  (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat) ≤ 
-    Float.abs (round beta (FLT_exp emin prec) rnd (x + y)) := by
+  (Int.natAbs beta : ℝ) ^ (Int.natAbs e : Nat) ≤ 
+    |round beta (FLT_exp emin prec) rnd (x + y)| := by
   sorry
 
 /-- Round FLT plus greater equal bound (alternative) -/
-lemma round_FLT_plus_ge' (x y : Float) (e : Int)
+lemma round_FLT_plus_ge' (x y : ℝ) (e : Int)
   (hx : generic_format beta (FLT_exp emin prec) x)
   (hy : generic_format beta (FLT_exp emin prec) y)
-  (h1 : x ≠ 0 → (Int.natAbs beta : Float) ^ (Int.natAbs (e + prec) : Nat) ≤ Float.abs x)
-  (h2 : x = 0 → y ≠ 0 → (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat) ≤ Float.abs y)
+  (h1 : x ≠ 0 → (Int.natAbs beta : ℝ) ^ (Int.natAbs (e + prec) : Nat) ≤ |x|)
+  (h2 : x = 0 → y ≠ 0 → (Int.natAbs beta : ℝ) ^ (Int.natAbs e : Nat) ≤ |y|)
   (h_nonzero : round beta (FLT_exp emin prec) rnd (x + y) ≠ 0) :
-  (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat) ≤ 
-    Float.abs (round beta (FLT_exp emin prec) rnd (x + y)) := by
+  (Int.natAbs beta : ℝ) ^ (Int.natAbs e : Nat) ≤ 
+    |round beta (FLT_exp emin prec) rnd (x + y)| := by
   sorry
 
 /-- Round FLX plus greater equal bound -/
-theorem round_FLX_plus_ge (x y : Float) (e : Int)
+theorem round_FLX_plus_ge (x y : ℝ) (e : Int)
   (hx : generic_format beta (FLX_exp prec) x)
   (hy : generic_format beta (FLX_exp prec) y)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (e + prec) : Nat) ≤ Float.abs x)
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs (e + prec) : Nat) ≤ |x|)
   (h_nonzero : round beta (FLX_exp prec) rnd (x + y) ≠ 0) :
-  (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat) ≤ 
-    Float.abs (round beta (FLX_exp prec) rnd (x + y)) := by
+  (Int.natAbs beta : ℝ) ^ (Int.natAbs e : Nat) ≤ 
+    |round beta (FLX_exp prec) rnd (x + y)| := by
   sorry
 
 -- Section: Plus error bounds
 
 /-- Plus error bounded by left operand -/
-lemma plus_error_le_l (x y : Float)
+lemma plus_error_le_l (x y : ℝ)
   (hx : generic_format beta fexp x) (hy : generic_format beta fexp y) :
-  Float.abs (round beta fexp (Znearest choice) (x + y) - (x + y)) ≤ Float.abs x := by
+  |round beta fexp (Znearest choice) (x + y) - (x + y)| ≤ |x| := by
   sorry
 
 /-- Plus error bounded by right operand -/
-lemma plus_error_le_r (x y : Float)
+lemma plus_error_le_r (x y : ℝ)
   (hx : generic_format beta fexp x) (hy : generic_format beta fexp y) :
-  Float.abs (round beta fexp (Znearest choice) (x + y) - (x + y)) ≤ Float.abs y := by
+  |round beta fexp (Znearest choice) (x + y) - (x + y)| ≤ |y| := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Prop/Plus_error.lean.bak b/FloatSpec/src/Prop/Plus_error.lean.bak
new file mode 100644
index 0000000..b2775d0
--- /dev/null
+++ b/FloatSpec/src/Prop/Plus_error.lean.bak
@@ -0,0 +1,167 @@
+-- Error of the rounded-to-nearest addition is representable
+-- Translated from Coq file: flocq/src/Prop/Plus_error.v
+
+import FloatSpec.src.Core
+import FloatSpec.src.Prop.Relative
+
+variable (beta : Int)
+variable (fexp : Int → Int)
+variable [Valid_exp fexp]
+
+-- Section: Plus error representability
+
+/-- Round representation with same exponent -/
+theorem round_repr_same_exp (rnd : Float → Int) [Valid_rnd rnd] (m e : Int) :
+  ∃ m', round beta fexp rnd (F2R (FlocqFloat.mk m e : FlocqFloat beta)) = 
+        F2R (FlocqFloat.mk m' e : FlocqFloat beta) := by
+  sorry
+
+variable [Monotone_exp fexp]
+variable (choice : Int → Bool)
+
+/-- Plus error auxiliary lemma -/
+lemma plus_error_aux (x y : Float) 
+  (h_exp : cexp beta fexp x ≤ cexp beta fexp y)
+  (hx : generic_format beta fexp x) (hy : generic_format beta fexp y) :
+  generic_format beta fexp (round beta fexp (Znearest choice) (x + y) - (x + y)) := by
+  sorry
+
+/-- Error of the addition -/
+theorem plus_error (x y : Float)
+  (hx : generic_format beta fexp x) (hy : generic_format beta fexp y) :
+  generic_format beta fexp (round beta fexp (Znearest choice) (x + y) - (x + y)) := by
+  sorry
+
+-- Section: Plus zero properties
+
+variable [Exp_not_FTZ fexp]
+
+/-- Round plus not equal to zero auxiliary -/
+lemma round_plus_neq_0_aux (rnd : Float → Int) [Valid_rnd rnd] (x y : Float)
+  (h_exp : cexp beta fexp x ≤ cexp beta fexp y)
+  (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
+  (h_pos : 0 < x + y) :
+  round beta fexp rnd (x + y) ≠ 0 := by
+  sorry
+
+/-- rnd(x+y)=0 → x+y ≠ 0 (provided this is not a FTZ format) -/
+theorem round_plus_neq_0 (rnd : Float → Int) [Valid_rnd rnd] (x y : Float)
+  (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
+  (h_nonzero : x + y ≠ 0) :
+  round beta fexp rnd (x + y) ≠ 0 := by
+  sorry
+
+/-- rnd(x+y)=0 → x+y = 0 -/
+theorem round_plus_eq_0 (rnd : Float → Int) [Valid_rnd rnd] (x y : Float)
+  (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
+  (h_zero : round beta fexp rnd (x + y) = 0) :
+  x + y = 0 := by
+  sorry
+
+-- Section: FLT format plus properties
+
+variable (emin prec : Int)
+variable [Prec_gt_0 prec]
+
+/-- FLT format plus small -/
+theorem FLT_format_plus_small (x y : Float)
+  (hx : generic_format beta (FLT_exp emin prec) x)
+  (hy : generic_format beta (FLT_exp emin prec) y)
+  (h_bound : Float.abs (x + y) ≤ (Int.natAbs beta : Float) ^ (Int.natAbs (prec + emin) : Nat)) :
+  generic_format beta (FLT_exp emin prec) (x + y) := by
+  sorry
+
+/-- FLT plus error with nearest rounding existence -/
+lemma FLT_plus_error_N_ex (x y : Float)
+  (hx : generic_format beta (FLT_exp emin prec) x)
+  (hy : generic_format beta (FLT_exp emin prec) y) :
+  ∃ eps, Float.abs eps ≤ u_ro beta prec / (1 + u_ro beta prec) ∧
+    round beta (FLT_exp emin prec) (Znearest choice) (x + y) = (x + y) * (1 + eps) := by
+  sorry
+
+/-- FLT plus error with round existence -/
+lemma FLT_plus_error_N_round_ex (x y : Float)
+  (hx : generic_format beta (FLT_exp emin prec) x)
+  (hy : generic_format beta (FLT_exp emin prec) y) :
+  ∃ eps, Float.abs eps ≤ u_ro beta prec ∧
+    x + y = round beta (FLT_exp emin prec) (Znearest choice) (x + y) * (1 + eps) := by
+  sorry
+
+-- Section: Plus mult ulp properties
+
+variable (rnd : Float → Int)
+variable [Valid_rnd rnd]
+
+/-- Existence of shift representation -/
+lemma ex_shift (x : Float) (e : Int) 
+  (hx : generic_format beta fexp x) (h_exp : e ≤ cexp beta fexp x) :
+  ∃ m : Int, x = (m : Float) * ((Int.natAbs beta : Float) ^ (Int.natAbs e : Nat)) := by
+  sorry
+
+/-- Magnitude minus one relation -/
+lemma mag_minus1 (z : Float) (h_nonzero : z ≠ 0) :
+  mag beta z - 1 = mag beta (z / (beta : Float)) := by
+  sorry
+
+/-- Round plus F2R representation -/
+theorem round_plus_F2R (x y : Float) 
+  (hx : generic_format beta fexp x) (hy : generic_format beta fexp y) (h_nonzero : x ≠ 0) :
+  ∃ m : Int, round beta fexp rnd (x + y) = 
+    F2R (FlocqFloat.mk m (cexp beta fexp (x / (beta : Float))) : FlocqFloat beta) := by
+  sorry
+
+variable [Exp_not_FTZ fexp]
+
+/-- Round plus greater equal ulp -/
+theorem round_plus_ge_ulp (x y : Float)
+  (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
+  (h_nonzero : round beta fexp rnd (x + y) ≠ 0) :
+  ulp beta fexp (x / (beta : Float)) ≤ Float.abs (round beta fexp rnd (x + y)) := by
+  sorry
+
+-- Section: FLT plus bounds
+
+/-- Round FLT plus greater equal bound -/
+theorem round_FLT_plus_ge (x y : Float) (e : Int)
+  (hx : generic_format beta (FLT_exp emin prec) x)
+  (hy : generic_format beta (FLT_exp emin prec) y)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (e + prec) : Nat) ≤ Float.abs x)
+  (h_nonzero : round beta (FLT_exp emin prec) rnd (x + y) ≠ 0) :
+  (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat) ≤ 
+    Float.abs (round beta (FLT_exp emin prec) rnd (x + y)) := by
+  sorry
+
+/-- Round FLT plus greater equal bound (alternative) -/
+lemma round_FLT_plus_ge' (x y : Float) (e : Int)
+  (hx : generic_format beta (FLT_exp emin prec) x)
+  (hy : generic_format beta (FLT_exp emin prec) y)
+  (h1 : x ≠ 0 → (Int.natAbs beta : Float) ^ (Int.natAbs (e + prec) : Nat) ≤ Float.abs x)
+  (h2 : x = 0 → y ≠ 0 → (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat) ≤ Float.abs y)
+  (h_nonzero : round beta (FLT_exp emin prec) rnd (x + y) ≠ 0) :
+  (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat) ≤ 
+    Float.abs (round beta (FLT_exp emin prec) rnd (x + y)) := by
+  sorry
+
+/-- Round FLX plus greater equal bound -/
+theorem round_FLX_plus_ge (x y : Float) (e : Int)
+  (hx : generic_format beta (FLX_exp prec) x)
+  (hy : generic_format beta (FLX_exp prec) y)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (e + prec) : Nat) ≤ Float.abs x)
+  (h_nonzero : round beta (FLX_exp prec) rnd (x + y) ≠ 0) :
+  (Int.natAbs beta : Float) ^ (Int.natAbs e : Nat) ≤ 
+    Float.abs (round beta (FLX_exp prec) rnd (x + y)) := by
+  sorry
+
+-- Section: Plus error bounds
+
+/-- Plus error bounded by left operand -/
+lemma plus_error_le_l (x y : Float)
+  (hx : generic_format beta fexp x) (hy : generic_format beta fexp y) :
+  Float.abs (round beta fexp (Znearest choice) (x + y) - (x + y)) ≤ Float.abs x := by
+  sorry
+
+/-- Plus error bounded by right operand -/
+lemma plus_error_le_r (x y : Float)
+  (hx : generic_format beta fexp x) (hy : generic_format beta fexp y) :
+  Float.abs (round beta fexp (Znearest choice) (x + y) - (x + y)) ≤ Float.abs y := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Prop/Relative.lean b/FloatSpec/src/Prop/Relative.lean
index 6badfd0..60be373 100644
--- a/FloatSpec/src/Prop/Relative.lean
+++ b/FloatSpec/src/Prop/Relative.lean
@@ -2,6 +2,9 @@
 -- Translated from Coq file: flocq/src/Prop/Relative.v
 
 import FloatSpec.src.Core
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 
@@ -11,29 +14,29 @@ variable (fexp : Int → Int)
 variable [Valid_exp fexp]
 
 /-- Relative error less than conversion -/
-lemma relative_error_lt_conversion (rnd : Float → Int) [Valid_rnd rnd] (x b : Float) 
+lemma relative_error_lt_conversion (rnd : ℝ → Int) [Valid_rnd rnd] (x b : ℝ) 
   (h_pos : 0 < b)
-  (h_bound : x ≠ 0 → Float.abs (round beta fexp rnd x - x) < b * Float.abs x) :
-  ∃ eps, Float.abs eps < b ∧ round beta fexp rnd x = x * (1 + eps) := by
+  (h_bound : x ≠ 0 → |round beta fexp rnd x - x| < b * |x|) :
+  ∃ eps, |eps| < b ∧ round beta fexp rnd x = x * (1 + eps) := by
   sorry
 
 /-- Relative error less than or equal conversion -/
-lemma relative_error_le_conversion (rnd : Float → Int) [Valid_rnd rnd] (x b : Float)
+lemma relative_error_le_conversion (rnd : ℝ → Int) [Valid_rnd rnd] (x b : ℝ)
   (h_nonneg : 0 ≤ b)
-  (h_bound : Float.abs (round beta fexp rnd x - x) ≤ b * Float.abs x) :
-  ∃ eps, Float.abs eps ≤ b ∧ round beta fexp rnd x = x * (1 + eps) := by
+  (h_bound : |round beta fexp rnd x - x| ≤ b * |x|) :
+  ∃ eps, |eps| ≤ b ∧ round beta fexp rnd x = x * (1 + eps) := by
   sorry
 
 /-- Relative error less than or equal conversion inverse -/
-lemma relative_error_le_conversion_inv (rnd : Float → Int) [Valid_rnd rnd] (x b : Float)
-  (h_exists : ∃ eps, Float.abs eps ≤ b ∧ round beta fexp rnd x = x * (1 + eps)) :
-  Float.abs (round beta fexp rnd x - x) ≤ b * Float.abs x := by
+lemma relative_error_le_conversion_inv (rnd : ℝ → Int) [Valid_rnd rnd] (x b : ℝ)
+  (h_exists : ∃ eps, |eps| ≤ b ∧ round beta fexp rnd x = x * (1 + eps)) :
+  |round beta fexp rnd x - x| ≤ b * |x| := by
   sorry
 
 /-- Relative error less than or equal conversion round inverse -/
-lemma relative_error_le_conversion_round_inv (rnd : Float → Int) [Valid_rnd rnd] (x b : Float)
-  (h_exists : ∃ eps, Float.abs eps ≤ b ∧ x = round beta fexp rnd x * (1 + eps)) :
-  Float.abs (round beta fexp rnd x - x) ≤ b * Float.abs (round beta fexp rnd x) := by
+lemma relative_error_le_conversion_round_inv (rnd : ℝ → Int) [Valid_rnd rnd] (x b : ℝ)
+  (h_exists : ∃ eps, |eps| ≤ b ∧ x = round beta fexp rnd x * (1 + eps)) :
+  |round beta fexp rnd x - x| ≤ b * |round beta fexp rnd x| := by
   sorry
 
 -- Section: Generic relative error
@@ -42,50 +45,50 @@ variable (emin p : Int)
 variable (h_min : ∀ k, emin < k → p ≤ k - fexp k)
 
 /-- Relative error bound -/
-theorem relative_error (rnd : Float → Int) [Valid_rnd rnd] (x : Float)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ≤ Float.abs x) :
-  Float.abs (round beta fexp rnd x - x) < 
-    (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * Float.abs x := by
+theorem relative_error (rnd : ℝ → Int) [Valid_rnd rnd] (x : ℝ)
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs emin : Nat) ≤ |x|) :
+  |round beta fexp rnd x - x| < 
+    (Int.natAbs beta : ℝ) ^ (Int.natAbs (-p + 1) : Nat) * |x| := by
   sorry
 
 /-- Relative error existence -/
-theorem relative_error_ex (rnd : Float → Int) [Valid_rnd rnd] (x : Float)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ≤ Float.abs x) :
-  ∃ eps, Float.abs eps < (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) ∧
+theorem relative_error_ex (rnd : ℝ → Int) [Valid_rnd rnd] (x : ℝ)
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs emin : Nat) ≤ |x|) :
+  ∃ eps, |eps| < (Int.natAbs beta : ℝ) ^ (Int.natAbs (-p + 1) : Nat) ∧
     round beta fexp rnd x = x * (1 + eps) := by
   sorry
 
 /-- Relative error F2R emin -/
-theorem relative_error_F2R_emin (rnd : Float → Int) [Valid_rnd rnd] (m : Int)
+theorem relative_error_F2R_emin (rnd : ℝ → Int) [Valid_rnd rnd] (m : Int)
   (h_nonzero : F2R (FlocqFloat.mk m emin : FlocqFloat beta) ≠ 0) :
-  Float.abs (round beta fexp rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
-    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) < 
-    (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * 
-    Float.abs (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) := by
+  |round beta fexp rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)| < 
+    (Int.natAbs beta : ℝ) ^ (Int.natAbs (-p + 1) : Nat) * 
+    |F2R (FlocqFloat.mk m emin : FlocqFloat beta)| := by
   sorry
 
 /-- Relative error F2R emin existence -/
-theorem relative_error_F2R_emin_ex (rnd : Float → Int) [Valid_rnd rnd] (m : Int) :
-  ∃ eps, Float.abs eps < (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) ∧
+theorem relative_error_F2R_emin_ex (rnd : ℝ → Int) [Valid_rnd rnd] (m : Int) :
+  ∃ eps, |eps| < (Int.natAbs beta : ℝ) ^ (Int.natAbs (-p + 1) : Nat) ∧
     round beta fexp rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) = 
     F2R (FlocqFloat.mk m emin : FlocqFloat beta) * (1 + eps) := by
   sorry
 
 /-- Relative error round -/
-theorem relative_error_round (rnd : Float → Int) [Valid_rnd rnd] (h_pos : 0 < p) (x : Float)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ≤ Float.abs x) :
-  Float.abs (round beta fexp rnd x - x) < 
-    (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * 
-    Float.abs (round beta fexp rnd x) := by
+theorem relative_error_round (rnd : ℝ → Int) [Valid_rnd rnd] (h_pos : 0 < p) (x : ℝ)
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs emin : Nat) ≤ |x|) :
+  |round beta fexp rnd x - x| < 
+    (Int.natAbs beta : ℝ) ^ (Int.natAbs (-p + 1) : Nat) * 
+    |round beta fexp rnd x| := by
   sorry
 
 /-- Relative error round F2R emin -/
-theorem relative_error_round_F2R_emin (rnd : Float → Int) [Valid_rnd rnd] (h_pos : 0 < p) (m : Int)
+theorem relative_error_round_F2R_emin (rnd : ℝ → Int) [Valid_rnd rnd] (h_pos : 0 < p) (m : Int)
   (h_nonzero : F2R (FlocqFloat.mk m emin : FlocqFloat beta) ≠ 0) :
-  Float.abs (round beta fexp rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
-    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) < 
-    (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * 
-    Float.abs (round beta fexp rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta))) := by
+  |round beta fexp rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)| < 
+    (Int.natAbs beta : ℝ) ^ (Int.natAbs (-p + 1) : Nat) * 
+    |round beta fexp rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta))| := by
   sorry
 
 -- Section: Nearest rounding relative error
@@ -93,48 +96,48 @@ theorem relative_error_round_F2R_emin (rnd : Float → Int) [Valid_rnd rnd] (h_p
 variable (choice : Int → Bool)
 
 /-- Relative error nearest -/
-theorem relative_error_N (x : Float)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ≤ Float.abs x) :
-  Float.abs (round beta fexp (Znearest choice) x - x) ≤ 
-    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * Float.abs x := by
+theorem relative_error_N (x : ℝ)
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs emin : Nat) ≤ |x|) :
+  |round beta fexp (Znearest choice) x - x| ≤ 
+    (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-p + 1) : Nat) * |x| := by
   sorry
 
 /-- Relative error nearest existence -/
-theorem relative_error_N_ex (x : Float)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ≤ Float.abs x) :
-  ∃ eps, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) ∧
+theorem relative_error_N_ex (x : ℝ)
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs emin : Nat) ≤ |x|) :
+  ∃ eps, |eps| ≤ (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-p + 1) : Nat) ∧
     round beta fexp (Znearest choice) x = x * (1 + eps) := by
   sorry
 
 /-- Relative error nearest F2R emin -/
 theorem relative_error_N_F2R_emin (m : Int) :
-  Float.abs (round beta fexp (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
-    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) ≤ 
-    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * 
-    Float.abs (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) := by
+  |round beta fexp (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)| ≤ 
+    (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-p + 1) : Nat) * 
+    |F2R (FlocqFloat.mk m emin : FlocqFloat beta)| := by
   sorry
 
 /-- Relative error nearest F2R emin existence -/
 theorem relative_error_N_F2R_emin_ex (m : Int) :
-  ∃ eps, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) ∧
+  ∃ eps, |eps| ≤ (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-p + 1) : Nat) ∧
     round beta fexp (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) = 
     F2R (FlocqFloat.mk m emin : FlocqFloat beta) * (1 + eps) := by
   sorry
 
 /-- Relative error nearest round -/
-theorem relative_error_N_round (h_pos : 0 < p) (x : Float)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ≤ Float.abs x) :
-  Float.abs (round beta fexp (Znearest choice) x - x) ≤ 
-    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * 
-    Float.abs (round beta fexp (Znearest choice) x) := by
+theorem relative_error_N_round (h_pos : 0 < p) (x : ℝ)
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs emin : Nat) ≤ |x|) :
+  |round beta fexp (Znearest choice) x - x| ≤ 
+    (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-p + 1) : Nat) * 
+    |round beta fexp (Znearest choice) x| := by
   sorry
 
 /-- Relative error nearest round F2R emin -/
 theorem relative_error_N_round_F2R_emin (h_pos : 0 < p) (m : Int) :
-  Float.abs (round beta fexp (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
-    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) ≤ 
-    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * 
-    Float.abs (round beta fexp (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta))) := by
+  |round beta fexp (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)| ≤ 
+    (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-p + 1) : Nat) * 
+    |round beta fexp (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta))| := by
   sorry
 
 -- Section: FLX relative error
@@ -147,32 +150,32 @@ lemma relative_error_FLX_aux (k : Int) : prec ≤ k - FLX_exp prec k := by
   sorry
 
 /-- FLX relative error -/
-theorem relative_error_FLX (rnd : Float → Int) [Valid_rnd rnd] (x : Float) (h_nonzero : x ≠ 0) :
-  Float.abs (round beta (FLX_exp prec) rnd x - x) < 
-    (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * Float.abs x := by
+theorem relative_error_FLX (rnd : ℝ → Int) [Valid_rnd rnd] (x : ℝ) (h_nonzero : x ≠ 0) :
+  |round beta (FLX_exp prec) rnd x - x| < 
+    (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) * |x| := by
   sorry
 
 /-- FLX relative error existence -/
-theorem relative_error_FLX_ex (rnd : Float → Int) [Valid_rnd rnd] (x : Float) :
-  ∃ eps, Float.abs eps < (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+theorem relative_error_FLX_ex (rnd : ℝ → Int) [Valid_rnd rnd] (x : ℝ) :
+  ∃ eps, |eps| < (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) ∧
     round beta (FLX_exp prec) rnd x = x * (1 + eps) := by
   sorry
 
 /-- FLX relative error round -/
-theorem relative_error_FLX_round (rnd : Float → Int) [Valid_rnd rnd] (x : Float) (h_nonzero : x ≠ 0) :
-  Float.abs (round beta (FLX_exp prec) rnd x - x) < 
-    (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * 
-    Float.abs (round beta (FLX_exp prec) rnd x) := by
+theorem relative_error_FLX_round (rnd : ℝ → Int) [Valid_rnd rnd] (x : ℝ) (h_nonzero : x ≠ 0) :
+  |round beta (FLX_exp prec) rnd x - x| < 
+    (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) * 
+    |round beta (FLX_exp prec) rnd x| := by
   sorry
 
 /-- FLX relative error nearest -/
-theorem relative_error_N_FLX (x : Float) :
-  Float.abs (round beta (FLX_exp prec) (Znearest choice) x - x) ≤ 
-    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * Float.abs x := by
+theorem relative_error_N_FLX (x : ℝ) :
+  |round beta (FLX_exp prec) (Znearest choice) x - x| ≤ 
+    (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) * |x| := by
   sorry
 
 /-- Unit roundoff -/
-def u_ro : Float := (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat)
+def u_ro : ℝ := (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat)
 
 /-- Unit roundoff is positive -/
 lemma u_ro_pos : 0 ≤ u_ro beta prec := by
@@ -191,40 +194,40 @@ lemma u_rod1pu_ro_le_u_ro : u_ro beta prec / (1 + u_ro beta prec) ≤ u_ro beta
   sorry
 
 /-- FLX relative error nearest alternative -/
-theorem relative_error_N_FLX' (x : Float) :
-  Float.abs (round beta (FLX_exp prec) (Znearest choice) x - x) ≤ 
-    u_ro beta prec / (1 + u_ro beta prec) * Float.abs x := by
+theorem relative_error_N_FLX' (x : ℝ) :
+  |round beta (FLX_exp prec) (Znearest choice) x - x| ≤ 
+    u_ro beta prec / (1 + u_ro beta prec) * |x| := by
   sorry
 
 /-- FLX relative error nearest existence -/
-theorem relative_error_N_FLX_ex (x : Float) :
-  ∃ eps, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+theorem relative_error_N_FLX_ex (x : ℝ) :
+  ∃ eps, |eps| ≤ (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) ∧
     round beta (FLX_exp prec) (Znearest choice) x = x * (1 + eps) := by
   sorry
 
 /-- FLX relative error nearest alternative existence -/
-theorem relative_error_N_FLX'_ex (x : Float) :
-  ∃ eps, Float.abs eps ≤ u_ro beta prec / (1 + u_ro beta prec) ∧
+theorem relative_error_N_FLX'_ex (x : ℝ) :
+  ∃ eps, |eps| ≤ u_ro beta prec / (1 + u_ro beta prec) ∧
     round beta (FLX_exp prec) (Znearest choice) x = x * (1 + eps) := by
   sorry
 
 /-- Relative error nearest round derivation -/
-lemma relative_error_N_round_ex_derive (x rx : Float)
-  (h_exists : ∃ eps, Float.abs eps ≤ u_ro beta prec / (1 + u_ro beta prec) ∧ rx = x * (1 + eps)) :
-  ∃ eps, Float.abs eps ≤ u_ro beta prec ∧ x = rx * (1 + eps) := by
+lemma relative_error_N_round_ex_derive (x rx : ℝ)
+  (h_exists : ∃ eps, |eps| ≤ u_ro beta prec / (1 + u_ro beta prec) ∧ rx = x * (1 + eps)) :
+  ∃ eps, |eps| ≤ u_ro beta prec ∧ x = rx * (1 + eps) := by
   sorry
 
 /-- FLX relative error nearest round existence -/
-theorem relative_error_N_FLX_round_ex (x : Float) :
-  ∃ eps, Float.abs eps ≤ u_ro beta prec ∧
+theorem relative_error_N_FLX_round_ex (x : ℝ) :
+  ∃ eps, |eps| ≤ u_ro beta prec ∧
     x = round beta (FLX_exp prec) (Znearest choice) x * (1 + eps) := by
   sorry
 
 /-- FLX relative error nearest round -/
-theorem relative_error_N_FLX_round (x : Float) :
-  Float.abs (round beta (FLX_exp prec) (Znearest choice) x - x) ≤ 
-    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * 
-    Float.abs (round beta (FLX_exp prec) (Znearest choice) x) := by
+theorem relative_error_N_FLX_round (x : ℝ) :
+  |round beta (FLX_exp prec) (Znearest choice) x - x| ≤ 
+    (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) * 
+    |round beta (FLX_exp prec) (Znearest choice) x| := by
   sorry
 
 -- Section: FLT relative error
@@ -237,109 +240,109 @@ lemma relative_error_FLT_aux (k : Int) (h_bound : emin + prec - 1 < k) :
   sorry
 
 /-- FLT relative error -/
-theorem relative_error_FLT (rnd : Float → Int) [Valid_rnd rnd] (x : Float)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ Float.abs x) :
-  Float.abs (round beta (FLT_exp emin prec) rnd x - x) < 
-    (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * Float.abs x := by
+theorem relative_error_FLT (rnd : ℝ → Int) [Valid_rnd rnd] (x : ℝ)
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ |x|) :
+  |round beta (FLT_exp emin prec) rnd x - x| < 
+    (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) * |x| := by
   sorry
 
 /-- FLT relative error F2R emin -/
-theorem relative_error_FLT_F2R_emin (rnd : Float → Int) [Valid_rnd rnd] (m : Int)
+theorem relative_error_FLT_F2R_emin (rnd : ℝ → Int) [Valid_rnd rnd] (m : Int)
   (h_nonzero : F2R (FlocqFloat.mk m emin : FlocqFloat beta) ≠ 0) :
-  Float.abs (round beta (FLT_exp emin prec) rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
-    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) < 
-    (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * 
-    Float.abs (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) := by
+  |round beta (FLT_exp emin prec) rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)| < 
+    (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) * 
+    |F2R (FlocqFloat.mk m emin : FlocqFloat beta)| := by
   sorry
 
 /-- FLT relative error F2R emin existence -/
-theorem relative_error_FLT_F2R_emin_ex (rnd : Float → Int) [Valid_rnd rnd] (m : Int) :
-  ∃ eps, Float.abs eps < (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+theorem relative_error_FLT_F2R_emin_ex (rnd : ℝ → Int) [Valid_rnd rnd] (m : Int) :
+  ∃ eps, |eps| < (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) ∧
     round beta (FLT_exp emin prec) rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) = 
     F2R (FlocqFloat.mk m emin : FlocqFloat beta) * (1 + eps) := by
   sorry
 
 /-- FLT relative error existence -/
-theorem relative_error_FLT_ex (rnd : Float → Int) [Valid_rnd rnd] (x : Float)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ Float.abs x) :
-  ∃ eps, Float.abs eps < (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+theorem relative_error_FLT_ex (rnd : ℝ → Int) [Valid_rnd rnd] (x : ℝ)
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ |x|) :
+  ∃ eps, |eps| < (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) ∧
     round beta (FLT_exp emin prec) rnd x = x * (1 + eps) := by
   sorry
 
 /-- FLT relative error nearest -/
-theorem relative_error_N_FLT (x : Float)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ Float.abs x) :
-  Float.abs (round beta (FLT_exp emin prec) (Znearest choice) x - x) ≤ 
-    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * Float.abs x := by
+theorem relative_error_N_FLT (x : ℝ)
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ |x|) :
+  |round beta (FLT_exp emin prec) (Znearest choice) x - x| ≤ 
+    (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) * |x| := by
   sorry
 
 /-- FLT relative error nearest existence -/
-theorem relative_error_N_FLT_ex (x : Float)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ Float.abs x) :
-  ∃ eps, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+theorem relative_error_N_FLT_ex (x : ℝ)
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ |x|) :
+  ∃ eps, |eps| ≤ (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) ∧
     round beta (FLT_exp emin prec) (Znearest choice) x = x * (1 + eps) := by
   sorry
 
 /-- FLT relative error nearest round -/
-theorem relative_error_N_FLT_round (x : Float)
-  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ Float.abs x) :
-  Float.abs (round beta (FLT_exp emin prec) (Znearest choice) x - x) ≤ 
-    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * 
-    Float.abs (round beta (FLT_exp emin prec) (Znearest choice) x) := by
+theorem relative_error_N_FLT_round (x : ℝ)
+  (h_bound : (Int.natAbs beta : ℝ) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ |x|) :
+  |round beta (FLT_exp emin prec) (Znearest choice) x - x| ≤ 
+    (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) * 
+    |round beta (FLT_exp emin prec) (Znearest choice) x| := by
   sorry
 
 /-- FLT relative error nearest F2R emin -/
 theorem relative_error_N_FLT_F2R_emin (m : Int) :
-  Float.abs (round beta (FLT_exp emin prec) (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
-    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) ≤ 
-    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * 
-    Float.abs (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) := by
+  |round beta (FLT_exp emin prec) (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)| ≤ 
+    (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) * 
+    |F2R (FlocqFloat.mk m emin : FlocqFloat beta)| := by
   sorry
 
 /-- FLT relative error nearest F2R emin existence -/
 theorem relative_error_N_FLT_F2R_emin_ex (m : Int) :
-  ∃ eps, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+  ∃ eps, |eps| ≤ (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) ∧
     round beta (FLT_exp emin prec) (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) = 
     F2R (FlocqFloat.mk m emin : FlocqFloat beta) * (1 + eps) := by
   sorry
 
 /-- FLT relative error nearest round F2R emin -/
 theorem relative_error_N_FLT_round_F2R_emin (m : Int) :
-  Float.abs (round beta (FLT_exp emin prec) (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
-    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) ≤ 
-    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * 
-    Float.abs (round beta (FLT_exp emin prec) (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta))) := by
+  |round beta (FLT_exp emin prec) (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)| ≤ 
+    (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) * 
+    |round beta (FLT_exp emin prec) (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta))| := by
   sorry
 
 /-- FLT error nearest auxiliary -/
-lemma error_N_FLT_aux (x : Float) (h_pos : 0 < x) :
-  ∃ eps eta, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
-    Float.abs eta ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ∧
+lemma error_N_FLT_aux (x : ℝ) (h_pos : 0 < x) :
+  ∃ eps eta, |eps| ≤ (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+    |eta| ≤ (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs emin : Nat) ∧
     eps * eta = 0 ∧
     round beta (FLT_exp emin prec) (Znearest choice) x = x * (1 + eps) + eta := by
   sorry
 
 /-- FLT relative error nearest alternative existence -/
-theorem relative_error_N_FLT'_ex (x : Float) :
-  ∃ eps eta, Float.abs eps ≤ u_ro beta prec / (1 + u_ro beta prec) ∧
-    Float.abs eta ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ∧
+theorem relative_error_N_FLT'_ex (x : ℝ) :
+  ∃ eps eta, |eps| ≤ u_ro beta prec / (1 + u_ro beta prec) ∧
+    |eta| ≤ (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs emin : Nat) ∧
     eps * eta = 0 ∧
     round beta (FLT_exp emin prec) (Znearest choice) x = x * (1 + eps) + eta := by
   sorry
 
 /-- FLT relative error nearest alternative separate -/
-theorem relative_error_N_FLT'_ex_separate (x : Float) :
+theorem relative_error_N_FLT'_ex_separate (x : ℝ) :
   ∃ x', round beta (FLT_exp emin prec) (Znearest choice) x' = 
     round beta (FLT_exp emin prec) (Znearest choice) x ∧
-    (∃ eta, Float.abs eta ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ∧ x' = x + eta) ∧
-    (∃ eps, Float.abs eps ≤ u_ro beta prec / (1 + u_ro beta prec) ∧
+    (∃ eta, |eta| ≤ (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs emin : Nat) ∧ x' = x + eta) ∧
+    (∃ eps, |eps| ≤ u_ro beta prec / (1 + u_ro beta prec) ∧
       round beta (FLT_exp emin prec) (Znearest choice) x' = x' * (1 + eps)) := by
   sorry
 
 /-- General FLT error nearest -/
-theorem error_N_FLT (emin prec : Int) (h_pos : 0 < prec) (choice : Int → Bool) (x : Float) :
-  ∃ eps eta, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
-    Float.abs eta ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ∧
+theorem error_N_FLT (emin prec : Int) (h_pos : 0 < prec) (choice : Int → Bool) (x : ℝ) :
+  ∃ eps eta, |eps| ≤ (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+    |eta| ≤ (1/2) * (Int.natAbs beta : ℝ) ^ (Int.natAbs emin : Nat) ∧
     eps * eta = 0 ∧
     round beta (FLT_exp emin prec) (Znearest choice) x = x * (1 + eps) + eta := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Prop/Relative.lean.bak b/FloatSpec/src/Prop/Relative.lean.bak
new file mode 100644
index 0000000..6badfd0
--- /dev/null
+++ b/FloatSpec/src/Prop/Relative.lean.bak
@@ -0,0 +1,345 @@
+-- Relative error of the roundings
+-- Translated from Coq file: flocq/src/Prop/Relative.v
+
+import FloatSpec.src.Core
+
+variable (beta : Int)
+
+-- Section: Relative error conversions
+
+variable (fexp : Int → Int)
+variable [Valid_exp fexp]
+
+/-- Relative error less than conversion -/
+lemma relative_error_lt_conversion (rnd : Float → Int) [Valid_rnd rnd] (x b : Float) 
+  (h_pos : 0 < b)
+  (h_bound : x ≠ 0 → Float.abs (round beta fexp rnd x - x) < b * Float.abs x) :
+  ∃ eps, Float.abs eps < b ∧ round beta fexp rnd x = x * (1 + eps) := by
+  sorry
+
+/-- Relative error less than or equal conversion -/
+lemma relative_error_le_conversion (rnd : Float → Int) [Valid_rnd rnd] (x b : Float)
+  (h_nonneg : 0 ≤ b)
+  (h_bound : Float.abs (round beta fexp rnd x - x) ≤ b * Float.abs x) :
+  ∃ eps, Float.abs eps ≤ b ∧ round beta fexp rnd x = x * (1 + eps) := by
+  sorry
+
+/-- Relative error less than or equal conversion inverse -/
+lemma relative_error_le_conversion_inv (rnd : Float → Int) [Valid_rnd rnd] (x b : Float)
+  (h_exists : ∃ eps, Float.abs eps ≤ b ∧ round beta fexp rnd x = x * (1 + eps)) :
+  Float.abs (round beta fexp rnd x - x) ≤ b * Float.abs x := by
+  sorry
+
+/-- Relative error less than or equal conversion round inverse -/
+lemma relative_error_le_conversion_round_inv (rnd : Float → Int) [Valid_rnd rnd] (x b : Float)
+  (h_exists : ∃ eps, Float.abs eps ≤ b ∧ x = round beta fexp rnd x * (1 + eps)) :
+  Float.abs (round beta fexp rnd x - x) ≤ b * Float.abs (round beta fexp rnd x) := by
+  sorry
+
+-- Section: Generic relative error
+
+variable (emin p : Int)
+variable (h_min : ∀ k, emin < k → p ≤ k - fexp k)
+
+/-- Relative error bound -/
+theorem relative_error (rnd : Float → Int) [Valid_rnd rnd] (x : Float)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ≤ Float.abs x) :
+  Float.abs (round beta fexp rnd x - x) < 
+    (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * Float.abs x := by
+  sorry
+
+/-- Relative error existence -/
+theorem relative_error_ex (rnd : Float → Int) [Valid_rnd rnd] (x : Float)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ≤ Float.abs x) :
+  ∃ eps, Float.abs eps < (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) ∧
+    round beta fexp rnd x = x * (1 + eps) := by
+  sorry
+
+/-- Relative error F2R emin -/
+theorem relative_error_F2R_emin (rnd : Float → Int) [Valid_rnd rnd] (m : Int)
+  (h_nonzero : F2R (FlocqFloat.mk m emin : FlocqFloat beta) ≠ 0) :
+  Float.abs (round beta fexp rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) < 
+    (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * 
+    Float.abs (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) := by
+  sorry
+
+/-- Relative error F2R emin existence -/
+theorem relative_error_F2R_emin_ex (rnd : Float → Int) [Valid_rnd rnd] (m : Int) :
+  ∃ eps, Float.abs eps < (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) ∧
+    round beta fexp rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) = 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta) * (1 + eps) := by
+  sorry
+
+/-- Relative error round -/
+theorem relative_error_round (rnd : Float → Int) [Valid_rnd rnd] (h_pos : 0 < p) (x : Float)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ≤ Float.abs x) :
+  Float.abs (round beta fexp rnd x - x) < 
+    (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * 
+    Float.abs (round beta fexp rnd x) := by
+  sorry
+
+/-- Relative error round F2R emin -/
+theorem relative_error_round_F2R_emin (rnd : Float → Int) [Valid_rnd rnd] (h_pos : 0 < p) (m : Int)
+  (h_nonzero : F2R (FlocqFloat.mk m emin : FlocqFloat beta) ≠ 0) :
+  Float.abs (round beta fexp rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) < 
+    (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * 
+    Float.abs (round beta fexp rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta))) := by
+  sorry
+
+-- Section: Nearest rounding relative error
+
+variable (choice : Int → Bool)
+
+/-- Relative error nearest -/
+theorem relative_error_N (x : Float)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ≤ Float.abs x) :
+  Float.abs (round beta fexp (Znearest choice) x - x) ≤ 
+    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * Float.abs x := by
+  sorry
+
+/-- Relative error nearest existence -/
+theorem relative_error_N_ex (x : Float)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ≤ Float.abs x) :
+  ∃ eps, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) ∧
+    round beta fexp (Znearest choice) x = x * (1 + eps) := by
+  sorry
+
+/-- Relative error nearest F2R emin -/
+theorem relative_error_N_F2R_emin (m : Int) :
+  Float.abs (round beta fexp (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) ≤ 
+    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * 
+    Float.abs (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) := by
+  sorry
+
+/-- Relative error nearest F2R emin existence -/
+theorem relative_error_N_F2R_emin_ex (m : Int) :
+  ∃ eps, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) ∧
+    round beta fexp (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) = 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta) * (1 + eps) := by
+  sorry
+
+/-- Relative error nearest round -/
+theorem relative_error_N_round (h_pos : 0 < p) (x : Float)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ≤ Float.abs x) :
+  Float.abs (round beta fexp (Znearest choice) x - x) ≤ 
+    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * 
+    Float.abs (round beta fexp (Znearest choice) x) := by
+  sorry
+
+/-- Relative error nearest round F2R emin -/
+theorem relative_error_N_round_F2R_emin (h_pos : 0 < p) (m : Int) :
+  Float.abs (round beta fexp (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) ≤ 
+    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-p + 1) : Nat) * 
+    Float.abs (round beta fexp (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta))) := by
+  sorry
+
+-- Section: FLX relative error
+
+variable (prec : Int)
+variable [Prec_gt_0 prec]
+
+/-- FLX relative error auxiliary -/
+lemma relative_error_FLX_aux (k : Int) : prec ≤ k - FLX_exp prec k := by
+  sorry
+
+/-- FLX relative error -/
+theorem relative_error_FLX (rnd : Float → Int) [Valid_rnd rnd] (x : Float) (h_nonzero : x ≠ 0) :
+  Float.abs (round beta (FLX_exp prec) rnd x - x) < 
+    (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * Float.abs x := by
+  sorry
+
+/-- FLX relative error existence -/
+theorem relative_error_FLX_ex (rnd : Float → Int) [Valid_rnd rnd] (x : Float) :
+  ∃ eps, Float.abs eps < (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+    round beta (FLX_exp prec) rnd x = x * (1 + eps) := by
+  sorry
+
+/-- FLX relative error round -/
+theorem relative_error_FLX_round (rnd : Float → Int) [Valid_rnd rnd] (x : Float) (h_nonzero : x ≠ 0) :
+  Float.abs (round beta (FLX_exp prec) rnd x - x) < 
+    (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * 
+    Float.abs (round beta (FLX_exp prec) rnd x) := by
+  sorry
+
+/-- FLX relative error nearest -/
+theorem relative_error_N_FLX (x : Float) :
+  Float.abs (round beta (FLX_exp prec) (Znearest choice) x - x) ≤ 
+    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * Float.abs x := by
+  sorry
+
+/-- Unit roundoff -/
+def u_ro : Float := (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat)
+
+/-- Unit roundoff is positive -/
+lemma u_ro_pos : 0 ≤ u_ro beta prec := by
+  sorry
+
+/-- Unit roundoff is less than 1 -/
+lemma u_ro_lt_1 : u_ro beta prec < 1 := by
+  sorry
+
+/-- Unit roundoff divided by (1 + u_ro) is positive -/
+lemma u_rod1pu_ro_pos : 0 ≤ u_ro beta prec / (1 + u_ro beta prec) := by
+  sorry
+
+/-- Unit roundoff divided by (1 + u_ro) is less than or equal to u_ro -/
+lemma u_rod1pu_ro_le_u_ro : u_ro beta prec / (1 + u_ro beta prec) ≤ u_ro beta prec := by
+  sorry
+
+/-- FLX relative error nearest alternative -/
+theorem relative_error_N_FLX' (x : Float) :
+  Float.abs (round beta (FLX_exp prec) (Znearest choice) x - x) ≤ 
+    u_ro beta prec / (1 + u_ro beta prec) * Float.abs x := by
+  sorry
+
+/-- FLX relative error nearest existence -/
+theorem relative_error_N_FLX_ex (x : Float) :
+  ∃ eps, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+    round beta (FLX_exp prec) (Znearest choice) x = x * (1 + eps) := by
+  sorry
+
+/-- FLX relative error nearest alternative existence -/
+theorem relative_error_N_FLX'_ex (x : Float) :
+  ∃ eps, Float.abs eps ≤ u_ro beta prec / (1 + u_ro beta prec) ∧
+    round beta (FLX_exp prec) (Znearest choice) x = x * (1 + eps) := by
+  sorry
+
+/-- Relative error nearest round derivation -/
+lemma relative_error_N_round_ex_derive (x rx : Float)
+  (h_exists : ∃ eps, Float.abs eps ≤ u_ro beta prec / (1 + u_ro beta prec) ∧ rx = x * (1 + eps)) :
+  ∃ eps, Float.abs eps ≤ u_ro beta prec ∧ x = rx * (1 + eps) := by
+  sorry
+
+/-- FLX relative error nearest round existence -/
+theorem relative_error_N_FLX_round_ex (x : Float) :
+  ∃ eps, Float.abs eps ≤ u_ro beta prec ∧
+    x = round beta (FLX_exp prec) (Znearest choice) x * (1 + eps) := by
+  sorry
+
+/-- FLX relative error nearest round -/
+theorem relative_error_N_FLX_round (x : Float) :
+  Float.abs (round beta (FLX_exp prec) (Znearest choice) x - x) ≤ 
+    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * 
+    Float.abs (round beta (FLX_exp prec) (Znearest choice) x) := by
+  sorry
+
+-- Section: FLT relative error
+
+variable (emin : Int)
+
+/-- FLT relative error auxiliary -/
+lemma relative_error_FLT_aux (k : Int) (h_bound : emin + prec - 1 < k) : 
+  prec ≤ k - FLT_exp emin prec k := by
+  sorry
+
+/-- FLT relative error -/
+theorem relative_error_FLT (rnd : Float → Int) [Valid_rnd rnd] (x : Float)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ Float.abs x) :
+  Float.abs (round beta (FLT_exp emin prec) rnd x - x) < 
+    (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * Float.abs x := by
+  sorry
+
+/-- FLT relative error F2R emin -/
+theorem relative_error_FLT_F2R_emin (rnd : Float → Int) [Valid_rnd rnd] (m : Int)
+  (h_nonzero : F2R (FlocqFloat.mk m emin : FlocqFloat beta) ≠ 0) :
+  Float.abs (round beta (FLT_exp emin prec) rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) < 
+    (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * 
+    Float.abs (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) := by
+  sorry
+
+/-- FLT relative error F2R emin existence -/
+theorem relative_error_FLT_F2R_emin_ex (rnd : Float → Int) [Valid_rnd rnd] (m : Int) :
+  ∃ eps, Float.abs eps < (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+    round beta (FLT_exp emin prec) rnd (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) = 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta) * (1 + eps) := by
+  sorry
+
+/-- FLT relative error existence -/
+theorem relative_error_FLT_ex (rnd : Float → Int) [Valid_rnd rnd] (x : Float)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ Float.abs x) :
+  ∃ eps, Float.abs eps < (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+    round beta (FLT_exp emin prec) rnd x = x * (1 + eps) := by
+  sorry
+
+/-- FLT relative error nearest -/
+theorem relative_error_N_FLT (x : Float)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ Float.abs x) :
+  Float.abs (round beta (FLT_exp emin prec) (Znearest choice) x - x) ≤ 
+    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * Float.abs x := by
+  sorry
+
+/-- FLT relative error nearest existence -/
+theorem relative_error_N_FLT_ex (x : Float)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ Float.abs x) :
+  ∃ eps, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+    round beta (FLT_exp emin prec) (Znearest choice) x = x * (1 + eps) := by
+  sorry
+
+/-- FLT relative error nearest round -/
+theorem relative_error_N_FLT_round (x : Float)
+  (h_bound : (Int.natAbs beta : Float) ^ (Int.natAbs (emin + prec - 1) : Nat) ≤ Float.abs x) :
+  Float.abs (round beta (FLT_exp emin prec) (Znearest choice) x - x) ≤ 
+    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * 
+    Float.abs (round beta (FLT_exp emin prec) (Znearest choice) x) := by
+  sorry
+
+/-- FLT relative error nearest F2R emin -/
+theorem relative_error_N_FLT_F2R_emin (m : Int) :
+  Float.abs (round beta (FLT_exp emin prec) (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) ≤ 
+    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * 
+    Float.abs (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) := by
+  sorry
+
+/-- FLT relative error nearest F2R emin existence -/
+theorem relative_error_N_FLT_F2R_emin_ex (m : Int) :
+  ∃ eps, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+    round beta (FLT_exp emin prec) (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) = 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta) * (1 + eps) := by
+  sorry
+
+/-- FLT relative error nearest round F2R emin -/
+theorem relative_error_N_FLT_round_F2R_emin (m : Int) :
+  Float.abs (round beta (FLT_exp emin prec) (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta)) - 
+    F2R (FlocqFloat.mk m emin : FlocqFloat beta)) ≤ 
+    (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) * 
+    Float.abs (round beta (FLT_exp emin prec) (Znearest choice) (F2R (FlocqFloat.mk m emin : FlocqFloat beta))) := by
+  sorry
+
+/-- FLT error nearest auxiliary -/
+lemma error_N_FLT_aux (x : Float) (h_pos : 0 < x) :
+  ∃ eps eta, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+    Float.abs eta ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ∧
+    eps * eta = 0 ∧
+    round beta (FLT_exp emin prec) (Znearest choice) x = x * (1 + eps) + eta := by
+  sorry
+
+/-- FLT relative error nearest alternative existence -/
+theorem relative_error_N_FLT'_ex (x : Float) :
+  ∃ eps eta, Float.abs eps ≤ u_ro beta prec / (1 + u_ro beta prec) ∧
+    Float.abs eta ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ∧
+    eps * eta = 0 ∧
+    round beta (FLT_exp emin prec) (Znearest choice) x = x * (1 + eps) + eta := by
+  sorry
+
+/-- FLT relative error nearest alternative separate -/
+theorem relative_error_N_FLT'_ex_separate (x : Float) :
+  ∃ x', round beta (FLT_exp emin prec) (Znearest choice) x' = 
+    round beta (FLT_exp emin prec) (Znearest choice) x ∧
+    (∃ eta, Float.abs eta ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ∧ x' = x + eta) ∧
+    (∃ eps, Float.abs eps ≤ u_ro beta prec / (1 + u_ro beta prec) ∧
+      round beta (FLT_exp emin prec) (Znearest choice) x' = x' * (1 + eps)) := by
+  sorry
+
+/-- General FLT error nearest -/
+theorem error_N_FLT (emin prec : Int) (h_pos : 0 < prec) (choice : Int → Bool) (x : Float) :
+  ∃ eps eta, Float.abs eps ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs (-prec + 1) : Nat) ∧
+    Float.abs eta ≤ (1/2) * (Int.natAbs beta : Float) ^ (Int.natAbs emin : Nat) ∧
+    eps * eta = 0 ∧
+    round beta (FLT_exp emin prec) (Znearest choice) x = x * (1 + eps) + eta := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Prop/Round_odd.lean b/FloatSpec/src/Prop/Round_odd.lean
index 1003466..feaccb7 100644
--- a/FloatSpec/src/Prop/Round_odd.lean
+++ b/FloatSpec/src/Prop/Round_odd.lean
@@ -2,13 +2,16 @@
 -- Translated from Coq file: flocq/src/Prop/Round_odd.v
 
 import FloatSpec.src.Core
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 variable (fexp : Int → Int)
 variable [Valid_exp fexp]
 
 /-- Round to odd rounding mode -/
-def Zodd : Float → Int := fun x =>
+def Zodd : ℝ → Int := fun x =>
   let n := Ztrunc x in
   if n % 2 = 0 then
     if x = n then n else n + 1
@@ -18,20 +21,20 @@ def Zodd : Float → Int := fun x =>
 instance : Valid_rnd (Zodd) := by sorry
 
 /-- Round to odd properties -/
-theorem round_odd_ge_ulp (x : Float) :
+theorem round_odd_ge_ulp (x : ℝ) :
   generic_format beta fexp x ∨ 
-  ulp beta fexp x ≤ Float.abs (round beta fexp Zodd x - x) := by
+  ulp beta fexp x ≤ |round beta fexp Zodd x - x| := by
   sorry
 
 /-- Round to odd for double rounding -/
 theorem round_odd_double_round (fexp1 fexp2 : Int → Int) [Valid_exp fexp1] [Valid_exp fexp2]
-  (choice : Int → Bool) (x : Float)
+  (choice : Int → Bool) (x : ℝ)
   (h_precision : ∀ e, fexp2 e ≤ fexp1 e) :
   round beta fexp2 (Znearest choice) (round beta fexp1 Zodd x) = 
   round beta fexp2 (Znearest choice) x := by
   sorry
 
 /-- Round to odd maintains format when appropriate -/
-theorem generic_format_round_odd (x : Float) :
+theorem generic_format_round_odd (x : ℝ) :
   generic_format beta fexp (round beta fexp Zodd x) := by
   sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Prop/Round_odd.lean.bak b/FloatSpec/src/Prop/Round_odd.lean.bak
new file mode 100644
index 0000000..1003466
--- /dev/null
+++ b/FloatSpec/src/Prop/Round_odd.lean.bak
@@ -0,0 +1,37 @@
+-- Round to odd properties
+-- Translated from Coq file: flocq/src/Prop/Round_odd.v
+
+import FloatSpec.src.Core
+
+variable (beta : Int)
+variable (fexp : Int → Int)
+variable [Valid_exp fexp]
+
+/-- Round to odd rounding mode -/
+def Zodd : Float → Int := fun x =>
+  let n := Ztrunc x in
+  if n % 2 = 0 then
+    if x = n then n else n + 1
+  else n
+
+/-- Round to odd is a valid rounding -/
+instance : Valid_rnd (Zodd) := by sorry
+
+/-- Round to odd properties -/
+theorem round_odd_ge_ulp (x : Float) :
+  generic_format beta fexp x ∨ 
+  ulp beta fexp x ≤ Float.abs (round beta fexp Zodd x - x) := by
+  sorry
+
+/-- Round to odd for double rounding -/
+theorem round_odd_double_round (fexp1 fexp2 : Int → Int) [Valid_exp fexp1] [Valid_exp fexp2]
+  (choice : Int → Bool) (x : Float)
+  (h_precision : ∀ e, fexp2 e ≤ fexp1 e) :
+  round beta fexp2 (Znearest choice) (round beta fexp1 Zodd x) = 
+  round beta fexp2 (Znearest choice) x := by
+  sorry
+
+/-- Round to odd maintains format when appropriate -/
+theorem generic_format_round_odd (x : Float) :
+  generic_format beta fexp (round beta fexp Zodd x) := by
+  sorry
\ No newline at end of file
diff --git a/FloatSpec/src/Prop/Sterbenz.lean b/FloatSpec/src/Prop/Sterbenz.lean
index b0dfdcb..38cbaf1 100644
--- a/FloatSpec/src/Prop/Sterbenz.lean
+++ b/FloatSpec/src/Prop/Sterbenz.lean
@@ -2,6 +2,9 @@
 -- Translated from Coq file: flocq/src/Prop/Sterbenz.v
 
 import FloatSpec.src.Core
+import Mathlib.Data.Real.Basic
+
+open Real
 
 variable (beta : Int)
 variable (fexp : Int → Int)
@@ -9,28 +12,28 @@ variable [Valid_exp fexp]
 variable [Monotone_exp fexp]
 
 /-- Generic format plus exact under magnitude condition -/
-theorem generic_format_plus (x y : Float)
+theorem generic_format_plus (x y : ℝ)
   (hx : generic_format beta fexp x) (hy : generic_format beta fexp y) 
-  (h_bound : Float.abs (x + y) ≤ (Int.natAbs beta : Float) ^ (Int.natAbs (min (mag beta x) (mag beta y)) : Nat)) :
+  (h_bound : |x + y| ≤ (Int.natAbs beta : ℝ) ^ (Int.natAbs (min (mag beta x) (mag beta y)) : Nat)) :
   generic_format beta fexp (x + y) := by
   sorry
 
 /-- Generic format plus weak condition -/
-theorem generic_format_plus_weak (x y : Float)
+theorem generic_format_plus_weak (x y : ℝ)
   (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
-  (h_bound : Float.abs (x + y) ≤ min (Float.abs x) (Float.abs y)) :
+  (h_bound : |x + y| ≤ min (|x|) (|y|)) :
   generic_format beta fexp (x + y) := by
   sorry
 
 /-- Sterbenz auxiliary lemma -/
-lemma sterbenz_aux (x y : Float)
+lemma sterbenz_aux (x y : ℝ)
   (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
   (h_bound : y ≤ x ∧ x ≤ 2 * y) :
   generic_format beta fexp (x - y) := by
   sorry
 
 /-- Sterbenz theorem for exact subtraction -/
-theorem sterbenz (x y : Float)
+theorem sterbenz (x y : ℝ)
   (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
   (h_bound : y / 2 ≤ x ∧ x ≤ 2 * y) :
   generic_format beta fexp (x - y) := by
diff --git a/FloatSpec/src/Prop/Sterbenz.lean.bak b/FloatSpec/src/Prop/Sterbenz.lean.bak
new file mode 100644
index 0000000..b0dfdcb
--- /dev/null
+++ b/FloatSpec/src/Prop/Sterbenz.lean.bak
@@ -0,0 +1,37 @@
+-- Sterbenz conditions for exact subtraction
+-- Translated from Coq file: flocq/src/Prop/Sterbenz.v
+
+import FloatSpec.src.Core
+
+variable (beta : Int)
+variable (fexp : Int → Int)
+variable [Valid_exp fexp]
+variable [Monotone_exp fexp]
+
+/-- Generic format plus exact under magnitude condition -/
+theorem generic_format_plus (x y : Float)
+  (hx : generic_format beta fexp x) (hy : generic_format beta fexp y) 
+  (h_bound : Float.abs (x + y) ≤ (Int.natAbs beta : Float) ^ (Int.natAbs (min (mag beta x) (mag beta y)) : Nat)) :
+  generic_format beta fexp (x + y) := by
+  sorry
+
+/-- Generic format plus weak condition -/
+theorem generic_format_plus_weak (x y : Float)
+  (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
+  (h_bound : Float.abs (x + y) ≤ min (Float.abs x) (Float.abs y)) :
+  generic_format beta fexp (x + y) := by
+  sorry
+
+/-- Sterbenz auxiliary lemma -/
+lemma sterbenz_aux (x y : Float)
+  (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
+  (h_bound : y ≤ x ∧ x ≤ 2 * y) :
+  generic_format beta fexp (x - y) := by
+  sorry
+
+/-- Sterbenz theorem for exact subtraction -/
+theorem sterbenz (x y : Float)
+  (hx : generic_format beta fexp x) (hy : generic_format beta fexp y)
+  (h_bound : y / 2 ≤ x ∧ x ≤ 2 * y) :
+  generic_format beta fexp (x - y) := by
+  sorry
\ No newline at end of file
diff --git a/lake-manifest.json b/lake-manifest.json
index 491e5cd..ab941e7 100644
--- a/lake-manifest.json
+++ b/lake-manifest.json
@@ -1,55 +1,95 @@
 {"version": "1.1.0",
  "packagesDir": ".lake/packages",
  "packages":
- [{"url": "https://github.com/leanprover-community/quote4",
+ [{"url": "https://github.com/leanprover-community/mathlib4",
    "type": "git",
    "subDir": null,
    "scope": "",
-   "rev": "d6afe6744246a799a3564dc84a878dab0c4a56d8",
-   "name": "Qq",
+   "rev": "482cd79248864e7a4785a012880d0066a196e5d3",
+   "name": "mathlib",
    "manifestFile": "lake-manifest.json",
-   "inputRev": "master",
+   "inputRev": null,
    "inherited": false,
+   "configFile": "lakefile.lean"},
+  {"url": "https://github.com/leanprover-community/plausible",
+   "type": "git",
+   "subDir": null,
+   "scope": "leanprover-community",
+   "rev": "c37191eba2da78393070da8c4367689d8c4276e4",
+   "name": "plausible",
+   "manifestFile": "lake-manifest.json",
+   "inputRev": "main",
+   "inherited": true,
    "configFile": "lakefile.toml"},
-  {"url": "https://github.com/leanprover-community/batteries",
+  {"url": "https://github.com/leanprover-community/LeanSearchClient",
    "type": "git",
    "subDir": null,
-   "scope": "",
-   "rev": "43d0460740bbb8999c0e07cd4ea878677be92989",
-   "name": "batteries",
+   "scope": "leanprover-community",
+   "rev": "6c62474116f525d2814f0157bb468bf3a4f9f120",
+   "name": "LeanSearchClient",
    "manifestFile": "lake-manifest.json",
    "inputRev": "main",
-   "inherited": false,
+   "inherited": true,
    "configFile": "lakefile.toml"},
-  {"url": "https://github.com/leanprover/verso",
+  {"url": "https://github.com/leanprover-community/import-graph",
    "type": "git",
    "subDir": null,
-   "scope": "",
-   "rev": "0ce8d9701aaf4fc76ca790a8bfc0b01067bcf476",
-   "name": "verso",
+   "scope": "leanprover-community",
+   "rev": "4241928fd3ebae83a037a253e39d9b773e34c3b4",
+   "name": "importGraph",
    "manifestFile": "lake-manifest.json",
    "inputRev": "main",
-   "inherited": false,
+   "inherited": true,
+   "configFile": "lakefile.toml"},
+  {"url": "https://github.com/leanprover-community/ProofWidgets4",
+   "type": "git",
+   "subDir": null,
+   "scope": "leanprover-community",
+   "rev": "96c67159f161fb6bf6ce91a2587232034ac33d7e",
+   "name": "proofwidgets",
+   "manifestFile": "lake-manifest.json",
+   "inputRev": "v0.0.67",
+   "inherited": true,
    "configFile": "lakefile.lean"},
-  {"url": "https://github.com/acmepjz/md4lean",
+  {"url": "https://github.com/leanprover-community/aesop",
    "type": "git",
    "subDir": null,
-   "scope": "",
-   "rev": "b16338c5c66f57ef5510d4334eb6fa4e2c6c8cd8",
-   "name": "MD4Lean",
+   "scope": "leanprover-community",
+   "rev": "0a136f764a5dfedc4498e93ad8e297cff57ba2fc",
+   "name": "aesop",
+   "manifestFile": "lake-manifest.json",
+   "inputRev": "master",
+   "inherited": true,
+   "configFile": "lakefile.toml"},
+  {"url": "https://github.com/leanprover-community/quote4",
+   "type": "git",
+   "subDir": null,
+   "scope": "leanprover-community",
+   "rev": "1ef3dac0f872ca6aaa7d02e015427e06dd0b6195",
+   "name": "Qq",
+   "manifestFile": "lake-manifest.json",
+   "inputRev": "master",
+   "inherited": true,
+   "configFile": "lakefile.toml"},
+  {"url": "https://github.com/leanprover-community/batteries",
+   "type": "git",
+   "subDir": null,
+   "scope": "leanprover-community",
+   "rev": "c4277d9bca1c4d366ae1d976175ff6c008e56ac2",
+   "name": "batteries",
    "manifestFile": "lake-manifest.json",
    "inputRev": "main",
    "inherited": true,
-   "configFile": "lakefile.lean"},
-  {"url": "https://github.com/leanprover/subverso",
+   "configFile": "lakefile.toml"},
+  {"url": "https://github.com/leanprover/lean4-cli",
    "type": "git",
    "subDir": null,
-   "scope": "",
-   "rev": "79c973b07e2f43c4ac1cec720bbe20b4fbfbd0e9",
-   "name": "subverso",
+   "scope": "leanprover",
+   "rev": "c682c91d2d4dd59a7187e2ab977ac25bd1f87329",
+   "name": "Cli",
    "manifestFile": "lake-manifest.json",
    "inputRev": "main",
    "inherited": true,
-   "configFile": "lakefile.lean"}],
+   "configFile": "lakefile.toml"}],
  "name": "FloatSpec",
  "lakeDir": ".lake"}
diff --git a/lakefile.lean b/lakefile.lean
index 5e82409..e869fa7 100644
--- a/lakefile.lean
+++ b/lakefile.lean
@@ -30,7 +30,7 @@ package FloatSpec where
 
 -- Used for math library
 -- COMMENTED OUT FOR SPEED: mathlib takes too long to build initially
--- require mathlib from git "https://github.com/leanprover-community/mathlib4"
+require mathlib from git "https://github.com/leanprover-community/mathlib4"
 
 /-- Main library -/
 @[default_target]
diff --git a/lean-toolchain b/lean-toolchain
index 24df1cc..2c6e1c4 100644
--- a/lean-toolchain
+++ b/lean-toolchain
@@ -1 +1 @@
-leanprover/lean4-nightly:nightly-2025-07-19
+leanprover/lean4:v4.22.0-rc4
