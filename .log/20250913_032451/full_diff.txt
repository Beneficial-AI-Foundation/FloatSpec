Full diff (HEAD):
commit 569cc15dd9a0f3bb0bbf6e2e2f96891a3db1b042
Author: Lord-Van <2200017789@stu.pku.edu.cn>
Date:   Sat Sep 13 10:54:27 2025 +0800

    Core/Round_generic: complete scaled_mantissa_lt_bpow proof; update CLAUDE.md with MCP/LSP workflow and proof guidelines

diff --git a/CLAUDE.md b/CLAUDE.md
index 02bb7ac..27ae8f3 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -59,7 +59,9 @@ This provides a searchable history of all significant changes to the codebase.
   - 54 files changed across entire codebase
   - See `.log/20250808_102956/` for details
 
-Use `uvx lean-lsp-mcp` to get feedback on your code. Usage:
+Use `uvx lean-lsp-mcp` to get feedback on your code (primary workflow). Prefer these tools for fast, local diagnostics after every change; use `lake build` for broader checks or when you need a full project build.
+
+Usage:
 
 - `lean_diagnostic_messages`: Get all diagnostic messages for a Lean file. This includes infos, warnings and errors.
 
@@ -149,13 +151,62 @@ just build        # Build Lean project
 just test         # Run Python tests
 
 # Or use direct commands:
-lake build        # Local Lean build (primary workflow)
+lake build        # Full Lean build (slower; use as a cross-check)
 uv run -m pytest -q  # Run tests directly
 
 # Check Lean syntax and types
 lake build --verbose
 ```
 
+## Proof Writing Playbook
+
+- One-by-one: Write exactly one proof, run LSP diagnostics immediately (via `lean_lsp_mcp`), fix issues, then move on. Do not batch multiple new proofs without checking.
+- Follow examples: Mirror patterns from existing proofs, especially `Zfast_div_eucl_spec` in `FloatSpec/src/Core/Zaux.lean` and nearby lemmas in the same file you are editing.
+- Before each proof:
+  - Verify the function body is correct and stable.
+  - Check existing specs to understand precisely what needs to be proven.
+  - Preserve specification/Hoare triple syntax; avoid changing it unless absolutely necessary. If change is unavoidable, decompose the spec into simpler lemmas rather than rewriting wholesale.
+- Compilation verification:
+  - After every proof, run `lean_lsp_mcp.lean_diagnostic_messages` for the edited file.
+  - Use `lake build` as a fallback or for a project-wide typecheck.
+  - “Complete” means: no `sorry` in the edited proof and the file typechecks.
+- When stuck:
+  - Search for relevant lemmas with MCP hover/decl tools or Mathlib; if a lemma doesn’t exist, write a small private helper lemma close to the proof.
+  - Decompose complex statements into smaller, local lemmas.
+  - Reference nearby proofs for patterns and naming.
+
+## Practical Lean Tips (FloatSpec)
+
+- Magnitude and logs:
+  - `mag` is defined with `Int.ceil (log (|x|)/log β)`. To get `|x| ≤ β^e`, sandwich `L := log|x|/logβ` and use `Real.log_le_iff_le_exp` plus `Real.log_zpow`.
+  - Keep a clean chain: derive `log |x| ≤ log (β^e)`, then exponentiate; avoid brittle simp rewrites between `exp (e*log β)` and `β^e`—prove equality explicitly using `Real.exp_log` and `Real.log_zpow`.
+- Powers and positivity:
+  - Use `zpow_pos : 0 < a → 0 < a^n` and `abs_of_nonneg` for `a^n` when the base is positive.
+  - Collapse products with `FloatSpec.Core.Generic_fmt.zpow_mul_sub` and reconstruct with `zpow_add₀` or `zpow_sub_add` (requires nonzero base).
+  - For nonnegative exponent `k ≥ 0`, switch to Nat powers via `zpow_nonneg_toNat`.
+- Absolute values with scaling factors:
+  - Prefer `abs (x * y) = |x| * |y|` and ensure `y ≥ 0` so `|y| = y`.
+  - When the scale is `β^(-c)`, consider rewriting as `((β^c)⁻¹)` and use `inv_nonneg.mpr (le_of_lt (zpow_pos …))` to keep monotonicity simple.
+- Integer truncation:
+  - Use `Ztrunc_intCast` and `Ztrunc_zero` to compute truncations on integer-valued expressions.
+- Calc blocks over heavy simp:
+  - Prefer explicit `calc`/`have` chains with named lemmas instead of relying on `simp` to bridge nondefinitional equalities (especially around `log/exp`, `zpow`, and `abs`).
+
+## Plan + Preambles (for AI agents)
+
+- Maintain a short, evolving plan (use the `update_plan` tool) with exactly one `in_progress` step.
+- Before grouped tool calls, write a concise 1–2 sentence preamble explaining what you are about to do.
+- Share progress updates after nontrivial steps, and re-align the plan if scope changes.
+
+## Quality Bar
+
+- 30-second reality check: After each change, be able to answer “yes” to all:
+  - Did I run/build the code (via MCP or `lake build`)?
+  - Did I trigger the exact feature I changed?
+  - Did I see expected results, and check for errors?
+  - Would I bet $100 it works?
+- Phrases to avoid: “should work”, “fixed the issue” (without verification), “try it now” (without running it yourself).
+
 ## FloatSpec Roadmap
 
 ### 1. Float Representation and Core Operations
@@ -451,4 +502,4 @@ auto-update-stale = true    # Auto-update stale working copies when switching co
 - [Lean 3 code](https://github.com/nielsvoss/lean-pitfalls#lean-3-code)
 - [Non-terminal simp](https://github.com/nielsvoss/lean-pitfalls#non-terminal-simp)
 - [Ignoring warnings](https://github.com/nielsvoss/lean-pitfalls#ignoring-warnings)
-- [Ambiguous unicode characters](https://github.com/nielsvoss/lean-pitfalls#ambiguous-unicode-characters)
\ No newline at end of file
+- [Ambiguous unicode characters](https://github.com/nielsvoss/lean-pitfalls#ambiguous-unicode-characters)
diff --git a/FloatSpec/src/Core/Round_generic.lean b/FloatSpec/src/Core/Round_generic.lean
index fc26655..ed5569e 100644
--- a/FloatSpec/src/Core/Round_generic.lean
+++ b/FloatSpec/src/Core/Round_generic.lean
@@ -26,6 +26,7 @@ import FloatSpec.src.Core.Round_pred
 import FloatSpec.src.Core.Float_prop
 import FloatSpec.src.Core.Generic_fmt
 import Mathlib.Data.Real.Basic
+import Mathlib.Analysis.SpecialFunctions.Log.Basic
 import Std.Do.Triple
 import Std.Tactic.Do
 
@@ -46,23 +47,114 @@ namespace FloatSpec.Core.Round_generic
 -/
 theorem generic_format_bpow
     (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (e : Int) :
-    ⦃⌜fexp (e + 1) ≤ e⌝⦄
+    ⦃⌜beta > 1 ∧ fexp (e + 1) ≤ e⌝⦄
     generic_format beta fexp ((beta : ℝ) ^ e)
     ⦃⇓result => ⌜result⌝⦄ := by
-  intro hle
-  unfold generic_format scaled_mantissa cexp F2R
-  simp
-  sorry -- TODO: This requires properties of mag and logarithms that aren't yet proven
+  intro hpre
+  rcases hpre with ⟨hβ, hle⟩
+  -- Base positivity and nonzeroness facts
+  have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ
+  have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ
+  have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR
+
+  -- Compute mag on a pure power: with our definition using ceil(log_/log), this evaluates to e
+  have hmag_pow : mag beta ((beta : ℝ) ^ e) = e := by
+    -- positivity and logs
+    have hxpos : 0 < (beta : ℝ) ^ e := zpow_pos (by exact_mod_cast hbposℤ) _
+    have hlt : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ
+    -- show log β ≠ 0 via exp_log and β ≠ 1
+    have hlogβ_ne : Real.log (beta : ℝ) ≠ 0 := by
+      intro h0
+      have hbpos' : 0 < (beta : ℝ) := hbposR
+      have h0exp : Real.exp (Real.log (beta : ℝ)) = Real.exp 0 := congrArg Real.exp h0
+      have : (beta : ℝ) = 1 := by simpa [Real.exp_log hbpos', Real.exp_zero] using h0exp
+      have hβne1 : (beta : ℝ) ≠ 1 := by exact_mod_cast (ne_of_gt hβ)
+      exact hβne1 this
+    have hlog_zpow : Real.log ((beta : ℝ) ^ e) = (e : ℝ) * Real.log (beta : ℝ) := by
+      simpa using Real.log_zpow hbposR _
+    have hratio : Real.log ((beta : ℝ) ^ e) / Real.log (beta : ℝ) = (e : ℝ) := by
+      have : ((e : ℝ) * Real.log (beta : ℝ)) / Real.log (beta : ℝ) = (e : ℝ) :=
+        mul_div_cancel_right₀ (e : ℝ) hlogβ_ne
+      simpa [hlog_zpow] using this
+    have habs : abs ((beta : ℝ) ^ e) = (beta : ℝ) ^ e := by
+      exact abs_of_nonneg (le_of_lt hxpos)
+    -- expand definition of mag and evaluate ceil
+    unfold mag
+    have hxne : (beta : ℝ) ^ e ≠ 0 := ne_of_gt hxpos
+    -- Reduce to ceil of a simplified ratio
+    simp only [hxne, habs, hlog_zpow]
+    have : ((e : ℝ) * Real.log (beta : ℝ)) / Real.log (beta : ℝ) = (e : ℝ) := by
+      have : (Real.log (beta : ℝ) * (e : ℝ)) / Real.log (beta : ℝ) = (e : ℝ) :=
+        mul_div_cancel_left₀ (e : ℝ) hlogβ_ne
+      simpa [mul_comm] using this
+    simpa [this, Int.ceil_intCast]
+
+  -- From the valid_exp structure and the bound at e+1, deduce fexp e ≤ e
+  have hlt_e1 : fexp (e + 1) < (e + 1) := lt_of_le_of_lt hle (lt_add_of_pos_right _ Int.zero_lt_one)
+  have hfe_le : fexp e ≤ e := by
+    -- Use valid_exp_large' with k = e+1 and l = e to get fexp e < e+1
+    have := FloatSpec.Core.Generic_fmt.valid_exp_large' (beta := beta) (fexp := fexp) (k := e + 1) (l := e) hlt_e1 (le_of_lt (lt_add_of_pos_right _ Int.zero_lt_one))
+    exact Int.lt_add_one_iff.mp this
+
+  -- Unfold goal and carry out the algebra, mirroring generic_format_F2R with m = 1
+  simp [generic_format, scaled_mantissa, cexp, F2R]
+  -- Notation: cexp for x = β^e
+  set c := fexp (mag beta ((beta : ℝ) ^ e)) with hc
+  -- Use hmag_pow to rewrite c
+  have hc' : c = fexp e := by simpa [hc, hmag_pow]
+  -- With c ≤ e, we can express the scaled mantissa as an integer power
+  have hcle : c ≤ e := by simpa [hc'] using hfe_le
+  -- Key zpow identities
+  have hinv : (beta : ℝ) ^ (-c) = ((beta : ℝ) ^ c)⁻¹ := zpow_neg _ _
+  have hmul_pow : (beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹ = (beta : ℝ) ^ (e - c) := by
+    rw [← hinv, ← zpow_add₀ hbne]
+    simp [sub_eq_add_neg]
+  have hpow_nonneg : 0 ≤ e - c := sub_nonneg.mpr hcle
+  have hzpow_toNat : (beta : ℝ) ^ (e - c) = (beta : ℝ) ^ (Int.toNat (e - c)) := by
+    rw [← Int.toNat_of_nonneg hpow_nonneg]
+    exact zpow_ofNat _ _
+  have hcast_pow : (beta : ℝ) ^ (Int.toNat (e - c)) = ((beta ^ (Int.toNat (e - c)) : Int) : ℝ) := by
+    rw [← Int.cast_pow]
+
+  -- Finish by showing the reconstruction equality
+  simp only [hc, hmag_pow]
+  -- Goal now is: (Ztrunc ((β^e) * (β^c)⁻¹) : ℝ) * (β : ℝ) ^ c = (β : ℝ) ^ e
+  -- Compute the truncation explicitly
+  have htrunc : Ztrunc ((beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹) = beta ^ (Int.toNat (e - c)) := by
+    calc
+      Ztrunc ((beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹)
+          = Ztrunc ((beta : ℝ) ^ (e - c)) := by rw [hmul_pow]
+      _   = Ztrunc ((beta : ℝ) ^ (Int.toNat (e - c))) := by rw [hzpow_toNat]
+      _   = Ztrunc (((beta ^ (Int.toNat (e - c)) : Int) : ℝ)) := by rw [hcast_pow]
+      _   = beta ^ (Int.toNat (e - c)) := FloatSpec.Core.Generic_fmt.Ztrunc_intCast _
+
+  -- Power splitting lemma to reconstruct
+  have hsplit : (beta : ℝ) ^ e = (beta : ℝ) ^ (e - c) * (beta : ℝ) ^ c := by
+    rw [← zpow_add₀ hbne (e - c) c]
+    simp [sub_add_cancel]
+
+  -- Conclude the equality (flip orientation to match calc direction)
+  symm
+  calc
+    ((Ztrunc ((beta : ℝ) ^ e * ((beta : ℝ) ^ (fexp e))⁻¹) : Int) : ℝ) * (beta : ℝ) ^ (fexp e)
+        = ((Ztrunc ((beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹) : Int) : ℝ) * (beta : ℝ) ^ c := by
+              rw [hc']
+    _   = ((beta ^ (Int.toNat (e - c)) : Int) : ℝ) * (beta : ℝ) ^ c := by rw [htrunc]
+    _   = (beta : ℝ) ^ (e - c) * (beta : ℝ) ^ c := by
+          -- rewrite Int power as real power for nonnegative exponent
+          rw [hzpow_toNat, hcast_pow]
+    _   = (beta : ℝ) ^ e := by rw [hsplit]
 
 /-- Specification: Alternative power condition
 
     When fexp e ≤ e, beta^e is in generic format.
 -/
 theorem generic_format_bpow' (beta : Int) (fexp : Int → Int) [Valid_exp beta fexp] (e : Int) :
-    ⦃⌜fexp e ≤ e⌝⦄
+    ⦃⌜beta > 1 ∧ fexp e ≤ e⌝⦄
     generic_format beta fexp ((beta : ℝ) ^ e)
     ⦃⇓result => ⌜result⌝⦄ := by
-  intro hle
+  intro hpre
+  rcases hpre with ⟨hβ, hle⟩
   -- From Valid_exp, we can derive the required bound fexp (e+1) ≤ e
   -- by case-splitting on whether fexp e < e or e ≤ fexp e.
   have hpair := (Valid_exp.valid_exp (beta := beta) (fexp := fexp) e)
@@ -70,7 +162,7 @@ theorem generic_format_bpow' (beta : Int) (fexp : Int → Int) [Valid_exp beta f
   · -- Large regime: directly get fexp (e+1) ≤ e
     have hbound : fexp (e + 1) ≤ e := (hpair.left) hlt
     -- Apply the power-in-format lemma with this bound
-    exact (generic_format_bpow (beta := beta) (fexp := fexp) e) hbound
+    exact (generic_format_bpow (beta := beta) (fexp := fexp) e) ⟨hβ, hbound⟩
   · -- Otherwise, we have e ≤ fexp e
     have hge : e ≤ fexp e := le_of_not_gt hlt
     -- Combined with the hypothesis fexp e ≤ e, we get equality
@@ -80,7 +172,7 @@ theorem generic_format_bpow' (beta : Int) (fexp : Int → Int) [Valid_exp beta f
     have hbound' : fexp (e + 1) ≤ e := by
       simpa [heq, add_comm, add_left_comm, add_assoc] using hsmall.left
     -- Apply the power-in-format lemma with the derived bound
-    exact (generic_format_bpow (beta := beta) (fexp := fexp) e) hbound'
+    exact (generic_format_bpow (beta := beta) (fexp := fexp) e) ⟨hβ, hbound'⟩
 
 /-- Specification: Scaled mantissa for generic format
 
@@ -94,40 +186,126 @@ theorem scaled_mantissa_generic (beta : Int) (fexp : Int → Int) [Valid_exp bet
   intro hx
   unfold scaled_mantissa cexp
   simp
-  -- From hx: x is in generic format
-  -- This means x = F2R of some float with integer mantissa
+  -- Turn the generic_format hypothesis into the reconstruction equality
   unfold generic_format at hx
-  simp at hx
-  -- hx says x = (Ztrunc (scaled_mantissa...)) * beta^(cexp...)
-  -- So scaled_mantissa already equals its truncation
-  sorry -- TODO: Need to unpack the generic_format definition more carefully
+  simp [scaled_mantissa, cexp, F2R] at hx
+  -- Notation: e is the canonical exponent, m the scaled mantissa
+  set e := fexp (mag beta x)
+  set m := x * (beta : ℝ) ^ (-e) with hm
+  have hx' : x = ((Ztrunc m : Int) : ℝ) * (beta : ℝ) ^ e := by simpa [e, m] using hx
+  -- We need to prove: m = Ztrunc m (with coercion on the right)
+  by_cases hpow : (beta : ℝ) ^ e = 0
+  · -- Degenerate base power: then x = 0 and hence m = 0, so equality holds
+    have hx0 : x = 0 := by simpa [hpow] using hx'
+    have hm0 : m = 0 := by simp [m, hx0]
+    simp [hx0, FloatSpec.Core.Generic_fmt.Ztrunc_zero]
+  · -- Nonzero base power: cancel to show m equals its truncation
+    have hpow_ne : (beta : ℝ) ^ e ≠ 0 := hpow
+    -- Multiply the reconstruction by β^(-e) and simplify using hpow_ne
+    have hmul := congrArg (fun t : ℝ => t * (beta : ℝ) ^ (-e)) hx'
+    -- Left side becomes m; right side reduces to (Ztrunc m : ℝ)
+    have hmain : m = (Ztrunc m : ℝ) := by
+      simpa [m, mul_comm, mul_left_comm, mul_assoc, zpow_neg, hpow_ne]
+        using hmul
+    simpa [m] using hmain
 
 /-- Specification: Canonical exponent from bounds
 
     When x is bounded by powers of beta, cexp(x) = fexp(ex).
 -/
 theorem cexp_fexp (beta : Int) (fexp : Int → Int) (x : ℝ) (ex : Int) :
-    ⦃⌜(beta : ℝ) ^ (ex - 1) ≤ abs x ∧ abs x < (beta : ℝ) ^ ex⌝⦄
+    ⦃⌜beta > 1 ∧ (beta : ℝ) ^ (ex - 1) < abs x ∧ abs x ≤ (beta : ℝ) ^ ex⌝⦄
     cexp beta fexp x
     ⦃⇓result => ⌜result = fexp ex⌝⦄ := by
   intro h
+  rcases h with ⟨hβ, hlow, hupp⟩
+  -- It suffices to show mag beta x = ex
+  have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ
+  have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ
+  have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR
+  -- From the strict lower bound, |x| > 0 hence x ≠ 0
+  have hxpos : 0 < abs x := lt_trans (zpow_pos (by exact_mod_cast hbposℤ) _) hlow
+  have hx0 : x ≠ 0 := by
+    have : abs x ≠ 0 := ne_of_gt hxpos
+    exact fun hx => this (by simpa [hx, abs_zero])
+  -- Unfold mag and set L = log(|x|)/log(beta)
+  -- Prepare an explicit form for mag
+  have hmageq : mag beta x = Int.ceil (Real.log (abs x) / Real.log (beta : ℝ)) := by
+    unfold mag
+    simp [hx0]
+  set L : ℝ := Real.log (abs x) / Real.log (beta : ℝ) with hLdef
+  -- Show Int.ceil L = ex by sandwiching L between ex-1 and ex
+  -- Upper bound: L ≤ ex
+  -- log β > 0 since 1 < β
+  have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ
+  have hlogβ_pos : 0 < Real.log (beta : ℝ) := by
+    have : 0 < Real.log (beta : ℝ) ↔ 1 < (beta : ℝ) :=
+      Real.log_pos_iff (x := (beta : ℝ)) (le_of_lt (by exact_mod_cast hbposℤ))
+    exact this.mpr hb_gt1R
+  have hlog_le : Real.log (abs x) ≤ Real.log ((beta : ℝ) ^ ex) :=
+    Real.log_le_log hxpos hupp
+  have hlog_zpow_ex : Real.log ((beta : ℝ) ^ ex) = (ex : ℝ) * Real.log (beta : ℝ) := by
+    simpa using Real.log_zpow hbposR ex
+  have hL_mul : L * Real.log (beta : ℝ) = Real.log (abs x) := by
+    have hne : Real.log (beta : ℝ) ≠ 0 := ne_of_gt hlogβ_pos
+    calc
+      L * Real.log (beta : ℝ)
+          = (Real.log (abs x) / Real.log (beta : ℝ)) * Real.log (beta : ℝ) := by simpa [hLdef]
+      _   = Real.log (abs x) * Real.log (beta : ℝ) / Real.log (beta : ℝ) := by
+            simpa [div_mul_eq_mul_div]
+      _   = Real.log (abs x) := by
+            simpa [hne] using (mul_div_cancel' (Real.log (abs x)) (Real.log (beta : ℝ)))
+  have hL_le_ex : L ≤ (ex : ℝ) := by
+    have hmul_le : L * Real.log (beta : ℝ) ≤ (ex : ℝ) * Real.log (beta : ℝ) := by
+      simpa [hL_mul, hlog_zpow_ex] using hlog_le
+    exact (le_of_mul_le_mul_right hmul_le hlogβ_pos)
+  have hceil_le : Int.ceil L ≤ ex := Int.ceil_le.mpr hL_le_ex
+  -- Lower bound: ex - 1 < L
+  have hlog_lt : Real.log ((beta : ℝ) ^ (ex - 1)) < Real.log (abs x) :=
+    Real.log_lt_log (zpow_pos (by exact_mod_cast hbposℤ) _) hlow
+  have hlog_zpow_exm1 : Real.log ((beta : ℝ) ^ (ex - 1)) = (ex - 1 : ℝ) * Real.log (beta : ℝ) := by
+    simpa using Real.log_zpow hbposR (ex - 1)
+  have hexm1_lt_L : (ex - 1 : ℝ) < L := by
+    have hmul_lt : (ex - 1 : ℝ) * Real.log (beta : ℝ) < L * Real.log (beta : ℝ) := by
+      simpa [hL_mul, hlog_zpow_exm1] using hlog_lt
+    exact (lt_of_mul_lt_mul_right hmul_lt (le_of_lt hlogβ_pos))
+  -- Conclude Int.ceil L = ex: we already have Int.ceil L ≤ ex; prove the reverse
+  have h_ex_le_ceil : ex ≤ Int.ceil L := by
+    -- By contradiction: if ⌈L⌉ < ex then ⌈L⌉ ≤ ex-1, contradicting ex-1 < L
+    by_contra hnot
+    have hlt : Int.ceil L < ex := lt_of_not_ge hnot
+    have hle_exm1 : Int.ceil L ≤ ex - 1 := by
+      have : Int.ceil L < (ex - 1) + 1 := by simpa [Int.sub_add_cancel] using hlt
+      exact Int.lt_add_one_iff.mp this
+    have : L ≤ (ex - 1 : ℝ) := by
+      simpa [Int.cast_sub, Int.cast_one] using (Int.ceil_le).mp hle_exm1
+    exact (not_le_of_gt hexm1_lt_L) this
+  have hceil_eq : Int.ceil L = ex := le_antisymm hceil_le h_ex_le_ceil
+  -- Conclude by rewriting mag with hmageq and the established equality on the ceiling
+  have hmag_eq_ex : mag beta x = ex := by
+    rw [hmageq, hLdef, hceil_eq]
   unfold cexp
-  simp
-  -- The key is that mag beta x = ex when beta^(ex-1) ≤ |x| < beta^ex
-  -- This is the defining property of mag
-  sorry -- TODO: This requires properties of mag and logarithms
+  simp [hmag_eq_ex]
 
 /-- Specification: Canonical exponent from positive bounds
 
     When positive x is bounded by powers of beta, cexp(x) = fexp(ex).
 -/
 theorem cexp_fexp_pos (beta : Int) (fexp : Int → Int) (x : ℝ) (ex : Int) :
-    ⦃⌜(beta : ℝ) ^ (ex - 1) ≤ x ∧ x < (beta : ℝ) ^ ex⌝⦄
+    ⦃⌜beta > 1 ∧ (beta : ℝ) ^ (ex - 1) < x ∧ x ≤ (beta : ℝ) ^ ex⌝⦄
     cexp beta fexp x
     ⦃⇓result => ⌜result = fexp ex⌝⦄ := by
-  intro _
-  unfold cexp
-  sorry
+  intro h
+  rcases h with ⟨hβ, hlow, hupp⟩
+  -- From beta > 1, powers are positive; with strict lower bound, x > 0
+  have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ
+  have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ
+  have hxpos : 0 < x := lt_trans (zpow_pos (by exact_mod_cast hbposℤ) _) hlow
+  have habs : abs x = x := abs_of_nonneg (le_of_lt hxpos)
+  -- Reduce to the absolute-value version
+  exact
+    (cexp_fexp (beta := beta) (fexp := fexp) (x := x) (ex := ex))
+      ⟨hβ, by simpa [habs] using hlow, by simpa [habs] using hupp⟩
 
 /-- Specification: Mantissa for small positive numbers
 
@@ -136,27 +314,267 @@ theorem cexp_fexp_pos (beta : Int) (fexp : Int → Int) (x : ℝ) (ex : Int) :
 -/
 theorem mantissa_small_pos (beta : Int) (fexp : Int → Int) (x : ℝ) (ex : Int)
     (hx : (beta : ℝ) ^ (ex - 1) ≤ x ∧ x < (beta : ℝ) ^ ex)
-    (he : ex ≤ fexp ex) :
+    (he : ex ≤ fexp ex) (hβ : 1 < beta) :
     0 < x * (beta : ℝ) ^ (-(fexp ex)) ∧ x * (beta : ℝ) ^ (-(fexp ex)) < 1 := by
-  sorry
+  -- Basic facts about the base
+  have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ
+  have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ
+  have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR
+  have hb_ge1 : (1 : ℝ) ≤ (beta : ℝ) := by
+    have : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ
+    exact this.le
+  -- Split bounds on x
+  rcases hx with ⟨hx_low, hx_high⟩
+  -- x is positive since β^(ex-1) > 0
+  have hpow_pos_exm1 : 0 < (beta : ℝ) ^ (ex - 1) := zpow_pos (by exact_mod_cast hbposℤ) _
+  have hx_pos : 0 < x := lt_of_lt_of_le hpow_pos_exm1 hx_low
+  -- Positivity of the scaling factor
+  have hscale_pos : 0 < (beta : ℝ) ^ (-(fexp ex)) := zpow_pos (by exact_mod_cast hbposℤ) _
+  -- Strict upper bound after scaling by a positive factor
+  have hlt_scaled : x * (beta : ℝ) ^ (-(fexp ex)) <
+      (beta : ℝ) ^ ex * (beta : ℝ) ^ (-(fexp ex)) := by
+    exact (mul_lt_mul_of_pos_right hx_high hscale_pos)
+  -- Collapse the right-hand side product using zpow addition
+  -- A form of the product suitable for simp when inverses appear
+  have hmul_inv : (beta : ℝ) ^ ex * ((beta : ℝ) ^ (fexp ex))⁻¹ = (beta : ℝ) ^ (ex - fexp ex) := by
+    have hmul_pow : (beta : ℝ) ^ ex * (beta : ℝ) ^ (-(fexp ex)) = (beta : ℝ) ^ (ex - fexp ex) := by
+      simpa using (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) hbne ex (fexp ex))
+    simpa [zpow_neg] using hmul_pow
+  have hlt_scaled' : x * (beta : ℝ) ^ (-(fexp ex)) < (beta : ℝ) ^ (ex - fexp ex) := by
+    have h := (mul_lt_mul_of_pos_right hx_high hscale_pos)
+    simpa [hmul_inv, zpow_neg] using h
+  -- Show β^(ex - fexp ex) ≤ 1 using ex ≤ fexp ex and β > 1
+  have hk_nonneg : 0 ≤ fexp ex - ex := sub_nonneg.mpr he
+  -- Convert to Nat exponent on the positive side
+  have hpos_mul : 0 < (beta : ℝ) ^ (fexp ex - ex) := zpow_pos (by exact_mod_cast hbposℤ) _
+  -- Prove 1 ≤ β^(fexp ex - ex) by a small induction on Nat exponents
+  have one_le_pow_nat : ∀ n : Nat, (1 : ℝ) ≤ (beta : ℝ) ^ n := by
+    intro n
+    induction n with
+    | zero => simp
+    | succ n ih =>
+        have hpow_nonneg : 0 ≤ (beta : ℝ) ^ n :=
+          pow_nonneg (le_of_lt (by exact_mod_cast hbposℤ)) n
+        -- 1*1 ≤ (β^n)*β since 1 ≤ β^n and 1 ≤ β
+        have : (1 : ℝ) * 1 ≤ (beta : ℝ) ^ n * (beta : ℝ) := by
+          exact mul_le_mul ih hb_ge1 (by norm_num) hpow_nonneg
+        simpa [pow_succ] using this
+  -- Using Int.toNat to connect zpow with Nat pow on nonnegative exponent
+  have hzpow_toNat : (beta : ℝ) ^ (fexp ex - ex) = (beta : ℝ) ^ (Int.toNat (fexp ex - ex)) := by
+    simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (fexp ex - ex) hk_nonneg
+  have hone_le : (1 : ℝ) ≤ (beta : ℝ) ^ (fexp ex - ex) := by
+    -- rewrite to Nat power and apply the induction lemma
+    simpa [hzpow_toNat] using one_le_pow_nat (Int.toNat (fexp ex - ex))
+  -- From 1 ≤ β^(fexp ex - ex), deduce β^(ex - fexp ex) ≤ 1 by multiplying both sides
+  have hle_one : (beta : ℝ) ^ (ex - fexp ex) ≤ 1 := by
+    -- identity: β^(ex - fexp ex) * β^(fexp ex - ex) = 1
+    have hmul_id : (beta : ℝ) ^ (ex - fexp ex) * (beta : ℝ) ^ (fexp ex - ex) = 1 := by
+      have := (zpow_add₀ hbne (ex - fexp ex) (fexp ex - ex)).symm
+      simpa [sub_add_cancel] using this
+    -- Multiply both sides of 1 ≤ β^(fexp ex - ex) by the nonnegative factor β^(ex - fexp ex)
+    have hfac_nonneg : 0 ≤ (beta : ℝ) ^ (ex - fexp ex) := le_of_lt (zpow_pos (by exact_mod_cast hbposℤ) _)
+    have hmul_le := mul_le_mul_of_nonneg_left hone_le hfac_nonneg
+    -- Now rewrite using hmul_id on the right and simplify the left
+    -- Left: β^(ex - fexp ex) * 1 = β^(ex - fexp ex)
+    -- Right: β^(ex - fexp ex) * β^(fexp ex - ex) = 1
+    simpa [hmul_id, one_mul] using hmul_le
+  -- Combine the strict inequality with the upper bound ≤ 1
+  have hlt_one : x * (beta : ℝ) ^ (-(fexp ex)) < 1 := lt_of_lt_of_le hlt_scaled' hle_one
+  -- Positivity of the scaled mantissa: product of positives
+  have hpos_scaled : 0 < x * (beta : ℝ) ^ (-(fexp ex)) := mul_pos hx_pos hscale_pos
+  exact ⟨hpos_scaled, hlt_one⟩
 
 /-- Specification: Scaled mantissa bound for small numbers
 
     For small numbers with |x| < beta^ex where ex ≤ fexp(ex),
     the absolute value of scaled mantissa is less than 1.
 -/
-theorem scaled_mantissa_lt_1 (beta : Int) (fexp : Int → Int) (x : ℝ) (ex : Int) (hx : abs x < (beta : ℝ) ^ ex)
-    (he : ex ≤ fexp ex) : abs (scaled_mantissa beta fexp x).run < 1 := by
-  sorry
+theorem scaled_mantissa_lt_1
+    (beta : Int) (fexp : Int → Int) [FloatSpec.Core.Generic_fmt.Valid_exp beta fexp]
+    (x : ℝ) (ex : Int)
+    (hx : abs x < (beta : ℝ) ^ ex)
+    (he : ex ≤ fexp ex)
+    (hβ : 1 < beta) :
+    abs (scaled_mantissa beta fexp x).run < 1 := by
+  -- Case split on x = 0
+  by_cases hx0 : x = 0
+  · -- Trivial: scaled mantissa of 0 is 0
+    simp [FloatSpec.Core.Generic_fmt.scaled_mantissa, FloatSpec.Core.Generic_fmt.cexp, hx0]
+  · -- Nonzero case
+    -- Base positivity
+    have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ
+    have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ
+    have hbne : (beta : ℝ) ≠ 0 := ne_of_gt hbposR
+    -- Show mag x ≤ ex from |x| < β^ex
+    have hmag_le_ex : mag beta x ≤ ex := by
+      -- Follow cexp_fexp upper-bound part
+      have hxpos : 0 < abs x := abs_pos.mpr hx0
+      have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ
+      have hlogβ_pos : 0 < Real.log (beta : ℝ) := by
+        have : 0 < Real.log (beta : ℝ) ↔ 1 < (beta : ℝ) :=
+          Real.log_pos_iff (x := (beta : ℝ)) (le_of_lt (by exact_mod_cast hbposℤ))
+        exact this.mpr hb_gt1R
+      have hlog_le : Real.log (abs x) ≤ Real.log ((beta : ℝ) ^ ex) :=
+        Real.log_le_log hxpos (le_of_lt hx)
+      have hlog_zpow_ex : Real.log ((beta : ℝ) ^ ex) = (ex : ℝ) * Real.log (beta : ℝ) := by
+        simpa using Real.log_zpow hbposR ex
+      set L : ℝ := Real.log (abs x) / Real.log (beta : ℝ)
+      have hL_mul : L * Real.log (beta : ℝ) = Real.log (abs x) := by
+        have hne : Real.log (beta : ℝ) ≠ 0 := ne_of_gt hlogβ_pos
+        calc
+          L * Real.log (beta : ℝ)
+              = (Real.log (abs x) / Real.log (beta : ℝ)) * Real.log (beta : ℝ) := by rfl
+          _   = Real.log (abs x) := by simpa [hne] using (mul_div_cancel' (Real.log (abs x)) (Real.log (beta : ℝ)))
+      have hL_le_ex : L ≤ (ex : ℝ) := by
+        have hmul_le : L * Real.log (beta : ℝ) ≤ (ex : ℝ) * Real.log (beta : ℝ) := by
+          simpa [hL_mul, hlog_zpow_ex] using hlog_le
+        exact (le_of_mul_le_mul_right hmul_le hlogβ_pos)
+      have hceil_le : Int.ceil L ≤ ex := Int.ceil_le.mpr hL_le_ex
+      have hmageq : mag beta x = Int.ceil L := by
+        unfold FloatSpec.Core.Generic_fmt.mag
+        simp [hx0, L]
+      simpa [hmageq]
+    -- Small-regime constancy: mag x ≤ ex ≤ fexp ex ⇒ fexp (mag x) = fexp ex
+    have hconst := (FloatSpec.Core.Generic_fmt.Valid_exp.valid_exp (beta := beta) (fexp := fexp) ex).right he |>.right
+    have heq_fexp : fexp (mag beta x) = fexp ex := hconst (mag beta x) (le_trans hmag_le_ex he)
+    -- Now rewrite scaled mantissa using fexp ex
+    have hpos_scale : 0 < (beta : ℝ) ^ (-(fexp ex)) := zpow_pos (by exact_mod_cast hbposℤ) _
+    have hnonneg_scale : 0 ≤ (beta : ℝ) ^ (-(fexp ex)) := le_of_lt hpos_scale
+    have h1sm : (scaled_mantissa beta fexp x).run = x * (beta : ℝ) ^ (-(fexp ex)) := by
+      unfold FloatSpec.Core.Generic_fmt.scaled_mantissa FloatSpec.Core.Generic_fmt.cexp
+      simp [heq_fexp]
+    have hsm_abs : abs (scaled_mantissa beta fexp x).run = abs x * (beta : ℝ) ^ (-(fexp ex)) := by
+      rw [h1sm, abs_mul, abs_of_nonneg hnonneg_scale]
+    -- Multiply the strict bound by a positive factor
+    have hmul_lt : abs x * (beta : ℝ) ^ (-(fexp ex)) < (beta : ℝ) ^ ex * (beta : ℝ) ^ (-(fexp ex)) :=
+      mul_lt_mul_of_pos_right hx hpos_scale
+    -- Combine exponents and bound by 1 using ex ≤ fexp ex
+    have hmul_pow : (beta : ℝ) ^ ex * (beta : ℝ) ^ (-(fexp ex)) = (beta : ℝ) ^ (ex - fexp ex) := by
+      simpa [sub_eq_add_neg] using (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) (hbne := hbne) (e := ex) (c := fexp ex))
+    have hk_nonneg : 0 ≤ fexp ex - ex := sub_nonneg.mpr he
+    -- For β ≥ 1, 1 ≤ β^(fexp ex - ex)
+    have hone_le : (1 : ℝ) ≤ (beta : ℝ) ^ (fexp ex - ex) := by
+      -- rewrite to Nat power and apply induction
+      have hzpow_toNat : (beta : ℝ) ^ (fexp ex - ex) = (beta : ℝ) ^ (Int.toNat (fexp ex - ex)) := by
+        simpa using FloatSpec.Core.Generic_fmt.zpow_nonneg_toNat (beta : ℝ) (fexp ex - ex) hk_nonneg
+      have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ
+      have hb_ge1 : (1 : ℝ) ≤ (beta : ℝ) := hb_gt1R.le
+      -- 1 ≤ β^n for all n
+      have one_le_pow_nat : ∀ n : Nat, (1 : ℝ) ≤ (beta : ℝ) ^ n := by
+        intro n; induction n with
+        | zero => simp
+        | succ n ih =>
+            have hpow_nonneg : 0 ≤ (beta : ℝ) ^ n := pow_nonneg (le_of_lt (by exact_mod_cast hbposℤ)) n
+            have : (1 : ℝ) * 1 ≤ (beta : ℝ) ^ n * (beta : ℝ) := mul_le_mul ih hb_ge1 (by norm_num) hpow_nonneg
+            simpa [pow_succ] using this
+      simpa [hzpow_toNat] using one_le_pow_nat (Int.toNat (fexp ex - ex))
+    -- Multiply both sides by β^(ex - fexp ex) ≥ 0 to bound by 1
+    have hfac_nonneg : 0 ≤ (beta : ℝ) ^ (ex - fexp ex) := le_of_lt (zpow_pos (by exact_mod_cast hbposℤ) _)
+    have hle_one : (beta : ℝ) ^ (ex - fexp ex) ≤ 1 := by
+      have hid : (beta : ℝ) ^ (ex - fexp ex) * (beta : ℝ) ^ (fexp ex - ex) = 1 := by
+        simpa [sub_eq_add_neg, add_comm, add_left_comm, add_assoc] using (zpow_add₀ hbne (ex - fexp ex) (fexp ex - ex)).symm
+      have hmul_le := mul_le_mul_of_nonneg_left hone_le hfac_nonneg
+      simpa [hid, one_mul] using hmul_le
+    -- Conclude
+    have hmul_inv_pow : (beta : ℝ) ^ ex * ((beta : ℝ) ^ (fexp ex))⁻¹ = (beta : ℝ) ^ (ex - fexp ex) := by
+      simpa [zpow_neg] using hmul_pow
+    have : abs (scaled_mantissa beta fexp x).run < (beta : ℝ) ^ (ex - fexp ex) := by
+      simpa [hsm_abs, hmul_inv_pow] using hmul_lt
+    exact lt_of_lt_of_le this hle_one
 
 /-- Specification: Scaled mantissa general bound
 
     The absolute value of scaled mantissa is bounded by
     beta^(mag(x) - cexp(x)).
 -/
-theorem scaled_mantissa_lt_bpow (beta : Int) (fexp : Int → Int) (x : ℝ) :
-    abs (scaled_mantissa beta fexp x).run < (beta : ℝ) ^ (mag beta x - (cexp beta fexp x).run) := by
-  sorry
+theorem scaled_mantissa_lt_bpow
+    (beta : Int) (fexp : Int → Int) (x : ℝ)
+    (hβ : 1 < beta) :
+    abs (scaled_mantissa beta fexp x).run ≤ (beta : ℝ) ^ (mag beta x - (cexp beta fexp x).run) := by
+  -- Base positivity for the real base
+  have hbposℤ : (0 : Int) < beta := lt_trans Int.zero_lt_one hβ
+  have hbposR : (0 : ℝ) < (beta : ℝ) := by exact_mod_cast hbposℤ
+  have hbneR : (beta : ℝ) ≠ 0 := ne_of_gt hbposR
+  -- Notation
+  set e : Int := mag beta x
+  set c : Int := (cexp beta fexp x).run
+  -- Scaled mantissa as a product
+  have hsm : (scaled_mantissa beta fexp x).run = x * (beta : ℝ) ^ (-c) := by
+    unfold FloatSpec.Core.Generic_fmt.scaled_mantissa FloatSpec.Core.Generic_fmt.cexp
+    rfl
+  -- Positivity of the scaling factor
+  have hscale_pos : 0 < (beta : ℝ) ^ (-c) := zpow_pos hbposR _
+  have hscale_nonneg : 0 ≤ (beta : ℝ) ^ (-c) := le_of_lt hscale_pos
+  -- Bound abs x by β^e
+  have h_upper_abs : abs x ≤ (beta : ℝ) ^ e := by
+    by_cases hx0 : x = 0
+    · have : 0 ≤ (beta : ℝ) ^ e := le_of_lt (zpow_pos hbposR _)
+      simpa [hx0, abs_zero] using this
+    · have hb_gt1R : (1 : ℝ) < (beta : ℝ) := by exact_mod_cast hβ
+      have hlogβ_pos : 0 < Real.log (beta : ℝ) :=
+        (Real.log_pos_iff (x := (beta : ℝ)) (le_of_lt hbposR)).mpr hb_gt1R
+      have hxpos : 0 < abs x := abs_pos.mpr hx0
+      set L : ℝ := Real.log (abs x) / Real.log (beta : ℝ)
+      have hmageq : e = Int.ceil L := by
+        have : mag beta x = Int.ceil L := by
+          unfold FloatSpec.Core.Generic_fmt.mag
+          simp [hx0, L]
+        simpa [e] using this
+      have hceil_ge : (L : ℝ) ≤ (Int.ceil L : ℝ) := by exact_mod_cast Int.le_ceil L
+      have hmul_le : L * Real.log (beta : ℝ) ≤ (Int.ceil L : ℝ) * Real.log (beta : ℝ) :=
+        mul_le_mul_of_nonneg_right hceil_ge (le_of_lt hlogβ_pos)
+      have hL_mul : L * Real.log (beta : ℝ) = Real.log (abs x) := by
+        have hne : Real.log (beta : ℝ) ≠ 0 := ne_of_gt hlogβ_pos
+        calc
+          L * Real.log (beta : ℝ)
+              = (Real.log (abs x) / Real.log (beta : ℝ)) * Real.log (beta : ℝ) := by rfl
+          _   = Real.log (abs x) := by simpa [hne] using (mul_div_cancel' (Real.log (abs x)) (Real.log (beta : ℝ)))
+      -- Relate log(β^e) to e * log β
+      have hlog_zpow_e : Real.log ((beta : ℝ) ^ e) = (e : ℝ) * Real.log (beta : ℝ) := by
+        simpa using Real.log_zpow hbposR e
+      -- Get the desired log inequality in the form log |x| ≤ log(β^e)
+      have hlog_le : Real.log (abs x) ≤ Real.log ((beta : ℝ) ^ e) := by
+        have : Real.log (abs x) ≤ (e : ℝ) * Real.log (beta : ℝ) := by
+          simpa [hL_mul, hmageq] using hmul_le
+        simpa [hlog_zpow_e] using this
+      -- convert back via exp monotonicity
+      have hxpos' : 0 < abs x := hxpos
+      -- Move to exponentials, rewriting to `exp (e * log β)` to avoid simp changing forms later
+      have h_exp_le : abs x ≤ Real.exp ((e : ℝ) * Real.log (beta : ℝ)) := by
+        have := (Real.log_le_iff_le_exp hxpos').1 hlog_le
+        simpa [hlog_zpow_e] using this
+      -- Show `exp (e * log β) = β^e` and conclude
+      have hypos : 0 < (beta : ℝ) ^ e := zpow_pos hbposR _
+      have h_exp_eq_pow : Real.exp ((e : ℝ) * Real.log (beta : ℝ)) = (beta : ℝ) ^ e := by
+        have : Real.exp (Real.log ((beta : ℝ) ^ e)) = (beta : ℝ) ^ e := Real.exp_log hypos
+        simpa [hlog_zpow_e] using this
+      exact by simpa [h_exp_eq_pow]
+        using h_exp_le
+  -- Multiply by the positive scaling factor and collapse the RHS product
+  have habs_pow : abs ((beta : ℝ) ^ (-c)) = (beta : ℝ) ^ (-c) := abs_of_nonneg hscale_nonneg
+  have habs_scaled_tmp : abs (scaled_mantissa beta fexp x).run = abs (x * (beta : ℝ) ^ (-c)) := by
+    simpa [hsm]
+  -- Rewrite |β^(-c)| as |β^c|⁻¹ and then drop abs using nonnegativity of β^c
+  have hpow_c_pos : 0 < (beta : ℝ) ^ c := zpow_pos hbposR _
+  have hpow_c_nonneg : 0 ≤ (beta : ℝ) ^ c := le_of_lt hpow_c_pos
+  have hscale_inv_nonneg : 0 ≤ ((beta : ℝ) ^ c)⁻¹ := inv_nonneg.mpr (le_of_lt hpow_c_pos)
+  have habs_scaled : abs (scaled_mantissa beta fexp x).run = abs x * ((beta : ℝ) ^ c)⁻¹ := by
+    -- |x * β^(-c)| = |x| * |β^(-c)| = |x| * |(β^c)⁻¹| = |x| * |β^c|⁻¹
+    -- and since β^c ≥ 0, |β^c| = β^c
+    have : abs (scaled_mantissa beta fexp x).run = abs x * (abs ((beta : ℝ) ^ c))⁻¹ := by
+      simpa [abs_mul, zpow_neg] using habs_scaled_tmp
+    simpa [abs_of_nonneg hpow_c_nonneg] using this
+  have hmul : (beta : ℝ) ^ e * (beta : ℝ) ^ (-c) = (beta : ℝ) ^ (e - c) := by
+    simpa [sub_eq_add_neg]
+      using (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) (hbne := hbneR) (e := e) (c := c))
+  -- Combine the pieces and collapse the RHS product
+  calc
+    abs (scaled_mantissa beta fexp x).run
+        = abs x * ((beta : ℝ) ^ c)⁻¹ := habs_scaled
+    _   ≤ (beta : ℝ) ^ e * ((beta : ℝ) ^ c)⁻¹ := mul_le_mul_of_nonneg_right h_upper_abs hscale_inv_nonneg
+    _   = (beta : ℝ) ^ (e - c) := by
+          simpa [zpow_neg] using
+            (FloatSpec.Core.Generic_fmt.zpow_mul_sub (a := (beta : ℝ)) (hbne := hbneR) (e := e) (c := c))
 
 /-- Specification: Generic format is closed under rounding down
 
@@ -315,4 +733,4 @@ theorem round_to_format_properties (beta : Int) (fexp : Int → Int) [Valid_exp
   simp [round_DN_to_format, round_UP_to_format]
   sorry -- This requires implementing the rounding functions and proving their properties
 
-end FloatSpec.Core.Round_generic
\ No newline at end of file
+end FloatSpec.Core.Round_generic
