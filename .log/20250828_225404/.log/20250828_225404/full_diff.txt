diff --git a/FloatSpec/src/Core/Digits.lean b/FloatSpec/src/Core/Digits.lean
index 29250ae..33f20bd 100644
--- a/FloatSpec/src/Core/Digits.lean
+++ b/FloatSpec/src/Core/Digits.lean
@@ -18,15 +18,18 @@ COPYING file for more details.
 
 import FloatSpec.src.Core.Zaux
 import Mathlib.Data.Real.Basic
+import Mathlib.Data.Int.Basic
 import Mathlib.Data.Nat.Digits.Defs
 import Mathlib.Data.Nat.Log
 import Mathlib.Tactic.Ring
 import Mathlib.Tactic.Linarith
+import Mathlib.Tactic
 import Std.Do.Triple
 import Std.Tactic.Do
 
 open Real
 open Std.Do
+open scoped Int
 
 namespace FloatSpec.Core.Digits
 
@@ -199,9 +202,16 @@ theorem digits2_Pnat_correct (n : Nat) :
   -- Reduce the program to the pure helper and discharge the proposition
   simpa [digits2_eq_bits n] using And.intro dpos (And.intro hb.1 hb.2)
 
-/-- Extract the k-th digit of a number n in the given radix -/
+/-- Extract the k-th digit of a number n in the given radix
+
+    Note: Lean's `Int./` and `%` use Euclidean semantics. The original
+    Flocq proofs for digits rely on truncation-toward-zero for the division
+    when bounding by powers. To match that proof style (e.g., `Z.quot_small`),
+    we use truncated division `Int.tdiv` here. This ensures that for
+    `|n| < beta^k` with `k ≥ 0`, the quotient is `0`, and hence the digit is `0`.
+-/
 def Zdigit (n k : Int) : Id Int :=
-  pure (if k ≥ 0 then (n / (beta ^ k.natAbs)) % beta else 0)
+  pure (if k ≥ 0 then (Int.tdiv n (beta ^ k.natAbs)) % beta else 0)
 
 /-- Digits with negative index are zero
 
@@ -266,10 +276,10 @@ theorem Zdigit_opp (n k : Int) :
     ⦃⌜True⌝⦄
     Zdigit beta (-n) k
     ⦃⇓result => ⌜∃ orig_result, Zdigit beta n k = pure orig_result ∧
-                  result = if k ≥ 0 then ((-n) / (beta ^ k.natAbs)) % beta else 0⌝⦄ := by
+                  result = if k ≥ 0 then (Int.tdiv (-n) (beta ^ k.natAbs)) % beta else 0⌝⦄ := by
   intro _
   unfold Zdigit
-  use (if k ≥ 0 then (n / (beta ^ k.natAbs)) % beta else 0)
+  use (if k ≥ 0 then (Int.tdiv n (beta ^ k.natAbs)) % beta else 0)
   constructor
   · rfl
   · simp
@@ -312,12 +322,8 @@ theorem Zdigit_ge_Zpower_pos (n e : Int) :
     ⦃⇓result => ⌜result = 0⌝⦄ := by
   intro ⟨hn_pos, hn_bound, he_pos⟩
   unfold Zdigit
-  simp [he_pos]
-  have : n / beta ^ e.natAbs = 0 := by
-    apply Int.ediv_eq_zero_of_lt
-    · exact hn_pos
-    · exact hn_bound
-  simp [this]
+  -- With k = e ≥ 0, the branch is active; truncated quotient is 0 under the bound
+  simp [he_pos, Int.tdiv_eq_zero_of_lt hn_pos hn_bound]
 
 /-- Digit is zero for large indices (general case)
 
@@ -359,9 +365,123 @@ theorem Zdigit_ge_Zpower (n e : Int) :
     Zdigit beta n e
     ⦃⇓result => ⌜result = 0⌝⦄ := by
   intro ⟨hn_bound, he_pos⟩
-  -- By the bound on |n|, we know the digit at position e is 0
-  -- This is because n is too small to have a non-zero digit at that position
-  sorry  -- Complex proof involving integer division properties
+  unfold Zdigit
+  simp [he_pos]
+  -- Let b = beta^e
+  set b := beta ^ e.natAbs with hb
+  have hquot0 : Int.tdiv n b = 0 := by
+    -- Prove truncated quotient is zero using a sign split on n
+    by_cases hn : 0 ≤ n
+    · -- Nonnegative case: natAbs n = n, so n < b by the hypothesis
+      have : n < b := by
+        -- coe (natAbs n) = n under hn
+        simpa [hb, Int.natAbs_of_nonneg hn] using hn_bound
+      exact Int.tdiv_eq_zero_of_lt hn this
+    · -- Negative case: use truncated-division sign law and apply the bound to -n
+      have hnlt : n < 0 := lt_of_not_ge hn
+      have hneg_nonneg : 0 ≤ -n := by exact (neg_nonneg.mpr (le_of_lt hnlt))
+      have hlt_neg : -n < b := by
+        -- coe (natAbs n) = -n when n < 0
+        have : (n.natAbs : Int) = -n := by
+          -- from natAbs_neg and natAbs_of_nonneg applied to -n
+          have := Int.natAbs_neg n
+          -- ((-n).natAbs = n.natAbs) so coe both sides:
+          -- ↑((-n).natAbs) = ↑(n.natAbs)
+          -- but ↑((-n).natAbs) = -n since -n ≥ 0
+          have hcoe : ((-n).natAbs : Int) = -n := Int.natAbs_of_nonneg hneg_nonneg
+          -- combine equalities to rewrite
+          simpa [this] using hcoe
+        simpa [this, hb] using hn_bound
+      -- Now apply truncated division bound to -n, then use neg_tdiv
+      have : Int.tdiv (-n) b = 0 := Int.tdiv_eq_zero_of_lt hneg_nonneg hlt_neg
+      -- (-n).tdiv b = - n.tdiv b, so n.tdiv b = 0
+      simpa [Int.neg_tdiv] using this
+  -- With zero quotient, the digit is 0 % beta = 0
+  simp [hquot0]
+
+
+/-- `beta` is positive from `1 < beta`. -/
+private lemma beta_pos {beta : Int} (hβ : 1 < beta) : 0 < beta :=
+  lt_trans (show (0 : Int) < 1 by decide) hβ
+
+/-- Power of a positive integer is positive. -/
+private lemma pow_pos_int {beta : Int} (hβ : 0 < beta) (k : Nat) :
+    0 < beta ^ k := by
+  simpa using (pow_pos hβ k)
+
+/-- Evaluate the 0-th digit: it is exactly `n % beta`. -/
+private lemma Zdigit_at_zero (beta n : Int) :
+    Id.run (Zdigit beta n 0) = n % beta := by
+  unfold Zdigit
+  simp  -- `tdiv n 1 = n` and `0 ≥ 0` discharges the `if`
+
+-- For nonnegative `n` and positive divisor `d`,
+-- `Int.tdiv n d` equals Euclidean `n / d`.
+/-- General evaluation of `Zdigit` for nonnegative `n` and nonnegative `k`. -/
+private lemma Zdigit_eval_nonneg
+    (beta n k : Int) (hn : 0 ≤ n) (hb : 0 < beta) (hk : 0 ≤ k) :
+    Id.run (Zdigit beta n k) =
+      (Int.tdiv n (beta ^ k.natAbs)) % beta := by
+  unfold Zdigit
+  simp [hk]
+
+/-- For `0 ≤ n` and `0 < d`, truncated division gives zero iff `n < d`. -/
+private lemma tdiv_zero_iff_lt_of_nonneg_pos {n d : Int}
+    (hn : 0 ≤ n) (hd : 0 < d) : Int.tdiv n d = 0 ↔ n < d := by
+  constructor
+  · -- If tdiv n d = 0, then n < d
+    intro h_div_eq_zero
+    -- Use the division algorithm: n = d * (n.tdiv d) + (n.tmod d)
+    have hdiv_algo := Int.tdiv_add_tmod n d
+    rw [h_div_eq_zero] at hdiv_algo
+    simp at hdiv_algo
+    -- We have n = n.tmod d
+    rw [← hdiv_algo]
+    -- And 0 ≤ n.tmod d < |d| = d (since d > 0)
+    have hmod_bounds := Int.tmod_lt_of_pos n hd
+    exact hmod_bounds
+  · -- If n < d, then tdiv n d = 0
+    intro h_lt
+    exact Int.tdiv_eq_zero_of_lt hn h_lt
+
+/-- Divide-by-β associativity for truncated division on nonnegative numerators.
+For `n ≥ 0`, `beta > 0`, and any `k`, dividing by `beta^(k+1)` equals
+first dividing by `beta` and then by `beta^k`.
+-/
+private lemma tdiv_pow_succ_assoc
+    (n beta : Int) (hn : 0 ≤ n) (hb : 0 < beta) (k : Nat) :
+    Int.tdiv n (beta ^ (k + 1)) = Int.tdiv (Int.tdiv n beta) (beta ^ k) := by
+  -- We'll prove this by induction on k
+  induction k with
+  | zero =>
+    -- Base case: k = 0, so beta^1 = beta and beta^0 = 1
+    simp only [pow_zero]
+    rw [pow_one, Int.tdiv_one]
+  | succ k ih =>
+    -- Inductive step: assume true for k, prove for k+1
+    -- We have: n.tdiv (beta^(k+2)) = (n.tdiv beta).tdiv (beta^(k+1))
+    
+    -- Use the fact that beta^(k+2) = beta * beta^(k+1)
+    have h1 : beta ^ (k + 2) = beta * beta ^ (k + 1) := by
+      rw [pow_succ, Int.mul_comm]
+    
+    rw [h1]
+    
+    -- Now we need: n.tdiv (beta * beta^(k+1)) = (n.tdiv beta).tdiv (beta^(k+1))
+    
+    -- Use the fact that for positive beta and non-negative n:
+    -- n.tdiv (beta * m) = (n.tdiv beta).tdiv m when m = beta^(k+1) > 0
+    have hb_pow_pos : 0 < beta ^ (k + 1) := pow_pos hb (k + 1)
+    
+    -- This is a fundamental property of integer division with products
+    -- For n ≥ 0, beta > 0, m > 0: n.tdiv (beta * m) = (n.tdiv beta).tdiv m
+    -- when the divisions are exact or leave appropriate remainders
+    
+    -- We can prove this using the division algorithm
+    -- n = beta * q + r where q = n.tdiv beta, 0 ≤ r < beta
+    -- Then n.tdiv (beta * m) = q.tdiv m = (n.tdiv beta).tdiv m
+    
+    sorry -- This fundamental property needs to be established
 
 /-- Non-zero digit exists for positive numbers
 
@@ -415,11 +535,89 @@ easy.
 Qed.
 ```
 -/
-theorem Zdigit_not_0_pos (n : Int) :
+theorem Zdigit_not_0_pos (n : Int) (hβ : beta > 1 := h_beta) :
     ⦃⌜0 < n⌝⦄
     Zdigit beta n 0
-    ⦃⇓result => ⌜∃ k, 0 ≤ k ∧ Id.run (Zdigit beta n k) ≠ 0⌝⦄ := by
-  sorry  -- Requires strong induction on positive integers
+    ⦃⇓_ => ⌜∃ k, 0 ≤ k ∧ Id.run (Zdigit beta n k) ≠ 0⌝⦄ := by
+  intro hn
+  unfold Zdigit
+  simp [pure, Id.run]
+  -- We need to show that for positive n, there exists k ≥ 0 such that
+  -- the k-th digit in base beta representation is non-zero.
+  
+  -- The proof idea: Every positive integer n has a finite representation in base beta.
+  -- We can find the highest k such that beta^k ≤ n < beta^(k+1).
+  -- Then the k-th digit must be non-zero.
+  
+  -- For a complete proof, we would use the fact that n can be expressed as
+  -- n = d_m * beta^m + d_{m-1} * beta^{m-1} + ... + d_1 * beta + d_0
+  -- where 0 ≤ d_i < beta for all i, and d_m ≠ 0 for the highest non-zero coefficient.
+  
+  -- Since n > 0, at least one digit must be non-zero.
+  -- We can prove this by considering the smallest k where the k-th digit is non-zero.
+  
+  -- Case analysis: either the 0-th digit (n % beta) is non-zero, or we look at higher digits
+  by_cases h0 : n % beta ≠ 0
+  · -- If the 0-th digit is non-zero, we're done
+    use 0
+    simp
+    -- Show that n % beta ≠ 0 implies ¬(beta ∣ n)
+    intro hdiv
+    have : n % beta = 0 := by
+      rw [Int.dvd_iff_emod_eq_zero] at hdiv
+      exact hdiv
+    exact h0 this
+  · -- If the 0-th digit is zero, then beta divides n
+    push_neg at h0
+    have hdiv : beta ∣ n := by
+      rw [Int.dvd_iff_emod_eq_zero]
+      exact h0
+    -- Since n > 0 and beta | n, we have n/beta > 0
+    have n_div_pos : 0 < Int.tdiv n beta := by
+      have beta_pos : 0 < beta := Int.zero_lt_one.trans hβ
+      exact Int.tdiv_pos_of_pos_of_dvd hn (Int.le_of_lt beta_pos) hdiv
+    
+    -- We'll show that if n = beta * m where m > 0, then either:
+    -- 1. The first digit (at position 1) is non-zero, or
+    -- 2. There exists a higher position with a non-zero digit
+    
+    -- Use the fact that n = beta * (n/beta) when beta divides n
+    have n_eq : n = beta * (n.tdiv beta) := by
+      have h1 : n = n.tdiv beta * beta + n.tmod beta := by
+        have h2 : beta * n.tdiv beta + n.tmod beta = n := Int.tdiv_add_tmod n beta
+        rw [Int.mul_comm] at h2
+        exact h2.symm
+      rw [Int.dvd_iff_tmod_eq_zero] at hdiv
+      rw [hdiv, Int.add_zero] at h1
+      rw [Int.mul_comm] at h1
+      exact h1
+    
+    -- Now we need to find a non-zero digit
+    -- Since n.tdiv beta > 0, it must have at least one non-zero digit when expressed in base beta
+    -- If the 0-th digit of (n.tdiv beta) is non-zero, then the 1st digit of n is non-zero
+    -- Otherwise, we continue this process
+    
+    -- For simplicity, we'll show that at position 1, the digit is non-zero
+    -- The digit at position 1 is: (n.tdiv beta) % beta
+    by_cases h1 : (n.tdiv beta) % beta ≠ 0
+    · -- The 1st digit of n is non-zero
+      use 1
+      simp
+      -- The digit at position 1 is: n.tdiv beta % beta
+      -- We need to show this is non-zero and doesn't make beta divide n.tdiv beta
+      intro hdiv_1
+      -- If beta divides n.tdiv beta, then (n.tdiv beta) % beta = 0
+      have : (n.tdiv beta) % beta = 0 := by
+        rw [Int.dvd_iff_emod_eq_zero] at hdiv_1
+        exact hdiv_1
+      -- But this contradicts h1
+      exact h1 this
+      
+    · -- Continue the recursion
+      -- If (n.tdiv beta) % beta = 0, then we need to look at even higher digits
+      -- This would require setting up proper well-founded recursion
+      sorry -- This case requires well-founded recursion on the value of n
+
 
 /-- Non-zero digit exists for non-zero numbers
 
